import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims

enum PopupPromptBuilder {}
struct ContactsEnrichmentDebugView {
    enum SortOption {
        case lastInteraction
        case name
        case enrichmentDate
        case interactionCount
    }
    enum FilterOption {
        case all
        case enriched
        case hasRelationship
        case hasEmployment
        case recentlyActive
    }
    var _contacts: SwiftUI.State<[Spec.ContactSummary]>
    var _selectedContact: SwiftUI.State<Spec.ContactSummary?>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _errorMessage: SwiftUI.State<Swift.String?>
    var _searchText: SwiftUI.State<Swift.String>
    var _sortBy: SwiftUI.State<Spec.ContactsEnrichmentDebugView.SortOption>
    var _filterBy: SwiftUI.State<Spec.ContactsEnrichmentDebugView.FilterOption>
}
struct ContactSummary {
    let contactId: Swift.String
    let displayName: Swift.String
    let preferredName: Swift.String?
    let relationshipToUser: Swift.String?
    let relationshipDetails: Swift.String?
    let relationshipConfidence: Swift.Double?
    let lastEnrichedAt: Swift.Double?
    let isTrusted: Swift.Bool
    let isBusiness: Swift.Bool
    let totalInteractions: Swift.Int
    let lastInteractionTs: Swift.Double
    let employmentCount: Swift.Int
    let educationCount: Swift.Int
    let topicCount: Swift.Int
    let platformCount: Swift.Int
}
struct ContactListRow {
    let contact: Spec.ContactSummary
}
struct ContactEnrichmentDetailView {
    let contactId: Swift.String
    var _overview: SwiftUI.State<Spec.ContactOverview?>
    var _relationshipHistory: SwiftUI.State<[[Swift.String : Any]]>
    var _biography: SwiftUI.State<Swift.String?>
    var _skills: SwiftUI.State<[Swift.String]>
    var _isLoading: SwiftUI.State<Swift.Bool>
}
struct FrameRecordHeader {}
class FrameRingWriter {
    let log: os.Logger
    let fileURL: Foundation.URL
    let maxBytes: Swift.Int64
    var handle: __C.NSFileHandle?
    let lock: __C.NSLock
}
class FrameRingTailer {
    let fileURL: Foundation.URL
    var handle: __C.NSFileHandle?
    let queue: __C.OS_dispatch_queue
    let pollInterval: Swift.Double
    var isRunning: Swift.Bool
    var onFrame: ((Foundation.Data, Swift.UInt64) -> ())?
}
enum AppPaths {}
enum LegacyAppSupportMigrator {}
enum DangerousPathError {
    case outsideAppDomain(Swift.String)
}
enum PathGuard {}
struct DraftContextDisplayView {
    let context: Swift.String
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct GmailDraftDetailView {
    let item: Spec.DraftListItem
    let observable: Spec.MessageFunctionCallingObservable?
    let onSkip: () -> ()
    let onSend: (_: Swift.String) -> ()
}
struct MessagesDraftDetailView {
    let item: Spec.DraftListItem
    let observable: Spec.MessageFunctionCallingObservable?
    let onSend: (_: Swift.String) -> ()
    let onCancel: () -> ()
    var _resolvedAvatarRef: SwiftUI.State<Swift.String?>
}
struct DraftListItem {
    let key: Swift.String
    let title: Swift.String
    let context: Swift.String
    let primary: Swift.String
    let urgency: Swift.Double
    let professionalImpact: Swift.Double
    let processedAt: Foundation.Date?
    let accountEmail: Swift.String?
    let threadId: Swift.String?
    let messageId: Swift.String?
    let subject: Swift.String?
    let recipientEmail: Swift.String?
    let cc: Swift.String?
    let bcc: Swift.String?
    let replyAll: Swift.Bool?
    let chatGuid: Swift.String?
    let contactNumber: Swift.String?
    let teamId: Swift.String?
    let channelId: Swift.String?
    let threadTs: Swift.String?
    let channelName: Swift.String?
    let conversationId: Swift.String?
    let participantUsername: Swift.String?
    let participantName: Swift.String?
}
struct SlackDraftDetailView {
    let item: Spec.DraftListItem
    let onSend: (_: Swift.String) -> ()
    let onCancel: () -> ()
}
struct XDMDraftDetailView {
    let item: Spec.DraftListItem
    let onSend: (_: Swift.String) -> ()
    let onCancel: () -> ()
}
struct SafeProcess {}
struct PinMenuView {
    let threadID: Swift.String
    let isPinned: Swift.Bool
    let onDismiss: () -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _pinnedChatManager: SwiftUI.StateObject<Spec.PinnedChatManager>
}
struct PinMenuOption {
    let icon: Swift.String
    let title: Swift.String
    var subtitle: Swift.String?
    let action: () -> ()
    var _isHovering: SwiftUI.State<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct $s4Spec0022PinMenuViewswift_tiAIefMX122_0_024_342666391A9BD0154DB0DA2E6F9529DLl7PreviewfMf_15PreviewRegistryfMu_ {}
struct ScreenObservation {
    struct AppInfo {
        enum CodingKeys {
            case bundleId
            case name
        }
        var bundleId: Swift.String?
        var name: Swift.String?
    }
    struct Element {
        enum CodingKeys {
            case id
            case role
            case label
            case text
            case frame
        }
        var id: Swift.String
        var role: Swift.String
        var label: Swift.String?
        var text: Swift.String?
        var frame: [Swift.Double]
    }
    struct Affordance {
        enum CodingKeys {
            case type
            case targetId
            case deeplink
        }
        var type: Swift.String
        var targetId: Swift.String?
        var deeplink: Swift.String?
    }
    enum CodingKeys {
        case timestamp
        case app
        case elements
        case extractedText
        case affordances
    }
    var timestamp: Swift.String
    var app: Spec.ScreenObservation.AppInfo?
    var elements: [Spec.ScreenObservation.Element]
    var extractedText: Swift.String?
    var affordances: [Spec.ScreenObservation.Affordance]
}
class AIProxyCertificatePinningDelegate: __C.NSObject {}
struct AIProxyService {
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
    let debugEnabled: Swift.Bool
    var apiVersion: Swift.String
    let betaHeaders: [Swift.String]?
}
struct PinnedChatCard {
    let chat: Spec.LocalChatThread
    let onTap: () -> ()
    var _isHovering: SwiftUI.State<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _pinnedChatManager: SwiftUI.StateObject<Spec.PinnedChatManager>
}
struct $s4Spec0025PinnedChatCardswift_jqFBgfMX80_0_33_D6F941A65CB44825A89CFBF45A58F5D0Ll7PreviewfMf_15PreviewRegistryfMu_ {}
struct AnthropicAPI {
    enum APIPath {
        case messages
        case textCompletions
        case countTokens
    }
    let base: Swift.String
    let apiPath: Spec.AnthropicAPI.APIPath
}
class XAPIService {
    struct RateLimitState {
        var remaining: Swift.Int?
        var resetAt: Foundation.Date?
        var limit: Swift.Int?
    }
    struct DeleteResponse {
        struct DeleteData {
            enum CodingKeys {
                case deleted
            }
            let deleted: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..DeleteData
    }
    struct LikeRequest {
        enum CodingKeys {
            case tweet_id
        }
        let tweet_id: Swift.String
    }
    struct LikeResponse {
        struct LikeData {
            enum CodingKeys {
                case liked
            }
            let liked: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..LikeData
    }
    struct UnlikeResponse {
        struct UnlikeData {
            enum CodingKeys {
                case liked
            }
            let liked: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..UnlikeData
    }
    struct RetweetRequest {
        enum CodingKeys {
            case tweet_id
        }
        let tweet_id: Swift.String
    }
    struct RetweetResponse {
        struct RetweetData {
            enum CodingKeys {
                case retweeted
            }
            let retweeted: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..RetweetData
    }
    struct UndoRetweetResponse {
        struct UndoRetweetData {
            enum CodingKeys {
                case retweeted
            }
            let retweeted: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..UndoRetweetData
    }
    struct BookmarkRequest {
        enum CodingKeys {
            case tweet_id
        }
        let tweet_id: Swift.String
    }
    struct BookmarkResponse {
        struct BookmarkData {
            enum CodingKeys {
                case bookmarked
            }
            let bookmarked: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..BookmarkData
    }
    struct RemoveBookmarkResponse {
        struct RemoveBookmarkData {
            enum CodingKeys {
                case bookmarked
            }
            let bookmarked: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..RemoveBookmarkData
    }
    struct FollowRequest {
        enum CodingKeys {
            case target_user_id
        }
        let target_user_id: Swift.String
    }
    struct FollowResponse {
        struct FollowData {
            enum CodingKeys {
                case following
            }
            let following: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..FollowData
    }
    struct UnfollowResponse {
        struct UnfollowData {
            enum CodingKeys {
                case following
            }
            let following: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..UnfollowData
    }
    struct BlockRequest {
        enum CodingKeys {
            case target_user_id
        }
        let target_user_id: Swift.String
    }
    struct BlockResponse {
        struct BlockData {
            enum CodingKeys {
                case blocking
            }
            let blocking: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..BlockData
    }
    struct UnblockResponse {
        struct UnblockData {
            enum CodingKeys {
                case blocking
            }
            let blocking: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..UnblockData
    }
    struct MuteRequest {
        enum CodingKeys {
            case target_user_id
        }
        let target_user_id: Swift.String
    }
    struct MuteResponse {
        struct MuteData {
            enum CodingKeys {
                case muting
            }
            let muting: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..MuteData
    }
    struct UnmuteResponse {
        struct UnmuteData {
            enum CodingKeys {
                case muting
            }
            let muting: Swift.Bool
        }
        enum CodingKeys {
            case data
        }
        let data: Spec.XAPIService..UnmuteData
    }
    struct CreateDMConversationRequest {
        struct Message {
            enum CodingKeys {
                case text
            }
            let text: Swift.String
        }
        enum CodingKeys {
            case conversation_type
            case participant_ids
            case message
        }
        let conversation_type: Swift.String
        let participant_ids: [Swift.String]
        let message: Spec.XAPIService..Message
    }
    struct SendDMRequest {
        enum CodingKeys {
            case text
        }
        let text: Swift.String
    }
    struct SendDMResponse {
        enum CodingKeys {
            case dm_conversation_id
            case dm_event_id
        }
        let dm_conversation_id: Swift.String
        let dm_event_id: Swift.String
    }
    let baseURL: Swift.String
    var requestQueue: [() async throws -> ()]
    var isProcessingQueue: Swift.Bool
    var rateLimitState: [Swift.String : Spec.XAPIService.RateLimitState]
}
enum XAPIServiceError {
    case decodingFailed(Swift.Error)
    case apiError([Spec.XAPIError])
    case httpError(Swift.Int)
    case invalidURL
    case invalidResponse
    case noData
    case rateLimitExceeded
}
enum HTTPMethod {
    case post
    case get
    case delete
}
struct JSONSchema {
    enum CodingKeys {
        case type
        case properties
        case required
        case pattern
        case const
        case enumValues
        case multipleOf
        case minimum
        case maximum
    }
    struct Property {
        enum CodingKeys {
            case type
            case description
            case format
            case items
            case required
            case pattern
            case const
            case enumValues
            case multipleOf
            case minimum
            case maximum
            case minItems
            case maxItems
            case uniqueItems
        }
        let type: Spec.JSONSchema.JSONType
        let description: Swift.String?
        let format: Swift.String?
        let items: Spec.JSONSchema.Items?
        let required: [Swift.String]?
        let pattern: Swift.String?
        let const: Swift.String?
        let enumValues: [Swift.String]?
        let multipleOf: Swift.Int?
        let minimum: Swift.Double?
        let maximum: Swift.Double?
        let minItems: Swift.Int?
        let maxItems: Swift.Int?
        let uniqueItems: Swift.Bool?
    }
    enum JSONType {
        case integer
        case string
        case boolean
        case array
        case object
        case number
        case null
    }
    struct Items {
        enum CodingKeys {
            case type
            case properties
            case pattern
            case const
            case enumValues
            case multipleOf
            case minimum
            case maximum
            case minItems
            case maxItems
            case uniqueItems
        }
        let type: Spec.JSONSchema.JSONType
        let properties: [Swift.String : Spec.JSONSchema.Property]?
        let pattern: Swift.String?
        let const: Swift.String?
        let enumValues: [Swift.String]?
        let multipleOf: Swift.Int?
        let minimum: Swift.Double?
        let maximum: Swift.Double?
        let minItems: Swift.Int?
        let maxItems: Swift.Int?
        let uniqueItems: Swift.Bool?
    }
    let type: Spec.JSONSchema.JSONType
    let properties: [Swift.String : Spec.JSONSchema.Property]?
    let required: [Swift.String]?
    let pattern: Swift.String?
    let const: Swift.String?
    let enumValues: [Swift.String]?
    let multipleOf: Swift.Int?
    let minimum: Swift.Int?
    let maximum: Swift.Int?
}
struct MessageParameter {
    enum System {
        case text(Swift.String)
        case list([Spec.MessageParameter.Cache])
    }
    struct Message {
        enum Role {
            case user
            case assistant
        }
        enum Content {
            enum ContentObject {
                enum CodingKeys {
                    case type
                    case source
                    case text
                    case title
                    case context
                    case citations
                    case id
                    case name
                    case input
                    case toolUseId
                    case content
                    case cacheControl
                    case isError
                    case thinking
                    case signature
                    case data
                }
                case text(Swift.String, Spec.MessageParameter.CacheControl?)
                case image(Spec.MessageParameter.Message.Content.ImageSource)
                case document(Spec.MessageParameter.Message.Content.DocumentSource)
                case toolUse(Swift.String, Swift.String, [Swift.String : Spec.MessageResponse.Content.DynamicContent])
                case toolResult(Swift.String, Swift.String, Swift.Bool?, Spec.MessageParameter.CacheControl?)
                case cache(Spec.MessageParameter.Cache)
                case thinking(Swift.String, Swift.String)
                case redactedThinking(Swift.String)
            }
            struct ImageSource {
                enum CodingKeys {
                    case type
                    case mediaType
                    case data
                }
                enum MediaType {
                    case jpeg
                    case png
                    case gif
                    case webp
                }
                enum ImageSourceType {
                    case base64
                }
                let type: Swift.String
                let mediaType: Swift.String
                let data: Swift.String
            }
            struct DocumentSource {
                struct Source {
                    enum CodingKeys {
                        case type
                        case mediaType
                        case data
                    }
                    let type: Swift.String
                    let mediaType: Swift.String
                    let data: Swift.String
                }
                enum DocumentError {
                    case exceededSizeLimit
                    case invalidBase64Data
                }
                enum MediaType {
                    case pdf
                    case plainText
                }
                enum DocumentSourceType {
                    case base64
                    case text
                }
                struct Citations {
                    enum CodingKeys {
                        case enabled
                    }
                    let enabled: Swift.Bool
                }
                enum CodingKeys {
                    case source
                    case title
                    case context
                    case citations
                }
                let source: Spec.MessageParameter.Message.Content.DocumentSource.Source
                let title: Swift.String?
                let context: Swift.String?
                let citations: Spec.MessageParameter.Message.Content.DocumentSource.Citations?
            }
            case text(Swift.String)
            case list([Spec.MessageParameter.Message.Content.ContentObject])
        }
        enum CodingKeys {
            case role
            case content
        }
        let role: Swift.String
        let content: Spec.MessageParameter.Message.Content
    }
    struct MetaData {
        enum CodingKeys {
            case userId
        }
        let userId: Foundation.UUID
    }
    struct ToolChoice {
        enum ToolType {
            case tool
            case auto
            case any
        }
        enum CodingKeys {
            case type
            case name
            case disableParallelToolUse
        }
        let type: Spec.MessageParameter.ToolChoice.ToolType
        let name: Swift.String?
        let disableParallelToolUse: Swift.Bool?
    }
    enum Tool {
        enum CodingKeys {
            case name
            case description
            case inputSchema
            case cacheControl
            case type
        }
        case function(name: Swift.String, description: Swift.String?, inputSchema: Spec.JSONSchema?, cacheControl: Spec.MessageParameter.CacheControl?)
        case hosted(type: Swift.String, name: Swift.String)
    }
    struct Cache {
        enum CacheType {
            case text
        }
        enum CodingKeys {
            case type
            case text
            case cacheControl
        }
        let type: Spec.MessageParameter.Cache.CacheType
        let text: Swift.String
        let cacheControl: Spec.MessageParameter.CacheControl?
    }
    struct CacheControl {
        enum CacheControlType {
            case ephemeral
        }
        enum CodingKeys {
            case type
        }
        let type: Spec.MessageParameter.CacheControl.CacheControlType
    }
    struct Thinking {
        enum ThinkingType {
            case enabled
        }
        enum CodingKeys {
            case type
            case budgetTokens
            case effort
        }
        let type: Spec.MessageParameter.Thinking.ThinkingType
        let budgetTokens: Swift.Int
        let effort: Swift.String?
    }
    enum CodingKeys {
        case model
        case messages
        case maxTokens
        case system
        case metadata
        case stopSequences
        case stream
        case temperature
        case topK
        case topP
        case minP
        case tools
        case toolChoice
        case thinking
    }
    let model: Swift.String
    let messages: [Spec.MessageParameter.Message]
    let maxTokens: Swift.Int
    let system: Spec.MessageParameter.System?
    let metadata: Spec.MessageParameter.MetaData?
    let stopSequences: [Swift.String]?
    var stream: Swift.Bool
    let temperature: Swift.Double?
    let topK: Swift.Int?
    let topP: Swift.Double?
    let minP: Swift.Int?
    let tools: [Spec.MessageParameter.Tool]?
    let toolChoice: Spec.MessageParameter.ToolChoice?
    let thinking: Spec.MessageParameter.Thinking?
}
struct MessageTokenCountParameter {
    enum CodingKeys {
        case model
        case messages
        case system
        case tools
    }
    let model: Swift.String
    let messages: [Spec.MessageParameter.Message]
    let system: Spec.MessageParameter.System?
    let tools: [Spec.MessageParameter.Tool]?
}
struct TextCompletionParameter {
    struct MetaData {
        enum CodingKeys {
            case userId
        }
        let userId: Foundation.UUID
    }
    enum CodingKeys {
        case model
        case prompt
        case maxTokensToSample
        case stopSequences
        case temperature
        case topP
        case topK
        case metadata
        case stream
    }
    let model: Swift.String
    let prompt: Swift.String
    let maxTokensToSample: Swift.Int
    let stopSequences: [Swift.String]?
    let temperature: Swift.Double?
    let topP: Swift.Int?
    let topK: Swift.Int?
    let metadata: Spec.TextCompletionParameter.MetaData?
    var stream: Swift.Bool
}
struct MessageInputTokens {
    enum CodingKeys {
        case inputTokens
    }
    let inputTokens: Swift.Int
}
struct MessageResponse {
    enum Content {
        struct ToolUse {
            enum CodingKeys {
                case id
                case name
                case input
            }
            let id: Swift.String
            let name: Swift.String
            let input: [Swift.String : Spec.MessageResponse.Content.DynamicContent]
        }
        struct Thinking {
            enum CodingKeys {
                case thinking
                case signature
            }
            let thinking: Swift.String
            let signature: Swift.String?
        }
        enum CodingKeys {
            case type
            case text
            case id
            case name
            case input
            case citations
            case thinking
            case signature
        }
        enum DynamicContent {
            case string(Swift.String)
            case integer(Swift.Int)
            case double(Swift.Double)
            case dictionary([Swift.String : Spec.MessageResponse.Content.DynamicContent])
            case array([Spec.MessageResponse.Content.DynamicContent])
            case bool(Swift.Bool)
            case null
        }
        enum TextEditorCommand {
            case view
            case str_replace
            case insert
            case create
            case undo_edit
        }
        case text(Swift.String, [Spec.MessageResponse.Citation]?)
        case toolUse(Spec.MessageResponse.Content.ToolUse)
        case thinking(Spec.MessageResponse.Content.Thinking)
    }
    enum Citation {
        enum CodingKeys {
            case type
            case citedText
            case documentIndex
            case documentTitle
            case startCharIndex
            case endCharIndex
            case startPageNumber
            case endPageNumber
            case startBlockIndex
            case endBlockIndex
        }
        struct CharLocation {
            enum CodingKeys {
                case citedText
                case documentIndex
                case documentTitle
                case startCharIndex
                case endCharIndex
            }
            let citedText: Swift.String?
            let documentIndex: Swift.Int?
            let documentTitle: Swift.String?
            let startCharIndex: Swift.Int?
            let endCharIndex: Swift.Int?
        }
        struct PageLocation {
            enum CodingKeys {
                case citedText
                case documentIndex
                case documentTitle
                case startPageNumber
                case endPageNumber
            }
            let citedText: Swift.String?
            let documentIndex: Swift.Int?
            let documentTitle: Swift.String?
            let startPageNumber: Swift.Int?
            let endPageNumber: Swift.Int?
        }
        struct ContentBlockLocation {
            enum CodingKeys {
                case citedText
                case documentIndex
                case documentTitle
                case startBlockIndex
                case endBlockIndex
            }
            let citedText: Swift.String?
            let documentIndex: Swift.Int?
            let documentTitle: Swift.String?
            let startBlockIndex: Swift.Int?
            let endBlockIndex: Swift.Int?
        }
        case charLocation(Spec.MessageResponse.Citation.CharLocation)
        case pageLocation(Spec.MessageResponse.Citation.PageLocation)
        case contentBlockLocation(Spec.MessageResponse.Citation.ContentBlockLocation)
    }
    struct Usage {
        enum CodingKeys {
            case inputTokens
            case outputTokens
            case thinkingTokens
            case cacheCreationInputTokens
            case cacheReadInputTokens
        }
        let inputTokens: Swift.Int?
        let outputTokens: Swift.Int
        let thinkingTokens: Swift.Int?
        let cacheCreationInputTokens: Swift.Int?
        let cacheReadInputTokens: Swift.Int?
    }
    enum CodingKeys {
        case id
        case type
        case model
        case role
        case content
        case stopReason
        case stopSequence
        case usage
    }
    let id: Swift.String
    let type: Swift.String
    let model: Swift.String
    let role: Swift.String
    let content: [Spec.MessageResponse.Content]
    let stopReason: Swift.String?
    let stopSequence: Swift.String?
    let usage: Spec.MessageResponse.Usage
}
struct MessageStreamResponse {
    struct Delta {
        enum CodingKeys {
            case type
            case text
            case thinking
            case signature
            case partialJson
            case citation
            case stopReason
            case stopSequence
        }
        let type: Swift.String?
        let text: Swift.String?
        let thinking: Swift.String?
        let signature: Swift.String?
        let partialJson: Swift.String?
        let citation: Spec.MessageResponse.Citation?
        let stopReason: Swift.String?
        let stopSequence: Swift.String?
    }
    struct ContentBlock {
        enum CodingKeys {
            case type
            case text
            case thinking
            case data
            case citations
            case input
            case name
            case id
        }
        let type: Swift.String
        let text: Swift.String?
        let thinking: Swift.String?
        let data: Swift.String?
        let citations: [Spec.MessageResponse.Citation]?
        let input: [Swift.String : Spec.MessageResponse.Content.DynamicContent]?
        let name: Swift.String?
        let id: Swift.String?
    }
    struct Error {
        enum CodingKeys {
            case type
            case message
        }
        let type: Swift.String
        let message: Swift.String
    }
    enum StreamEvent {
        case contentBlockStart
        case contentBlockDelta
        case contentBlockStop
        case messageStart
        case messageDelta
        case messageStop
    }
    enum CodingKeys {
        case type
        case index
        case contentBlock
        case message
        case delta
        case usage
        case error
    }
    let type: Swift.String
    let index: Swift.Int?
    let contentBlock: Spec.MessageStreamResponse.ContentBlock?
    let message: Spec.MessageResponse?
    let delta: Spec.MessageStreamResponse.Delta?
    let usage: Spec.MessageResponse.Usage?
    let error: Spec.MessageStreamResponse.Error?
}
struct TextCompletionResponse {
    enum CodingKeys {
        case id
        case type
        case completion
        case stopReason
        case model
    }
    let id: Swift.String
    let type: Swift.String
    let completion: Swift.String
    let stopReason: Swift.String
    let model: Swift.String
}
struct TextCompletionStreamResponse {
    enum CodingKeys {
        case type
        case completion
        case stopReason
        case model
    }
    let type: Swift.String
    let completion: Swift.String?
    let stopReason: Swift.String?
    let model: Swift.String?
}
struct ErrorResponse {
    struct Error {
        enum CodingKeys {
            case type
            case message
        }
        let type: Swift.String
        let message: Swift.String
    }
    enum CodingKeys {
        case type
        case error
    }
    let type: Swift.String
    let error: Spec.ErrorResponse.Error
}
enum Model {
    case other(Swift.String)
    case claudeInstant12
    case claude2
    case claude21
    case claude3Opus
    case claude3Sonnet
    case claude3Haiku
    case claude35Haiku
    case claude45Haiku
    case claude40Sonnet
    case claude45Sonnet
    case claude40Opus
    case gemini25Flash
    case gemini25Pro
    case gemma3Local
    case grok4Latest
    case minimaxM2
    case minimaxM2Stable
    case cerebrasQwen3235BThinking
    case cerebrasQwen3235BInstruct
    case cerebrasGPTOSS120B
    case gpt4o
    case gpt4oMini
    case gpt4Turbo
    case gpt4
    case gpt35Turbo
    case gpt5
    case gpt5Mini
    case gpt5Nano
    case o1
    case o1Mini
    case o1Preview
    case o3
    case o3Mini
    case ollamaGLM46Cloud
    case ollamaQwen2532B
    case ollamaQwen2514B
    case ollamaQwen257B
    case ollamaMistral24B
    case ollamaDeepseek14B
    case lmStudio
    case mlxGPTOSS20B
}
class StreamHandler {
    struct ToolUseBlock {
        let id: Swift.String
        let name: Swift.String
        var input: [Swift.String : Spec.MessageResponse.Content.DynamicContent]
        var accumulatedJson: Swift.String?
    }
    var threadID: Swift.String?
    var shouldBroadcastToUI: Swift.Bool
    let verboseLogging: Swift.Bool
    var streamError: Swift.Error?
    var stopReason: Swift.String?
    var currentThinking: Swift.String
    var signature: Swift.String?
    var currentResponse: Swift.String
    var currentToolUse: Spec.StreamHandler.ToolUseBlock?
    var currentToolUseJson: Swift.String
    var currentBlockIndex: Swift.Int?
    var currentBlockType: Swift.String?
    var thinkingBlocks: [(thinking: Swift.String, signature: Swift.String?)]
    var redactedThinkingBlocks: [Swift.String]
    var toolUseBlocks: [Spec.StreamHandler.ToolUseBlock]
    var toolUseJsonMap: [Swift.String : Swift.String]
    var isThinkingInline: Swift.Bool
    var inlineThinkingBuffer: Swift.String
    var hasEmittedThinkingStart: Swift.Bool
    var lastMessageToolUpdate: [Swift.String : (message: Swift.String, time: Foundation.Date)]
    let messageToolUpdateThrottle: Swift.Double
    var textDeltaBuffer: [Swift.String : Swift.String]
    var textDeltaTimer: __C.NSTimer?
}
enum APIError {
    case requestFailed(description: Swift.String)
    case responseUnsuccessful(description: Swift.String)
    case jsonDecodingFailure(description: Swift.String)
    case dataCouldNotBeReadMissingData(description: Swift.String)
    case invalidData
    case bothDecodingStrategiesFailed
    case timeOutError
}
struct XDMReplyPreviewView {
    let conversationId: Swift.String
    let participantUsername: Swift.String
    let participantName: Swift.String?
    let initialMessage: Swift.String
    let onSend: (_: Swift.String) -> ()
    let onCancel: () -> ()
    var _messageText: SwiftUI.State<Swift.String>
    var _isExpanded: SwiftUI.State<Swift.Bool>
    var _isLoadingHistory: SwiftUI.State<Swift.Bool>
    var _recentMessages: SwiftUI.State<[Spec.XDirectMessage]>
    var _isBodyFocused: SwiftUI.FocusState<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct $s4Spec0030XDMReplyPreviewViewswift_eDAEifMX343_0_33_A8F11E40B349CFC31149B42DCE1340FDLl7PreviewfMf_15PreviewRegistryfMu_ {}
class AnthropicServiceFactory {}
struct CerebrasService {
    class UserMessageTracker {
        var recentMessages: [Swift.String]
    }
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let apiKey: Swift.String
    let basePath: Swift.String
    let debugEnabled: Swift.Bool
    let enableThinking: Swift.Bool
    var messageTracker: Spec.CerebrasService.UserMessageTracker
}
class DefaultAnthropicService {
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let apiKey: Swift.String
    let apiVersion: Swift.String
    let basePath: Swift.String
    let betaHeaders: [Swift.String]?
    let debugEnabled: Swift.Bool
    var activeStreamTask: __C.NSURLSessionDataTask?
    let taskQueue: __C.OS_dispatch_queue
    var currentThreadID: Swift.String
}
class GeminiService {
    class UserMessageTracker {
        var recentMessages: [Swift.String]
    }
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let apiKey: Swift.String
    let basePath: Swift.String
    let debugEnabled: Swift.Bool
    let messageTracker: Spec.GeminiService.UserMessageTracker
    var activeStreamTask: __C.NSURLSessionDataTask?
    let taskQueue: __C.OS_dispatch_queue
    var defaultThinkingBudget: Swift.Int?
    var includeThoughtSummaries: Swift.Bool
}
struct GeminiResponse {
    enum CodingKeys {
        case candidates
        case usageMetadata
    }
    let candidates: [Spec.GeminiCandidate]?
    let usageMetadata: Spec.GeminiUsageMetadata?
}
struct GeminiCandidate {
    enum CodingKeys {
        case content
        case finishReason
        case index
    }
    let content: Spec.GeminiContent
    let finishReason: Swift.String?
    let index: Swift.Int?
}
struct GeminiContent {
    enum CodingKeys {
        case parts
        case role
    }
    let parts: [Spec.GeminiPart]
    let role: Swift.String?
}
struct GeminiPart {
    enum CodingKeys {
        case text
        case functionCall
        case functionResponse
        case thought
    }
    let text: Swift.String?
    let functionCall: Spec.GeminiFunctionCall?
    let functionResponse: Spec.GeminiFunctionResponse?
    let thought: Swift.Bool?
}
struct GeminiFunctionCall {
    enum CodingKeys {
        case name
        case args
    }
    let name: Swift.String
    let args: [Swift.String : Any]
}
struct GeminiFunctionResponse {
    enum CodingKeys {
        case name
        case response
    }
    let name: Swift.String
    let response: [Swift.String : Any]
}
struct GeminiUsageMetadata {
    enum CodingKeys {
        case promptTokenCount
        case candidatesTokenCount
        case totalTokenCount
        case thoughtsTokenCount
    }
    let promptTokenCount: Swift.Int?
    let candidatesTokenCount: Swift.Int?
    let totalTokenCount: Swift.Int?
    let thoughtsTokenCount: Swift.Int?
}
struct GeminiTokenCountResponse {
    enum CodingKeys {
        case totalTokens
    }
    let totalTokens: Swift.Int
}
struct GoogleVertexService {
    enum VertexModel {
        case claudeOpus4
        case claudeSonnet45
        case claudeHaiku35
    }
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let projectId: Swift.String
    let region: Swift.String
    let accessToken: Swift.String
    let modelId: Swift.String
    let debugEnabled: Swift.Bool
    let anthropicVersion: Swift.String
}
class GrokService {
    enum JSONValue {
        case string(Swift.String)
        case int(Swift.Int)
        case double(Swift.Double)
        case bool(Swift.Bool)
        case array([Spec.GrokService.JSONValue])
        case object([Swift.String : Spec.GrokService.JSONValue])
        case null
    }
    struct GrokChatCompletionRequest {
        enum CodingKeys {
            case model
            case messages
            case maxTokens
            case temperature
            case topP
            case stream
            case streamOptions
            case tools
            case toolChoice
            case user
        }
        let model: Swift.String
        let messages: [Spec.GrokService.GrokMessage]
        let maxTokens: Swift.Int?
        let temperature: Swift.Double?
        let topP: Swift.Double?
        var stream: Swift.Bool
        let streamOptions: Spec.GrokService.StreamOptions?
        let tools: [[Swift.String : Any]]?
        let toolChoice: Any?
        let user: Swift.String?
    }
    struct StreamOptions {
        enum CodingKeys {
            case includeUsage
        }
        let includeUsage: Swift.Bool
    }
    struct GrokMessage {
        enum CodingKeys {
            case role
            case content
        }
        let role: Swift.String
        let content: Swift.String
    }
    struct GrokResponse {
        struct Choice {
            enum CodingKeys {
                case index
                case message
                case finishReason
            }
            let index: Swift.Int
            let message: Spec.GrokService.GrokResponse.ResponseMessage
            let finishReason: Swift.String?
        }
        struct ResponseMessage {
            enum CodingKeys {
                case role
                case content
                case toolCalls
            }
            struct ToolCall {
                struct FunctionCall {
                    enum CodingKeys {
                        case name
                        case arguments
                    }
                    let name: Swift.String
                    let arguments: Swift.String
                }
                enum CodingKeys {
                    case id
                    case type
                    case function
                }
                let id: Swift.String
                let type: Swift.String
                let function: Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.FunctionCall
            }
            let role: Swift.String
            let content: Swift.String?
            let toolCalls: [Spec.GrokService.GrokResponse.ResponseMessage.ToolCall]?
        }
        struct Usage {
            enum CodingKeys {
                case promptTokens
                case completionTokens
                case totalTokens
            }
            let promptTokens: Swift.Int
            let completionTokens: Swift.Int
            let totalTokens: Swift.Int
        }
        enum CodingKeys {
            case id
            case object
            case created
            case model
            case choices
            case usage
        }
        let id: Swift.String
        let object: Swift.String
        let created: Swift.Int
        let model: Swift.String
        let choices: [Spec.GrokService.GrokResponse.Choice]
        let usage: Spec.GrokService.GrokResponse.Usage?
    }
    struct GrokStreamingChunk {
        struct StreamChoice {
            enum CodingKeys {
                case index
                case delta
                case finishReason
            }
            let index: Swift.Int
            let delta: Spec.GrokService.GrokStreamingChunk.Delta?
            let finishReason: Swift.String?
        }
        struct Delta {
            enum CodingKeys {
                case role
                case content
                case reasoningContent
                case toolCalls
            }
            let role: Swift.String?
            let content: Swift.String?
            let reasoningContent: Swift.String?
            let toolCalls: [Spec.GrokService.GrokStreamingChunk.ToolCall]?
        }
        struct ToolCall {
            struct FunctionCall {
                enum CodingKeys {
                    case name
                    case arguments
                }
                let name: Swift.String?
                let arguments: Swift.String?
            }
            enum CodingKeys {
                case index
                case id
                case type
                case function
            }
            let index: Swift.Int
            let id: Swift.String?
            let type: Swift.String?
            let function: Spec.GrokService.GrokStreamingChunk.ToolCall.FunctionCall?
        }
        enum CodingKeys {
            case id
            case object
            case created
            case model
            case choices
            case usage
        }
        let id: Swift.String
        let object: Swift.String
        let created: Swift.Int
        let model: Swift.String
        let choices: [Spec.GrokService.GrokStreamingChunk.StreamChoice]
        let usage: Spec.GrokService.GrokResponse.Usage?
    }
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let apiKey: Swift.String
    let basePath: Swift.String
    let debugEnabled: Swift.Bool
    var defaultThinkingBudget: Swift.Int?
    var includeThoughtSummaries: Swift.Bool
}
class LocalLLMService {
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let modelManager: Spec.ModelManager
    var cachedSystemPrompt: Swift.String?
    var cachedPromptPath: Swift.String?
    var isCacheWarming: Swift.Bool
}
enum LocalLLMError {
    case unsupportedModelType(Swift.String)
    case cachingFailed(Swift.String)
    case modelNotReady
    case streamingNotSupported
    case notImplemented
}
struct NovitaService {
    class UserMessageTracker {
        var recentMessages: [Swift.String]
    }
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let apiKey: Swift.String
    let basePath: Swift.String
    let debugEnabled: Swift.Bool
    var messageTracker: Spec.NovitaService.UserMessageTracker
}
class OpenAIResponsesService {
    class UserMessageTracker {
        var recentMessages: [Swift.String]
    }
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let apiKey: Swift.String
    let basePath: Swift.String
    let debugEnabled: Swift.Bool
    let messageTracker: Spec.OpenAIResponsesService.UserMessageTracker
    var activeStreamTask: __C.NSURLSessionDataTask?
    let taskQueue: __C.OS_dispatch_queue
    var currentResponseId: Swift.String?
}
struct _FnOut {
    enum CodingKeys {
        case type
        case call_id
        case output
    }
    let type: Swift.String
    let call_id: Swift.String
    let output: Swift.String
}
struct _ResumeBody {
    enum CodingKeys {
        case model
        case previous_response_id
        case input
        case stream
    }
    let model: Swift.String
    let previous_response_id: Swift.String
    let input: [Spec._FnOut]
    let stream: Swift.Bool
}
class OpenAIService {
    class UserMessageTracker {
        var recentMessages: [Swift.String]
    }
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let apiKey: Swift.String
    let basePath: Swift.String
    let debugEnabled: Swift.Bool
    let messageTracker: Spec.OpenAIService.UserMessageTracker
    var activeStreamTask: __C.NSURLSessionDataTask?
    let taskQueue: __C.OS_dispatch_queue
}
struct OpenAIResponse {
    enum CodingKeys {
        case id
        case object
        case created
        case model
        case choices
        case usage
    }
    let id: Swift.String
    let object: Swift.String
    let created: Swift.Int
    let model: Swift.String
    let choices: [Spec.OpenAIChoice]
    let usage: Spec.OpenAIUsage?
}
struct OpenAIChoice {
    enum CodingKeys {
        case index
        case message
        case finishReason
    }
    let index: Swift.Int
    let message: Spec.OpenAIMessage
    let finishReason: Swift.String?
}
struct OpenAIMessage {
    enum CodingKeys {
        case role
        case content
        case toolCalls
    }
    let role: Swift.String
    let content: Swift.String?
    let toolCalls: [Spec.OpenAIToolCall]?
}
struct OpenAIToolCall {
    enum CodingKeys {
        case id
        case type
        case function
    }
    let id: Swift.String
    let type: Swift.String
    let function: Spec.OpenAIFunction
}
struct OpenAIFunction {
    enum CodingKeys {
        case name
        case arguments
    }
    let name: Swift.String
    let arguments: Swift.String
}
struct OpenAIUsage {
    enum CodingKeys {
        case promptTokens
        case completionTokens
        case totalTokens
    }
    let promptTokens: Swift.Int
    let completionTokens: Swift.Int
    let totalTokens: Swift.Int
}
struct OpenAIStreamChunk {
    enum CodingKeys {
        case id
        case object
        case created
        case model
        case choices
    }
    let id: Swift.String
    let object: Swift.String
    let created: Swift.Int
    let model: Swift.String
    let choices: [Spec.OpenAIStreamChoice]
}
struct OpenAIStreamChoice {
    enum CodingKeys {
        case index
        case delta
        case finishReason
    }
    let index: Swift.Int
    let delta: Spec.OpenAIDelta
    let finishReason: Swift.String?
}
struct OpenAIDelta {
    enum CodingKeys {
        case role
        case content
        case toolCalls
        case refusal
    }
    let role: Swift.String?
    let content: Swift.String?
    let toolCalls: [Spec.OpenAIToolCallDelta]?
    let refusal: Swift.String?
}
struct OpenAIToolCallDelta {
    enum CodingKeys {
        case index
        case id
        case type
        case function
    }
    let index: Swift.Int
    let id: Swift.String?
    let type: Swift.String?
    let function: Spec.OpenAIFunctionDelta?
}
struct OpenAIFunctionDelta {
    enum CodingKeys {
        case name
        case arguments
    }
    let name: Swift.String?
    let arguments: Swift.String?
}
struct TogetherService {
    class UserMessageTracker {
        var recentMessages: [Swift.String]
    }
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let apiKey: Swift.String
    let basePath: Swift.String
    let debugEnabled: Swift.Bool
    let enableThinking: Swift.Bool
    var messageTracker: Spec.TogetherService.UserMessageTracker
}
enum AuthError {
    case signInFailed(message: Swift.String)
    case gmailAPIError(message: Swift.String)
    case unknown
    case network
    case userCancelled
    case emailAlreadyInUse
    case invalidEmail
    case weakPassword
    case wrongPassword
    case userNotFound
    case requiresRecentLogin
    case credentialAlreadyInUse
    case userDisabled
    case gmailAccessDenied
    case gmailTokenExpired
}
class AuthViewModel {
    var _user: Combine.Published<FirebaseAuth.User?>
    var _gmailAccessToken: Combine.Published<Swift.String?>
    var handle: __C.NSObject?
    var lastAuthUid: Swift.String?
    let gmailScope: Swift.String
    let calendarScope: Swift.String
    let contactsScope: Swift.String
    let contactsOtherScope: Swift.String
}
struct ContinueWithGoogleButton {
    let robotoFontSize: CoreGraphics.CGFloat
    var _auth: SwiftUI.EnvironmentObject<Spec.AuthViewModel>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _signInError: SwiftUI.State<Spec.AuthError?>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _lockoutTask: SwiftUI.State<Swift.Task<(), Swift.Never>?>
    let customAction: (() -> ())?
}
struct GooglePillStyle {
    var _isEnabled: SwiftUI.Environment<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
class GoogleMultiAccountManager {
    struct GoogleAccount {
        enum CodingKeys {
            case id
            case email
            case accessToken
            case refreshToken
            case displayName
            case expirationDate
        }
        let id: Foundation.UUID
        let email: Swift.String
        var accessToken: Swift.String
        var refreshToken: Swift.String?
        let displayName: Swift.String?
        var expirationDate: Foundation.Date?
    }
    var _accounts: Combine.Published<[Spec.GoogleMultiAccountManager.GoogleAccount]>
    let userDefaultsKey: Swift.String
    let gmailScope: Swift.String
    let calendarScope: Swift.String
    let contactsScope: Swift.String
}
struct XAPISettingsView {
    var _isEnabled: SwiftUI.State<Swift.Bool>
    var _connectedUsername: SwiftUI.State<Swift.String?>
    var _connectedAt: SwiftUI.State<Foundation.Date?>
    var _scopes: SwiftUI.State<[Swift.String]>
    var _isAuthenticating: SwiftUI.State<Swift.Bool>
    var _errorMessage: SwiftUI.State<Swift.String?>
    var _monitoringStatus: SwiftUI.State<Spec.XMonitoringService.MonitoringStatus?>
}
struct $s4Spec0027XAPISettingsViewswift_ovFAhfMX308_0_33_CBD234D87587863EFB66F4D04456F3CBLl7PreviewfMf_15PreviewRegistryfMu_ {}
class InstagramAuthManager: __C.NSObject {
    var onSaved: ((_: Swift.Bool) -> ())?
    var hasSaved: Swift.Bool
    var window: __C.NSWindow?
    var webView: __C.WKWebView?
}
class InstagramCredentialsStore {
    struct Envelope {
        enum CodingKeys {
            case nonce
            case ciphertext
            case tag
            case createdAt
        }
        let nonce: Foundation.Data
        let ciphertext: Foundation.Data
        let tag: Foundation.Data
        let createdAt: Foundation.Date
    }
    let keyTag: Foundation.Data
    let storageKey: Swift.String
}
struct SignInWithGoogleButtonView {
    var _auth: SwiftUI.EnvironmentObject<Spec.AuthViewModel>
    var _error: SwiftUI.State<Spec.AuthError?>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
class SimpleOAuthFlow {}
class WebAuthPresentationContextProvider: __C.NSObject {}
class SlackAuthManager: __C.NSObject {
    let defaultUserScopes: [Swift.String]
    var session: __C.ASWebAuthenticationSession?
    var webWindow: __C.NSWindow?
    var webView: __C.WKWebView?
    var pendingState: Swift.String?
}
class GmailEmailComposer {
    let baseURL: Swift.String
}
enum GmailError {
    case httpError(statusCode: Swift.Int)
    case unauthorized
    case forbidden
    case notFound
    case invalidResponse
}
class MessageEventTestViewModel {
    let dm: Spec.DirectMessagesManager
    let ai: Spec.AppleIntelligenceService
    var _searchText: Combine.Published<Swift.String>
    var _contacts: Combine.Published<[Spec.Contact]>
    var _isSearching: Combine.Published<Swift.Bool>
    var _selectedContact: Combine.Published<Spec.Contact?>
    var _selectedChatGuid: Combine.Published<Swift.String?>
    var _messages: Combine.Published<[Spec.Message]>
    var _lastIncomingMessage: Combine.Published<Spec.Message?>
    var _isAnalyzing: Combine.Published<Swift.Bool>
    var _analysisOutput: Combine.Published<Swift.String>
    var _errorMessage: Combine.Published<Swift.String?>
    var _status: Combine.Published<Swift.String>
    var _useAppleIntelligence: Combine.Published<Swift.Bool>
    var _validationResults: Combine.Published<[Spec.EventValidationResult]>
    var _validEventCount: Combine.Published<Swift.Int>
    var _invalidEventCount: Combine.Published<Swift.Int>
}
struct EventValidationResult {
    let id: Foundation.UUID
    let title: Swift.String
    let startDateTime: Swift.String
    let participants: [Swift.String]
    let isValid: Swift.Bool
    let reasons: [Swift.String]
    let eventType: Swift.String
}
class GmailService {
    struct AttachmentResponse {
        enum CodingKeys {
            case data
            case size
        }
        let data: Swift.String?
        let size: Swift.Int?
    }
    let baseURL: Swift.String
}
struct ThreadListResponse {
    enum CodingKeys {
        case threads
    }
    let threads: [Spec.ThreadID]?
}
struct ThreadID {
    enum CodingKeys {
        case id
    }
    let id: Swift.String
}
struct ThreadDetail {
    enum CodingKeys {
        case messages
    }
    let messages: [Spec.GmailMessage]
}
struct GmailMessage {
    enum CodingKeys {
        case id
        case snippet
        case payload
        case internalDate
        case labelIds
    }
    let id: Swift.String
    let snippet: Swift.String
    let payload: Spec.Payload
    let internalDate: Swift.String
    let labelIds: [Swift.String]?
}
struct Payload {
    enum CodingKeys {
        case headers
        case body
        case parts
    }
    let headers: [Spec.Header]
    let body: Spec.MessageBody?
    let parts: [Spec.MessagePart]?
}
struct Header {
    enum CodingKeys {
        case name
        case value
    }
    let name: Swift.String
    let value: Swift.String
}
struct MessageBody {
    enum CodingKeys {
        case data
        case size
        case attachmentId
    }
    let data: Swift.String?
    let size: Swift.Int?
    let attachmentId: Swift.String?
}
struct MessagePart {
    enum CodingKeys {
        case mimeType
        case filename
        case body
        case parts
    }
    let mimeType: Swift.String
    let filename: Swift.String?
    let body: Spec.MessageBody?
    let parts: [Spec.MessagePart]?
}
struct EmailDetail {
    enum CodingKeys {
        case id
        case threadId
        case snippet
        case payload
        case internalDate
        case labelIds
    }
    let id: Swift.String
    let threadId: Swift.String
    let snippet: Swift.String
    let payload: Spec.Payload
    let internalDate: Swift.String
    let labelIds: [Swift.String]?
}
struct ThreadSummary {
    let id: Swift.String
    let messages: [Spec.MessageSummary]
}
struct MessageSummary {
    let id: Swift.String
    let from: Swift.String
    let to: Swift.String
    let subject: Swift.String
    let snippet: Swift.String
    let date: Swift.Int64
    let labelIds: [Swift.String]?
}
enum AppTheme {
    enum Colors {}
    enum Surfaces {}
}
enum ToolFilterStrategy {
    case blacklist([Swift.String])
    case none
    case priorityTiers
    case contextAware
}
struct Phase2Participant {
    enum CodingKeys {
        case name
        case contacts
    }
    let name: Swift.String
    let contacts: [Swift.String]
}
struct AttachmentDoc {
    enum CodingKeys {
        case title
        case url
        case type
    }
    let title: Swift.String?
    let url: Swift.String?
    let type: Swift.String?
}
struct Phase2DraftedAction {
    enum CodingKeys {
        case spec_should_do_further_work
        case content
        case spec_further_work_description
        case description
        case title
        case button_title
    }
    let spec_should_do_further_work: Swift.Bool?
    let content: Swift.String?
    let spec_further_work_description: Swift.String?
    let description: Swift.String?
    let title: Swift.String?
    let button_title: Swift.String?
}
struct Phase2Event {
    enum CodingKeys {
        case event_id
        case event_title
        case event_description
        case start_datetime
        case end_datetime
        case estimated_duration_in_minutes
        case participants
        case meeting_location
        case meeting_link
        case meeting_call_link
        case meeting_info_link
        case attachment_docs_for_review
        case source_docs
        case associated_stream_id
        case status
        case spec_drafted_actions
        case meeting_prep_doc
        case meeting_debrief_doc
        case event_urgent_action
        case is_duplicate
        case is_deprecated
        case is_solicitation
        case meeting_type
        case has_approximate_or_specific_event_location
        case has_approximate_meeting_location
        case has_attended_event_from_sender_previously
        case is_all_day_event
    }
    let event_id: Swift.String
    let event_title: Swift.String
    let event_description: Swift.String
    let start_datetime: Swift.String
    let end_datetime: Swift.String?
    let estimated_duration_in_minutes: Swift.Int?
    let participants: [Spec.Phase2Participant]
    let meeting_location: Swift.String?
    let meeting_link: Swift.String?
    let meeting_call_link: Swift.String?
    let meeting_info_link: Swift.String?
    let attachment_docs_for_review: [Spec.AttachmentDoc]
    let source_docs: Spec.SourceDocs
    let associated_stream_id: Swift.String
    let status: Swift.String
    let spec_drafted_actions: [Spec.Phase2DraftedAction]?
    let meeting_prep_doc: Spec.MeetingPrepDoc?
    let meeting_debrief_doc: Spec.MeetingDebriefDoc?
    let event_urgent_action: Spec.EventUrgentAction?
    let is_duplicate: Swift.Bool?
    let is_deprecated: Swift.Bool?
    let is_solicitation: Swift.Bool?
    let meeting_type: Swift.String?
    let has_approximate_or_specific_event_location: Swift.Bool?
    let has_attended_event_from_sender_previously: Swift.Bool?
    let is_all_day_event: Swift.Bool?
}
enum SourceDocs {
    case string(Swift.String)
    case array([Swift.String])
}
struct Phase2Data {
    enum CodingKeys {
        case events
    }
    let events: [Spec.Phase2Event]
}
class Phase2EventParser {
    enum CanonicalEventStatus {
        case confirmed
        case invited
        case tentative
        case proposed
        case rescheduled
        case scheduled
        case cancelled
        case canceled
        case declined
        case unknown
    }
}
struct AnyViewModifier {}
struct AspectRatioModifier {
    let ratio: CoreGraphics.CGFloat
}
struct EquatableViewModifier {}
struct SpecLeadingWatermarkModifier {
    let size: CoreGraphics.CGFloat
    let opacity: Swift.Double
    let leadingPadding: CoreGraphics.CGFloat
    let pushTextBy: CoreGraphics.CGFloat
}
class PinnedChatManager {
    var _pinnedChats: Combine.Published<[Spec.LocalChatThread]>
    var cleanupTimer: __C.NSTimer?
}
struct FirestoreStoredMessage {
    enum CodingKeys {
        case id
        case createdAt
        case anthropicId
        case message
    }
    var _id: FirebaseFirestore.DocumentID<Swift.String>
    var createdAt: __C.FIRTimestamp
    var anthropicId: Swift.String?
    var message: Spec.MessageParameter.Message
}
struct RelayChatMessage {
    enum CodingKeys {
        case id
        case threadID
        case text
        case createdAt
        case senderUid
        case processed
    }
    var _id: FirebaseFirestore.DocumentID<Swift.String>
    var threadID: Swift.String
    var text: Swift.String
    var createdAt: __C.FIRTimestamp
    var senderUid: Swift.String
    var processed: Swift.Bool
}
struct SpecVirtualMachine {
    enum CodingKeys {
        case id
        case isActive
        case lastActiveAt
        case currentActiveApp
        case currentActiveThreadID
        case status
        case name
        case displayName
        case ownerUserID
        case editors
        case viewers
        case ipAddress
        case hostName
        case createdAt
        case updatedAt
    }
    var _id: FirebaseFirestore.DocumentID<Swift.String>
    var isActive: Swift.Bool
    var lastActiveAt: __C.FIRTimestamp?
    var currentActiveApp: Swift.String?
    var currentActiveThreadID: Swift.String?
    var status: Swift.String?
    var name: Swift.String
    var displayName: Swift.String?
    var ownerUserID: Swift.String?
    var editors: [Swift.String]?
    var viewers: [Swift.String]?
    var ipAddress: Swift.String?
    var hostName: Swift.String?
    var createdAt: __C.FIRTimestamp
    var updatedAt: __C.FIRTimestamp
}
struct DraftXDMReplyPreviewView {
    let conversationId: Swift.String
    let participantUsername: Swift.String
    let participantName: Swift.String?
    let initialMessage: Swift.String
    let onSend: (_: Swift.String) -> ()
    let onCancel: () -> ()
    var _messageText: SwiftUI.State<Swift.String>
    var _isExpanded: SwiftUI.State<Swift.Bool>
    var _isLoadingHistory: SwiftUI.State<Swift.Bool>
    var _recentMessages: SwiftUI.State<[Spec.XDirectMessage]>
    var _isBodyFocused: SwiftUI.FocusState<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct $s4Spec0035DraftXDMReplyPreviewViewswift_IgGGkfMX343_0_33_EC73086B80D134D99E46CA09658DD3B5Ll7PreviewfMf_15PreviewRegistryfMu_ {}
actor VirtualMachineService {
    var $defaultActor: 
    let db: __C.FIRFirestore
    let col: __C.FIRCollectionReference
}
struct CalendarReport {
    let extractionDate: Foundation.Date
    let calendars: [Spec.CalendarInfo]
    let events: [Spec.CalendarEvent]
    let stats: Spec.CalendarStats
}
struct CalendarInfo {
    let id: Swift.String
    let title: Swift.String
    let type: Swift.String
    let color: Swift.String?
    let eventCount: Swift.Int
    let isSubscribed: Swift.Bool
    let isImmutable: Swift.Bool
}
struct CalendarEvent {
    let id: Swift.String
    let calendarId: Swift.String
    let title: Swift.String
    let notes: Swift.String?
    let location: Swift.String?
    let startDate: Foundation.Date
    let endDate: Foundation.Date
    let isAllDay: Swift.Bool
    let status: Swift.String
    let attendeeCount: Swift.Int
    let hasAlarms: Swift.Bool
    let isRecurring: Swift.Bool
    let recurrenceRule: Swift.String?
    let organizer: Swift.String?
    let url: Swift.String?
}
struct CalendarStats {
    let totalEvents: Swift.Int
    let upcomingEvents: Swift.Int
    let pastEvents: Swift.Int
    let recurringEvents: Swift.Int
    let eventsWithAttendees: Swift.Int
    let allDayEvents: Swift.Int
    let calendarCount: Swift.Int
}
class CalendarExtractor {
    let database: Spec.UserProfileDatabase
    let eventStore: __C.EKEventStore
}
enum DKEventStream {
    case appIntents
    case appUsage
    case appWebUsage
    case appMediaUsage
    case bluetoothConnected
    case notificationUsage
    case portraitEntity
    case discoverabilitySignals
    case displayBacklit
    case deviceLocked
}
struct DKEventRecord {
    let streamName: Swift.String
    let timestamp: Foundation.Date
    let endTime: Foundation.Date?
    let valueString: Swift.String?
    let valueInteger: Swift.Int?
    let valueDouble: Swift.Double?
    let metadata: [Swift.String : Any]
    let deviceId: Swift.String?
}
struct StreamAnalysis {
    let streamName: Swift.String
    let recordCount: Swift.Int
    let dateRange: (start: Foundation.Date, end: Foundation.Date)?
    let topValues: [(value: Swift.String, count: Swift.Int)]
    let patterns: [Swift.String]
    let insights: [Swift.String]
}
struct ComprehensiveDKReport {
    let extractionDate: Foundation.Date
    let dateRange: (start: Foundation.Date, end: Foundation.Date)
    let streamAnalyses: [Spec.StreamAnalysis]
    let crossStreamInsights: [Swift.String]
    let userBehaviorProfile: Spec.UserBehaviorProfile
    let deviceBreakdown: [Swift.String : Spec.DeviceInfo]
    let usageCharts: Spec.UsageCharts?
}
struct UsageCharts {
    let hourlyUsage: [Swift.Int : Swift.Int]
    let weeklyHourlyAverage: [Swift.Int : [Swift.Int : Swift.Int]]
    let dailyTotals: [Swift.String : Swift.Int]
    let peakUsageHours: [(hour: Swift.Int, minutes: Swift.Int)]
    let deviceHourlyUsage: [Swift.String : [Swift.Int : Swift.Int]]
}
struct DeviceInfo {
    let deviceId: Swift.String
    let deviceName: Swift.String
    let deviceType: Swift.String
    let eventCount: Swift.Int
    let firstSeen: Foundation.Date?
    let lastSeen: Foundation.Date?
    let primaryStreams: [Swift.String]
}
struct UserBehaviorProfile {
    let workingHours: [Swift.Int]
    let focusApps: [Swift.String]
    let communicationPattern: Swift.String
    let mediaConsumptionHabits: Swift.String
    let deviceUsagePattern: Swift.String
    let bluetoothDevices: [Swift.String]
    let webBrowsingTopics: [Swift.String]
    let dailyRoutine: Swift.String
}
struct DeviceIdentification {
    let uuid: Swift.String
    let name: Swift.String
    let type: Swift.String
    let confidence: Swift.String
    let syncCount: Swift.Int
}
class ComprehensiveDKEventExtractor {
    var _isExtracting: Combine.Published<Swift.Bool>
    var _progress: Combine.Published<Swift.Double>
    var _statusMessage: Combine.Published<Swift.String>
    var _currentStream: Combine.Published<Swift.String>
    var _extractedReport: Combine.Published<Spec.ComprehensiveDKReport?>
    let database: Spec.UserProfileDatabase
    var deviceMappings: [Swift.String : Spec.DeviceIdentification]
}
struct DKEventInsightsDemo {
    struct InsightCategory {
        let id: Foundation.UUID
        let name: Swift.String
        let icon: Swift.String
        let insights: [Swift.String]
        let color: SwiftUI.Color
    }
    var _screenTimeExtractor: SwiftUI.StateObject<Spec.ScreenTimeExtractor>
    var _comprehensiveExtractor: SwiftUI.StateObject<Spec.ComprehensiveDKEventExtractor>
    var _insights: SwiftUI.State<[Spec.DKEventInsightsDemo.InsightCategory]>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _selectedCategory: SwiftUI.State<Spec.DKEventInsightsDemo.InsightCategory?>
}
struct DKEventInsightsDemoApp {}
enum FunctionCallDefinition {
    case instagramClickYourStory
    case instagramOpenSeenBy
    case instagramCheckViewer
    case browserStartSubagent
    case browserNavigate
    case browserViewSourceAsText
    case browserGetAccessibilityTree
    case browserClickElement
    case browserEnterTextIntoInputField
    case browserWait
    case browserGetCurrentUrl
    case browserSearchElement
    case browserPressKey
    case browserCloseTabs
    case browserOpenTabs
    case createNotionPage
    case fileWrite
    case fileRead
    case createExcelWorkbook
    case editDocument
    case readFullUserProfile
    case profileEdit
    case searchEvents
    case searchStreams
    case searchStreamNodes
    case searchBrowserHistory
    case searchBrowserBookmarks
    case searchNotionPages
    case eventCreate
    case eventEdit
    case streamEdit
    case streamNodeEdit
    case messagesRead
    case messagesDraft
    case messagesFindContact
    case messagesFindChat
    case messagesReadRecentConversations
    case messagesFindNeedsReply
    case messagesSearch
    case getContactMessagingInfo
    case whatsappRead
    case whatsappDraft
    case whatsappFindContact
    case whatsappFindChat
    case whatsappReadRecentConversations
    case whatsappFindNeedsReply
    case emailRead
    case emailSearch
    case emailDraft
    case emailListAccounts
    case emailOpenThread
    case emailOpenAttachment
    case emailDraftReply
    case emailFindNeedsReply
    case slackListAccounts
    case slackListConversations
    case slackFindUser
    case slackFindConversation
    case slackRead
    case slackSearchMessages
    case slackListInteractions
    case slackReadRecentConversations
    case slackOpenThread
    case slackDraftReply
    case slackConfirmSendReply
    case slackFindNeedsReply
    case replyProcessingCreateDraft
    case replyProcessingNoDraft
    case replyProcessingDeprecateDraft
    case meetingNotesReadSummary
    case meetingNotesReadTranscript
    case meetingNotesList
    case meetingDebriefRead
    case meetingDebriefGenerate
    case viewUserSchedule
    case calendarListEvents
    case calendarCreateEvent
    case calendarUpdateEvent
    case calendarDeleteEvent
    case digitalWellbeingSetGoal
    case digitalWellbeingGetStatus
    case appleNotesCreate
    case appleNotesRead
    case appleNotesEdit
    case appleNotesList
    case appleNotesSearch
    case taskCreate
    case taskEdit
    case taskList
    case taskDelete
    case taskExecuteNow
    case taskViewLogs
    case taskHandleFailure
    case xGetTimeline
    case xGetMentions
    case xGetUserTweets
    case xSearchTweets
    case xGetTweet
    case xGetUserProfile
    case xGetFollowers
    case xGetFollowing
    case xGetBookmarks
    case xGetDirectMessages
    case xSearchSpaces
    case xDraftTweet
    case xDraftReplyTweet
    case xDraftDM
}
struct Meeting {
    let id: Swift.String
    let title: Swift.String
    let createdAt: Foundation.Date
    let creatorName: Swift.String
    let creatorEmail: Swift.String
    let attendees: [Spec.Attendee]
    let conferenceURL: Swift.String?
    let summary: Swift.String?
    let transcripts: [Spec.TranscriptEntry]
    var provider: Swift.String?
}
struct Attendee {
    let name: Swift.String
    let email: Swift.String
}
struct TranscriptEntry {
    let text: Swift.String
    let source: Swift.String
    let startTimestamp: Foundation.Date?
    let endTimestamp: Foundation.Date?
    let isFinal: Swift.Bool
}
class MeetingNotesProviderManager {
    var providers: [Spec.MeetingNotesProvider]
}
struct MeetingNotes {}
enum MeetingNotesError {
    case providerNotFound(Swift.String)
    case providerNotAvailable(Swift.String)
    case meetingNotFound(Swift.String)
    case noProvidersAvailable
    case invalidFormat
}
class GranolaMeetingNotesProvider {
    struct GranolaCache {
        let state: Spec.GranolaMeetingNotesProvider.GranolaState
    }
    struct GranolaState {
        let documents: [Swift.String : Spec.GranolaMeetingNotesProvider.Document]
        let meetingsMetadata: [Swift.String : Spec.GranolaMeetingNotesProvider.MeetingMetadata]
        let transcripts: [Swift.String : [Spec.GranolaMeetingNotesProvider.TranscriptData]]
        let documentPanels: [Swift.String : [Swift.String : Spec.GranolaMeetingNotesProvider.Panel]]
    }
    struct Document {
        let id: Swift.String
        let title: Swift.String?
        let createdAt: Swift.String?
        let summary: Swift.String?
        let notes: Swift.String?
        let overview: Swift.String?
    }
    struct MeetingMetadata {
        let creator: Spec.GranolaMeetingNotesProvider.Creator?
        let attendees: [Spec.GranolaMeetingNotesProvider.AttendeeData]?
        let conferencing: Spec.GranolaMeetingNotesProvider.Conferencing?
    }
    struct Creator {
        let name: Swift.String?
        let email: Swift.String?
    }
    struct AttendeeData {
        let email: Swift.String?
        let details: Spec.GranolaMeetingNotesProvider.AttendeeDetails?
    }
    struct AttendeeDetails {
        let person: Spec.GranolaMeetingNotesProvider.PersonDetails?
    }
    struct PersonDetails {
        let name: Spec.GranolaMeetingNotesProvider.NameDetails?
    }
    struct NameDetails {
        let fullName: Swift.String?
    }
    struct Conferencing {
        let url: Swift.String?
    }
    struct TranscriptData {
        enum CodingKeys {
            case text
            case source
            case start_timestamp
            case end_timestamp
            case is_final
        }
        let text: Swift.String?
        let source: Swift.String?
        let start_timestamp: Swift.String?
        let end_timestamp: Swift.String?
        let is_final: Swift.Bool?
    }
    struct Panel {
        enum CodingKeys {
            case title
            case content
        }
        let title: Swift.String?
        let content: Spec.GranolaMeetingNotesProvider.ProseMirrorContent?
    }
    struct ProseMirrorContent {
        enum CodingKeys {
            case type
            case content
        }
        let type: Swift.String?
        let content: [Spec.GranolaMeetingNotesProvider.ProseMirrorNode]?
    }
    struct ProseMirrorNode {
        enum CodingKeys {
            case type
            case text
            case content
        }
        let type: Swift.String?
        let text: Swift.String?
        let content: [Spec.GranolaMeetingNotesProvider.ProseMirrorNode]?
    }
    struct CacheWrapper {
        enum CodingKeys {
            case cache
        }
        let cache: Swift.String
    }
    struct CacheData {
        enum CodingKeys {
            case state
            case version
        }
        let state: Spec.GranolaMeetingNotesProvider.GranolaStateData
        let version: Swift.Int?
    }
    struct GranolaStateData {
        enum CodingKeys {
            case documents
            case meetingsMetadata
            case transcripts
            case documentPanels
            case calendars
            case events
            case people
            case featureFlags
        }
        let documents: [Swift.String : Spec.GranolaMeetingNotesProvider.DocumentData]
        let meetingsMetadata: [Swift.String : Spec.GranolaMeetingNotesProvider.MeetingMetadataData]
        let transcripts: [Swift.String : [Spec.GranolaMeetingNotesProvider.TranscriptData]]
        let documentPanels: [Swift.String : [Swift.String : Spec.GranolaMeetingNotesProvider.Panel]]
        let calendars: [Swift.String : Any]?
        let events: [Swift.String : Any]?
        let people: [Swift.String : Any]?
        let featureFlags: [Swift.String : Any]?
    }
    struct DocumentData {
        enum CodingKeys {
            case id
            case title
            case created_at
            case summary
            case notes
            case notes_plain
            case overview
        }
        let id: Swift.String?
        let title: Swift.String?
        let created_at: Swift.String?
        let summary: Swift.String?
        let notes: Swift.String?
        let notes_plain: Swift.String?
        let overview: Swift.String?
    }
    struct MeetingMetadataData {
        enum CodingKeys {
            case creator
            case attendees
            case conferencing
        }
        let creator: Spec.GranolaMeetingNotesProvider.CreatorData?
        let attendees: [Spec.GranolaMeetingNotesProvider.AttendeeDataCodable]?
        let conferencing: Spec.GranolaMeetingNotesProvider.ConferencingData?
    }
    struct CreatorData {
        enum CodingKeys {
            case name
            case email
        }
        let name: Swift.String?
        let email: Swift.String?
    }
    struct AttendeeDataCodable {
        enum CodingKeys {
            case email
            case details
        }
        let email: Swift.String?
        let details: Spec.GranolaMeetingNotesProvider.AttendeeDetailsData?
    }
    struct AttendeeDetailsData {
        enum CodingKeys {
            case person
        }
        let person: Spec.GranolaMeetingNotesProvider.PersonDetailsData?
    }
    struct PersonDetailsData {
        enum CodingKeys {
            case name
        }
        let name: Spec.GranolaMeetingNotesProvider.NameDetailsData?
    }
    struct NameDetailsData {
        enum CodingKeys {
            case fullName
        }
        let fullName: Swift.String?
    }
    struct ConferencingData {
        enum CodingKeys {
            case url
        }
        let url: Swift.String?
    }
    let name: Swift.String
}
class QuillMeetingNotesProvider {
    let name: Swift.String
    let extractor: Spec.QuillDataExtractor
}
class ResumptionGuard {
    var hasResumed: Swift.Bool
    let lock: __C.NSLock
}
class ResponseManager {
    var responseHandlers: [Swift.String : (_: Swift.String) -> ()]
    var observers: [__C.NSObject]
    let handlerQueue: __C.OS_dispatch_queue
    var timedOutCommands: Swift.Set<Swift.String>
}
class MessageFunctionCallingObservable {
    struct CachePoint {
        let messageIndex: Swift.Int
        let blockIndex: Swift.Int
        let size: Swift.Int
        let age: Swift.Int
        let valueScore: Swift.Double
    }
    struct CacheLocation {
        let messageIndex: Swift.Int
        let blockIndex: Swift.Int
    }
    struct SummaryResponse {
        enum CodingKeys {
            case userQuery
            case actionsTaken
            case successfulApproaches
            case failedApproaches
            case remainingActions
            case nextSteps
        }
        let userQuery: Swift.String
        let actionsTaken: [Swift.String]
        let successfulApproaches: [Swift.String]
        let failedApproaches: [Swift.String]
        let remainingActions: [Swift.String]
        let nextSteps: [Swift.String]
    }
    struct SlackNeedsReply {
        let teamId: Swift.String
        let teamName: Swift.String
        let channelId: Swift.String
        let channelName: Swift.String
        let lastSenderName: Swift.String
        let lastSenderUserId: Swift.String
        let lastText: Swift.String
        let lastTs: Swift.String
        let lastDate: Foundation.Date
        let userLastReplyDate: Foundation.Date?
        let messageCount: Swift.Int
        let isExternal: Swift.Bool
        let isMention: Swift.Bool
    }
    struct ThreadNeedsReply {
        let threadId: Swift.String
        let messageId: Swift.String
        let subject: Swift.String
        let snippet: Swift.String
        let lastSender: Swift.String
        let lastSenderEmail: Swift.String
        let lastMessageDate: Foundation.Date
        let userLastReplyDate: Foundation.Date?
        let threadMessageCount: Swift.Int
        let accountEmail: Swift.String
        let url: Swift.String
        let isSpam: Swift.Bool
    }
    struct ProfileEmailMeta {
        let isPrimary: Swift.Bool
        let isBusiness: Swift.Bool
    }
    var _threadID: Swift.String
    var _modelCapabilities: Spec.ModelCapabilities?
    var _conversationTokens: [Swift.String : Any]
    var _contextWindowThreshold: Swift.Double
    var _needsSummarization: Swift.Bool
    var _pendingUserInput: Swift.String?
    var _contactInfoCache: [Swift.String : [Swift.String : Any]]
    var _attachedSummaries: [Spec.ConversationSummary]
    var _attachedStreamContext: Swift.String?
    var _currentEmailThreadId: Swift.String?
    var _currentEmailMessageId: Swift.String?
    var _currentEmailAccount: Swift.String?
    var _currentEmailSubject: Swift.String?
    var _currentEmailFromHeader: Swift.String?
    var _currentEmailToHeader: Swift.String?
    var _currentEmailCcHeader: Swift.String?
    var _currentEmailReplyToHeader: Swift.String?
    var _currentSlackTeamId: Swift.String?
    var _currentSlackChannelId: Swift.String?
    var _currentSlackThreadTs: Swift.String?
    var _isAppleNotesSearchInFlight: Swift.Bool
    var _hasReadProfileInConversation: Swift.Bool
    var _chatService: Spec.ChatServiceProtocol?
    var _disablePersistence: Swift.Bool
    var _broadcastUINotifications: Swift.Bool
    var _service: Spec.AnthropicService
    var _errorMessage: Swift.String
    var _isLoading: Swift.Bool
    var _message: Swift.String
    var _thinking: Swift.String
    var _selectedModel: Spec.Model?
    var _messages: [Spec.MessageParameter.Message]
    var _streamHandler: Spec.StreamHandler
    var _toolUse: Spec.MessageResponse.Content.ToolUse?
    let responseManager: Spec.ResponseManager
    var _isAwaitingUserResponse: Swift.Bool
    var _userResponseMessage: Spec.MessageParameter.Message?
    var _userResponseToolUseId: Swift.String?
    var _isStopRequested: Swift.Bool
    var _didAutoFailoverFromAnthropic: Swift.Bool
    var _forceHighReasoningForOpenAI: Swift.Bool
    var _forceMinimalReasoningForOpenAI: Swift.Bool
    var _isInMultiTurnConversation: Swift.Bool
    var _lastMessageToolUseId: Swift.String?
    var _totalJson: Swift.String
    var _onMessageUpdate: ((_: Swift.String) -> ())?
    var _onNewResponse: ((_: Swift.String) -> ())?
    var _onToolUseUpdate: ((Spec.MessageResponse.Content.ToolUse, Swift.String) -> ())?
    var _onToolResponseUpdate: ((Swift.String, [Swift.String : Any], Swift.String?, Swift.String?, Swift.Bool?) -> ())?
    var _onToolUseMetadataUpdate: ((Swift.String, [Swift.String : Any]) -> ())?
    var _onChatTitleGenerated: ((_: Swift.String) -> ())?
    var _cacheCtl: Spec.MessageParameter.CacheControl?
    var _openAIResponseId: Swift.String?
    var _toolChoice: Spec.MessageParameter.ToolChoice
    var _task: Swift.Task<(), Swift.Never>?
    var _toolUseProviderInfo: [Swift.String : Swift.String]
    var _toolUseInputJsonCache: [Swift.String : Swift.String]
    let _$observationRegistrar: Observation.ObservationRegistrar
}
class ProfileBuildCheckpoint {
    struct Checkpoint {
        enum CodingKeys {
            case version
            case timestamp
            case buildStartTime
            case phase
            case completedSources
            case currentProfileKeys
            case totalRecordsSaved
            case checksum
        }
        let version: Swift.Int
        let timestamp: Foundation.Date
        let buildStartTime: Foundation.Date
        let phase: Swift.String
        var completedSources: [Swift.String : Spec.ProfileBuildCheckpoint.SourceCheckpoint]
        var currentProfileKeys: [Swift.String]
        var totalRecordsSaved: Swift.Int
        let checksum: Swift.String
    }
    struct SourceCheckpoint {
        enum CodingKeys {
            case sourceName
            case completed
            case timestamp
            case batchesCompleted
            case totalBatches
            case recordsSaved
            case error
        }
        let sourceName: Swift.String
        let completed: Swift.Bool
        let timestamp: Foundation.Date
        let batchesCompleted: Swift.Int
        let totalBatches: Swift.Int?
        let recordsSaved: Swift.Int
        let error: Swift.String?
    }
    let checkpointKey: Swift.String
    let backupCheckpointKey: Swift.String
    let corruptionCountKey: Swift.String
    let maxCorruptionAttempts: Swift.Int
}
class ProfileDataTransformer {
    let sourceAppMapping: [Swift.String : Swift.String]
}
struct EnrichedContactsListView {
    var _contacts: SwiftUI.State<[Spec.SimpleContactItem]>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _selectedContactId: SwiftUI.State<Swift.String?>
    let onContactSelected: ((_: Swift.String) -> ())?
}
struct SimpleContactItem {
    let contactId: Swift.String
    let displayName: Swift.String
    let relationshipToUser: Swift.String?
    let currentCompany: Swift.String?
    let totalInteractions: Swift.Int
    let daysSinceLastContact: Swift.Int
}
struct DraftSlackReplyPreviewView {
    let teamId: Swift.String
    let channelId: Swift.String
    let channelName: Swift.String
    let threadTs: Swift.String?
    let initialMessage: Swift.String
    let onSend: (_: Swift.String) -> ()
    let onCancel: () -> ()
    var _messageText: SwiftUI.State<Swift.String>
    var _isExpanded: SwiftUI.State<Swift.Bool>
    var _isLoadingHistory: SwiftUI.State<Swift.Bool>
    var _recentMessages: SwiftUI.State<[[Swift.String : Any]]>
    var _isBodyFocused: SwiftUI.FocusState<Swift.Bool>
}
struct RemindersReport {
    let extractionDate: Foundation.Date
    let accounts: [Spec.ReminderAccount]
    let lists: [Spec.ReminderList]
    let reminders: [Spec.ReminderItem]
    let stats: Spec.RemindersStats
}
struct ReminderAccount {
    let id: Swift.String
    let name: Swift.String?
    let type: Swift.String?
    let listCount: Swift.Int
    let reminderCount: Swift.Int
}
struct ReminderList {
    let id: Swift.String
    let accountId: Swift.String?
    let name: Swift.String
    let color: Swift.String?
    let reminderCount: Swift.Int
    let completedCount: Swift.Int
    let isShared: Swift.Bool
    let sortOrder: Swift.Int?
}
struct ReminderItem {
    let id: Swift.String
    let listId: Swift.String?
    let accountId: Swift.String?
    let title: Swift.String
    let notes: Swift.String?
    let isCompleted: Swift.Bool
    let completedDate: Foundation.Date?
    let dueDate: Foundation.Date?
    let priority: Swift.Int
    let flagged: Swift.Bool
    let creationDate: Foundation.Date?
    let modificationDate: Foundation.Date?
    let hasAlarm: Swift.Bool
    let hasAttachment: Swift.Bool
    let hasSubtasks: Swift.Bool
    let parentReminderId: Swift.String?
}
struct RemindersStats {
    let totalReminders: Swift.Int
    let completedReminders: Swift.Int
    let overdueReminders: Swift.Int
    let upcomingReminders: Swift.Int
    let flaggedReminders: Swift.Int
    let remindersWithAlarms: Swift.Int
    let remindersWithAttachments: Swift.Int
    let remindersWithSubtasks: Swift.Int
    let listCount: Swift.Int
    let accountCount: Swift.Int
}
class RemindersExtractor {
    let database: Spec.UserProfileDatabase
}
enum ScreenTimeError {
    case accessDenied(Swift.String)
    case databaseError(Swift.String)
    case noData
}
struct ScreenTimeDevice {
    enum CodingKeys {
        case deviceId
        case deviceName
        case deviceType
        case osVersion
        case lastSyncDate
    }
    let deviceId: Swift.String
    let deviceName: Swift.String
    let deviceType: Swift.String
    let osVersion: Swift.String?
    let lastSyncDate: Foundation.Date
}
struct AppUsageData {
    enum CodingKeys {
        case appName
        case bundleIdentifier
        case category
        case totalMinutes
        case numberOfPickups
        case notificationCount
    }
    let appName: Swift.String
    let bundleIdentifier: Swift.String?
    let category: Swift.String?
    let totalMinutes: Swift.Int
    let numberOfPickups: Swift.Int?
    let notificationCount: Swift.Int?
}
struct DailyScreenTime {
    enum CodingKeys {
        case date
        case totalScreenTime
        case pickupCount
        case appUsage
        case mostUsedApp
        case deviceId
    }
    let date: Foundation.Date
    let totalScreenTime: Swift.Int
    let pickupCount: Swift.Int
    let appUsage: [Spec.AppUsageData]
    let mostUsedApp: Swift.String?
    let deviceId: Swift.String
}
struct ScreenTimeReport {
    enum CodingKeys {
        case devices
        case dailyUsage
        case weeklyAverage
        case extractionDate
    }
    let devices: [Spec.ScreenTimeDevice]
    let dailyUsage: [Spec.DailyScreenTime]
    let weeklyAverage: Swift.Int?
    let extractionDate: Foundation.Date
}
struct UsagePattern {
    let appName: Swift.String
    let totalMinutes: Swift.Int
    let sessionCount: Swift.Int
    let firstUsage: Foundation.Date
    let lastUsage: Foundation.Date
    let peakHours: [Swift.Int]
    let averageSessionLength: Swift.Int
    let longestSession: Swift.Int
    let usageDistribution: Swift.String
    let timeBlocks: [(hour: Swift.Int, minutes: Swift.Int)]
}
struct DailyUsageSummary {
    let date: Foundation.Date
    let totalScreenTime: Swift.Int
    let activeHours: Swift.Int
    let firstActivity: Foundation.Date?
    let lastActivity: Foundation.Date?
    let topApps: [Spec.UsagePattern]
    let narrativeSummary: Swift.String
}
class ScreenTimeExtractor {
    var _isExtracting: Combine.Published<Swift.Bool>
    var _progress: Combine.Published<Swift.Double>
    var _statusMessage: Combine.Published<Swift.String>
    var _extractedData: Combine.Published<Spec.ScreenTimeReport?>
    let database: Spec.UserProfileDatabase
}
struct TestComprehensiveDKEventView {
    var _extractor: SwiftUI.StateObject<Spec.ComprehensiveDKEventExtractor>
    var _extractionError: SwiftUI.State<Swift.String?>
    var _isRunning: SwiftUI.State<Swift.Bool>
    var _extractedReportText: SwiftUI.State<Swift.String>
}
enum IncrementalProfileBuilderFunction {
    case processDataBatch
    case loadKnowledgeSummary
    case saveKnowledgeSummary
    case finalizeProfile
}
struct AttributeCatalogue {}
struct AttributeTableDefinition {
    let required: [Swift.String]
    let optional: [Swift.String]
}
enum UserProfileBuilderFunction {
    case buildCompleteProfile
    case updateWelcomeMessage
    case messagesReadRecentConversations
    case meetingNotesReadSummary
    case meetingNotesReadTranscript
    case meetingNotesList
}
struct ProfileDataRow {
    let icon: Swift.String
    let title: Swift.String
    let description: Swift.String
}
struct ProfileBuilderLaunchCheck {}
struct AnyAppProgress {
    let id: Swift.String
    let title: Swift.String
    let icon: Swift.String
    let progress: Swift.Double
    let status: Swift.String
    let isActive: Swift.Bool
    let isComplete: Swift.Bool
    let error: Swift.String?
}
struct ProfileBuilderProgressView {
    let currentStep: Swift.String
    let progress: Swift.Double
    var apps: [Spec.AnyAppProgress]
}
struct ProfileBuilderCompletionView {
    let summary: Swift.String
    let onContinue: () -> ()
}
struct ProfileBuilderOnboardingView {
    let onSkip: () -> ()
    let onStart: () -> ()
    var onViewDatabase: (() -> ())?
}
enum ProfileBuilderError {
    case invalidData(Swift.String)
}
enum ExtractionPhase {
    case profileData
    case streamsAndActions
}
struct AppScanProgress {
    let id: Swift.String
    var title: Swift.String
    var icon: Swift.String
    var progress: Swift.Double
    var status: Swift.String
    var isActive: Swift.Bool
    var isComplete: Swift.Bool
    var error: Swift.String?
}
class UserProfileBuilderService {
    var _isRunning: Combine.Published<Swift.Bool>
    var _currentStep: Combine.Published<Swift.String>
    var _progress: Combine.Published<Swift.Double>
    var _errorMessage: Combine.Published<Swift.String?>
    var _completionSummary: Combine.Published<Swift.String?>
    var _criticalQuestions: Combine.Published<[[Swift.String : Swift.String]]>
    var _databaseAccessErrors: Combine.Published<[Swift.String]?>
    var _selectedModel: Combine.Published<Swift.String>
    var _appProgress: Combine.Published<[Swift.String : Spec.AppScanProgress]>
    var _startDate: Combine.Published<Foundation.Date?>
    var _recentActivity: Combine.Published<Swift.String>
    var _currentPhase: Combine.Published<Spec.ExtractionPhase?>
    var _phase1Complete: Combine.Published<Swift.Bool>
    var _phase2Complete: Combine.Published<Swift.Bool>
    var _processingPhase: Combine.Published<Swift.String>
    var _totalConversationsProcessed: Combine.Published<Swift.Int>
    var _currentKnowledgeSummary: Combine.Published<Swift.String>
    var processedConversationIds: Swift.Set<Swift.String>
    var _totalTokensUsed: Combine.Published<Swift.Int>
    var _inputTokensUsed: Combine.Published<Swift.Int>
    var _outputTokensUsed: Combine.Published<Swift.Int>
    var _currentBatchTokensUsed: Combine.Published<Swift.Int>
    var tokenUsageLog: [[Swift.String : Any]]
    var _dataPointsFound: Combine.Published<Swift.Int>
    var _contactsFound: Combine.Published<Swift.Int>
    var _eventsFound: Combine.Published<Swift.Int>
    var _emailsProcessed: Combine.Published<Swift.Int>
    var _messagesProcessed: Combine.Published<Swift.Int>
    var _slackMessagesProcessed: Combine.Published<Swift.Int>
    var _notionPagesProcessed: Combine.Published<Swift.Int>
    var _whatsappMessagesProcessed: Combine.Published<Swift.Int>
    var _calendarEventsProcessed: Combine.Published<Swift.Int>
    var _meetingNotesProcessed: Combine.Published<Swift.Int>
    var _lastSaveError: Combine.Published<Swift.String?>
    var _saveErrorCount: Combine.Published<Swift.Int>
    var _lastSuccessfulSave: Combine.Published<Foundation.Date?>
    var _checkpointInfo: Combine.Published<Swift.String?>
    var _isResuming: Combine.Published<Swift.Bool>
    var onComplete: ((Swift.Bool, Swift.String) -> ())?
    var _rawProfileSaveMode: Combine.Published<Swift.Bool>
    let service: Spec.AnthropicService
    let functionCallingObservable: Spec.MessageFunctionCallingObservable
    var isHandlingToolUse: Swift.Bool
    var watchdogTimer: __C.NSTimer?
    var lastProgressAt: Foundation.Date
}
enum DatabaseError {
    case prepareFailed(Swift.String)
    case executeFailed(Swift.String)
    case invalidInput(Swift.String)
    case openFailed(Swift.String)
    case notFound
}
class UserProfileDatabase {
    var db: Swift.OpaquePointer?
    let dbPath: Swift.String
    let queue: __C.OS_dispatch_queue
}
enum WelcomeMessageToolDescription {}
class AppleNotesDataExtractor {
    let notesDbPath: Swift.String
}
struct AppleNotesData {
    let notes: [Spec.AppleNote]
}
struct AppleNote {
    let id: Swift.Int
    let title: Swift.String
    let content: Swift.String
    let snippet: Swift.String
    let folder: Swift.String
    let createdDate: Foundation.Date
    let modifiedDate: Foundation.Date
    let wordCount: Swift.Int
    let attachmentCount: Swift.Int
    let identifier: Swift.String
}
enum AppleNotesError {
    case databaseReadError(Swift.Error)
    case notAvailable
    case noDatabaseFound
    case databaseAccessDenied
    case invalidDatabaseFormat
}
class CalendarDataExtractor {
    let eventStore: __C.EKEventStore
}
struct ExtractedEvent {
    let id: Swift.String
    let title: Swift.String
    let startDate: Foundation.Date
    let endDate: Foundation.Date
    let location: Swift.String?
    let notes: Swift.String?
    let attendees: [Spec.EventAttendee]
    let isAllDay: Swift.Bool
    let url: Foundation.URL?
    let createdDate: Foundation.Date
    let modifiedDate: Foundation.Date
}
struct EventAttendee {
    let name: Swift.String
    let email: Swift.String
    let status: Spec.AttendeeStatus
}
enum AttendeeStatus {
    case accepted
    case declined
    case tentative
    case unknown
}
enum CalendarError {
    case accessDenied
}
class ChromeDataExtractor {
    let chromeBasePath: Swift.String
}
struct BrowserData {
    let history: [Spec.HistoryItem]
    let bookmarks: [Spec.Bookmark]
}
struct HistoryItem {
    let id: Swift.String
    let url: Swift.String
    let title: Swift.String
    let visitDate: Foundation.Date
    let lastVisitDate: Foundation.Date
    let visitCount: Swift.Int
}
struct Bookmark {
    let id: Swift.String
    let url: Swift.String
    let title: Swift.String
    let folder: Swift.String?
    let dateAdded: Foundation.Date
}
class GmailDataExtractor {
    let gmailService: Spec.GmailService
    weak var authViewModel: Spec.AuthViewModel?
    let flightKeywords: [Swift.String]
    let airlineDomains: [Swift.String]
}
struct ExtractedEmail {
    let id: Swift.String
    let subject: Swift.String
    let body: Swift.String
    let date: Foundation.Date
    let from: Spec.EmailAddress
    let to: [Spec.EmailAddress]
    let cc: [Spec.EmailAddress]
    let bcc: [Spec.EmailAddress]
    let attachments: [Spec.EmailAttachment]
    let labels: [Swift.String]
    let threadId: Swift.String?
}
struct EmailAddress {
    let email: Swift.String
    let name: Swift.String?
}
struct EmailAttachment {
    let id: Swift.String
    let filename: Swift.String
    let mimeType: Swift.String
    let size: Swift.Int64
}
class GranolaDataExtractor {
    let granolaBasePath: Swift.String
}
struct MeetingNotesData {
    let meetings: [Spec.MeetingNote]
}
struct MeetingNote {
    let id: Swift.String
    let title: Swift.String
    let content: Swift.String
    let date: Foundation.Date
    let duration: Swift.Int
    let participants: [Swift.String]
    let tags: [Swift.String]
    let transcripts: [[Swift.String : Any]]?
}
struct CallLog {
    let id: Swift.String
    let title: Swift.String?
    let startedAt: Foundation.Date
    let endedAt: Foundation.Date?
    let durationSeconds: Swift.Int?
    let direction: Swift.String?
    let participants: [Swift.String]
}
enum GranolaError {
    case cacheReadError(Swift.Error)
    case notInstalled
    case noDatabaseFound
    case databaseAccessDenied
    case invalidCacheFormat
}
class MessagesDataExtractor {
    let dbPath: Swift.String
    let contactStore: __C.CNContactStore
}
struct ExtractedMessage {
    let id: Swift.String
    let content: Swift.String
    let date: Foundation.Date
    let isFromMe: Swift.Bool
    let contact: Spec.ExtractedContact?
    let snippet: Swift.String
    let attachments: [Spec.ExtractedAttachment]
}
struct ExtractedContact {
    let name: Swift.String
    let handle: Swift.String
    let handleType: Spec.HandleType
}
enum HandleType {
    case phone
    case email
    case other
}
struct ExtractedAttachment {
    let id: Swift.String
    let filename: Swift.String
    let mimeType: Swift.String
    let size: Swift.Int64
}
enum MessagesDBAccessError {
    case databaseConnectionFailed
    case queryPreparationFailed
}
class NotesDataExtractor {}
struct ExtractedNote {
    let id: Swift.String
    let title: Swift.String
    let content: Swift.String
    let createdDate: Foundation.Date
    let modifiedDate: Foundation.Date
    let folder: Swift.String?
    let tags: [Swift.String]
    let attachments: [Spec.NoteAttachment]
}
struct NoteAttachment {
    let id: Swift.String
    let filename: Swift.String
    let type: Spec.AttachmentType
}
enum AttachmentType {
    case image
    case pdf
    case audio
    case video
    case other
}
class NotionDataExtractor {
    let notionDbPath: Swift.String
    let indexedDbPath: Swift.String
    let localStoragePath: Swift.String
    let cacheDbPath: Swift.String
}
struct NotionData {
    let pages: [Spec.NotionPage]
    let sharedPagesCount: Swift.Int
    let sharedPagesHints: [Swift.String]
    let workspaces: [Spec.NotionWorkspace]
    let userProfile: Spec.NotionUserProfile?
    let collaborators: [Spec.NotionCollaborator]
    let comments: [Spec.NotionComment]
    let databases: [Spec.NotionDatabase]
    let teamInfo: [Spec.NotionTeam]
    let activitySummary: Spec.NotionActivitySummary
}
struct NotionPage {
    let id: Swift.String
    let title: Swift.String
    let content: Swift.String
    let createdDate: Foundation.Date
    let modifiedDate: Foundation.Date
    let wordCount: Swift.Int
    let workspace: Swift.String?
    let createdBy: Swift.String?
    let lastEditedBy: Swift.String?
    let permissions: [Swift.String]?
    let isPublic: Swift.Bool
}
struct NotionWorkspace {
    let id: Swift.String
    let name: Swift.String
    let createdDate: Foundation.Date?
    let memberCount: Swift.Int
    let pageCount: Swift.Int
    let role: Swift.String?
}
struct NotionUserProfile {
    let id: Swift.String
    let email: Swift.String
    let name: Swift.String?
    let workspaces: [Swift.String]
    let totalPagesCreated: Swift.Int
    let totalPagesEdited: Swift.Int
    let settings: [Swift.String : Any]
}
struct NotionCollaborator {
    let id: Swift.String
    let email: Swift.String
    let name: Swift.String?
    let sharedPageCount: Swift.Int
    let lastCollaborationDate: Foundation.Date?
}
struct NotionComment {
    let id: Swift.String
    let pageId: Swift.String
    let pageTitle: Swift.String?
    let text: Swift.String
    let createdBy: Swift.String
    let createdDate: Foundation.Date
    let discussionContext: Swift.String?
}
struct NotionDatabase {
    let id: Swift.String
    let title: Swift.String
    let schema: [Swift.String : Swift.String]
    let rowCount: Swift.Int
    let lastModified: Foundation.Date
}
struct NotionTeam {
    let id: Swift.String
    let name: Swift.String
    let memberCount: Swift.Int
    let description: Swift.String?
}
struct NotionActivitySummary {
    let totalEdits: Swift.Int
    let activeWorkspaces: Swift.Int
    let collaboratorCount: Swift.Int
    let commentCount: Swift.Int
    let databaseCount: Swift.Int
    let recentActivity: [Swift.String]
}
struct NotionItem {
    let id: Swift.String
    let title: Swift.String
    let content: Swift.String
    let description: Swift.String?
    let createdDate: Foundation.Date
    let modifiedDate: Foundation.Date
    let tags: [Swift.String]
    let properties: [Swift.String : Any]
    let isProject: Swift.Bool
    let isTask: Swift.Bool
    let parentId: Swift.String?
}
enum NotionError {
    case databaseReadError(Swift.Error)
    case notInstalled
    case noDatabaseFound
    case databaseAccessDenied
    case invalidDatabaseFormat
}
class QuillDataExtractor {
    let quillBasePath: Swift.String
}
enum QuillError {
    case notInstalled
    case noDatabaseFound
    case databaseAccessDenied
    case databaseReadError
}
class SafariDataExtractor {
    let safariBasePath: Swift.String
}
enum KGNodeType {
    case personUser
    case personContact
    case contactMethod
    case employmentEdu
    case event
    case document
    case place
    case projectTopic
    case thread
}
enum KGEdgeType {
    case knows
    case contactMethod
    case worksAt
    case participatesIn
    case relatesTo
    case involvedIn
    case belongsToThread
    case conflictsWith
}
struct PersonUserNode {
    struct TripLocation {
        enum CodingKeys {
            case destination
            case startDate
            case endDate
        }
        let destination: Swift.String
        let startDate: Foundation.Date
        let endDate: Foundation.Date
    }
    enum CodingKeys {
        case id
        case nodeType
        case value
        case sourceApp
        case sourceDocId
        case firstSeenUtc
        case lastSeenUtc
        case confidence
        case graphVersion
        case legalName
        case preferredName
        case dateOfBirth
        case primaryLocation
        case placeOfOrigin
        case tempLocation
        case futureTripLocations
    }
    let id: Swift.String
    let nodeType: Spec.KGNodeType
    let value: Swift.String
    let sourceApp: Swift.String
    let sourceDocId: Swift.String
    let firstSeenUtc: Foundation.Date
    var lastSeenUtc: Foundation.Date
    let confidence: Swift.Float
    var graphVersion: Swift.Int
    let legalName: Swift.String
    let preferredName: Swift.String?
    let dateOfBirth: Foundation.Date?
    let primaryLocation: Swift.String?
    let placeOfOrigin: Swift.String?
    let tempLocation: Swift.String?
    var futureTripLocations: [Spec.PersonUserNode.TripLocation]
}
struct PersonContactNode {
    enum CodingKeys {
        case id
        case nodeType
        case value
        case sourceApp
        case sourceDocId
        case firstSeenUtc
        case lastSeenUtc
        case confidence
        case graphVersion
        case displayName
        case relationship
        case appsUsed
        case lastContactUtc
        case messagesPerWeek
        case avgResponseLatencyHrs
    }
    let id: Swift.String
    let nodeType: Spec.KGNodeType
    var value: Swift.String
    let sourceApp: Swift.String
    let sourceDocId: Swift.String
    let firstSeenUtc: Foundation.Date
    var lastSeenUtc: Foundation.Date
    let confidence: Swift.Float
    var graphVersion: Swift.Int
    var displayName: Swift.String
    var relationship: Swift.String?
    var appsUsed: [Swift.String]
    var lastContactUtc: Foundation.Date?
    var messagesPerWeek: Swift.Float
    var avgResponseLatencyHrs: Swift.Float
}
struct ContactMethodNode {
    enum ContactType {
        case phone
        case email
        case social
        case address
    }
    enum CodingKeys {
        case id
        case nodeType
        case value
        case sourceApp
        case sourceDocId
        case firstSeenUtc
        case lastSeenUtc
        case confidence
        case graphVersion
        case type
        case normalizedValue
    }
    let id: Swift.String
    let nodeType: Spec.KGNodeType
    let value: Swift.String
    let sourceApp: Swift.String
    let sourceDocId: Swift.String
    let firstSeenUtc: Foundation.Date
    var lastSeenUtc: Foundation.Date
    let confidence: Swift.Float
    var graphVersion: Swift.Int
    let type: Spec.ContactMethodNode.ContactType
    let normalizedValue: Swift.String
}
struct EmploymentEduNode {
    enum CodingKeys {
        case id
        case nodeType
        case value
        case sourceApp
        case sourceDocId
        case firstSeenUtc
        case lastSeenUtc
        case confidence
        case graphVersion
        case role
        case company
        case school
        case projects
        case startUtc
        case endUtc
    }
    let id: Swift.String
    let nodeType: Spec.KGNodeType
    let value: Swift.String
    let sourceApp: Swift.String
    let sourceDocId: Swift.String
    let firstSeenUtc: Foundation.Date
    var lastSeenUtc: Foundation.Date
    let confidence: Swift.Float
    var graphVersion: Swift.Int
    let role: Swift.String?
    let company: Swift.String?
    let school: Swift.String?
    let projects: [Swift.String]
    let startUtc: Foundation.Date?
    let endUtc: Foundation.Date?
}
struct EventNode {
    enum EventType {
        case meeting
        case call
        case appointment
        case travel
        case social
        case other
    }
    enum CodingKeys {
        case id
        case nodeType
        case value
        case sourceApp
        case sourceDocId
        case firstSeenUtc
        case lastSeenUtc
        case confidence
        case graphVersion
        case title
        case startUtc
        case endUtc
        case location
        case eventType
    }
    let id: Swift.String
    let nodeType: Spec.KGNodeType
    let value: Swift.String
    let sourceApp: Swift.String
    let sourceDocId: Swift.String
    let firstSeenUtc: Foundation.Date
    var lastSeenUtc: Foundation.Date
    let confidence: Swift.Float
    var graphVersion: Swift.Int
    let title: Swift.String
    let startUtc: Foundation.Date
    let endUtc: Foundation.Date
    let location: Swift.String?
    let eventType: Spec.EventNode.EventType
}
struct DocumentNode {
    enum DocumentType {
        case email
        case sms
        case note
        case url
        case transcript
        case attachment
    }
    enum CodingKeys {
        case id
        case nodeType
        case value
        case sourceApp
        case sourceDocId
        case firstSeenUtc
        case lastSeenUtc
        case confidence
        case graphVersion
        case docType
        case createdUtc
        case titleSnippet
        case contentSnippet
    }
    let id: Swift.String
    let nodeType: Spec.KGNodeType
    let value: Swift.String
    let sourceApp: Swift.String
    let sourceDocId: Swift.String
    let firstSeenUtc: Foundation.Date
    var lastSeenUtc: Foundation.Date
    let confidence: Swift.Float
    var graphVersion: Swift.Int
    let docType: Spec.DocumentNode.DocumentType
    let createdUtc: Foundation.Date
    let titleSnippet: Swift.String
    let contentSnippet: Swift.String?
}
struct PlaceNode {
    enum PlaceType {
        case home
        case office
        case hotel
        case airport
        case city
        case country
        case other
    }
    enum CodingKeys {
        case id
        case nodeType
        case value
        case sourceApp
        case sourceDocId
        case firstSeenUtc
        case lastSeenUtc
        case confidence
        case graphVersion
        case name
        case geoLat
        case geoLon
        case placeType
    }
    let id: Swift.String
    let nodeType: Spec.KGNodeType
    let value: Swift.String
    let sourceApp: Swift.String
    let sourceDocId: Swift.String
    let firstSeenUtc: Foundation.Date
    var lastSeenUtc: Foundation.Date
    let confidence: Swift.Float
    var graphVersion: Swift.Int
    let name: Swift.String
    var geoLat: Swift.Double?
    var geoLon: Swift.Double?
    var placeType: Spec.PlaceNode.PlaceType
}
struct ProjectTopicNode {
    enum CodingKeys {
        case id
        case nodeType
        case value
        case sourceApp
        case sourceDocId
        case firstSeenUtc
        case lastSeenUtc
        case confidence
        case graphVersion
        case topicName
        case description
        case keywords
    }
    let id: Swift.String
    let nodeType: Spec.KGNodeType
    let value: Swift.String
    let sourceApp: Swift.String
    let sourceDocId: Swift.String
    let firstSeenUtc: Foundation.Date
    var lastSeenUtc: Foundation.Date
    let confidence: Swift.Float
    var graphVersion: Swift.Int
    let topicName: Swift.String
    var description: Swift.String?
    var keywords: [Swift.String]
}
struct KGEdge {
    enum CodingKeys {
        case id
        case fromNodeId
        case toNodeId
        case edgeType
        case confidence
        case sourceApp
        case firstSeenUtc
        case lastSeenUtc
        case graphVersion
        case metadata
    }
    let id: Swift.String
    var fromNodeId: Swift.String
    var toNodeId: Swift.String
    let edgeType: Spec.KGEdgeType
    let confidence: Swift.Float
    let sourceApp: Swift.String
    let firstSeenUtc: Foundation.Date
    var lastSeenUtc: Foundation.Date
    var graphVersion: Swift.Int
    let metadata: [Swift.String : Swift.String]?
}
struct WorkThread {
    enum CodingKeys {
        case threadId
        case title
        case participants
        case startUtc
        case lastUpdateUtc
        case artifactCount
        case active
        case keywords
        case embedding
        case messageGuids
    }
    let threadId: Swift.String
    let title: Swift.String
    let participants: [Swift.String]
    let startUtc: Foundation.Date
    var lastUpdateUtc: Foundation.Date
    var artifactCount: Swift.Int
    var active: Swift.Bool
    let keywords: [Swift.String]
    let embedding: [Swift.Float]?
    let messageGuids: [Swift.String]
}
struct KGProcessingStatus {
    enum ProcessingPhase {
        case knowledgeGraph
        case threads
    }
    enum ProcessingStatus {
        case running
        case ready
        case ok
        case error
        case noNewData
    }
    enum CodingKeys {
        case phase
        case status
        case runId
        case graphVersion
        case timestamp
        case nodeCounts
        case edgeCounts
        case highlights
        case error
    }
    let phase: Spec.KGProcessingStatus.ProcessingPhase
    let status: Spec.KGProcessingStatus.ProcessingStatus
    let runId: Swift.String
    let graphVersion: Swift.Int
    let timestamp: Foundation.Date
    let nodeCounts: [Swift.String : Swift.Int]
    let edgeCounts: [Swift.String : Swift.Int]
    let highlights: Spec.KGHighlights?
    let error: Swift.String?
}
struct KGHighlights {
    struct ContactHighlight {
        enum CodingKeys {
            case name
            case relationship
            case messagesPerWeek
        }
        let name: Swift.String
        let relationship: Swift.String?
        let messagesPerWeek: Swift.Float
    }
    struct TripHighlight {
        enum CodingKeys {
            case destination
            case start
            case end
        }
        let destination: Swift.String
        let start: Foundation.Date
        let end: Foundation.Date
    }
    enum CodingKeys {
        case primaryLocation
        case topContacts
        case upcomingTrips
        case currentProjects
        case employment
    }
    let primaryLocation: Swift.String?
    let topContacts: [Spec.KGHighlights.ContactHighlight]
    let upcomingTrips: [Spec.KGHighlights.TripHighlight]
    let currentProjects: [Swift.String]?
    let employment: Swift.String?
}
struct DataSourceStatus {
    enum DataSource {
        case messages
        case whatsapp
        case gmail
        case calendar
        case granola
        case zoom
        case meet
        case teams
        case appleNotes
        case notion
        case chrome
        case safari
    }
    enum SyncStatus {
        case pending
        case syncing
        case done
        case error
        case noAccess
    }
    enum CodingKeys {
        case source
        case lastSync
        case status
        case itemsProcessed
        case error
    }
    let source: Spec.DataSourceStatus.DataSource
    let lastSync: Foundation.Date?
    let status: Spec.DataSourceStatus.SyncStatus
    let itemsProcessed: Swift.Int
    let error: Swift.String?
}
class KnowledgeGraphBuilder {
    var _status: Combine.Published<Spec.KGProcessingStatus?>
    var _isProcessing: Combine.Published<Swift.Bool>
    var _sourceStatuses: Combine.Published<[Spec.DataSourceStatus]>
    let db: __C.FIRFirestore
    let messagesExtractor: Spec.MessagesDataExtractor
    let gmailExtractor: Spec.GmailDataExtractor
    let calendarExtractor: Spec.CalendarDataExtractor
    let notesExtractor: Spec.NotesDataExtractor
    let notionExtractor: Spec.NotionDataExtractor
    let chromeExtractor: Spec.ChromeDataExtractor
    let vectorSearch: Spec.SemanticSearchManager
    let contactResolver: Spec.ContactResolver
    var nodes: [Swift.String : Spec.KGNode]
    var edges: [Swift.String : Spec.KGEdge]
    var graphVersion: Swift.Int
}
struct ContactStats {
    let messagesPerWeek: Swift.Float
    let avgResponseLatencyHrs: Swift.Float
    let lastContactDate: Foundation.Date
}
struct ExtractedDateInfo {
    let date: Foundation.Date
    let endDate: Foundation.Date?
    let context: Swift.String
    let confidence: Swift.Float
    let location: Swift.String?
}
struct ExtractedLocationInfo {
    let name: Swift.String
    let type: Spec.PlaceNode.PlaceType
    let confidence: Swift.Float
}
struct ExtractedPersonInfo {
    let name: Swift.String
    let confidence: Swift.Float
}
enum KnowledgeGraphCacheStore {}
class KnowledgeGraphLLMAgent {
    enum Phase {
        case error(Swift.String)
        case idle
        case knowledgeGraph
        case threadDiscovery
        case complete
    }
    struct LogEntry {
        let id: Foundation.UUID
        let timestamp: Foundation.Date
        let message: Swift.String
        let phase: Spec.KnowledgeGraphLLMAgent.Phase
    }
    enum SystemPromptPhase {
        case phase1
        case phase2
    }
    enum KGAgentError {
        case systemPromptNotFound(Swift.String)
        case phase1Failed
        case phase2Failed
    }
    var _currentPhase: Combine.Published<Spec.KnowledgeGraphLLMAgent.Phase>
    var _processingLog: Combine.Published<[Spec.KnowledgeGraphLLMAgent.LogEntry]>
    let anthropicService: Spec.AnthropicService
    let kgBuilder: Spec.KnowledgeGraphBuilder
    let threadService: Spec.ThreadDiscoveryService
    var currentToolCall: (name: Swift.String, id: Swift.String, accumulatedJson: Swift.String)?
    var lastProcessedSource: Swift.String?
    let phase1SystemPrompt: Swift.String
    let phase2SystemPrompt: Swift.String
}
class ThreadDiscoveryService {
    enum LLMModel {
        case claude40Sonnet
        case claude45Sonnet
        case gemini25Flash
    }
    struct MessageData {
        let guid: Swift.String
        let text: Swift.String
        let date: Foundation.Date
        let isFromMe: Swift.Bool
        let contact: Swift.String
        let handle: Swift.String?
        let groupTitle: Swift.String?
        let hasAttachments: Swift.Bool
    }
    struct LLMThread {
        let title: Swift.String
        let description: Swift.String
        let participants: [Swift.String]
        let keywords: [Swift.String]
        let messageGuids: [Swift.String]
        let startDate: Foundation.Date?
        let lastUpdateDate: Foundation.Date?
        let isActive: Swift.Bool
        let threadType: Swift.String
    }
    struct LLMThreadResponse {
        enum CodingKeys {
            case title
            case description
            case participants
            case keywords
            case messageGuids
            case startDate
            case lastUpdateDate
            case isActive
            case threadType
        }
        let title: Swift.String
        let description: Swift.String
        let participants: [Swift.String]
        let keywords: [Swift.String]
        let messageGuids: [Swift.String]
        let startDate: Foundation.Date?
        let lastUpdateDate: Foundation.Date?
        let isActive: Swift.Bool
        let threadType: Swift.String
    }
    enum ThreadDiscoveryError {
        case invalidLLMResponse(Swift.String)
        case databaseConnectionFailed
        case queryPreparationFailed
    }
    var _status: Combine.Published<Spec.KGProcessingStatus?>
    var _isProcessing: Combine.Published<Swift.Bool>
    var _threads: Combine.Published<[Spec.WorkThread]>
    var _selectedModel: Combine.Published<Spec.ThreadDiscoveryService.LLMModel>
    var activeThreads: [Swift.String : Spec.WorkThread]
    var closedThreads: [Swift.String : Spec.WorkThread]
    let messagesDBPath: Swift.String
}
struct KnowledgeGraphExtractionTestView {
    var _messages: SwiftUI.State<[Spec.Message]>
    var _delta: SwiftUI.State<Spec.KGDelta?>
    var _isProcessing: SwiftUI.State<Swift.Bool>
    var _errorMessage: SwiftUI.State<Swift.String?>
    var _successMessage: SwiftUI.State<Swift.String?>
    var _isApiKeyConfigured: SwiftUI.State<Swift.Bool>
    var _contactSearchText: SwiftUI.State<Swift.String>
    var _isLoadingMessages: SwiftUI.State<Swift.Bool>
}
struct KnowledgeGraphLLMSimpleTestView {
    var _viewModel: SwiftUI.StateObject<Spec.KnowledgeGraphLLMSimpleTestViewModel>
    var _showingResults: SwiftUI.State<Swift.Bool>
}
class KnowledgeGraphLLMSimpleTestViewModel {
    struct ExtractedEntity {
        let id: Foundation.UUID
        let type: Swift.String
        let value: Swift.String
        let confidence: Swift.Double
        let context: Swift.String
    }
    var _isModelReady: Combine.Published<Swift.Bool>
    var _isProcessing: Combine.Published<Swift.Bool>
    var _status: Combine.Published<Swift.String>
    var _testText: Combine.Published<Swift.String>
    var _extractedEntities: Combine.Published<[Spec.KnowledgeGraphLLMSimpleTestViewModel.ExtractedEntity]>
}
struct EntityResultsView {
    let entities: [Spec.KnowledgeGraphLLMSimpleTestViewModel.ExtractedEntity]
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
}
class KnowledgeGraphLLMTest {
    enum TimeRange {
        case lastWeek
        case lastMonth
        case last3Months
        case last6Months
        case lastYear
    }
    struct ExtractedEntity {
        let type: Swift.String
        let value: Swift.String
        let confidence: Swift.Double
        let context: Swift.String
        let sourceMessageId: Swift.String
        let timestamp: Foundation.Date
        let sender: Swift.String
        let conversationId: Swift.String
    }
    struct IMessage {
        let id: Swift.String
        let content: Swift.String
        let timestamp: Foundation.Date
        let sender: Swift.String
        let conversationId: Swift.String
        let conversationName: Swift.String
        let isFromMe: Swift.Bool
    }
    enum TestError {
        case modelNotReady
        case notAuthenticated
        case invalidSession
    }
    var _isProcessing: Combine.Published<Swift.Bool>
    var _progress: Combine.Published<Swift.Double>
    var _status: Combine.Published<Swift.String>
    var _extractedEntities: Combine.Published<[Spec.KnowledgeGraphLLMTest.ExtractedEntity]>
    var _processedMessages: Combine.Published<Swift.Int>
    var _totalMessages: Combine.Published<Swift.Int>
    var _error: Combine.Published<Swift.String?>
    var _selectedTimeRange: Combine.Published<Spec.KnowledgeGraphLLMTest.TimeRange>
    var cancellables: Swift.Set<Combine.AnyCancellable>
}
struct KnowledgeGraphLLMTestView {
    var _test: SwiftUI.StateObject<Spec.KnowledgeGraphLLMTest>
    var _showingEntities: SwiftUI.State<Swift.Bool>
}
struct EntityListView {
    let entities: [Spec.KnowledgeGraphLLMTest.ExtractedEntity]
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
}
struct KnowledgeGraphLLMTestView_Previews {}
struct TestKnowledgeGraphView {
    var _kgBuilder: SwiftUI.StateObject<Spec.KnowledgeGraphBuilder>
    var _threadService: SwiftUI.StateObject<Spec.ThreadDiscoveryService>
    var _isRunning: SwiftUI.State<Swift.Bool>
    var _logMessages: SwiftUI.State<[Swift.String]>
}
actor MessageCollector {
    var $defaultActor: 
    let dbPath: Swift.String
}
enum MessageCollectorError {
    case cannotOpenDatabase
    case queryPreparationFailed
}
enum LastCursor {}
actor BasicSemanticSearch {
    var $defaultActor: 
    var messageIndex: [Swift.String : Spec.EncryptedMessage]
    var messageVectors: [Swift.String : [Swift.String]]
}
struct CipherEnvelope {
    enum CodingKeys {
        case id
        case senderPubKeyDER
        case ciphertext
        case wrappedKeys
        case createdAt
    }
    let id: Foundation.UUID
    let senderPubKeyDER: Foundation.Data
    let ciphertext: Foundation.Data
    let wrappedKeys: [Swift.String : Foundation.Data]
    let createdAt: Foundation.Date
}
actor EncryptedSync {
    var $defaultActor: 
    let db: __C.FIRFirestore
}
enum EncryptedSyncError {
    case notAuthenticated
}
actor ContactResolver {
    var $defaultActor: 
    let contactStore: __C.CNContactStore
    var contactCache: [Swift.String : Swift.String]
}
actor DeviceKey {
    var $defaultActor: 
    var priv: CryptoKit.P256.KeyAgreement.PrivateKey?
    var pub: CryptoKit.P256.KeyAgreement.PublicKey?
    let privateKeyTag: Swift.String
    let publicKeyTag: Swift.String
    let serviceName: Swift.String
    let accessGroup: Swift.String
}
enum CryptoError {
    case keychainError(Swift.Int32)
    case noKey
}
struct EncryptedMessage {
    enum CodingKeys {
        case id
        case sender
        case content
        case date
        case isEncrypted
        case isFromMe
        case service
        case isDelivered
        case isRead
        case hasAttachments
        case contactName
        case groupName
    }
    let id: Swift.String
    let sender: Swift.String
    let content: Swift.String
    let date: Foundation.Date
    let isEncrypted: Swift.Bool
    var isFromMe: Swift.Bool
    var service: Swift.String
    var isDelivered: Swift.Bool
    var isRead: Swift.Bool
    var hasAttachments: Swift.Bool
    var contactName: Swift.String?
    var groupName: Swift.String?
}
enum KeychainHelper {}
enum KeychainError {
    case itemNotFound
}
enum SecretsKeychain {
    enum Key {}
}
struct MessageRecord {
    enum CodingKeys {
        case guid
        case rowid
        case text
        case attributedBody
        case subject
        case date
        case dateRead
        case dateDelivered
        case dateRetracted
        case dateEdited
        case handleId
        case handle
        case isFromMe
        case otherHandle
        case destinationCallerId
        case isDelivered
        case isRead
        case isSent
        case isFinished
        case error
        case service
        case type
        case itemType
        case isEmote
        case isAudioMessage
        case cacheRoomnames
        case groupTitle
        case groupActionType
        case threadOriginatorGuid
        case threadOriginatorPart
        case replyToGuid
        case associatedMessageGuid
        case associatedMessageType
        case cacheHasAttachments
        case balloonBundleId
        case payloadData
        case expressiveSendStyleId
        case isArchive
        case isSpam
        case isCorrupt
        case wasDowngraded
        case isServiceMessage
        case isSystemMessage
        case isForward
        case isExpirable
        case expireState
        case hasUnseenMention
        case associatedMessageEmoji
        case ckRecordId
        case ckSyncState
    }
    var guid: Swift.String
    var rowid: Swift.Int64?
    var text: Swift.String?
    var attributedBody: Foundation.Data?
    var subject: Swift.String?
    var date: Swift.Int
    var dateRead: Swift.Int?
    var dateDelivered: Swift.Int?
    var dateRetracted: Swift.Int?
    var dateEdited: Swift.Int?
    var handleId: Swift.Int?
    var handle: Swift.String?
    var isFromMe: Swift.Bool
    var otherHandle: Swift.Int?
    var destinationCallerId: Swift.String?
    var isDelivered: Swift.Bool?
    var isRead: Swift.Bool?
    var isSent: Swift.Bool?
    var isFinished: Swift.Bool?
    var error: Swift.Int?
    var service: Swift.String?
    var type: Swift.Int
    var itemType: Swift.Int?
    var isEmote: Swift.Bool?
    var isAudioMessage: Swift.Bool?
    var cacheRoomnames: Swift.String?
    var groupTitle: Swift.String?
    var groupActionType: Swift.Int?
    var threadOriginatorGuid: Swift.String?
    var threadOriginatorPart: Swift.String?
    var replyToGuid: Swift.String?
    var associatedMessageGuid: Swift.String?
    var associatedMessageType: Swift.Int?
    var cacheHasAttachments: Swift.Bool
    var balloonBundleId: Swift.String?
    var payloadData: Foundation.Data?
    var expressiveSendStyleId: Swift.String?
    var isArchive: Swift.Bool?
    var isSpam: Swift.Bool?
    var isCorrupt: Swift.Bool?
    var wasDowngraded: Swift.Bool?
    var isServiceMessage: Swift.Bool?
    var isSystemMessage: Swift.Bool?
    var isForward: Swift.Bool?
    var isExpirable: Swift.Bool?
    var expireState: Swift.Int?
    var hasUnseenMention: Swift.Bool?
    var associatedMessageEmoji: Swift.String?
    var ckRecordId: Swift.String?
    var ckSyncState: Swift.Int?
}
struct HandleRecord {
    enum CodingKeys {
        case rowid
        case id
        case country
        case service
        case uncanonicalized_id
        case person_centric_id
    }
    var rowid: Swift.Int64
    var id: Swift.String
    var country: Swift.String?
    var service: Swift.String?
    var uncanonicalized_id: Swift.String?
    var person_centric_id: Swift.String?
}
struct ChatRecord {
    enum CodingKeys {
        case rowid
        case guid
        case chatIdentifier
        case serviceName
        case roomName
        case displayName
        case groupId
        case lastAddressedHandle
        case isArchived
        case lastReadMessageTimestamp
    }
    var rowid: Swift.Int64
    var guid: Swift.String
    var chatIdentifier: Swift.String
    var serviceName: Swift.String?
    var roomName: Swift.String?
    var displayName: Swift.String?
    var groupId: Swift.String?
    var lastAddressedHandle: Swift.String?
    var isArchived: Swift.Bool
    var lastReadMessageTimestamp: Swift.Int?
}
struct AttachmentRecord {
    enum CodingKeys {
        case rowid
        case guid
        case filename
        case mimeType
        case totalBytes
        case isOutgoing
        case hideAttachment
        case createdDate
    }
    var rowid: Swift.Int64
    var guid: Swift.String
    var filename: Swift.String?
    var mimeType: Swift.String?
    var totalBytes: Swift.Int64?
    var isOutgoing: Swift.Bool?
    var hideAttachment: Swift.Bool?
    var createdDate: Swift.Int?
}
struct DraftConversationDetailView {
    let platform: Swift.String
    let item: Spec.DraftListItem
    let messagesDetailView: () -> SwiftUI.AnyView
    let gmailDetailView: () -> SwiftUI.AnyView
    let slackDetailView: () -> SwiftUI.AnyView
    let xdmDetailView: () -> SwiftUI.AnyView
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
class XAuthManager: __C.NSObject {
    let defaultScopes: [Swift.String]
    var session: __C.ASWebAuthenticationSession?
    var pendingCodeVerifier: Swift.String?
    var pendingState: Swift.String?
}
enum XAuthError {
    case authorizationDenied(Swift.String)
    case tokenExchangeFailed(Swift.Int)
    case missingClientId
    case invalidAuthURL
    case invalidState
    case invalidCallbackURL
    case stateMismatch
    case missingAuthorizationCode
    case invalidResponse
    case invalidTokenResponse
    case notAuthenticated
    case noRefreshToken
    case tokenRefreshFailed
    case unsupportedPlatform
}
actor MLXSemanticSearch {
    var $defaultActor: 
    let hubApi: Hub.HubApi
    var modelContainer: MLXEmbedders.ModelContainer?
    var messageIndex: [Foundation.UUID : Spec.EncryptedMessage]
    var embeddings: [Foundation.UUID : [Swift.Float]]
    var isInitialized: Swift.Bool
}
actor PeerDirectory {
    var $defaultActor: 
    let db: __C.FIRFirestore
}
enum PeerDirectoryError {
    case notAuthenticated
}
struct SearchResult {
    let id: Swift.String
    let message: Spec.EncryptedMessage
    let score: Swift.Float
}
class SemanticSearchManager {
    var _isIndexing: Combine.Published<Swift.Bool>
    var _isReady: Combine.Published<Swift.Bool>
    let engine: Spec.VecturaKitSemanticSearch
    var hasInitialized: Swift.Bool
}
actor VecturaKitSemanticSearch {
    struct IndexMetadata {
        enum CodingKeys {
            case messageCount
            case lastIndexDate
            case oldestMessageDate
            case newestMessageDate
        }
        let messageCount: Swift.Int
        let lastIndexDate: Foundation.Date
        let oldestMessageDate: Foundation.Date
        let newestMessageDate: Foundation.Date
    }
    var $defaultActor: 
    var vectorDB: VecturaMLXKit.VecturaMLXKit?
    var messageIndex: [Foundation.UUID : Spec.EncryptedMessage]
    let config: VecturaKit.VecturaConfig
    var isInitialized: Swift.Bool
    var isInitializing: Swift.Bool
    var indexMetadata: Spec.VecturaKitSemanticSearch.IndexMetadata?
    let hubApi: Hub.HubApi
    var modelContainer: MLXEmbedders.ModelContainer?
}
enum VecturaError {
    case initializationFailed
}
struct MailRAGInboxView {
    var _messages: SwiftUI.State<[Spec.EncryptedMessage]>
    var _searchQuery: SwiftUI.State<Swift.String>
    var _filteredMessages: SwiftUI.State<[Spec.EncryptedMessage]>
    var _selectedMessage: SwiftUI.State<Spec.EncryptedMessage?>
    var _isSyncing: SwiftUI.State<Swift.Bool>
    var _syncError: SwiftUI.State<Swift.String?>
    var _lastSyncDate: SwiftUI.State<Foundation.Date?>
    var _deviceFingerprint: SwiftUI.State<Swift.String>
    var _showingMessageDetail: SwiftUI.State<Swift.Bool>
    var _useSemanticSearch: SwiftUI.State<Swift.Bool>
    var _semanticSearchManager: SwiftUI.StateObject<Spec.SemanticSearchManager>
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
}
struct MessageRowView {
    let message: Spec.EncryptedMessage
}
struct MessageDetailView {
    let message: Spec.EncryptedMessage
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
}
class LocalContactsStore {
    let dbQueue: GRDB.DatabaseQueue
}
struct ContactMetricStats {
    let averageResponseSeconds14d: Swift.Double?
    let medianResponseSeconds14d: Swift.Double?
}
struct LocalLLMExtractor {}
class FirstRunInstaller {
    enum State {
        case installing(Swift.Double)
        case failed(Swift.Error)
        case ready
    }
    var _state: Combine.Published<Spec.FirstRunInstaller.State>
    var cancellables: Swift.Set<Combine.AnyCancellable>
    let modelManager: Any?
}
struct DraftEmailReplyPreviewView {
    let from: Swift.String
    let to: Swift.String
    let subject: Swift.String
    let cc: Swift.String?
    var _bodyString: SwiftUI.State<Swift.String>
    let onSend: (Swift.String, Swift.Bool) -> ()
    let onCancel: () -> ()
    var _isBodyFocused: SwiftUI.FocusState<Swift.Bool>
    var _showSendConfirmation: SwiftUI.State<Swift.Bool>
    var _isExpanded: SwiftUI.State<Swift.Bool>
    var _didLoadContact: SwiftUI.State<Swift.Bool>
    var _toResolvedName: SwiftUI.State<Swift.String?>
    var _toPhotoBase64: SwiftUI.State<Swift.String?>
}
class GraphStore {
    let dbQueue: GRDB.DatabaseQueue
}
struct NodeData {
    let id: Swift.String
    let label: Swift.String
}
struct EdgeData {
    let id: Swift.String
    let source: Swift.String
    let target: Swift.String
}
class GraphViewModel {
    var _nodes: Combine.Published<[Spec.NodeData]>
    var _edges: Combine.Published<[Spec.EdgeData]>
    let dbPath: Swift.String
}
struct GraphView {
    var _graphVM: SwiftUI.StateObject<Spec.GraphViewModel>
    var _graphStates: SwiftUI.State<Grape.ForceDirectedGraphState>
}
enum NodeType {
    case PERSON
    case PERSON_CONTACT
    case CONTACT_METHOD
    case EMPLOYMENT_EDU
    case EVENT
    case PROJECT_TOPIC
    case PLACE
    case DOCUMENT_MESSAGE
}
struct Node {
    enum CodingKeys {
        case id
        case version
        case type
        case properties
        case status
    }
    var id: Swift.String
    var version: Swift.Int
    var type: Spec.NodeType
    var properties: [Swift.String : Spec.CodableValue]
    var status: Swift.String?
}
struct Edge {
    enum CodingKeys {
        case source
        case target
        case type
        case properties
    }
    var source: Swift.String
    var target: Swift.String
    var type: Swift.String
    var properties: [Swift.String : Spec.CodableValue]?
}
struct CodableValue {
    enum CodingKeys {
        case value
        case sourceApp
        case sourceDocID
        case tsUTC
        case confidence
    }
    var value: Swift.String
    var sourceApp: Swift.String
    var sourceDocID: Swift.String
    var tsUTC: Swift.String
    var confidence: Swift.Double
}
struct KGDelta {
    enum CodingKeys {
        case nodes
        case edges
    }
    var nodes: [Spec.Node]
    var edges: [Spec.Edge]
}
actor LocalChatService {
    var $defaultActor: 
    let store: Spec.LocalChatStore
    let threadID: Swift.String
    var _messages: [Spec.MessageParameter.Message]
    var messagesLoaded: Swift.Bool
    let messagesPerPage: Swift.Int
    var oldest: Foundation.Date?
}
actor LocalThreadService {
    struct Listener {
        let cancel: () -> ()
    }
    var $defaultActor: 
    let store: Spec.LocalChatStore
    let threadsPerPage: Swift.Int
}
actor FirestoreToLocalChatMigrator {
    enum MigrationError {
        case notSignedIn
    }
    var $defaultActor: 
    let store: Spec.LocalChatStore
    let db: __C.FIRFirestore
}
struct LocalChatThread {
    let id: Swift.String
    var title: Swift.String?
    var iconName: Swift.String?
    var preview: Swift.String?
    var createdAt: Foundation.Date
    var updatedAt: Foundation.Date
    var isHidden: Swift.Bool?
    var isPinned: Swift.Bool?
    var pinnedAt: Foundation.Date?
    var pinnedUntil: Foundation.Date?
}
struct LocalStoredMessage {
    let id: Swift.String
    let threadId: Swift.String
    let role: Swift.String
    let contentJSON: Foundation.Data
    let anthropicId: Swift.String?
    let createdAt: Foundation.Date
}
struct LocalPaginationCursor {
    let updatedAt: Foundation.Date
    let lastId: Swift.String
}
class LocalChatStore {
    let dbQueue: GRDB.DatabaseQueue
}
class ModelManager {
    var _session: Combine.Published<Any?>
    var _downloadProgress: Combine.Published<Swift.Double>
    var _isReady: Combine.Published<Swift.Bool>
    var _lastError: Combine.Published<Swift.Error?>
    let modelRepo: Swift.String
    let ggufFile: Swift.String
    let mlxModelRepoDefault: Swift.String
}
struct DBNode {
    enum CodingKeys {
        case id
        case label
        case json
    }
    var id: Swift.Int64?
    var label: Swift.String
    var json: Swift.String
}
struct DBEdge {
    enum CodingKeys {
        case id
        case src
        case dst
        case type
        case json
    }
    var id: Swift.Int64?
    var src: Swift.Int64
    var dst: Swift.Int64
    var type: Swift.String
    var json: Swift.String?
}
class GraphDatabase {}
enum GraphDatabaseError {
    case cannotCreateTable(Swift.String)
    case cannotCreateIndex(Swift.String)
    case transactionError(Swift.String)
    case insertFailed(Swift.String)
    case cannotOpenDatabase
}
struct OpusExtractor {}
enum ExtractionError {
    case noModelSession
    case invalidClient
    case missingAPIKey
    case noTextInResponse
}
struct MessageCommitmentTestView {
    var _vm: SwiftUI.StateObject<Spec.MessageCommitmentTestViewModel>
}
struct CommitmentValidationResultRow {
    let result: Spec.CommitmentValidationResult
}
struct $s4Spec0036MessageCommitmentTestViewswift_tjBBlfMX406_0_33_51422BF8EC5C729106D29ABBC979E2A9Ll7PreviewfMf_15PreviewRegistryfMu_ {}
class PersonalStyleDatasetExporter {
    struct Record {
        enum CodingKeys {
            case prompt
            case response
        }
        let prompt: Swift.String
        let response: Swift.String
    }
    struct ChatMessage {
        enum CodingKeys {
            case role
            case content
        }
        let role: Swift.String
        let content: Swift.String
    }
    struct ChatSample {
        enum CodingKeys {
            case messages
            case conversations
            case instruction
            case input
            case output
            case prompt
            case response
        }
        let messages: [Spec.PersonalStyleDatasetExporter.ChatMessage]
        let conversations: [[Swift.String : Swift.String]]
        let instruction: Swift.String
        let input: Swift.String
        let output: Swift.String
        let prompt: Swift.String
        let response: Swift.String
    }
}
class ChatTitleModel {
    var _title: Combine.Published<Swift.String>
    var _isTitleGenerated: Combine.Published<Swift.Bool>
    var _previewImage: Combine.Published<Swift.String>
}
struct ContactOverview {
    struct AppIdentity {
        let app: Swift.String
        let handle: Swift.String?
        let displayName: Swift.String?
        let profileImagePath: Swift.String?
    }
    struct Container {
        let platform: Swift.String
        let type: Swift.String?
        let id: Swift.String
        let name: Swift.String?
        let firstSeen: Foundation.Date
        let lastSeen: Foundation.Date
    }
    struct WeeklyStats {
        let weekStart: Foundation.Date
        let messagesIn: Swift.Int
        let messagesOut: Swift.Int
    }
    struct ResponseStats {
        let avgSeconds14d: Swift.Double?
        let medianSeconds14d: Swift.Double?
    }
    struct SocialLink {
        let platform: Swift.String
        let handle: Swift.String?
        let url: Swift.String?
        let confidence: Swift.Double?
    }
    struct Address {
        let type: Swift.String?
        let city: Swift.String?
        let country: Swift.String?
        let full: Swift.String?
    }
    struct Employment {
        let company: Swift.String?
        let role: Swift.String?
        let isCurrent: Swift.Bool?
        let confidence: Swift.Double?
    }
    struct Education {
        let institution: Swift.String?
        let degree: Swift.String?
        let confidence: Swift.Double?
    }
    struct Topic {
        let topic: Swift.String
        let weight: Swift.Double?
    }
    struct RelatedContact {
        let contactId: Swift.String
        let weight: Swift.Double?
        let relationType: Swift.String
    }
    struct ChannelMetrics {
        let platform: Swift.String
        let handle: Swift.String?
        let lastInteraction: Foundation.Date
        let firstInteraction: Foundation.Date
        let totalInteractions: Swift.Int
        let messagesIn: Swift.Int
        let messagesOut: Swift.Int
        let avgMessagesPerWeek: Swift.Double
        let daysSinceLastContact: Swift.Int
    }
    let contactId: Swift.String
    let displayName: Swift.String?
    let preferredName: Swift.String?
    let isBusiness: Swift.Bool
    let isPersonal: Swift.Bool
    let isTrusted: Swift.Bool
    let appIdentities: [Spec.ContactOverview.AppIdentity]
    let containers: [Spec.ContactOverview.Container]
    let perPlatformWeekly: [Swift.String : Spec.ContactOverview.WeeklyStats]
    let perPlatformResponse: [Swift.String : Spec.ContactOverview.ResponseStats]
    let socialLinks: [Spec.ContactOverview.SocialLink]
    let addresses: [Spec.ContactOverview.Address]
    let employment: [Spec.ContactOverview.Employment]
    let education: [Spec.ContactOverview.Education]
    let topics: [Spec.ContactOverview.Topic]
    let relatedContacts: [Spec.ContactOverview.RelatedContact]
    let channelMetrics: [Spec.ContactOverview.ChannelMetrics]
    let relationshipToUser: Swift.String?
    let relationshipToUserDetails: Swift.String?
    let relationshipConfidence: Swift.Double?
}
struct Phase2Task {
    enum TaskSource {
        case gmail
        case email
        case message
        case slack
        case whatsapp
        case other
    }
    enum TaskPriority {
        case urgent
        case thisWeek
        case upcoming
        case someday
    }
    let id: Swift.String
    let title: Swift.String
    let description: Swift.String
    let contextSummary: Swift.String?
    let senderName: Swift.String
    let senderEmail: Swift.String?
    let senderImage: Swift.String?
    let source: Spec.Phase2Task.TaskSource
    let priority: Spec.Phase2Task.TaskPriority
    let dueDate: Foundation.Date?
    let project: Swift.String?
    let projectIcon: Swift.String?
    let createdAt: Foundation.Date
    let rawData: Any?
    let urgency: Swift.Double
    let professionalImpact: Swift.Double
    let personalImpact: Swift.Double
}
class ThinkingState {
    var _text: Combine.Published<Swift.String>
    var _isShowing: Combine.Published<Swift.Bool>
    var _threadID: Combine.Published<Swift.String>
    var _startTime: Combine.Published<Foundation.Date?>
    var _durationSeconds: Combine.Published<Swift.Double?>
    var _isStreaming: Combine.Published<Swift.Bool>
}
struct Todo {
    enum TodoType {
        case messageDraft
        case emailDraft
        case slackDraft
        case webTask
        case manualTask
    }
    enum Priority {
        case low
        case medium
        case high
    }
    enum Category {
        case work
        case personal
        case shopping
        case health
        case finance
        case other
    }
    enum CodingKeys {
        case id
        case type
        case title
        case description
        case dueDate
        case isCompleted
        case priority
        case category
        case createdAt
        case completedAt
    }
    let id: Foundation.UUID
    var type: Spec.Todo.TodoType
    var title: Swift.String
    var description: Swift.String?
    var dueDate: Foundation.Date?
    var isCompleted: Swift.Bool
    var priority: Spec.Todo.Priority
    var category: Spec.Todo.Category?
    var createdAt: Foundation.Date
    var completedAt: Foundation.Date?
}
enum EncryptedFileStore {}
class BrowserManager: __C.NSObject {
    enum BrowserKind {
        case chrome
        case safari
    }
    var windowController: Spec.BrowserWindowController?
    var headlessWebView: __C.WKWebView?
    var uiSuppressed: Swift.Bool
}
class BrowserWindowController: __C.NSWindowController {
    let webView: __C.WKWebView
    let windowRef: __C.NSWindow
}
class BrowserSubagentRunner {
    var isRunning: Swift.Bool
    var directive: Swift.String
    var observable: Spec.MessageFunctionCallingObservable?
    var inheritedService: Spec.AnthropicService?
}
class EmbeddedBrowserController {
    enum Mode {
        case thumbnail
        case expanded
    }
    var _isVisible: Combine.Published<Swift.Bool>
    var _mode: Combine.Published<Spec.EmbeddedBrowserController.Mode>
    var _lockThumbnail: Combine.Published<Swift.Bool>
    var _viewportSize: Combine.Published<__C.CGSize>
    var _thumbnailWidth: Combine.Published<CoreGraphics.CGFloat>
    var _thumbnailMaxHeight: Combine.Published<CoreGraphics.CGFloat>
    var _thumbnailMagnification: Combine.Published<CoreGraphics.CGFloat>
    var _expandedWidth: Combine.Published<CoreGraphics.CGFloat>
    var _cornerRadius: Combine.Published<CoreGraphics.CGFloat>
    var _statusText: Combine.Published<Swift.String>
    var _urlString: Combine.Published<Swift.String>
    let webView: __C.WKWebView
}
struct EmbeddedBrowserRepresentable {}
struct EmbeddedBrowserOverlayView {
    var _controller: SwiftUI.ObservedObject<Spec.EmbeddedBrowserController>
}
class AppleIntelligenceService {
    struct AvailableModel {
        let id: Swift.String
        let name: Swift.String
        let displayName: Swift.String
        let isAvailable: Swift.Bool
        let unavailableReason: Swift.String?
    }
    var sessionStorage: Any?
}
enum AppleIntelligenceError {
    case unsupportedSystem(Swift.String)
    case noModelsAvailable(Swift.String)
    case notImplemented(Swift.String)
    case apiError(Swift.String)
    case modelRefusal(Swift.String)
}
class AudioTranscriptionService {}
class AuthHealthService {
    var _missingGoogleRefreshEmails: Combine.Published<[Swift.String]>
}
class AvatarImageCache {
    let cache: __C.NSCache<__C.NSString, Swift.AnyObject>
    let negativeCache: __C.NSCache<__C.NSString, Swift.AnyObject>
}
class AvatarResolver {
    let workQueue: __C.NSOperationQueue
    let cache: __C.NSCache<__C.NSString, __C.NSString>
    var inFlight: [Swift.String : [(_: Swift.String?) -> ()]]
    let lock: __C.NSLock
}
struct BackgroundConfig {
    let morningHour: Swift.Int
    let morningMinute: Swift.Int
    let middayHour: Swift.Int
    let middayMinute: Swift.Int
    let eveningHour: Swift.Int
    let eveningMinute: Swift.Int
    let homeGreetingModel: Spec.Model
    let meetingPrepModel: Spec.Model
    let meetingPrepThinkingBudget: Swift.Int
    let meetingPrepMaxTokens: Swift.Int
    let firstTimeChatModel: Spec.Model
    let firstTimeChatThinkingBudget: Swift.Int
    let firstTimeChatMaxTokens: Swift.Int
    let intraDayPrepModel: Spec.Model
    let replyScanModel: Spec.Model
    let needsReplyModel: Spec.Model
    let needsReplyThinkingBudget: Swift.Int
    let needsReplyMaxTokens: Swift.Int
    let needsReplyOutputBudget: Swift.Int
    let needsReplyDaysBack: Swift.Int
    let needsReplyMinAgeSeconds: Swift.Double
    let todosAuditModel: Spec.Model
}
enum BackgroundServicesGate {}
class BackgroundServiceTracker {
    var _hasActiveServices: Combine.Published<Swift.Bool>
    var _activeServiceNames: Combine.Published<Swift.Set<Swift.String>>
    var activeServiceCount: Swift.Int
}
class BackgroundTasksScheduler {
    var timer: __C.NSTimer?
    let checkInterval: Swift.Double
    let anchorLeewaySeconds: Swift.Double
}
class BackgroundUpdateService {
    var apiKey: Swift.String
    let disabled: Swift.Bool
    let debugLogging: Swift.Bool
    var broadcastUINotifications: Swift.Bool
    var lastBatchContext: (latestText: Swift.String, isFromMe: Swift.Bool, latestSenderName: Swift.String?)?
    let gate: Spec.SingleFlight
    var lastRunAt: Foundation.Date?
    let minRunInterval: Swift.Double
}
actor SingleFlight {
    var $defaultActor: 
    var running: Swift.Bool
}
class BrowserSearchService {
    enum BrowserType {
        case chrome
        case safari
    }
    let chromeExtractor: Spec.ChromeDataExtractor
    let safariExtractor: Spec.SafariDataExtractor
}
class ConnectivityService {
    var _isConnected: Combine.Published<Swift.Bool>
    var _isExpensive: Combine.Published<Swift.Bool>
    var _isConstrained: Combine.Published<Swift.Bool>
    let monitor: Network.NWPathMonitor
    let monitorQueue: __C.OS_dispatch_queue
}
class ContactEnrichmentBackgroundService {
    let lastRunKey: Swift.String
    let minRunIntervalSeconds: Swift.Double
    let maxContactsPerRun: Swift.Int
    let activityWindowDays: Swift.Int
    var isRunning: Swift.Bool
    let disabled: Swift.Bool
}
class ContactEnrichmentService {
    let store: Spec.LocalContactsStore
    let enrichmentIntervalDays: Swift.Double
}
struct ContactMessagingInfo {
    enum CodingKeys {
        case contactId
        case displayName
        case availableChannels
        case recommendedChannel
    }
    let contactId: Swift.String
    let displayName: Swift.String
    let availableChannels: [Spec.ChannelOption]
    let recommendedChannel: Spec.ChannelOption
}
struct ChannelOption {
    enum CodingKeys {
        case platform
        case handle
        case daysSinceLastContact
        case avgMessagesPerWeek
        case isRecommended
    }
    let platform: Swift.String
    let handle: Swift.String
    let daysSinceLastContact: Swift.Int
    let avgMessagesPerWeek: Swift.Double
    let isRecommended: Swift.Bool
}
class ContactMessagingLookupTool {
    let store: Spec.LocalContactsStore
}
enum ContactMessagingError {
    case contactNotFound(name: Swift.String)
    case noChannelsAvailable(name: Swift.String)
}
enum ContactsAccessPolicy {}
class ContactsAggregatorService {
    let store: Spec.LocalContactsStore
}
enum ContactsIngestionHooks {
    struct SocialLinkExtracted {
        let platform: Swift.String
        let handle: Swift.String?
        let url: Swift.String
    }
}
struct DraftConversationListView {
    let platform: Swift.String
    let items: [Spec.DraftListItem]
    var _selectedKey: SwiftUI.Binding<Swift.String?>
    let onSelect: (_: Swift.String) -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
class ContactsQueryService {
    let store: Spec.LocalContactsStore
}
class CurrentUserStateStore {
    var cachedString: Swift.String?
}
class DevicePresenceService {
    var _shouldShowIosSyncReminder: Combine.Published<Swift.Bool>
    var _shouldShowMacSyncPrompt: Combine.Published<Swift.Bool>
    var started: Swift.Bool
    var devicesListener: __C.FIRListenerRegistration?
    var macDevicesListener: __C.FIRListenerRegistration?
    var authHandle: __C.NSObject?
    var presenceTimer: __C.NSTimer?
    var currentUid: Swift.String?
    var lastPresenceUpdate: Foundation.Date?
    var lastSyncReminderCheck: Foundation.Date?
    var cachedEmail: Swift.String?
    var isAppActive: Swift.Bool
    var appActivationObserver: __C.NSObject?
    var appDeactivationObserver: __C.NSObject?
}
class DeviceRealtimeSyncService {
    var greetingListener: __C.FIRListenerRegistration?
    var chatInboxListener: __C.FIRListenerRegistration?
    var phase2Listener: __C.FIRListenerRegistration?
    var snapshotListener: __C.FIRListenerRegistration?
    var started: Swift.Bool
    var lastSnapshotPublishTime: Foundation.Date?
    var isApplyingPeerSnapshot: Swift.Bool
}
class DigitalWellbeingService {
    var _goalsByDomain: Combine.Published<[Swift.String : Swift.Int]>
    var _todayUsageSecondsByDomain: Combine.Published<[Swift.String : Swift.Int]>
    var _todayOverrideLimitSecondsByDomain: Combine.Published<[Swift.String : Swift.Int]>
    var monitorTimer: __C.NSTimer?
    var currentDomain: Swift.String?
    var lastSampleAt: Foundation.Date
    var lastDayKey: Swift.String
    var shownNudgeForDomainOnDay: [Swift.String : Swift.String]
    var nudgeWindowController: __C.NSWindowController?
    var nudgeDomain: Swift.String?
    var nudgeCloseObserver: Any?
    var appActivationObserver: Any?
    var nudgeHostBundleId: Swift.String?
    var debugLogging: Swift.Bool
    let usageDefaultsPrefix: Swift.String
    let nudgedDefaultsPrefix: Swift.String
    let overridesDefaultsPrefix: Swift.String
}
struct DigitalWellbeingNudgeView {
    let domain: Swift.String
    let usedMinutes: Swift.Int
    let limitMinutes: Swift.Int
    let onDismiss: () -> ()
    var _isVisible: SwiftUI.State<Swift.Bool>
    var _snark: SwiftUI.State<Swift.String>
}
struct VisualEffectBlurView {
    var material: __C.Material
    var blendingMode: __C.BlendingMode
    var state: __C.State
}
struct OverlayPillButtonStyle {
    var foreground: SwiftUI.Color
    var background: SwiftUI.Color
}
struct DraftsPageIndicatorView {
    var _selectedPage: SwiftUI.Binding<Swift.Int>
    let draftCounts: (messages: Swift.Int, gmail: Swift.Int, slack: Swift.Int, x: Swift.Int)
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _isXEnabled: SwiftUI.State<Swift.Bool>
}
struct IconWithBadge {
    let iconName: Swift.String
    let count: Swift.Int
}
class DocumentWriter {
    enum SetupState {
        case failed(Swift.String)
        case unknown
        case notSetup
        case settingUp
        case ready
    }
    struct FormatDef {
        enum CodingKeys {
            case key
            case bold
            case italic
            case underline
            case strike
            case fontName
            case fontSize
            case fontColor
            case bgColor
            case alignment
            case lineSpacing
            case spaceBefore
            case spaceAfter
            case leftIndent
            case rightIndent
            case firstLineIndent
        }
        let key: Swift.String
        let bold: Swift.Bool?
        let italic: Swift.Bool?
        let underline: Swift.Bool?
        let strike: Swift.Bool?
        let fontName: Swift.String?
        let fontSize: Swift.Double?
        let fontColor: Swift.String?
        let bgColor: Swift.String?
        let alignment: Swift.String?
        let lineSpacing: Swift.Double?
        let spaceBefore: Swift.Double?
        let spaceAfter: Swift.Double?
        let leftIndent: Swift.Double?
        let rightIndent: Swift.Double?
        let firstLineIndent: Swift.Double?
    }
    struct RunSpec {
        enum CodingKeys {
            case text
            case format
        }
        let text: Swift.String
        let format: Swift.String?
    }
    struct ParagraphSpec {
        enum CodingKeys {
            case type
            case text
            case runs
            case format
            case paragraphFormat
        }
        let type: Swift.String
        let text: Swift.String?
        let runs: [Spec.DocumentWriter.RunSpec]?
        let format: Swift.String?
        let paragraphFormat: Swift.String?
    }
    struct HeadingSpec {
        enum CodingKeys {
            case type
            case text
            case level
        }
        let type: Swift.String
        let text: Swift.String
        let level: Swift.Int?
    }
    struct TableCellSpec {
        enum CodingKeys {
            case text
            case format
        }
        let text: Swift.String?
        let format: Swift.String?
    }
    struct TableRowSpec {
        enum CodingKeys {
            case cells
        }
        let cells: [Spec.DocumentWriter.TableCellSpec]
    }
    struct TableSpec {
        enum CodingKeys {
            case type
            case rows
            case cols
            case style
        }
        let type: Swift.String
        let rows: [Spec.DocumentWriter.TableRowSpec]
        let cols: Swift.Int
        let style: Swift.String?
    }
    struct ImageSpec {
        enum CodingKeys {
            case type
            case path
            case widthInches
            case heightInches
        }
        let type: Swift.String
        let path: Swift.String
        let widthInches: Swift.Double?
        let heightInches: Swift.Double?
    }
    struct PageBreakSpec {
        enum CodingKeys {
            case type
        }
        let type: Swift.String
    }
    struct DocumentSpec {
        enum CodingKeys {
            case sourcePath
            case destinationPath
            case formats
            case templateReplacements
            case content
        }
        let sourcePath: Swift.String?
        let destinationPath: Swift.String
        let formats: [Spec.DocumentWriter.FormatDef]
        let templateReplacements: [Swift.String : Swift.String]?
        let content: [Spec.DocumentWriter.ContentBlock]
    }
    enum ContentBlock {
        case paragraph(Spec.DocumentWriter.ParagraphSpec)
        case heading(Spec.DocumentWriter.HeadingSpec)
        case table(Spec.DocumentWriter.TableSpec)
        case image(Spec.DocumentWriter.ImageSpec)
        case pageBreak(Spec.DocumentWriter.PageBreakSpec)
    }
    struct AnyCodable {
        let value: Any
    }
}
struct ParsedSignature {
    let company: Swift.String?
    let role: Swift.String?
    let phone: Swift.String?
    let linkedInURL: Swift.String?
    let website: Swift.String?
    let confidence: Swift.Double
}
class EmailSignatureParser {}
class EventDeduplicationService {
    var isRunning: Swift.Bool
    var lastRunTime: Foundation.Date?
    let minRunInterval: Swift.Double
}
class EventDuplicateDetector {}
class EventPreparationService {
    var isRunning: Swift.Bool
    var streamCompletedFlag: Swift.Bool
}
class ExcelWriter {
    struct FormatDef {
        let key: Swift.String
        let bold: Swift.Bool
        let italic: Swift.Bool
        let fontName: Swift.String?
        let fontSize: Swift.Double?
        let numFormat: Swift.String?
        let bgColorRGB: Swift.String?
        let fontColorRGB: Swift.String?
        let textWrap: Swift.Bool
    }
    struct CellSpec {
        let row: Swift.UInt32
        let col: Swift.UInt16
        let stringValue: Swift.String?
        let numberValue: Swift.Double?
        let boolValue: Swift.Bool?
        let formula: Swift.String?
        let hyperlink: Swift.String?
        let formatKey: Swift.String?
    }
    struct MergeSpec {
        let firstRow: Swift.UInt32
        let firstCol: Swift.UInt16
        let lastRow: Swift.UInt32
        let lastCol: Swift.UInt16
        let stringValue: Swift.String?
        let numberValue: Swift.Double?
        let formatKey: Swift.String?
    }
    struct ColumnWidthSpec {
        let firstCol: Swift.UInt16
        let lastCol: Swift.UInt16
        let width: Swift.Double
    }
    struct FreezePanes {
        let rows: Swift.UInt32
        let cols: Swift.UInt16
    }
    struct TableSpec {
        let startRow: Swift.UInt32
        let startCol: Swift.UInt16
        let headers: [Swift.String]
        let rows: [[Swift.String]]
        let headerFormatKey: Swift.String?
        let bodyFormatKey: Swift.String?
    }
    struct ChartSeriesSpec {
        let name: Swift.String?
        let categories: Swift.String?
        let values: Swift.String
    }
    enum ChartType {
        case column
        case bar
        case line
        case area
        case pie
        case scatter
    }
    struct ChartSpec {
        let type: Spec.ExcelWriter.ChartType
        let anchorRow: Swift.UInt32
        let anchorCol: Swift.UInt16
        let title: Swift.String?
        let series: [Spec.ExcelWriter.ChartSeriesSpec]
    }
    struct ImageSpec {
        let row: Swift.UInt32
        let col: Swift.UInt16
        let path: Swift.String
        let scaleX: Swift.Double?
        let scaleY: Swift.Double?
    }
    struct WorksheetSpec {
        let name: Swift.String
        let columns: [Spec.ExcelWriter.ColumnWidthSpec]
        let freeze: Spec.ExcelWriter.FreezePanes?
        let rowHeights: [(Swift.UInt32, Swift.Double)]
        let cells: [Spec.ExcelWriter.CellSpec]
        let merges: [Spec.ExcelWriter.MergeSpec]
        let tables: [Spec.ExcelWriter.TableSpec]
        let autoFilter: Swift.String?
        let charts: [Spec.ExcelWriter.ChartSpec]
        let images: [Spec.ExcelWriter.ImageSpec]
    }
    struct WorkbookSpec {
        let destinationPath: Swift.String
        let defaultDateFormat: Swift.String?
        let formats: [Spec.ExcelWriter.FormatDef]
        let worksheets: [Spec.ExcelWriter.WorksheetSpec]
    }
}
enum FineTuneRuntimeManager {
    struct PythonRuntime {
        let pythonPath: Swift.String
        let env: [Swift.String : Swift.String]
    }
}
class ForegroundActivityTracker {
    var lastActionAt: Foundation.Date
    let minIntervalBetweenSignals: Swift.Double
    let activityThreshold: Swift.Double
}
class ChatTitleService {
    var useAIProxy: Swift.Bool
    var apiKey: Swift.String
    var baseURL: Foundation.URL
    var modelName: Swift.String
}
enum TitleServiceError {
    case apiError(statusCode: Swift.Int)
    case missingAPIKey
    case noContentGenerated
}
struct OpenAIChatCompletionsRequest {
    enum CodingKeys {
        case model
        case messages
        case stream
        case user
        case maxTokens
    }
    let model: Swift.String
    let messages: [Spec.OpenAIMessage]
    let maxTokens: Swift.Int?
    let stream: Swift.Bool
    let user: Swift.String?
}
struct OpenAIMessage {
    enum CodingKeys {
        case role
        case content
    }
    let role: Swift.String
    let content: Swift.String
}
struct OpenAIChatCompletionsResponse {
    enum CodingKeys {
        case choices
    }
    let choices: [Spec.OpenAIChoice]
}
struct OpenAIChoice {
    enum CodingKeys {
        case message
    }
    let message: Spec.OpenAIChoiceMessage
}
struct OpenAIChoiceMessage {
    enum CodingKeys {
        case role
        case content
    }
    let role: Swift.String
    let content: Swift.String
}
class GlobalChatRegistry {
    var _observable: Combine.Published<Spec.MessageFunctionCallingObservable?>
    var getActions: (() -> [Spec.AIAction])?
    var setActions: ((_: [Spec.AIAction]) -> ())?
    var submitMessage: ((_: Swift.String) -> ())?
    var isNextSubmissionFromPopup: Swift.Bool
}
class GmailAccountIndexResolverService {
    let progressiveWindowsDays: [Swift.Int]
}
struct DeduplicationStats {
    var arraysProcessed: Swift.Int
    var duplicatesRemoved: Swift.Int
}
class GmailLiveSyncService {
    var timer: __C.NSTimer?
    var isStarted: Swift.Bool
    var syncInFlight: Swift.Bool
    let fastInterval: Swift.Double
    let slowInterval: Swift.Double
    let historyKeyPrefix: Swift.String
}
actor GodLogger {
    enum Category {
        case service
        case llm
        case crud
        case ui
        case network
        case other
    }
    enum Level {
        case debug
        case info
        case warn
        case error
    }
    struct Entry {
        enum CodingKeys {
            case id
            case ts
            case category
            case level
            case source
            case message
            case context
            case payloadJSON
        }
        let id: Swift.String
        let ts: Swift.Double
        let category: Spec.GodLogger.Category
        let level: Spec.GodLogger.Level
        let source: Swift.String
        let message: Swift.String
        let context: [Swift.String : Swift.String]?
        let payloadJSON: Swift.String?
    }
    var $defaultActor: 
    let maxEntries: Swift.Int
    let persistEveryNAdds: Swift.Int
    var persistCounter: Swift.Int
    var entries: [Spec.GodLogger.Entry]
    var subscribers: [Foundation.UUID : (_: Spec.GodLogger.Entry) -> ()]
}
class GoogleCalendarService {
    let base: Swift.String
    let urlSession: __C.NSURLSession
}
class GoogleCalendarSyncService {
    var timer: __C.NSTimer?
    var isStarted: Swift.Bool
    var syncInFlight: Swift.Bool
    let fastInterval: Swift.Double
    let slowInterval: Swift.Double
    let timeHorizonDays: Swift.Int
    let maxResultsPerCalendar: Swift.Int
}
class GoogleContactsService {
    struct ContactInfo {
        let displayName: Swift.String?
        let photoBase64: Swift.String?
    }
    let peopleBase: Swift.String
    let cacheKeyPrefix: Swift.String
    let urlSession: __C.NSURLSession
}
actor AuthViewModelAccessor {
    var $defaultActor: 
}
actor GoogleAccountsAccessor {
    var $defaultActor: 
}
struct GoogleAccountThin {
    let email: Swift.String
    let accessToken: Swift.String
}
class GranolaNotesWatcher {
    var source: __C.OS_dispatch_source_vnode?
    var fileDescriptor: Swift.Int32
    let cachePath: Swift.String
    let onChange: () -> ()
    var isWatching: Swift.Bool
    var debounceTimer: __C.NSTimer?
    let debounceInterval: Swift.Double
    let startupSuppressInterval: Swift.Double
    let startupStartedAt: Foundation.Date
}
enum GranolaWatcherError {
    case cacheNotFound(path: Swift.String)
    case cannotOpenFile(path: Swift.String)
}
class HomeGreetingService {
    let storageKey: Swift.String
    let lastGeneratedAtKey: Swift.String
    let lastAttemptedAtKey: Swift.String
    var isGenerating: Swift.Bool
    var streamCompletedFlag: Swift.Bool
}
enum ImageBlobStore {}
class InitialBackgroundServicesKickoff {
    let kickoffKey: Swift.String
    var isRunning: Swift.Bool
    let todoServicesDisabled: Swift.Bool
    let contactEnrichmentDisabled: Swift.Bool
}
class InitialCalendarPopulationService {
    let eventStore: __C.EKEventStore
    var hasPopulated: Swift.Bool
}
enum InstagramToolGating {}
class IntraDayPrepService {
    enum TimeSlot {
        case morning
        case midday
        case evening
    }
    var isRunning: Swift.Bool
    var streamCompletedFlag: Swift.Bool
}
class InviteService {
    struct Config {
        var enabled: Swift.Bool
        var dailyEarnEnabled: Swift.Bool
        var signupRequiresInvite: Swift.Bool
        var initialInvites: Swift.Int
        var maxInvites: Swift.Int
    }
    struct InviteCode {
        let id: Swift.String
        let code: Swift.String
        let inviterUid: Swift.String
        let status: Swift.String
        let createdAt: Foundation.Date?
        let usedBy: Swift.String?
        let usedAt: Foundation.Date?
    }
    var hasStarted: Swift.Bool
    var config: Spec.InviteService.Config
    let userDefaults: __C.NSUserDefaults
    let initialGrantDoneField: Swift.String
    let temporarySkipInviteGate: Swift.Bool
    let lastAwardAttemptKey: Swift.String
    let inviteGatePassedKey: Swift.String
    var didInitAfterAuth: Swift.Bool
}
enum KnowledgeSummaryStore {}
class LLMBanGate {
    var isBanned: Swift.Bool
    var banReason: Swift.String?
    var lastUpdated: Foundation.Date?
    let userDefaults: __C.NSUserDefaults
    let cachedBanKey: Swift.String
    let cachedReasonKey: Swift.String
    var listener: __C.FIRListenerRegistration?
}
struct LLMBannedError {
    let reason: Swift.String?
}
actor AsyncSemaphore {
    var $defaultActor: 
    var value: Swift.Int
    var waiters: [Swift.CheckedContinuation<(), Swift.Never>]
}
actor LLMWorkScheduler {
    enum Category {
        case realtime
        case backgroundScan
        case audit
    }
    var $defaultActor: 
    let realtimeGlobalSemaphore: Spec.AsyncSemaphore
    let backgroundGlobalSemaphore: Spec.AsyncSemaphore
    var perCategory: [Spec.LLMWorkScheduler.Category : Spec.AsyncSemaphore]
}
enum MailRAGCacheStore {}
class MeetingDebriefPreferences {
    let debriefEnabledKey: Swift.String
    let meetingTypesKey: Swift.String
    let minDurationKey: Swift.String
    let autoReflectionKey: Swift.String
}
class MeetingDebriefScheduler {
    struct TranscriptInfo {
        let id: Swift.String
        let title: Swift.String
        let date: Foundation.Date
    }
    var transcriptMonitorTimer: __C.NSTimer?
    var timeoutMonitorTimer: __C.NSTimer?
    let transcriptCheckInterval: Swift.Double
    let timeoutCheckInterval: Swift.Double
    let timeoutThreshold: Swift.Double
    let lastSeenTranscriptsKey: Swift.String
    let processedEventsKey: Swift.String
}
class MeetingDebriefService {
    struct ParsedMeeting {
        let id: Swift.String
        let title: Swift.String
        let date: Foundation.Date
    }
    var isGenerating: Swift.Bool
    var streamCompletedFlag: Swift.Bool
}
class MeetingPrepDocService {
    var isRunning: Swift.Bool
    var streamCompletedFlag: Swift.Bool
}
class MessageContextAnalyzer {
    let geminiEndpoint: Swift.String
    let model: Swift.String
    var lastAPICallTime: Foundation.Date?
    let minimumTimeBetweenCalls: Swift.Double
}
struct ContextData {
    let streams: [[Swift.String : Any]]
    let events: [[Swift.String : Any]]
    let todos: [[Swift.String : Any]]
    let streamNodes: [[Swift.String : Any]]
}
struct MessageAnalysisResult {
    let streams: [[Swift.String : Any]]
    let streamNodes: [[Swift.String : Any]]
    let events: [[Swift.String : Any]]
    let actions: [[Swift.String : Any]]
    let specDraftedAction: [Swift.String : Any]?
}
struct MCAGeminiRequest {
    enum CodingKeys {
        case contents
        case generationConfig
    }
    let contents: [Spec.MCAGeminiContent]
    let generationConfig: Spec.MCAGeminiGenerationConfig
}
struct MCAGeminiContent {
    enum CodingKeys {
        case parts
    }
    let parts: [Spec.MCAGeminiPart]?
}
struct MCAGeminiPart {
    enum CodingKeys {
        case text
    }
    let text: Swift.String
}
struct MCAGeminiGenerationConfig {
    enum CodingKeys {
        case temperature
        case maxOutputTokens
        case topP
        case topK
    }
    let temperature: Swift.Double
    let maxOutputTokens: Swift.Int
    let topP: Swift.Double
    let topK: Swift.Int
}
struct MCAGeminiResponse {
    enum CodingKeys {
        case candidates
    }
    let candidates: [Spec.MCAGeminiCandidate]?
}
struct MCAGeminiCandidate {
    enum CodingKeys {
        case content
    }
    let content: Spec.MCAGeminiContent?
}
class MessageDatabaseWatcher {
    var source: __C.OS_dispatch_source_vnode?
    var fileDescriptor: Swift.Int32
    let dbPath: Swift.String
    let onChange: () -> ()
    var isWatching: Swift.Bool
    var debounceTimer: __C.NSTimer?
    let debounceInterval: Swift.Double
}
enum MessageWatcherError {
    case cannotOpenFile(path: Swift.String)
    case permissionDenied
}
class RealtimeMessageMonitor {
    struct PendingMessage {
        let guid: Swift.String
        let date: Foundation.Date
        let text: Swift.String
        let isFromMe: Swift.Bool
        let handleId: Swift.String?
    }
    class BatchBuffer {
        var messages: [Spec.RealtimeMessageMonitor.PendingMessage]
        var timer: __C.NSTimer?
        var firstReceivedAt: Foundation.Date?
    }
    var watcher: Spec.MessageDatabaseWatcher?
    var lastProcessedMessageId: Swift.String?
    var processedMessageIds: Swift.Set<Swift.String>
    let processQueue: __C.OS_dispatch_queue
    var isInitialLoad: Swift.Bool
    var monitoringStartTime: Foundation.Date?
    var hasPendingChanges: Swift.Bool
    var activeTask: Swift.Task<(), Swift.Never>?
    var isRunning: Swift.Bool
    var batchBuffers: [Swift.String : Spec.RealtimeMessageMonitor.BatchBuffer]
    let batchDelay: Swift.Double
    var cleanupTimer: __C.NSTimer?
    let maxProcessedMessageIds: Swift.Int
    var processedMessageTimestamps: [Swift.String : Foundation.Date]
}
class MessageMonitoringIntegration {}
class MessagesConversationMonitor {
    var timer: __C.NSTimer?
    var activationObserver: Any?
    var lastBundleId: Swift.String?
    var lastChatTitle: Swift.String?
    var lastSlackConversationTitle: Swift.String?
    var shownDraftTodoIds: Swift.Set<Swift.String>
    var started: Swift.Bool
}
struct ModelCapabilities {
    let modelName: Swift.String
    let contextWindow: Swift.Int
    let maxOutputTokens: Swift.Int?
    let supportsFunctionCalling: Swift.Bool
    let provider: Swift.String
}
class ModelCapabilitiesService {
    var cache: [Swift.String : Spec.ModelCapabilities]
    let session: __C.NSURLSession
    let cacheVersion: Swift.String
}
class MiniMaxService: Spec.DefaultAnthropicService {}
class NeedsReplyBackgroundService {
    struct MessageCandidate {
        let chatGuid: Swift.String
        let messageGuid: Swift.String
        let senderHandle: Swift.String
        let senderName: Swift.String?
        let preview: Swift.String
        let lastInboundTs: Foundation.Date
        let contextSummary: Swift.String
        let dedupeKey: Swift.String
    }
    struct SlackCandidate {
        let teamId: Swift.String
        let channelId: Swift.String
        let threadTs: Swift.String
        let senderUserId: Swift.String
        let senderName: Swift.String?
        let preview: Swift.String
        let lastInboundTs: Foundation.Date
        let contextSummary: Swift.String
        let dedupeKey: Swift.String
    }
    struct GmailCandidate {
        let accountEmail: Swift.String
        let threadId: Swift.String
        let messageId: Swift.String
        let senderEmail: Swift.String
        let senderName: Swift.String?
        let subject: Swift.String
        let preview: Swift.String
        let lastInboundTs: Foundation.Date
        let contextSummary: Swift.String
        let dedupeKey: Swift.String
    }
    struct WhatsAppCandidate {
        let chatGuid: Swift.String
        let messageGuid: Swift.String
        let senderHandle: Swift.String
        let senderName: Swift.String?
        let preview: Swift.String
        let lastInboundTs: Foundation.Date
        let contextSummary: Swift.String
        let dedupeKey: Swift.String
        let isGroup: Swift.Bool
    }
    struct XCandidate {
        enum XCandidateType {
            case directMessage(conversationId: Swift.String)
            case mention
        }
        let tweetId: Swift.String
        let authorId: Swift.String
        let authorUsername: Swift.String?
        let text: Swift.String
        let createdAt: Foundation.Date
        let contextSummary: Swift.String
        let dedupeKey: Swift.String
        let type: Spec.NeedsReplyBackgroundService.XCandidate.XCandidateType
    }
    struct RunResults {
        let messages: [Spec.NeedsReplyBackgroundService.MessageCandidate]
        let slack: [Spec.NeedsReplyBackgroundService.SlackCandidate]
        let gmail: [Spec.NeedsReplyBackgroundService.GmailCandidate]
        let whatsapp: [Spec.NeedsReplyBackgroundService.WhatsAppCandidate]
        let x: [Spec.NeedsReplyBackgroundService.XCandidate]
    }
    let disabled: Swift.Bool
}
class NotionSearchService {
    struct Query {
        let keywords: [Swift.String]
        let titleKeywords: [Swift.String]
        let bodyKeywords: [Swift.String]
        let workspaceNames: [Swift.String]
        let fromDateTime: Foundation.Date?
        let toDateTime: Foundation.Date?
        let pageIds: [Swift.String]
        let requirePublic: Swift.Bool
        let sortBy: Swift.String
        let sortOrderDesc: Swift.Bool
        let limit: Swift.Int
    }
    let extractor: Spec.NotionDataExtractor
}
class OpenAIResponsesProvider {
    struct Message {
        enum Role {
            case user
            case assistant
            case system
            case tool
        }
        let id: Foundation.UUID
        let role: Spec.OpenAIResponsesProvider.Message.Role
        var content: Swift.String
        var isStreaming: Swift.Bool
        var responseId: Swift.String?
        var reasoningContent: Swift.String?
        var toolCalls: [Spec.OpenAIResponsesProvider.ToolCall]
        var finishReason: Swift.String?
    }
    struct ToolCall {
        let id: Swift.String
        let name: Swift.String
        var arguments: Swift.String
        var result: Swift.String?
    }
    struct Configuration {
        var model: Spec.Model
        var temperature: Swift.Double?
        var maxTokens: Swift.Int?
        var tools: [Spec.OpenAIResponsesProvider.Tool]?
        var toolChoice: Spec.OpenAIResponsesProvider.ToolChoice?
        var reasoning: Spec.OpenAIResponsesProvider.ReasoningConfiguration?
        var stream: Swift.Bool
    }
    struct ReasoningConfiguration {
        var effort: Swift.String
    }
    struct Tool {
        let name: Swift.String
        let description: Swift.String
        let parameters: [Swift.String : Any]
    }
    enum ToolChoice {
        case specific(Swift.String)
        case auto
        case none
        case required
    }
    var _messages: [Spec.OpenAIResponsesProvider.Message]
    var _isStreaming: Swift.Bool
    var _error: Swift.String?
    var _configuration: Spec.OpenAIResponsesProvider.Configuration
    var _onStreamingStart: (() -> ())?
    var _onDelta: ((_: Swift.String) -> ())?
    var _onReasoningDelta: ((_: Swift.String) -> ())?
    var _onToolCall: ((_: Spec.OpenAIResponsesProvider.ToolCall) -> ())?
    var _onCompleted: ((Swift.String, Swift.String?) -> ())?
    var _onError: ((_: Swift.String) -> ())?
    let service: Spec.AnthropicService
    var _previousResponseId: Swift.String?
    var _streamTask: Swift.Task<(), Swift.Never>?
    let _$observationRegistrar: Observation.ObservationRegistrar
}
enum StreamEvent {
    case started(responseId: Swift.String)
    case textDelta(Swift.String)
    case reasoningDelta(Swift.String)
    case toolCallStart(name: Swift.String, id: Swift.String)
    case toolCallArgumentsDelta(id: Swift.String, arguments: Swift.String)
    case toolCallCompleted(id: Swift.String, name: Swift.String, arguments: Swift.String)
    case requiresAction(responseId: Swift.String, toolCalls: [(id: Swift.String, name: Swift.String, arguments: Swift.String)])
    case completed(responseId: Swift.String, text: Swift.String, reasoning: Swift.String?)
    case error(Swift.Error)
}
class OpenAIResponsesStreamHandler {
    struct StreamBuffer {
        struct ToolCallBuffer {
            let id: Swift.String
            var name: Swift.String?
            var arguments: Swift.String
        }
        var responseId: Swift.String?
        var text: Swift.String
        var reasoning: Swift.String
        var toolCalls: [Swift.String : Spec.OpenAIResponsesStreamHandler.StreamBuffer.ToolCallBuffer]
    }
    var _currentText: Combine.Published<Swift.String>
    var _currentReasoning: Combine.Published<Swift.String>
    var _isStreaming: Combine.Published<Swift.Bool>
    var _error: Combine.Published<Swift.Error?>
    var onEvent: ((_: Spec.StreamEvent) -> ())?
    var buffer: Spec.OpenAIResponsesStreamHandler.StreamBuffer
    let debugEnabled: Swift.Bool
}
class OpenAIServiceWrapper {
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let openAIService: SwiftOpenAI.OpenAIService
    let debugEnabled: Swift.Bool
    var activeStreamTask: Swift.Task<(), Swift.Never>?
}
class OpenAIToolCallHandler {
    struct Tool {
        let name: Swift.String
        let description: Swift.String
        let parameters: Spec.OpenAIToolCallHandler.ToolParameters
        let handler: (Swift.String, [Swift.String : Any]) async throws -> Swift.String
    }
    struct ToolParameters {
        let type: Swift.String
        let properties: [Swift.String : Spec.OpenAIToolCallHandler.PropertyDefinition]
        let required: [Swift.String]
    }
    class PropertyDefinition {
        let type: Swift.String
        let description: Swift.String?
        let enumValues: [Swift.String]?
        let items: Spec.OpenAIToolCallHandler.PropertyDefinition?
    }
    struct ToolResult {
        let toolCallId: Swift.String
        let result: Swift.Result<Swift.String, Swift.Error>
    }
    struct ToolExecutionRequest {
        let id: Swift.String
        let name: Swift.String
        let arguments: Swift.String
    }
    var _tools: Combine.Published<[Swift.String : Spec.OpenAIToolCallHandler.Tool]>
    var _pendingExecutions: Combine.Published<[Spec.OpenAIToolCallHandler.ToolExecutionRequest]>
    var _executionHistory: Combine.Published<[Spec.OpenAIToolCallHandler.ToolResult]>
    var _isExecuting: Combine.Published<Swift.Bool>
    var debugEnabled: Swift.Bool
}
enum ToolError {
    case toolNotFound(Swift.String)
    case invalidArguments(Swift.String)
    case executionFailed(Swift.String)
}
class PairingSyncService {
    struct MacPairingSession {
        let id: Swift.String
        let urlString: Swift.String
    }
    var macListeners: [Swift.String : __C.FIRListenerRegistration]
    var processingPayload: Swift.Set<Swift.String>
}
enum PersonalStyleFineTuneService {
    struct PythonRunResult {
        let status: Swift.Int32
        let stdout: Swift.String
        let stderr: Swift.String
    }
}
class Phase1ProfileStore {
    var cachedProfileString: Swift.String?
}
class Phase2Store {
    var notifWorkItem: Dispatch.DispatchWorkItem?
    let notifDebounceInterval: Swift.Double
    var cachedRoot: [Swift.String : Any]?
    var needsPersistence: Swift.Bool
    var persistenceWorkItem: Dispatch.DispatchWorkItem?
}
class Phase2TaskManager {
    var _professionalTasks: Combine.Published<[Spec.Phase2Task]>
    var _personalTasks: Combine.Published<[Spec.Phase2Task]>
    var _isPersonalExpanded: Combine.Published<Swift.Bool>
    let userDefaults: __C.NSUserDefaults
    var reloadWorkItem: Dispatch.DispatchWorkItem?
    let reloadDebounceInterval: Swift.Double
    var reloadScheduledAt: Foundation.Date
    var lastReloadCompletedAt: Foundation.Date
    var printedAvatarNoneTodoIds: Swift.Set<Swift.String>
    let debugAvatarLogging: Swift.Bool
    var referencedBodyBackfillInProgressIds: Swift.Set<Swift.String>
}
class QuillNotesWatcher {
    var source: __C.OS_dispatch_source_vnode?
    var fileDescriptor: Swift.Int32
    let dbPath: Swift.String
    let onChange: () -> ()
    var isWatching: Swift.Bool
    var debounceTimer: __C.NSTimer?
    let debounceInterval: Swift.Double
    let startupSuppressInterval: Swift.Double
    let startupStartedAt: Foundation.Date
}
enum QuillWatcherError {
    case databaseNotFound(path: Swift.String)
    case cannotOpenFile(path: Swift.String)
}
class RemoteAccessControlService {
    var _isGloballyDisabled: Combine.Published<Swift.Bool>
    var _isUserDisabled: Combine.Published<Swift.Bool>
    var authHandle: __C.NSObject?
    var globalListener: __C.FIRListenerRegistration?
    var userListener: __C.FIRListenerRegistration?
    var started: Swift.Bool
}
class ReplyDraftingService {
    struct DraftResult {
        let shouldDraft: Swift.Bool
        let primary: Swift.String
        let alternates: [Swift.String]
        let context: Swift.String
        let extras: [Swift.String : Any]
        let reason: Swift.String
    }
    enum DraftParseError {
        case parse(Swift.String)
        case emptyOutput
    }
}
enum ReplyProcessingNullifier {}
class ResponseStreamProvider {
    struct ResponseMessage {
        enum MessageRole {
            case user
            case assistant
        }
        let id: Foundation.UUID
        let role: Spec.ResponseStreamProvider.ResponseMessage.MessageRole
        var content: Swift.String
        var isStreaming: Swift.Bool
        var responseId: Swift.String?
    }
    var _messages: [Spec.ResponseStreamProvider.ResponseMessage]
    var _isStreaming: Swift.Bool
    var _error: Swift.String?
    var _onDelta: ((_: Swift.String) -> ())?
    var _onCompleted: ((Swift.String, Swift.String?) -> ())?
    var _onError: ((_: Swift.String) -> ())?
    let service: Spec.AnthropicService
    var _previousResponseId: Swift.String?
    var _streamTask: Swift.Task<(), Swift.Never>?
    let _$observationRegistrar: Observation.ObservationRegistrar
}
class SFSymbolSuggestionService {
    struct Context {
        let streamId: Swift.String
        let streamTitle: Swift.String
        let streamDescription: Swift.String?
        let sampleNodeTitles: [Swift.String]
        let desiredSymbol: Swift.String?
    }
    let queue: __C.OS_dispatch_queue
    var attemptedKeys: Swift.Set<Swift.String>
    let attemptedKeysLock: __C.NSLock
}
struct SiteMetadata {
    let url: Foundation.URL
    let title: Swift.String
    let favicon: __C.NSImage?
}
class SiteMetadataService {
    class CachedMetadata: __C.NSObject {
        let meta: Spec.SiteMetadata
    }
    var cache: __C.NSCache<__C.NSURL, Spec.SiteMetadataService.CachedMetadata>
}
struct SlackUserMeta {
    enum CodingKeys {
        case id
        case teamId
        case name
        case realName
        case displayName
        case email
        case isBot
        case updatedAt
    }
    let id: Swift.String
    let teamId: Swift.String
    let name: Swift.String?
    let realName: Swift.String?
    let displayName: Swift.String?
    let email: Swift.String?
    let isBot: Swift.Bool?
    let updatedAt: Swift.Double
}
struct SlackConversationMeta {
    enum CodingKeys {
        case id
        case teamId
        case name
        case nameNormalized
        case isIM
        case isMPIM
        case isPrivate
        case isArchived
        case dmUserId
        case updatedAt
        case raw
    }
    let id: Swift.String
    let teamId: Swift.String
    let name: Swift.String?
    let nameNormalized: Swift.String?
    let isIM: Swift.Bool
    let isMPIM: Swift.Bool
    let isPrivate: Swift.Bool
    let isArchived: Swift.Bool
    let dmUserId: Swift.String?
    let updatedAt: Swift.Double
    let raw: [Swift.String : Spec.AnyCodable]?
}
struct AnyCodable {
    let value: Any
}
struct SlackAccountSummary {
    enum CodingKeys {
        case id
        case teamId
        case teamName
        case authedUserId
        case accessToken
        case refreshToken
        case expirationDate
    }
    let id: Foundation.UUID
    let teamId: Swift.String
    var teamName: Swift.String?
    var authedUserId: Swift.String
    var accessToken: Swift.String
    var refreshToken: Swift.String?
    var expirationDate: Foundation.Date?
}
struct SlackPostResult {
    let ok: Swift.Bool
    let channelId: Swift.String
    let ts: Swift.String
    var permalink: Swift.String?
}
class SlackService {
    struct SlackThreadMeta {
        let teamId: Swift.String
        let channelId: Swift.String
        let threadTs: Swift.String
        let json: Swift.String
    }
    let storageKey: Swift.String
    var accounts: [Spec.SlackAccountSummary]
    var userDisplayNameCache: [Swift.String : Swift.String]
    var usersByTeam: [Swift.String : [Swift.String : Spec.SlackUserMeta]]
    var emailToUserIdByTeam: [Swift.String : [Swift.String : Swift.String]]
    var conversationsByTeam: [Swift.String : [Swift.String : Spec.SlackConversationMeta]]
    var nameToChannelIdByTeam: [Swift.String : [Swift.String : Swift.String]]
    var dmChannelByUserIdByTeam: [Swift.String : [Swift.String : Swift.String]]
    var lastUsersRefreshAt: [Swift.String : Foundation.Date]
    var lastConversationsRefreshAt: [Swift.String : Foundation.Date]
    let usersCacheTTL: Swift.Double
    let conversationsCacheTTL: Swift.Double
    let cacheDirName: Swift.String
    var lastDraftBody: Swift.String?
}
class SmartEmailFilter {}
class StartupOneShotSyncService {
    var started: Swift.Bool
}
class TelemetryService {
    var hasStarted: Swift.Bool
    let sessionId: Swift.String
}
class TodoCreationAndDraftService {
    var isRunning: Swift.Bool
    var streamCompletedFlag: Swift.Bool
    let disabled: Swift.Bool
}
class TodoManager {
    var _todos: Combine.Published<[Spec.Todo]>
    let userDefaults: __C.NSUserDefaults
    let todosKey: Swift.String
    var observers: [Any]
}
class TodoReplyRefreshService {
    var isRunning: Swift.Bool
    var streamCompletedFlag: Swift.Bool
    let disabled: Swift.Bool
}
class TodosAuditService {
    var isRunning: Swift.Bool
    var streamCompletedFlag: Swift.Bool
}
class TodosBackgroundService {
    let phaseKey: Swift.String
    let inFlightKey: Swift.String
    let disabled: Swift.Bool
}
class TodosMigrationService {
    let migrationKey: Swift.String
}
class TodosResponseBackgroundService {
    let disabled: Swift.Bool
    var slackNameCache: [Swift.String : Swift.String]
}
enum BackupError {
    case invalidJSONData(Swift.String)
    case noBackupFound(Swift.String)
    case invalidFileFormat(Swift.String)
    case missingRequiredData(Swift.String)
}
class UserDataBackupService {
    let backupPrefix: Swift.String
    let phase1Keys: [Swift.String]
    let phase2Keys: [Swift.String]
    let additionalKeys: [Swift.String]
}
enum UserDefaultsInstrumentation {}
enum UserDefaultsSanitizer {}
class UserDocumentService {
    var hasStarted: Swift.Bool
    var lastActivityUpdate: Foundation.Date?
    let activityUpdateInterval: Swift.Double
    let userDocInitializedKey: Swift.String
}
struct TimerState {
    let startTime: Foundation.Date
    let duration: Swift.Double
    let sessionId: Swift.String
}
enum BrowserActionExecutor {}
enum CalendarActionExecutor {}
enum CommunicationActionExecutor {}
enum DataActionExecutor {}
class XMonitoringService {
    struct MonitoringStatus {
        let isRunning: Swift.Bool
        let lastMentionCheck: Foundation.Date?
        let lastDMCheck: Foundation.Date?
        let processedMentionCount: Swift.Int
        let processedDMCount: Swift.Int
    }
    let defaultMonitoringInterval: Swift.Double
    var monitoringTimer: __C.NSTimer?
    var lastMentionCheck: Foundation.Date?
    var lastDMCheck: Foundation.Date?
    var processedMentionIds: Swift.Set<Swift.String>
    var processedDMIds: Swift.Set<Swift.String>
}
enum FileActionExecutor {}
class FailureHandler {}
class ExecutionContext {
    let task: Spec.SpecTask
    var setStatusById: [Swift.String : Spec.ActionSetStatus]
    var outputsByActionId: [Swift.String : Spec.JSONValue]
}
class DraftAvatarResolver {
    let workQueue: __C.NSOperationQueue
    let cache: __C.NSCache<__C.NSString, __C.NSString>
    var inFlight: [Swift.String : [(_: Swift.String?) -> ()]]
    let lock: __C.NSLock
}
enum XFeatureGate {}
struct DraftMessagesReplyPreviewView {
    let contactName: Swift.String
    let contactNumber: Swift.String?
    let chatGuid: Swift.String?
    let initialMessage: Swift.String
    let context: Swift.String
    var _messageText: SwiftUI.State<Swift.String>
    let onSend: (Swift.String, Swift.Bool) -> ()
    let onCancel: () -> ()
    var _isBodyFocused: SwiftUI.FocusState<Swift.Bool>
    var _showSendConfirmation: SwiftUI.State<Swift.Bool>
    var _isExpanded: SwiftUI.State<Swift.Bool>
    var _isLoadingHistory: SwiftUI.State<Swift.Bool>
    var _didLoadHistory: SwiftUI.State<Swift.Bool>
    var _recentMessages: SwiftUI.State<[Spec.Message]>
    var _processedMessages: SwiftUI.State<[(message: Spec.Message, reactions: [Swift.String])]>
    var _currentMessageLimit: SwiftUI.State<Swift.Int>
    var _canLoadMore: SwiftUI.State<Swift.Bool>
    let contactInfo: [Swift.String : Any]?
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _avatarImageRef: SwiftUI.Binding<Swift.String?>
}
class TaskExecutor {}
class ActionLogger {}
enum LogFormatter {}
enum ActionExecutor {
    case spec
    case user
}
enum ActionStatus {
    case pending
    case running
    case succeeded
    case failed
    case skipped
    case timeout
}
struct RetryPolicy {
    enum Backoff {
        case fixed
        case exponential
    }
    enum CodingKeys {
        case maxAttempts
        case backoff
        case delaySeconds
    }
    var maxAttempts: Swift.Int
    var backoff: Spec.RetryPolicy.Backoff
    var delaySeconds: Swift.Double
}
struct ActionResult {
    enum CodingKeys {
        case output
        case errorMessage
        case startedAt
        case finishedAt
        case durationMs
    }
    var output: Spec.JSONValue?
    var errorMessage: Swift.String?
    var startedAt: Foundation.Date?
    var finishedAt: Foundation.Date?
    var durationMs: Swift.Int?
}
struct Action {
    enum CodingKeys {
        case actionId
        case actionType
        case parameters
        case executor
        case timingDelaySeconds
        case retryPolicy
        case timeoutSeconds
        case status
        case result
    }
    let actionId: Swift.String
    var actionType: Spec.ActionType
    var parameters: [Swift.String : Spec.JSONValue]
    var executor: Spec.ActionExecutor
    var timingDelaySeconds: Swift.Double?
    var retryPolicy: Spec.RetryPolicy?
    var timeoutSeconds: Swift.Double?
    var status: Spec.ActionStatus
    var result: Spec.ActionResult?
}
struct ActionSet {
    enum CodingKeys {
        case setId
        case name
        case actions
        case executionTiming
        case dependsOn
        case status
    }
    let setId: Swift.String
    var name: Swift.String
    var actions: [Spec.Action]
    var executionTiming: Spec.ExecutionTiming
    var dependsOn: [Spec.DependencyCondition]?
    var status: Spec.ActionSetStatus
}
enum ActionType {
    enum CodingKeys {
        case kind
        case definition
        case parameters
        case seconds
        case prompt
        case inputType
        case instruction
        case taskId
    }
    enum Kind {
        case functionCall
        case wait
        case requestUserInput
        case userManualAction
        case triggerTask
    }
    case functionCall(definition: Swift.String, parameters: [Swift.String : Spec.JSONValue])
    case wait(seconds: Swift.Double)
    case requestUserInput(prompt: Swift.String, inputType: Swift.String?)
    case userManualAction(instruction: Swift.String)
    case triggerTask(taskId: Swift.String)
}
enum ExecutionStatus {
    case running
    case succeeded
    case failed
    case cancelled
    case partial
}
struct ExecutionLog {
    enum CodingKeys {
        case logId
        case taskId
        case executionStart
        case executionEnd
        case actionSetLogs
        case overallStatus
    }
    let logId: Swift.String
    let taskId: Swift.String
    let executionStart: Foundation.Date
    var executionEnd: Foundation.Date?
    var actionSetLogs: [Spec.ActionSetLog]
    var overallStatus: Spec.ExecutionStatus
}
struct ActionSetLog {
    enum CodingKeys {
        case setId
        case name
        case status
        case startedAt
        case finishedAt
        case actionLogs
    }
    let setId: Swift.String
    var name: Swift.String
    var status: Spec.ActionSetStatus
    var startedAt: Foundation.Date?
    var finishedAt: Foundation.Date?
    var actionLogs: [Spec.ActionLog]
}
struct ActionLog {
    enum CodingKeys {
        case actionId
        case actionType
        case parameters
        case executor
        case status
        case startedAt
        case finishedAt
        case durationMs
        case output
        case errorMessage
    }
    let actionId: Swift.String
    var actionType: Swift.String
    var parameters: [Swift.String : Spec.JSONValue]
    var executor: Spec.ActionExecutor
    var status: Spec.ActionStatus
    var startedAt: Foundation.Date?
    var finishedAt: Foundation.Date?
    var durationMs: Swift.Int?
    var output: Spec.JSONValue?
    var errorMessage: Swift.String?
}
enum JSONValue {
    case string(Swift.String)
    case int(Swift.Int)
    case double(Swift.Double)
    case bool(Swift.Bool)
    case array([Spec.JSONValue])
    case object([Swift.String : Spec.JSONValue])
    case null
}
struct SpecTask {
    enum CodingKeys {
        case taskId
        case title
        case description
        case createdAt
        case schedule
        case actionSets
        case notifyOnCompletion
        case notifyOnFailure
        case isActive
        case lastExecution
        case nextExecution
    }
    let taskId: Swift.String
    var title: Swift.String
    var description: Swift.String?
    var createdAt: Foundation.Date
    var schedule: Spec.TaskSchedule
    var actionSets: [Spec.ActionSet]
    var notifyOnCompletion: Swift.Bool
    var notifyOnFailure: Swift.Bool
    var isActive: Swift.Bool
    var lastExecution: Foundation.Date?
    var nextExecution: Foundation.Date?
}
struct TaskSchedule {
    enum CodingKeys {
        case timeZoneIdentifier
        case startAt
        case recurrence
        case end
        case jitterSeconds
        case skipIfRunning
        case catchUpOnMissedRuns
        case nextFire
    }
    var timeZoneIdentifier: Swift.String
    var startAt: Foundation.Date?
    var recurrence: Spec.RecurrenceRule?
    var end: Spec.RecurrenceEnd?
    var jitterSeconds: Swift.Double?
    var skipIfRunning: Swift.Bool
    var catchUpOnMissedRuns: Swift.Bool
    var nextFire: Foundation.Date?
}
struct RecurrenceRule {
    enum Frequency {
        case daily
        case weekly
        case monthly
    }
    enum CodingKeys {
        case frequency
        case interval
        case byWeekday
        case byMonthday
    }
    var frequency: Spec.RecurrenceRule.Frequency
    var interval: Swift.Int
    var byWeekday: [Swift.Int]?
    var byMonthday: [Swift.Int]?
}
struct RecurrenceEnd {
    enum CodingKeys {
        case until
        case count
    }
    var until: Foundation.Date?
    var count: Swift.Int?
}
enum ActionSetStatus {
    case pending
    case scheduled
    case running
    case succeeded
    case failed
    case skipped
}
struct DependencyCondition {
    enum OnStatus {
        case succeeded
        case failed
    }
    enum CodingKeys {
        case dependsOnSetId
        case onStatus
    }
    var dependsOnSetId: Swift.String
    var onStatus: Spec.DependencyCondition.OnStatus
}
enum ExecutionTiming {
    enum CodingKeys {
        case kind
        case seconds
    }
    enum Kind {
        case immediate
        case delay
        case conditional
    }
    case delay(seconds: Swift.Double)
    case immediate
    case conditional
}
class TaskScheduler {
    var timers: [Swift.String : __C.OS_dispatch_source_timer]
    var runningTasks: Swift.Set<Swift.String>
}
class ExecutionLogManager {
    let fm: __C.NSFileManager
}
class TaskStorageManager {
    let fm: __C.NSFileManager
}
enum AIAPIKeys {}
enum AIProxyConfig {
    struct Service {
        let partialKey: Swift.String
        let serviceURL: Swift.String
    }
}
enum AppRelauncher {}
enum ContactsPermissionHelper {}
class DeviceInfoUtils {}
struct MessagesResponse {
    let success: Swift.Bool
    let messages: [Spec.Message]
    let message: Swift.String
    let executionTimeMs: Swift.Int
}
struct DraftResponse {
    let success: Swift.Bool
    let message: Swift.String
    let contactInfo: [Swift.String : Any]?
    let threadId: Swift.String?
    let resolvedHandle: Swift.String?
    let draftContent: Swift.String?
}
struct SendResponse {
    let success: Swift.Bool
    let message: Swift.String
}
struct FindContactResponse {
    let success: Swift.Bool
    let contacts: [Spec.Contact]
    let message: Swift.String
}
struct Contact {
    let name: Swift.String
    let handle: Swift.String
    let type: Swift.String
    let isRecent: Swift.Bool
    let chatGuid: Swift.String?
}
struct RecentConversationsResponse {
    let success: Swift.Bool
    let conversations: [Spec.RecentConversation]
    let message: Swift.String
    let executionTimeMs: Swift.Int
}
struct RecentConversation {
    let chatGuid: Swift.String
    let displayName: Swift.String?
    let participants: [Spec.ConversationParticipant]
    let messages: [Spec.Message]
    let lastMessageDate: Foundation.Date
    let lastMessageFromUser: Swift.Bool
    let totalMessageCount: Swift.Int
}
struct ConversationParticipant {
    let handle: Swift.String
    let name: Swift.String
    let personCentricId: Swift.String?
}
struct AttachmentInfo {
    let id: Swift.Int
    let guid: Swift.String?
    let filename: Swift.String
    let uti: Swift.String?
    let mimeType: Swift.String?
    let transferName: Swift.String?
    let totalBytes: Swift.Int?
}
struct FindChatResponse {
    let success: Swift.Bool
    let message: Swift.String
    let chat: Spec.ChatMatch?
}
struct ChatMatch {
    let chatGuid: Swift.String
    let handle: Swift.String
    let contactName: Swift.String
    let messageCount: Swift.Int
    let lastMessageDate: Foundation.Date
    let matchConfidence: Swift.Double
    let matchReason: Swift.String
}
enum MessagesError {
    case permissionDenied(message: Swift.String)
    case databaseConnectionFailed
    case queryPreparationFailed
    case chatNotFound
    case databaseBusy
}
struct Message {
    let guid: Swift.String?
    let text: Swift.String
    let isFromMe: Swift.Bool
    let date: Foundation.Date
    let handleId: Swift.String?
    let attachmentFilename: Swift.String?
    let _sender: Swift.String?
    let contactId: Swift.Int?
    let chatGuid: Swift.String?
    let isGroupChat: Swift.Bool
    let groupName: Swift.String?
}
class DirectMessagesManager {
    struct ContactHandle {
        let handle: Swift.String
        let contactName: Swift.String
        let score: Swift.Double
        let isExact: Swift.Bool
    }
    let messagesDBPath: Swift.String
    let contactStore: __C.CNContactStore
    let queue: __C.OS_dispatch_queue
    let nicknameMapping: [Swift.String : [Swift.String]]
}
enum GodMode {}
enum LLMUserContext {}
enum MessageDBParser {}
class MessagesAdapter {}
enum MessagesAdapterError {
    case unknownCommand(Swift.String)
    case missingParameter(Swift.String)
    case groupChatsNotImplemented
}
class ProfileBuildingDiagnostics {}
class ProfileBuildLogger {
    enum LogLevel {
        case critical
        case info
        case debug
    }
    var logFileURL: Foundation.URL?
    var logFileHandle: __C.NSFileHandle?
    let queue: __C.OS_dispatch_queue
    var sessionStartTime: Foundation.Date?
    var contactsCountCache: (value: Swift.Int, timestamp: Foundation.Date)?
    let contactsCountTTL: Swift.Double
    var llmObserversInstalled: Swift.Bool
    var isSessionActive: Swift.Bool
}
struct DraftsPlatformPageView {
    let allDrafts: (messages: [Spec.DraftListItem], gmail: [Spec.DraftListItem], slack: [Spec.DraftListItem], x: [Spec.DraftListItem])
    var _selectedMessagesDraft: SwiftUI.Binding<Swift.String?>
    var _selectedGmailDraft: SwiftUI.Binding<Swift.String?>
    var _selectedSlackDraft: SwiftUI.Binding<Swift.String?>
    var _selectedXDraft: SwiftUI.Binding<Swift.String?>
    let messagesDetailView: (_: Spec.DraftListItem) -> SwiftUI.AnyView
    let gmailDetailView: (_: Spec.DraftListItem) -> SwiftUI.AnyView
    let slackDetailView: (_: Spec.DraftListItem) -> SwiftUI.AnyView
    let xdmDetailView: (_: Spec.DraftListItem) -> SwiftUI.AnyView
    var _selectedDraftsPage: SwiftUI.Binding<Swift.Int>
    let draftCounts: (messages: Swift.Int, gmail: Swift.Int, slack: Swift.Int, x: Swift.Int)
}
class TrackpadHapticGenerator {
    let performer: __C.NSHapticFeedbackPerformer
}
class WhatsAppAdapter {}
enum WhatsAppAdapterError {
    case unknownCommand(Swift.String)
    case missingParameter(Swift.String)
    case whatsAppNotInstalled
}
class WhatsAppDetection {}
struct WhatsAppMessagesResponse {
    let success: Swift.Bool
    let messages: [Spec.WhatsAppMessage]
    let message: Swift.String
    let executionTimeMs: Swift.Int
}
struct WhatsAppDraftResponse {
    let success: Swift.Bool
    let message: Swift.String
    let contactInfo: [Swift.String : Any]?
    let threadId: Swift.String?
    let resolvedHandle: Swift.String?
    let draftContent: Swift.String?
}
struct WhatsAppSendResponse {
    let success: Swift.Bool
    let message: Swift.String
}
struct WhatsAppFindContactResponse {
    let success: Swift.Bool
    let contacts: [Spec.WhatsAppContact]
    let message: Swift.String
}
struct WhatsAppContact {
    let name: Swift.String
    let handle: Swift.String
    let type: Swift.String
    let isRecent: Swift.Bool
    let chatGuid: Swift.String?
}
struct WhatsAppRecentConversationsResponse {
    let success: Swift.Bool
    let conversations: [Spec.WhatsAppRecentConversation]
    let message: Swift.String
    let executionTimeMs: Swift.Int
}
struct WhatsAppRecentConversation {
    let chatGuid: Swift.String
    let displayName: Swift.String?
    let participants: [Spec.WhatsAppConversationParticipant]
    let messages: [Spec.WhatsAppMessage]
    let lastMessageDate: Foundation.Date
    let lastMessageFromUser: Swift.Bool
    let totalMessageCount: Swift.Int
}
struct WhatsAppConversationParticipant {
    let handle: Swift.String
    let name: Swift.String
    let personCentricId: Swift.String?
}
struct WhatsAppFindChatResponse {
    let success: Swift.Bool
    let message: Swift.String
    let chat: Spec.WhatsAppChatMatch?
}
struct WhatsAppChatMatch {
    let chatGuid: Swift.String
    let handle: Swift.String
    let contactName: Swift.String
    let messageCount: Swift.Int
    let lastMessageDate: Foundation.Date
    let matchConfidence: Swift.Double
    let matchReason: Swift.String
}
enum WhatsAppError {
    case databaseConnectionFailed
    case queryPreparationFailed
    case chatNotFound
    case whatsAppNotInstalled
    case permissionDenied
}
struct WhatsAppMessage {
    let guid: Swift.String?
    let text: Swift.String
    let isFromMe: Swift.Bool
    let date: Foundation.Date
    let handleId: Swift.String?
    let attachmentFilename: Swift.String?
    let _sender: Swift.String?
    let contactId: Swift.Int?
}
class WhatsAppManager {
    let whatsAppDBPath: Swift.String
    let whatsAppMediaPath: Swift.String
    let whatsAppLegacyDBPath: Swift.String
    let whatsAppDesktopPath: Swift.String
    let contactStore: __C.CNContactStore
    let queue: __C.OS_dispatch_queue
    let nicknameMapping: [Swift.String : [Swift.String]]
}
struct ContactHandle {
    let handle: Swift.String
    let contactName: Swift.String
    let score: Swift.Double
    let isExact: Swift.Bool
}
struct WrappingFlowLayout {
    var spacing: CoreGraphics.CGFloat
}
struct IncrementalProfileBuilderView {
    var _profileBuilder: SwiftUI.StateObject<Spec.UserProfileBuilderService>
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
}
struct ProcessingVisualization {
    let phase: Swift.String
    let progress: Swift.Double
}
struct PhaseIndicator {
    let name: Swift.String
    let icon: Swift.String
    let isActive: Swift.Bool
    let isComplete: Swift.Bool
}
struct FeatureRow {
    let icon: Swift.String
    let title: Swift.String
    let description: Swift.String
}
struct AIAction {
    struct ToolUse {
        let id: Swift.String
        let name: Swift.String
        let inputDisplay: Swift.String
    }
    let id: Foundation.UUID
    var description: Swift.String
    var response: Swift.String?
    var isCompleted: Swift.Bool
    var isError: Swift.Bool
    var requiresResponse: Swift.Bool
    var suggestUserTakeover: Swift.String?
    var isUserMessage: Swift.Bool
    var commandString: Swift.String?
    var toolUse: Spec.AIAction.ToolUse?
    var toolInput: Swift.String?
    var toolResponse: Swift.String?
    var attachments: [Spec.Attachment]?
    var thinkingText: Swift.String?
    var thinkingDurationSeconds: Swift.Double?
    var thinkingStartTime: Foundation.Date?
    var isThinkingStreaming: Swift.Bool
}
struct Attachment {
    let id: Foundation.UUID
    let url: Foundation.URL
    let isImage: Swift.Bool
    let title: Swift.String
    let fileType: Swift.String
}
struct ANSIParser {
    struct Attributes {
        var foreground: __C.NSColor
        var background: __C.NSColor
        var isBold: Swift.Bool
        var isUnderline: Swift.Bool
    }
    let colorTable: [Swift.Int : __C.NSColor]
}
struct AnthropicOverloadedToastView {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    let onDismiss: () -> ()
}
struct AppleIntelligenceTestView {
    var _viewModel: SwiftUI.StateObject<Spec.AppleIntelligenceTestViewModel>
}
struct $s4Spec0036AppleIntelligenceTestViewswift_tjBBlfMX342_0_33_2C5BFA3853141A4DEA4FE53924BBF36BLl7PreviewfMf_15PreviewRegistryfMu_ {}
class AppleIntelligenceTestViewModel {
    let service: Spec.AppleIntelligenceService
    var _systemPrompt: Combine.Published<Swift.String>
    var _userMessage: Combine.Published<Swift.String>
    var _output: Combine.Published<Swift.String>
    var _isProcessing: Combine.Published<Swift.Bool>
    var _errorMessage: Combine.Published<Swift.String?>
    var _errorRecoverySuggestion: Combine.Published<Swift.String?>
    var _availableModels: Combine.Published<[Spec.AppleIntelligenceService.AvailableModel]>
    var _selectedModelId: Combine.Published<Swift.String?>
    var _isSupported: Combine.Published<Swift.Bool>
    var _systemVersion: Combine.Published<Swift.String>
    var _statusMessage: Combine.Published<Swift.String>
    var _useStreaming: Combine.Published<Swift.Bool>
    var _enablePrewarming: Combine.Published<Swift.Bool>
    var _isPrewarmed: Combine.Published<Swift.Bool>
    var _lastResponseTime: Combine.Published<Swift.Double>
    var _outputCharacterCount: Combine.Published<Swift.Int>
    var _outputWordCount: Combine.Published<Swift.Int>
}
enum OnboardingProgressKey {}
actor InFlightBatchRegistry {
    var $defaultActor: 
    var keys: Swift.Set<Swift.String>
    var lastStartAt: [Swift.String : Foundation.Date]
}
actor ProfileBuildCoordinator {
    var $defaultActor: 
    var isRunning: Swift.Bool
}
enum ProfileBuildingStage {
    case preparing
    case collectingMessages
    case collectingGmail
    case collectingWhatsApp
    case collectingChrome
    case collectingGranola
    case collectingNotion
    case collectingAppleNotes
    case collectingReminders
    case collectingScreenTime
    case analyzingData
    case buildingProfile
    case savingProfile
    case buildingStreams
    case complete
}
struct AutomaticProfileBuilder {
    var _profileBuilderService: SwiftUI.StateObject<Spec.UserProfileBuilderService>
    var _auth: SwiftUI.EnvironmentObject<Spec.AuthViewModel>
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    let onComplete: () -> ()
    var _currentStage: SwiftUI.State<Spec.ProfileBuildingStage>
    var _progress: SwiftUI.State<Swift.Double>
    var _errorMessage: SwiftUI.State<Swift.String>
    var _hasError: SwiftUI.State<Swift.Bool>
    var _completedStages: SwiftUI.State<Swift.Set<Spec.ProfileBuildingStage>>
    var _statusMessage: SwiftUI.State<Swift.String>
    var _isComplete: SwiftUI.State<Swift.Bool>
    var _profileJSON: SwiftUI.State<Swift.String>
    var _isBuildingNow: SwiftUI.State<Swift.Bool>
    var _messagesCount: SwiftUI.State<Swift.Int>
    var _messagesAnalyzed: SwiftUI.State<Swift.Int>
    var _gmailCount: SwiftUI.State<Swift.Int>
    var _totalDataPoints: SwiftUI.State<Swift.Int>
    var _realTimeDataPoints: SwiftUI.State<Swift.Int>
    var _realTimeContacts: SwiftUI.State<Swift.Int>
    var _realTimeEvents: SwiftUI.State<Swift.Int>
    var _realTimeMessages: SwiftUI.State<Swift.Int>
    var _realTimeEmails: SwiftUI.State<Swift.Int>
    var _currentBatchNumber: SwiftUI.State<Swift.Int>
    var _totalBatchesEstimate: SwiftUI.State<Swift.Int>
    var _saveErrors: SwiftUI.State<[Swift.String]>
    var _lastSaveTime: SwiftUI.State<Foundation.Date?>
    var _includeGmail: SwiftUI.State<Swift.Bool>
    var _includeWhatsApp: SwiftUI.State<Swift.Bool>
    var _includeChrome: SwiftUI.State<Swift.Bool>
    var _includeGranola: SwiftUI.State<Swift.Bool>
    var _includeQuill: SwiftUI.State<Swift.Bool>
    var _includeNotion: SwiftUI.State<Swift.Bool>
    var _includeAppleNotes: SwiftUI.State<Swift.Bool>
    var _includeReminders: SwiftUI.State<Swift.Bool>
    var _includeScreenTime: SwiftUI.State<Swift.Bool>
    var _chromeDaysBack: SwiftUI.State<Swift.Int>
    var _granolaDaysBack: SwiftUI.State<Swift.Int>
    var _quillDaysBack: SwiftUI.State<Swift.Int>
    var _notionDaysBack: SwiftUI.State<Swift.Int>
    var _appleNotesDaysBack: SwiftUI.State<Swift.Int>
    var _includeGranolaTranscripts: SwiftUI.State<Swift.Bool>
    var _includeQuillTranscripts: SwiftUI.State<Swift.Bool>
    var _includeNotionContent: SwiftUI.State<Swift.Bool>
    var _includeAppleNotesContent: SwiftUI.State<Swift.Bool>
    var _compressChromeHistory: SwiftUI.State<Swift.Bool>
}
struct AutomaticProfileBuilder_Previews {}
class BirthdayMessagePopupModel {
    var _isVisible: Combine.Published<Swift.Bool>
}
class BirthdayMessagePopupManager {
    var window: __C.NSWindow?
    var hosting: SwiftUI.NSHostingController<Spec.BirthdayMessagePopupView>?
    var dismissWork: Dispatch.DispatchWorkItem?
    var mouseTimer: __C.NSTimer?
    var keyMonitor: Any?
    var popupSize: __C.CGSize
    let horizontalOffset: CoreGraphics.CGFloat
    let verticalOffset: CoreGraphics.CGFloat
    let model: Spec.BirthdayMessagePopupModel
}
struct BirthdayMessagePopupView {
    var _model: SwiftUI.ObservedObject<Spec.BirthdayMessagePopupModel>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct GlassOrFallback {
    let cornerRadius: CoreGraphics.CGFloat
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct TaperedTabShape {
    var cornerRadius: CoreGraphics.CGFloat
}
struct BlackTabDropdownView {
    var _message: SwiftUI.State<Swift.String>
    var _appName: SwiftUI.State<Swift.String>
    var _appIcon: SwiftUI.State<Swift.String>
    var _contactProfileImage: SwiftUI.State<__C.NSImage?>
    var _appNSImage: SwiftUI.State<__C.NSImage?>
    let onClose: () -> ()
    let onOpen: () -> ()
    var _dragOffset: SwiftUI.State<CoreGraphics.CGFloat>
    var _isDragging: SwiftUI.State<Swift.Bool>
    var _showingKeyboardHints: SwiftUI.State<Swift.Bool>
    var _progress: SwiftUI.State<Swift.Double>
    var _timer: SwiftUI.State<__C.NSTimer?>
    var _isHovering: SwiftUI.State<Swift.Bool>
    var _remainingTime: SwiftUI.State<Swift.Double>
    let totalDuration: Swift.Double
    let updateInterval: Swift.Double
}
class BlackTabWindow: __C.NSWindow {
    var mouseEventMonitor: Any?
    var keyboardEventMonitor: Any?
    var localKeyboardMonitor: Any?
}
class BlackTabWindowController: __C.NSWindowController {
    var hostingController: SwiftUI.NSHostingController<Spec.BlackTabDropdownView>?
    var cancellables: Swift.Set<Combine.AnyCancellable>
    let bodyHeight: CoreGraphics.CGFloat
    let tabWidth: CoreGraphics.CGFloat
    let animationDuration: Swift.Double
}
class BlackTabManager {
    var windowController: Spec.BlackTabWindowController?
}
class XProactiveService {
    let minEngagementDataPoints: Swift.Int
}
struct OptimalPostingTimeResult {
    let suggestedTimes: [Spec.SuggestedPostingTime]
    let confidence: Spec.AnalysisConfidence
    let analysis: Swift.String
}
struct SuggestedPostingTime {
    let hour: Swift.Int
    let dayOfWeek: Swift.Int
    let averageEngagement: Swift.Int
    let description: Swift.String
    let rank: Swift.Int
}
enum AnalysisConfidence {
    case high
    case medium
    case low
}
struct EngagementStats {
    var totalEngagement: Swift.Int
    var tweetCount: Swift.Int
}
struct EngagementInsights {
    let tweetCount: Swift.Int
    let averageLikes: Swift.Double
    let averageRetweets: Swift.Double
    let averageReplies: Swift.Double
    let averageImpressions: Swift.Double?
    let topTweet: Spec.XTweet?
    let insights: [Swift.String]
    let trendingUp: Swift.Bool
    let trendingDown: Swift.Bool
}
struct ViralStatus {
    let isViral: Swift.Bool
    let totalEngagement: Swift.Int?
    let reason: Swift.String
}
struct ThreadComposition {
    let tweets: [Swift.String]
    let totalTweets: Swift.Int
    let preview: Swift.String
}
struct ContentSuggestion {
    enum SuggestionType {
        case trendingTopic
        case engagement
        case update
        case question
    }
    let type: Spec.ContentSuggestion.SuggestionType
    let suggestion: Swift.String
    let confidence: Spec.AnalysisConfidence
}
struct NetworkAnalysis {
    let totalFollowers: Swift.Int
    let totalFollowing: Swift.Int
    let mutualConnections: Swift.Int
    let verifiedFollowers: Swift.Int
    let suggestedFollows: [Spec.XUser]
    let analysis: Swift.String
}
enum XProactiveError {
    case insufficientData
    case analysisFailled
}
struct CentralizedContactDetailView {
    let contactId: Swift.String
    var _overview: SwiftUI.State<Spec.ContactOverview?>
    var _avatarImages: SwiftUI.State<[(platform: Swift.String, image: __C.NSImage)]>
    var _isLoading: SwiftUI.State<Swift.Bool>
}
struct ContainersListView {
    let items: [Spec.ContactOverview.Container]
}
struct FlowLayoutView<A, B> where A: Swift.RandomAccessCollection, B: SwiftUI.View, A.Sequence.Element: Swift.Hashable {
    let items: A
    let content: (_: A.Sequence.Element) -> B
}
struct ChatInputField {
    var _text: SwiftUI.Binding<Swift.String>
    var placeholder: Swift.String
    var onSubmit: () -> ()
    var onAttachmentTap: (() -> ())?
    var _isHovering: SwiftUI.State<Swift.Bool>
    var _isFocused: SwiftUI.Binding<Swift.Bool>
    var _textFieldFocused: SwiftUI.FocusState<Swift.Bool>
    var _isTextFieldFocused: SwiftUI.State<Swift.Bool>
    var fontSize: CoreGraphics.CGFloat
    var verticalPadding: CoreGraphics.CGFloat
    let cornerRadius: CoreGraphics.CGFloat
    var onNewChat: (() -> ())?
    var onDragProgress: ((_: CoreGraphics.CGFloat) -> ())?
    var _isProcessing: SwiftUI.Binding<Swift.Bool>
    var _selectedReasoningEffort: SwiftUI.Binding<Spec.ReasoningEffort>
    var _actions: SwiftUI.Binding<[Spec.AIAction]>
    var onStopRequest: (() -> ())?
    var onSummarizeChat: (() -> ())?
    var onPreviousChatSelected: ((_: Swift.String) -> ())?
    var _previousChats: SwiftUI.Binding<[(id: Swift.String, title: Swift.String, icon: Swift.String)]>
    var _selectedPreviousChat: SwiftUI.State<(id: Swift.String, title: Swift.String, icon: Swift.String)?>
    var _dragTranslationY: SwiftUI.GestureState<CoreGraphics.CGFloat>
    let dragThreshold: CoreGraphics.CGFloat
    let maxDrag: CoreGraphics.CGFloat
    var _isTransitioning: SwiftUI.State<Swift.Bool>
    var _animatedOffset: SwiftUI.State<CoreGraphics.CGFloat>
    var _isPulsing: SwiftUI.State<Swift.Bool>
    var _hasTriggeredThresholdHaptic: SwiftUI.State<Swift.Bool>
    var _textHeight: SwiftUI.State<CoreGraphics.CGFloat>
    let maxHeight: CoreGraphics.CGFloat
    let minHeight: CoreGraphics.CGFloat
    var onModelChange: ((_: Spec.Model) -> ())?
    var _selectedModel: SwiftUI.State<Spec.Model>
    var _modelIcon: SwiftUI.State<Swift.String>
    var _modelDisplayName: SwiftUI.State<Swift.String>
}
class NonScrollingScrollView: __C.NSScrollView {}
class NonScrollingTextView: __C.NSTextView {}
class TransparentClipView: __C.NSClipView {}
struct MacTextEditor {
    class Coordinator: __C.NSObject {
        let parent: Spec.MacTextEditor
        weak var textView: __C.NSTextView?
        var appearanceObserver: Foundation.NSKeyValueObservation?
    }
    var _text: SwiftUI.Binding<Swift.String>
    let isProcessing: Swift.Bool
    let onSubmit: () -> ()
    var _textHeight: SwiftUI.Binding<CoreGraphics.CGFloat>
    let fontSize: CoreGraphics.CGFloat
    let horizontalPadding: CoreGraphics.CGFloat
    let verticalPadding: CoreGraphics.CGFloat
    let maxHeight: CoreGraphics.CGFloat
}
struct ChatInputExample {
    var _messageText: SwiftUI.State<Swift.String>
}
class MacPairingRequestService {
    var listener: __C.FIRListenerRegistration?
    var isListening: Swift.Bool
}
struct ChatHistoryItem {
    let id: Swift.String
    var title: Swift.String
    var preview: Swift.String
    var timestamp: Swift.String
    var iconName: Swift.String
}
struct SidebarRow {
    let item: Spec.ChatHistoryItem
    let isSelected: Swift.Bool
    let onSelect: () -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct ShareRow {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct UserProfileView {}
struct ChatSidebarView {
    let chatHistories: [Spec.ChatHistoryItem]
    let selectedThreadId: Swift.String
    var _isCollapsed: SwiftUI.Binding<Swift.Bool>
    var _sidebarOffset: SwiftUI.Binding<CoreGraphics.CGFloat>
    var isDragging: Swift.Bool
    var onNewChat: () -> ()
    var onSelectChat: (Swift.String, Swift.String, Swift.String) -> ()
    var _remoteChats: SwiftUI.State<[Spec.ChatHistoryItem]>
    var _listener: SwiftUI.State<Spec.LocalThreadService.Listener?>
    var _isLoadingMoreChats: SwiftUI.State<Swift.Bool>
    var _hasMoreChats: SwiftUI.State<Swift.Bool>
    var _lastChatCursor: SwiftUI.State<Spec.LocalPaginationCursor?>
    var _scheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _showingLogoutAlert: SwiftUI.State<Swift.Bool>
    let width: CoreGraphics.CGFloat
}
struct SpecChatHistoryItem {
    let id: Foundation.UUID
    let threadId: Swift.String
    let title: Swift.String
    let lastMessage: Swift.String
    let timestamp: Foundation.Date
    let messageCount: Swift.Int
    let iconName: Swift.String?
}
struct ChatsListView {
    var _chatHistory: SwiftUI.State<[Spec.SpecChatHistoryItem]>
    var _listener: SwiftUI.State<Spec.LocalThreadService.Listener?>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _isLoadingMore: SwiftUI.State<Swift.Bool>
    var _hasMoreChats: SwiftUI.State<Swift.Bool>
    var _lastCursor: SwiftUI.State<Spec.LocalPaginationCursor?>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var onChatSelected: ((Swift.String, Swift.String, Swift.String?) -> ())?
}
struct ChatRowView {
    let chat: Spec.SpecChatHistoryItem
    var _isHovering: SwiftUI.State<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct $s4Spec0024ChatsListViewswift_ynAHffMX395_0_33_3351E9E840B2833270E61F9394A6F554Ll7PreviewfMf_15PreviewRegistryfMu_ {}
struct CheckboxField<A> where A: SwiftUI.View {
    var _checked: SwiftUI.Binding<Swift.Bool>
    let label: A
    let size: CoreGraphics.CGFloat
    let color: SwiftUI.Color
}
struct CheckboxField_Previews {}
struct SimpleCheckboxField {
    var _checked: SwiftUI.Binding<Swift.Bool>
    let size: CoreGraphics.CGFloat
    let color: SwiftUI.Color
}
struct SimpleCheckboxField_Previews {}
struct DraftConversationRowView {
    let item: Spec.DraftListItem
    let platform: Swift.String
    let isSelected: Swift.Bool
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _resolvedImageRef: SwiftUI.State<Swift.String?>
}
struct RingShape {
    var innerRadius: CoreGraphics.CGFloat
    var outerRadius: CoreGraphics.CGFloat
}
struct CircleWithBite {
    var biteOffset: CoreGraphics.CGFloat
}
struct AnyShape {
    let _path: (_: __C.CGRect) -> SwiftUI.Path
}
struct CollapsedToolUseGroup {
    let toolUses: [Spec.GroupedToolUseRow.ToolUseInfo]
    var _activeTimers: SwiftUI.Binding<[Swift.String : Spec.TimerState]>
    let observable: Spec.MessageFunctionCallingObservable
    var _isExpanded: SwiftUI.Binding<Swift.Bool>
    var _animateExpansion: SwiftUI.State<Swift.Bool>
}
struct ContactDetailView {
    let contactId: Swift.String
    var _overview: SwiftUI.State<Spec.ContactOverview?>
    var _relationshipHistory: SwiftUI.State<[[Swift.String : Any]]>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _errorMessage: SwiftUI.State<Swift.String?>
    var _showingEditSheet: SwiftUI.State<Swift.Bool>
}
struct ContactHeaderView {
    let overview: Spec.ContactOverview
}
struct RelationshipSectionView {
    let relationshipType: Swift.String?
    let relationshipDetails: Swift.String?
    let confidence: Swift.Double?
    let history: [[Swift.String : Any]]
    let onEdit: () -> ()
    var _showingHistory: SwiftUI.State<Swift.Bool>
}
struct RelationshipHistoryView {
    let history: [[Swift.String : Any]]
}
struct ChannelMetricsSectionView {
    let channels: [Spec.ContactOverview.ChannelMetrics]
}
struct ChannelMetricRow {
    let channel: Spec.ContactOverview.ChannelMetrics
}
struct EmploymentSectionView {
    let employment: [Spec.ContactOverview.Employment]
}
struct EducationSectionView {
    let education: [Spec.ContactOverview.Education]
}
struct TopicsSectionView {
    let topics: [Spec.ContactOverview.Topic]
}
struct AddressesSectionView {
    let addresses: [Spec.ContactOverview.Address]
}
struct RelationshipEditView {
    let contactId: Swift.String
    let currentType: Swift.String?
    let currentDetails: Swift.String?
    let onSave: (Swift.String, Swift.String) -> ()
    var _selectedType: SwiftUI.State<Swift.String>
    var _details: SwiftUI.State<Swift.String>
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    let relationshipTypes: [Swift.String]
}
struct ConversationConfirmationView {
    let conversationTitle: Swift.String
    let confirmationQuestion: Swift.String
    let senderName: Swift.String
    let senderSource: Swift.String
    let senderProfileImage: SwiftUI.Image?
    let messageContent: Swift.String
    let highlightedWords: [Swift.String]
    let draftedResponse: Swift.String
    let onSend: (_: Swift.String) -> ()
    let onDetails: () -> ()
    let onDismiss: () -> ()
    var _isHoveringClose: SwiftUI.State<Swift.Bool>
    var _editableDraftedResponse: SwiftUI.State<Swift.String>
    var _isTextEditorFocused: SwiftUI.FocusState<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    let onHeightChange: ((_: CoreGraphics.CGFloat) -> ())?
}
class ConversationConfirmationWindow: __C.NSWindow {
    var keyboardEventMonitor: Any?
    var localKeyboardMonitor: Any?
}
class ConversationConfirmationWindowController: __C.NSWindowController {
    var hostingController: SwiftUI.NSHostingController<Spec.ConversationConfirmationView>?
    var cancellables: Swift.Set<Combine.AnyCancellable>
    let notificationWidth: CoreGraphics.CGFloat
    let minHeight: CoreGraphics.CGFloat
    let maxHeight: CoreGraphics.CGFloat
    let rightMargin: CoreGraphics.CGFloat
    let topMargin: CoreGraphics.CGFloat
    let animationDuration: Swift.Double
    var calculatedHeight: CoreGraphics.CGFloat
    var resizeWorkItem: Dispatch.DispatchWorkItem?
    var conversationTitle: Swift.String
    var confirmationQuestion: Swift.String
    var senderName: Swift.String
    var senderSource: Swift.String
    var senderProfileImage: SwiftUI.Image?
    var messageContent: Swift.String
    var highlightedWords: [Swift.String]
    var draftedResponse: Swift.String
    var onSend: (_: Swift.String) -> ()
    var onDetails: () -> ()
    var onDismiss: () -> ()
}
class ConversationConfirmationManager {
    var windowController: Spec.ConversationConfirmationWindowController?
    var isShowing: Swift.Bool
}
struct ConversationSummary {
    enum CodingKeys {
        case id
        case originalThreadId
        case userQuery
        case actionsTaken
        case successfulApproaches
        case failedApproaches
        case remainingActions
        case nextSteps
        case timestamp
    }
    let id: Foundation.UUID
    let originalThreadId: Swift.String
    let userQuery: Swift.String
    let actionsTaken: [Swift.String]
    let successfulApproaches: [Swift.String]
    let failedApproaches: [Swift.String]
    let remainingActions: [Swift.String]
    let nextSteps: [Swift.String]
    let timestamp: Foundation.Date
}
class CursorLogoPopupManager {
    struct Shortcut {
        let usesCommand: Swift.Bool
        let usesControl: Swift.Bool
        let usesOption: Swift.Bool
        let usesShift: Swift.Bool
        let keyToken: Swift.String
    }
    enum ActionType {
        case paste
        case open_url
        case copy_to_clipboard
        case focus_app
    }
    struct PopupAction {
        let type: Spec.CursorLogoPopupManager.ActionType
        let title: Swift.String
        let content: Swift.String
    }
    class FrameGrabber: __C.NSObject {
        let semaphore: __C.OS_dispatch_semaphore
        var image: __C.NSImage?
    }
    var window: __C.NSWindow?
    var hostingController: SwiftUI.NSHostingController<Spec.CursorLogoPopupView>?
    var mouseMonitor: Any?
    var localMouseMonitor: Any?
    var mousePollTimer: __C.NSTimer?
    var mouseEventTap: __C.CFMachPort?
    var mouseRunLoopSource: __C.CFRunLoopSource?
    let enableGlobalMouseMonitor: Swift.Bool
    let enableLocalMouseMonitor: Swift.Bool
    let enableMouseMoveEventTap: Swift.Bool
    let minPositionOriginUpdateInterval: Swift.Double
    var lastPositionOriginUpdateAt: Swift.Double
    var lastRoundedAnchor: __C.CGPoint
    var lastAppliedSize: __C.CGSize
    var lastOverlayUpdateAt: Swift.Double
    let minOverlayUpdateInterval: Swift.Double
    var activeActions: [Swift.String : Spec.CursorLogoPopupManager.PopupAction]
    var typingEventTap: __C.CFMachPort?
    var typingRunLoopSource: __C.CFRunLoopSource?
    var typingTapPaused: Swift.Bool
    var tapHealthTimer: __C.NSTimer?
    var visibleContentWidth: CoreGraphics.CGFloat
    var dismissWorkItem: Dispatch.DispatchWorkItem?
    var localKeyMonitor: Any?
    var globalKeyMonitor: Any?
    var pillExpanded: Swift.Bool
    var foregroundApp: (name: Swift.String, icon: __C.NSImage)?
    let viewModel: Spec.CursorLogoPopupViewModel
    var transcriptText: Swift.String
    var overlayWindow: __C.NSWindow?
    var strokeView: Spec.StrokeOverlayView?
    var flagsMonitor: Any?
    var isOptionHeld: Swift.Bool
    var mouseDrawEventTap: __C.CFMachPort?
    var mouseDrawRunLoopSource: __C.CFRunLoopSource?
    var appResignObserver: Any?
    var appBecomeObserver: Any?
    var flagsPollTimer: __C.NSTimer?
    var optionChangeWork: Dispatch.DispatchWorkItem?
    let optionDebounceDuration: Swift.Double
    var optionArmedForDrawing: Swift.Bool
    var drawingSessionActive: Swift.Bool
    var overlayShownAt: Swift.Double?
    let overlayOptionUpGrace: Swift.Double
    let enableInternalMessagesMonitor: Swift.Bool
    var messagesMonitorTimer: __C.NSTimer?
    var lastMessagesChatTitle: Swift.String?
    var lastMessagesPreviewTitle: Swift.String?
    var lastMessagesPreviewShownAt: Swift.Double
    var lastFrontmostBundleId: Swift.String?
    var frontmostAppObserver: Any?
    var shownTodoIdsThisSession: Swift.Set<Swift.String>
    var currentPreviewTodoId: Swift.String?
    var selectionPollTimer: __C.NSTimer?
    var capturedSelectedText: Swift.String?
    var hadSelectionOnOpen: Swift.Bool
    var loggedChromeTabsForCurrentPopup: Swift.Bool
    var streamTopAnchorY: CoreGraphics.CGFloat?
    var suppressStreamingUntilNextPopupSubmit: Swift.Bool
    var popupObservable: Spec.MessageFunctionCallingObservable?
    var pillWidth: CoreGraphics.CGFloat
    var currentWindowSize: __C.CGSize
    let compactWindowSize: __C.CGSize
    let horizontalOffset: CoreGraphics.CGFloat
    let verticalOffset: CoreGraphics.CGFloat
}
class CursorLogoPopupViewModel {
    var _isVisible: Combine.Published<Swift.Bool>
    var _hasSelection: Combine.Published<Swift.Bool>
    var _isThinking: Combine.Published<Swift.Bool>
    var _activeToolName: Combine.Published<Swift.String?>
    var _showThinkingIcon: Combine.Published<Swift.Bool>
    var _showToolIcon: Combine.Published<Swift.Bool>
    var _initialSelectedText: Combine.Published<Swift.String?>
}
struct CursorLogoPopupView {
    struct Holder {}
    var _model: SwiftUI.ObservedObject<Spec.CursorLogoPopupViewModel>
    var _chatRegistry: SwiftUI.ObservedObject<Spec.GlobalChatRegistry>
    var _streamPulse: SwiftUI.State<Swift.Bool>
    var _isStreaming: SwiftUI.State<Swift.Bool>
    var _peakStreamingHeight: SwiftUI.State<CoreGraphics.CGFloat>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _scale: SwiftUI.State<CoreGraphics.CGFloat>
    var _isPill: SwiftUI.State<Swift.Bool>
    var _bgWidth: SwiftUI.State<CoreGraphics.CGFloat>
    var _revealWidth: SwiftUI.State<CoreGraphics.CGFloat>
    var _minTypingWidth: SwiftUI.State<CoreGraphics.CGFloat>
    var _appName: SwiftUI.State<Swift.String>
    var _appIcon: SwiftUI.State<__C.NSImage?>
    var _inputText: SwiftUI.State<Swift.String>
    var _transcript: SwiftUI.State<Swift.String>
    let transcriptProvider: () -> Swift.String
    var _overlayContentHeight: SwiftUI.State<CoreGraphics.CGFloat>
    var _displayedHeight: SwiftUI.State<CoreGraphics.CGFloat>
    let chatMaxHeight: CoreGraphics.CGFloat
    var _isInputFocused: SwiftUI.FocusState<Swift.Bool>
    var _isEditing: SwiftUI.State<Swift.Bool>
    var _selectionBadgeWidth: SwiftUI.State<CoreGraphics.CGFloat>
    var _didAutoExpandWidthForStream: SwiftUI.State<Swift.Bool>
    var _isDraftPreviewActive: SwiftUI.State<Swift.Bool>
    var _activeDraftKind: SwiftUI.State<Swift.String?>
    var _textFieldResetId: SwiftUI.State<Foundation.UUID>
}
struct DraftSendButton {
    let kind: Swift.String
    let onSend: () -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct PopupTranscriptView {
    let text: Swift.String
    var plain: Swift.Bool
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct SelectedTextBadge {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
class StrokeOverlayView: __C.NSView {
    var currentShapeLayer: __C.CAShapeLayer?
    var currentCGPath: __C.CGMutablePath?
    var strokeLayers: [__C.CAShapeLayer]
    var lineWidth: CoreGraphics.CGFloat
    var lineColor: __C.NSColor
    var debugTintAlpha: CoreGraphics.CGFloat
}
struct MiniVisualEffectView {
    let material: __C.Material
    let blendingMode: __C.BlendingMode
}
struct LiquidGlassBackground {
    let cornerRadius: CoreGraphics.CGFloat
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
class CursorLogoPopupStagedManager {
    var window: __C.NSWindow?
    var hostingController: SwiftUI.NSHostingController<Spec.CursorLogoPopupStagedView>?
    var dismissWorkItem: Dispatch.DispatchWorkItem?
}
struct CursorLogoPopupStagedView {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _message: SwiftUI.State<Swift.String>
    var _scale: SwiftUI.State<CoreGraphics.CGFloat>
    var _opacity: SwiftUI.State<Swift.Double>
}
class CursorPopupWindow: __C.NSWindow {}
struct DarkBlurEffectView {}
struct DraftedActionDetailView {
    let title: Swift.String
    let content: Swift.String
    let onDismiss: (() -> ())?
    let onCreateNotionPage: (() -> ())?
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct DraftedActionDetailView_Previews {}
class DraftingRepliesPopupModel {
    var _isVisible: Combine.Published<Swift.Bool>
    var _showGmailIcon: Combine.Published<Swift.Bool>
    var _showSlackIcon: Combine.Published<Swift.Bool>
    var _scale: Combine.Published<CoreGraphics.CGFloat>
}
class DraftingRepliesPopupManager {
    var window: __C.NSWindow?
    var hosting: SwiftUI.NSHostingController<Spec.DraftingRepliesPopupView>?
    var dismissWork: Dispatch.DispatchWorkItem?
    var mouseTimer: __C.NSTimer?
    var keyMonitor: Any?
    var popupSize: __C.CGSize
    let horizontalOffset: CoreGraphics.CGFloat
    let verticalOffset: CoreGraphics.CGFloat
    let model: Spec.DraftingRepliesPopupModel
}
struct DraftingRepliesPopupView {
    var _model: SwiftUI.ObservedObject<Spec.DraftingRepliesPopupModel>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct Effect {
    var gradientStops: [SwiftUI.Gradient.Stop]
    var width: CoreGraphics.CGFloat
    var blur: CoreGraphics.CGFloat
    var cornerRadius: CoreGraphics.CGFloat
}
struct EffectNoBlur {
    var gradientStops: [SwiftUI.Gradient.Stop]
    var width: CoreGraphics.CGFloat
    var cornerRadius: CoreGraphics.CGFloat
}
struct EmailReplyPreviewView {
    let from: Swift.String
    let to: Swift.String
    let subject: Swift.String
    let cc: Swift.String?
    var _bodyString: SwiftUI.State<Swift.String>
    let onSend: (Swift.String, Swift.Bool) -> ()
    let onCancel: () -> ()
    var _isBodyFocused: SwiftUI.FocusState<Swift.Bool>
    var _showSendConfirmation: SwiftUI.State<Swift.Bool>
    var _isExpanded: SwiftUI.State<Swift.Bool>
    var _didLoadContact: SwiftUI.State<Swift.Bool>
    var _toResolvedName: SwiftUI.State<Swift.String?>
    var _toPhotoBase64: SwiftUI.State<Swift.String?>
}
struct EnhancedEmailDraftCard {
    struct GmailThreadMessage {
        let id: Swift.String
        let from: Swift.String
        let fromEmail: Swift.String
        let snippet: Swift.String
        let date: Swift.String
        var photoBase64: Swift.String?
    }
    let item: Spec.DraftListItem
    let observable: Spec.MessageFunctionCallingObservable?
    let onSkip: () -> ()
    let onSend: (_: Swift.String) -> ()
    var _threadMessages: SwiftUI.State<[Spec.EnhancedEmailDraftCard.GmailThreadMessage]>
    var _isLoadingThread: SwiftUI.State<Swift.Bool>
    var _bodyText: SwiftUI.State<Swift.String>
    var _toField: SwiftUI.State<Swift.String>
    var _ccField: SwiftUI.State<Swift.String>
    var _bccField: SwiftUI.State<Swift.String>
    var _subjectField: SwiftUI.State<Swift.String>
    var _isThreadExpanded: SwiftUI.State<Swift.Bool>
    var _isHeadersExpanded: SwiftUI.State<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct EventDetailView {
    let event: Spec.SpecEvent
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct EventFullScreenDetailView {
    let event: Spec.SpecEvent
    var onDismiss: (() -> ())?
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct FlowingGradientBackground {
    var _animate: SwiftUI.State<Swift.Bool>
    let colours: [SwiftUI.Color]
}
struct FocusedTextFieldNS {
    class Coordinator: __C.NSObject {
        var parent: Spec.FocusedTextFieldNS
        var prevBecomeFirstResponder: Swift.Bool
        var didRequestFocus: Swift.Bool
        var cancellable: Any?
        var caret: Swift.Int
        var selectionRange: __C._NSRange
        var showCaret: Swift.Bool
        weak var overlay: Spec.FocusedTextFieldNS.CaretOverlayView?
    }
    class CaretOverlayView: __C.NSView {
        var text: Swift.String
        var caret: Swift.Int
        var selection: __C._NSRange
        var showCaret: Swift.Bool
        var font: __C.NSFont
        var caretTimer: __C.NSTimer?
        var caretOn: Swift.Bool
    }
    var _text: SwiftUI.Binding<Swift.String>
    var placeholder: Swift.String
    var becomeFirstResponder: Swift.Bool
    var editable: Swift.Bool
    var onChanged: (_: Swift.String) -> ()
}
class MessageCommitmentTestViewModel {
    let dm: Spec.DirectMessagesManager
    let ai: Spec.AppleIntelligenceService
    var _searchText: Combine.Published<Swift.String>
    var _contacts: Combine.Published<[Spec.Contact]>
    var _isSearching: Combine.Published<Swift.Bool>
    var _selectedContact: Combine.Published<Spec.Contact?>
    var _selectedChatGuid: Combine.Published<Swift.String?>
    var _messages: Combine.Published<[Spec.Message]>
    var _lastIncomingMessage: Combine.Published<Spec.Message?>
    var _isAnalyzing: Combine.Published<Swift.Bool>
    var _analysisOutput: Combine.Published<Swift.String>
    var _errorMessage: Combine.Published<Swift.String?>
    var _status: Combine.Published<Swift.String>
    var _useAppleIntelligence: Combine.Published<Swift.Bool>
    var _validationResults: Combine.Published<[Spec.CommitmentValidationResult]>
    var _validCommitmentCount: Combine.Published<Swift.Int>
    var _invalidCommitmentCount: Combine.Published<Swift.Int>
}
struct CommitmentValidationResult {
    let id: Foundation.UUID
    let title: Swift.String
    let description: Swift.String
    let todoType: Swift.String
    let deadline: Swift.String
    let isValid: Swift.Bool
    let reasons: [Swift.String]
}
struct FocusRequestor {
    class FocusableView: __C.NSView {}
}
struct CursorModifier {
    let cursor: __C.NSCursor
}
struct CursorView {
    let cursor: __C.NSCursor
}
struct FoldedCornerShape {
    var cornerRadius: CoreGraphics.CGFloat
    var foldSize: CoreGraphics.CGFloat
    var insetAmount: CoreGraphics.CGFloat
}
struct FoldedCornerCard {
    let title: Swift.String
    let content: Swift.String
    var width: CoreGraphics.CGFloat
    var height: CoreGraphics.CGFloat
    var backgroundColor: SwiftUI.Color?
    var textColor: SwiftUI.Color?
    var titleColor: SwiftUI.Color?
    var cornerRadius: CoreGraphics.CGFloat
    var foldSize: CoreGraphics.CGFloat
    var isSelected: Swift.Bool
    var onTap: (() -> ())?
    var _isHovered: SwiftUI.State<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct DynamicFoldedCornerCard {
    let title: Swift.String
    let content: Swift.String
    var backgroundColor: SwiftUI.Color?
    var textColor: SwiftUI.Color?
    var titleColor: SwiftUI.Color?
    var cornerRadius: CoreGraphics.CGFloat
    var foldSizeRatio: CoreGraphics.CGFloat
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct FoldedCornerCard_Previews {}
class FullDiskAccessGuidePopupManager {
    var window: __C.NSWindow?
    var hostingController: SwiftUI.NSHostingController<Spec.FullDiskAccessGuidePopupView>?
    var mouseMonitor: Any?
    var localMouseMonitor: Any?
    var globalKeyMonitor: Any?
    var localKeyMonitor: Any?
    var dismissWorkItem: Dispatch.DispatchWorkItem?
    var notificationObserver: Any?
    var keyEventTap: __C.CFMachPort?
    var keyRunLoopSource: __C.CFRunLoopSource?
    var visibleContentWidth: CoreGraphics.CGFloat
    var currentWindowSize: __C.CGSize
    let compactWindowSize: __C.CGSize
    let horizontalOffset: CoreGraphics.CGFloat
    var pillWidth: CoreGraphics.CGFloat
}
struct FullDiskAccessGuidePopupView {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _scale: SwiftUI.State<CoreGraphics.CGFloat>
    var _isPill: SwiftUI.State<Swift.Bool>
    var _bgWidth: SwiftUI.State<CoreGraphics.CGFloat>
    var _revealWidth: SwiftUI.State<CoreGraphics.CGFloat>
    var _contentHeight: SwiftUI.State<CoreGraphics.CGFloat>
    let fullText: Swift.String
}
struct GmailInboxView {
    var _auth: SwiftUI.EnvironmentObject<Spec.AuthViewModel>
    var _emails: SwiftUI.State<[Spec.ExtractedEmail]>
    var _searchQuery: SwiftUI.State<Swift.String>
    var _filteredEmails: SwiftUI.State<[Spec.ExtractedEmail]>
    var _selectedEmail: SwiftUI.State<Spec.ExtractedEmail?>
    var _isSyncing: SwiftUI.State<Swift.Bool>
    var _syncError: SwiftUI.State<Swift.String?>
    var _lastSyncDate: SwiftUI.State<Foundation.Date?>
    var _showingEmailDetail: SwiftUI.State<Swift.Bool>
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
}
struct GEmailRowView {
    let email: Spec.ExtractedEmail
}
struct EmailDetailView {
    let email: Spec.ExtractedEmail
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
}
struct $s4Spec0025GmailInboxViewswift_jqFBgfMX299_0_33_1427BA44F03587623720D14C6A92452ALl7PreviewfMf_15PreviewRegistryfMu_ {}
struct GodLogsView {
    var _all: SwiftUI.State<[Spec.GodLogger.Entry]>
    var _searchText: SwiftUI.State<Swift.String>
    var _selectedCategory: SwiftUI.State<Spec.GodLogger.Category?>
    var _selectedLevel: SwiftUI.State<Spec.GodLogger.Level?>
    var _liveSubscriptionId: SwiftUI.State<Foundation.UUID?>
}
class GodLogsWindowController: __C.NSWindowController {}
struct GoogleReauthOverlay {
    var _authHealth: SwiftUI.ObservedObject<Spec.AuthHealthService>
    var _buttonStates: SwiftUI.State<[Swift.String : Spec.ButtonState]>
}
enum ButtonState {
    case idle
    case loading
    case authenticated
    case failed
}
struct HoverView<A> where A: SwiftUI.View {
    class Coordinator: __C.NSObject {
        var parent: Spec.HoverView<A>
        var view: __C.NSView?
        var isHovering: Swift.Bool
        var tooltipWindow: __C.NSWindow?
    }
    let content: () -> A
}
struct IntraDayPrepDetailView {
    let prep: Spec.IntraDayPrep
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct InviteGateView {
    var _code: SwiftUI.State<Swift.String>
    var _isSubmitting: SwiftUI.State<Swift.Bool>
    var _errorMessage: SwiftUI.State<Swift.String?>
    let onSuccess: () -> ()
}
struct InviteManagementView {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _invites: SwiftUI.State<[Spec.InviteService.InviteCode]>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _isGenerating: SwiftUI.State<Swift.Bool>
    var _errorMessage: SwiftUI.State<Swift.String?>
    var _successMessage: SwiftUI.State<Swift.String?>
    var _copiedCode: SwiftUI.State<Swift.String?>
    var _searchText: SwiftUI.State<Swift.String>
}
struct $s4Spec0031InviteManagementViewswift_yFFIifMX464_0_33_4C04BA7BA45D428A67D4FB6E2CEDD77BLl7PreviewfMf_15PreviewRegistryfMu_ {}
struct InviteQuickSharePopup {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _availableCount: SwiftUI.State<Swift.Int>
    var _codes: SwiftUI.State<[Spec.InviteService.InviteCode]>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _copied: SwiftUI.State<Swift.Bool>
    var _errorMessage: SwiftUI.State<Swift.String?>
    var _shareMessage: SwiftUI.State<Swift.String>
}
struct IosSyncReminderToastView {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    let onDismiss: () -> ()
    let onOpenInstructions: () -> ()
}
struct XTweet {
    enum CodingKeys {
        case id
        case text
        case lang
        case authorId
        case createdAt
        case conversationId
        case inReplyToUserId
        case referencedTweets
        case attachments
        case publicMetrics
        case entities
        case contextAnnotations
    }
    struct ReferencedTweet {
        enum CodingKeys {
            case type
            case id
        }
        let type: Swift.String
        let id: Swift.String
    }
    struct Attachments {
        enum CodingKeys {
            case mediaKeys
            case pollIds
        }
        let mediaKeys: [Swift.String]?
        let pollIds: [Swift.String]?
    }
    struct PublicMetrics {
        enum CodingKeys {
            case retweetCount
            case replyCount
            case likeCount
            case quoteCount
            case bookmarkCount
            case impressionCount
        }
        let retweetCount: Swift.Int
        let replyCount: Swift.Int
        let likeCount: Swift.Int
        let quoteCount: Swift.Int
        let bookmarkCount: Swift.Int?
        let impressionCount: Swift.Int?
    }
    struct Entities {
        struct URL {
            enum CodingKeys {
                case start
                case end
                case url
                case expandedUrl
                case displayUrl
                case unwoundUrl
            }
            let start: Swift.Int
            let end: Swift.Int
            let url: Swift.String
            let expandedUrl: Swift.String?
            let displayUrl: Swift.String?
            let unwoundUrl: Swift.String?
        }
        struct Hashtag {
            enum CodingKeys {
                case start
                case end
                case tag
            }
            let start: Swift.Int
            let end: Swift.Int
            let tag: Swift.String
        }
        struct Mention {
            enum CodingKeys {
                case start
                case end
                case username
                case id
            }
            let start: Swift.Int
            let end: Swift.Int
            let username: Swift.String
            let id: Swift.String?
        }
        struct Cashtag {
            enum CodingKeys {
                case start
                case end
                case tag
            }
            let start: Swift.Int
            let end: Swift.Int
            let tag: Swift.String
        }
        enum CodingKeys {
            case urls
            case hashtags
            case mentions
            case cashtags
        }
        let urls: [Spec.XTweet.Entities.URL]?
        let hashtags: [Spec.XTweet.Entities.Hashtag]?
        let mentions: [Spec.XTweet.Entities.Mention]?
        let cashtags: [Spec.XTweet.Entities.Cashtag]?
    }
    struct ContextAnnotation {
        struct Domain {
            enum CodingKeys {
                case id
                case name
                case description
            }
            let id: Swift.String
            let name: Swift.String
            let description: Swift.String?
        }
        struct Entity {
            enum CodingKeys {
                case id
                case name
                case description
            }
            let id: Swift.String
            let name: Swift.String
            let description: Swift.String?
        }
        enum CodingKeys {
            case domain
            case entity
        }
        let domain: Spec.XTweet.ContextAnnotation.Domain
        let entity: Spec.XTweet.ContextAnnotation.Entity
    }
    let id: Swift.String
    let text: Swift.String
    let authorId: Swift.String?
    let createdAt: Foundation.Date?
    let conversationId: Swift.String?
    let inReplyToUserId: Swift.String?
    let referencedTweets: [Spec.XTweet.ReferencedTweet]?
    let attachments: Spec.XTweet.Attachments?
    let publicMetrics: Spec.XTweet.PublicMetrics?
    let entities: Spec.XTweet.Entities?
    let contextAnnotations: [Spec.XTweet.ContextAnnotation]?
    let lang: Swift.String?
}
struct XUser {
    enum CodingKeys {
        case id
        case name
        case username
        case description
        case location
        case url
        case verified
        case protected
        case createdAt
        case verifiedType
        case profileImageUrl
        case publicMetrics
    }
    struct PublicMetrics {
        enum CodingKeys {
            case followersCount
            case followingCount
            case tweetCount
            case listedCount
        }
        let followersCount: Swift.Int
        let followingCount: Swift.Int
        let tweetCount: Swift.Int
        let listedCount: Swift.Int
    }
    let id: Swift.String
    let name: Swift.String
    let username: Swift.String
    let createdAt: Foundation.Date?
    let description: Swift.String?
    let location: Swift.String?
    let url: Swift.String?
    let verified: Swift.Bool?
    let verifiedType: Swift.String?
    let protected: Swift.Bool?
    let profileImageUrl: Swift.String?
    let publicMetrics: Spec.XUser.PublicMetrics?
}
struct XDirectMessage {
    enum CodingKeys {
        case id
        case text
        case attachments
        case senderId
        case dmConversationId
        case createdAt
        case referencedTweets
    }
    struct Attachments {
        enum CodingKeys {
            case mediaKeys
        }
        let mediaKeys: [Swift.String]?
    }
    struct ReferencedTweet {
        enum CodingKeys {
            case id
        }
        let id: Swift.String
    }
    let id: Swift.String
    let text: Swift.String
    let senderId: Swift.String?
    let dmConversationId: Swift.String?
    let createdAt: Foundation.Date?
    let attachments: Spec.XDirectMessage.Attachments?
    let referencedTweets: [Spec.XDirectMessage.ReferencedTweet]?
}
struct XDMConversation {
    enum CodingKeys {
        case id
        case type
        case participantIds
    }
    let id: Swift.String
    let type: Swift.String
    let participantIds: [Swift.String]?
}
struct XSpace {
    enum CodingKeys {
        case id
        case state
        case title
        case lang
        case createdAt
        case scheduledStart
        case startedAt
        case endedAt
        case hostIds
        case speakerIds
        case invitedUserIds
        case participantCount
        case isTicketed
    }
    let id: Swift.String
    let state: Swift.String
    let title: Swift.String?
    let createdAt: Foundation.Date?
    let scheduledStart: Foundation.Date?
    let startedAt: Foundation.Date?
    let endedAt: Foundation.Date?
    let hostIds: [Swift.String]?
    let speakerIds: [Swift.String]?
    let invitedUserIds: [Swift.String]?
    let participantCount: Swift.Int?
    let lang: Swift.String?
    let isTicketed: Swift.Bool?
}
struct XMedia {
    enum CodingKeys {
        case mediaKey
        case type
        case url
        case width
        case height
        case previewImageUrl
        case durationMs
        case publicMetrics
    }
    struct PublicMetrics {
        enum CodingKeys {
            case viewCount
        }
        let viewCount: Swift.Int?
    }
    let mediaKey: Swift.String
    let type: Swift.String
    let url: Swift.String?
    let previewImageUrl: Swift.String?
    let width: Swift.Int?
    let height: Swift.Int?
    let durationMs: Swift.Int?
    let publicMetrics: Spec.XMedia.PublicMetrics?
}
struct XList {
    enum CodingKeys {
        case id
        case name
        case description
        case ownerId
        case createdAt
        case private
        case followerCount
        case memberCount
    }
    let id: Swift.String
    let name: Swift.String
    let description: Swift.String?
    let ownerId: Swift.String
    let createdAt: Foundation.Date?
    let private: Swift.Bool?
    let followerCount: Swift.Int?
    let memberCount: Swift.Int?
}
struct XPoll {
    enum CodingKeys {
        case id
        case options
        case durationMinutes
        case endDatetime
        case votingStatus
    }
    struct Option {
        enum CodingKeys {
            case position
            case label
            case votes
        }
        let position: Swift.Int
        let label: Swift.String
        let votes: Swift.Int
    }
    let id: Swift.String
    let options: [Spec.XPoll.Option]
    let durationMinutes: Swift.Int?
    let endDatetime: Foundation.Date?
    let votingStatus: Swift.String?
}
struct XAPIResponse<A> where A: Swift.Decodable, A: Swift.Encodable {
    struct Includes {
        struct Place {
            enum CodingKeys {
                case id
                case name
                case geo
                case fullName
                case countryCode
                case placeType
            }
            struct Geo {
                enum CodingKeys {
                    case type
                    case coordinates
                }
                let type: Swift.String
                let coordinates: [[[Swift.Double]]]?
            }
            let id: Swift.String
            let fullName: Swift.String?
            let name: Swift.String?
            let countryCode: Swift.String?
            let placeType: Swift.String?
            let geo: Spec.XAPIResponse<A>.Includes.Place.Geo?
        }
        enum CodingKeys {
            case tweets
            case users
            case media
            case polls
            case places
        }
        let tweets: [Spec.XTweet]?
        let users: [Spec.XUser]?
        let media: [Spec.XMedia]?
        let polls: [Spec.XPoll]?
        let places: [Spec.XAPIResponse<A>.Includes.Place]?
    }
    struct Meta {
        enum CodingKeys {
            case nextToken
            case previousToken
            case resultCount
            case newestId
            case oldestId
        }
        let resultCount: Swift.Int?
        let nextToken: Swift.String?
        let previousToken: Swift.String?
        let newestId: Swift.String?
        let oldestId: Swift.String?
    }
    enum CodingKeys {
        case data
        case includes
        case meta
        case errors
    }
    let data: A?
    let includes: Spec.XAPIResponse<A>.Includes?
    let meta: Spec.XAPIResponse<A>.Meta?
    let errors: [Spec.XAPIError]?
}
struct XAPIError {
    enum CodingKeys {
        case title
        case detail
        case type
        case parameter
        case value
        case resourceType
    }
    let title: Swift.String?
    let detail: Swift.String?
    let type: Swift.String?
    let resourceType: Swift.String?
    let parameter: Swift.String?
    let value: Swift.String?
}
struct XCreateTweetRequest {
    enum CodingKeys {
        case text
        case replySettings
        case directMessageDeepLink
        case forSuperFollowersOnly
        case geo
        case media
        case poll
        case quoteTweetId
        case reply
    }
    struct Geo {
        enum CodingKeys {
            case placeId
        }
        let placeId: Swift.String
    }
    struct Media {
        enum CodingKeys {
            case mediaIds
            case taggedUserIds
        }
        let mediaIds: [Swift.String]
        let taggedUserIds: [Swift.String]?
    }
    struct Poll {
        enum CodingKeys {
            case options
            case durationMinutes
        }
        let options: [Swift.String]
        let durationMinutes: Swift.Int
    }
    struct Reply {
        enum CodingKeys {
            case inReplyToTweetId
            case excludeReplyUserIds
        }
        let inReplyToTweetId: Swift.String
        let excludeReplyUserIds: [Swift.String]?
    }
    let text: Swift.String
    let replySettings: Swift.String?
    let directMessageDeepLink: Swift.String?
    let forSuperFollowersOnly: Swift.Bool?
    let geo: Spec.XCreateTweetRequest.Geo?
    let media: Spec.XCreateTweetRequest.Media?
    let poll: Spec.XCreateTweetRequest.Poll?
    let quoteTweetId: Swift.String?
    let reply: Spec.XCreateTweetRequest.Reply?
}
struct XSendDMRequest {
    struct Attachment {
        enum CodingKeys {
            case mediaId
        }
        let mediaId: Swift.String
    }
    enum CodingKeys {
        case text
        case attachments
    }
    let text: Swift.String?
    let attachments: [Spec.XSendDMRequest.Attachment]?
}
struct XSearchQuery {
    let query: Swift.String
    let startTime: Foundation.Date?
    let endTime: Foundation.Date?
    let sinceId: Swift.String?
    let untilId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let sortOrder: Swift.String?
}
struct KnowledgeGraphView {
    var _kgBuilder: SwiftUI.StateObject<Spec.KnowledgeGraphBuilder>
    var _threadService: SwiftUI.StateObject<Spec.ThreadDiscoveryService>
    var _llmAgent: SwiftUI.StateObject<Spec.KnowledgeGraphLLMAgent>
    var _selectedTab: SwiftUI.State<Swift.Int>
    var _showingSettings: SwiftUI.State<Swift.Bool>
    var _showingVisualization: SwiftUI.State<Swift.Bool>
}
struct KnowledgeGraphContentView {
    var _builder: SwiftUI.ObservedObject<Spec.KnowledgeGraphBuilder>
}
struct ThreadsListView {
    var _threadService: SwiftUI.ObservedObject<Spec.ThreadDiscoveryService>
    var _searchText: SwiftUI.State<Swift.String>
    var _showOnlyActive: SwiftUI.State<Swift.Bool>
    var _selectedThread: SwiftUI.State<Spec.WorkThread?>
    var _showingThreadDetail: SwiftUI.State<Swift.Bool>
}
struct ProcessingLogView {
    var _llmAgent: SwiftUI.ObservedObject<Spec.KnowledgeGraphLLMAgent>
}
struct KGStatusCard {
    let status: Spec.KGProcessingStatus
}
struct DataSourcesCard {
    let sources: [Spec.DataSourceStatus]
}
struct GraphStatisticsCard {
    let nodeCounts: [Swift.String : Swift.Int]
    let edgeCounts: [Swift.String : Swift.Int]
}
struct HighlightsCard {
    let highlights: Spec.KGHighlights
}
struct ThreadRowView {
    let thread: Spec.WorkThread
}
struct KnowledgeGraphSettingsView {
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _monthsBack: SwiftUI.AppStorage<Swift.Int>
    var _autoRefresh: SwiftUI.AppStorage<Swift.Bool>
    var _refreshInterval: SwiftUI.AppStorage<Swift.Int>
}
struct ThreadDetailContentView {
    struct ThreadMessage {
        let guid: Swift.String
        let text: Swift.String
        let date: Foundation.Date
        let isFromMe: Swift.Bool
        let contact: Swift.String
    }
    let thread: Spec.WorkThread
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _isLoadingMessages: SwiftUI.State<Swift.Bool>
    var _threadMessages: SwiftUI.State<[Spec.ThreadDetailContentView.ThreadMessage]>
    var _errorMessage: SwiftUI.State<Swift.String?>
}
struct MessageBubbleView {
    let message: Spec.ThreadDetailContentView.ThreadMessage
}
struct KnowledgeGraphVisualizationView {
    var _kgBuilder: SwiftUI.ObservedObject<Spec.KnowledgeGraphBuilder>
    var _selectedVisualization: SwiftUI.State<Swift.Int>
    var _selectedNode: SwiftUI.State<Spec.KGNode?>
    var _hoveredContact: SwiftUI.State<Swift.String?>
}
struct StatBadge {
    let title: Swift.String
    let value: Swift.String
    let color: SwiftUI.Color
}
struct TimelineEventRow {}
struct ContactCard {
    let contact: Spec.PersonContactNode
    let isHovered: Swift.Bool
}
struct HeatmapGrid {
    let days: [Swift.String]
    let hours: [Swift.Int]
}
struct ActivityBreakdown {
    let title: Swift.String
    let data: [(Swift.String, Swift.Int)]
}
struct ContactNode {
    let angle: Swift.Double
    let radius: Swift.Double
}
struct LumaKeyVideoView {
    let url: Foundation.URL
    var threshold: Swift.Float
    var softness: Swift.Float
    var invert: Swift.Bool
    var playbackRate: Swift.Float
    var burstLoopCount: Swift.Int
    var burstPauseSeconds: Swift.Double
    var applyMedian: Swift.Bool
    var edgeSmoothRadius: CoreGraphics.CGFloat
    var _player: SwiftUI.State<__C.AVPlayer?>
    var _videoOutput: SwiftUI.State<__C.AVPlayerItemVideoOutput?>
    var _endObserver: SwiftUI.State<Any?>
    var _loopsCompletedInBurst: SwiftUI.State<Swift.Int>
    var _pendingResumeWorkItem: SwiftUI.State<Dispatch.DispatchWorkItem?>
}
class LumaKeyKernel {
    let kernel: __C.CIColorKernel
}
struct LumaPlayerContainerView {
    class RenderView: __C.NSView {
        var player: __C.AVPlayer?
        var output: __C.AVPlayerItemVideoOutput?
        var ciContext: __C.CIContext
        var timer: __C.NSTimer?
        var threshold: Swift.Float
        var softness: Swift.Float
        var invert: Swift.Bool
        var applyMedian: Swift.Bool
        var edgeSmoothRadius: CoreGraphics.CGFloat
        var lastDraw: Swift.Double
        let minFrameInterval: Swift.Double
    }
    let player: __C.AVPlayer?
    let output: __C.AVPlayerItemVideoOutput?
    let threshold: Swift.Float
    let softness: Swift.Float
    let invert: Swift.Bool
    let applyMedian: Swift.Bool
    let edgeSmoothRadius: CoreGraphics.CGFloat
}
struct MacBlurView {
    let material: __C.Material
    let blendingMode: __C.BlendingMode
}
enum MacPairingAcceptState {
    case error(Swift.String)
    case enteringLink
    case syncing
    case complete
}
struct MacPairingAcceptView {
    var _linkInput: SwiftUI.Binding<Swift.String>
    var _state: SwiftUI.State<Spec.MacPairingAcceptState>
    var onCancel: () -> ()
    var onAccept: (_: Swift.String) -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _isTextFieldFocused: SwiftUI.FocusState<Swift.Bool>
}
enum MacPairingState {
    case waitingForScan
    case syncing
    case complete
}
enum MacPairingMode {
    case forIOS
    case forMac
}
struct MacPairingOverlay {
    let qrImage: __C.NSImage?
    let urlString: Swift.String
    let state: Spec.MacPairingState
    let mode: Spec.MacPairingMode
    let onClose: () -> ()
    var _completionScale: SwiftUI.State<CoreGraphics.CGFloat>
    var _completionOpacity: SwiftUI.State<Swift.Double>
    var _showCopiedFeedback: SwiftUI.State<Swift.Bool>
}
struct RotatingModifier {
    var _isRotating: SwiftUI.State<Swift.Bool>
}
struct XTweetComposeView {
    let initialTweet: Swift.String
    let replyToTweetId: Swift.String?
    let replyToUsername: Swift.String?
    let quoteTweetId: Swift.String?
    let onPost: (Swift.String, Swift.String?, Swift.String?) -> ()
    let onCancel: () -> ()
    var _tweetText: SwiftUI.State<Swift.String>
    var _isExpanded: SwiftUI.State<Swift.Bool>
    var _characterCount: SwiftUI.State<Swift.Int>
    var _showCharacterWarning: SwiftUI.State<Swift.Bool>
    var _isBodyFocused: SwiftUI.FocusState<Swift.Bool>
    let maxCharacters: Swift.Int
    let warningThreshold: Swift.Int
}
struct $s4Spec0028XTweetComposeViewswift_IxAFhfMX295_0_33_C71A03E5690659FC409BACF6172CF061Ll7PreviewfMf_15PreviewRegistryfMu_ {}
enum MacSyncGateState {
    case choosingOption
    case waitingForLink
    case syncing
}
struct MacSyncGateView {
    var _state: SwiftUI.Binding<Spec.MacSyncGateState>
    var onSyncWithExisting: () -> ()
    var onSetupSeparate: () -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct WindowAccessor {
    let callback: (_: __C.NSWindow?) -> ()
}
class SparkleUpdaterController: __C.NSObject {
    let updaterController: __C.SPUStandardUpdaterController
    var backgroundUpdateTimer: __C.NSTimer?
    var cancellables: Swift.Set<Combine.AnyCancellable>
    var _canCheckForUpdates: Combine.Published<Swift.Bool>
    var _isCheckingForUpdates: Combine.Published<Swift.Bool>
    var _updateAvailable: Combine.Published<Swift.Bool>
    var _updateVersion: Combine.Published<Swift.String?>
    var _automaticallyChecksForUpdates: Combine.Published<Swift.Bool>
    var _updateCheckIntervalHours: Combine.Published<Swift.Int>
    var _isCriticalUpdate: Combine.Published<Swift.Bool>
    var _showCriticalUpdateDialog: Combine.Published<Swift.Bool>
    var appIsActive: Swift.Bool
    var pendingUpdateItem: __C.SUAppcastItem?
    var pendingInstallationBlock: (() -> ())?
    var appLifecycleObservers: [__C.NSObject]
    var countdownTimer: __C.NSTimer?
    var countdownSecondsRemaining: Swift.Int
    var countdownNotification: __C.NSUserNotification?
}
class SparkleUpdaterDelegate: __C.NSObject {
    weak var controller: Spec.SparkleUpdaterController?
}
struct DraftedAction {
    enum CodingKeys {
        case id
        case title
        case description
        case content
    }
    let id: Foundation.UUID
    let title: Swift.String
    let description: Swift.String
    let content: Swift.String
}
struct MeetingPrepDoc {
    enum CodingKeys {
        case title
        case content
        case spec_message
        case summary_2m
        case summary_30s
    }
    let title: Swift.String?
    let content: Swift.String?
    let spec_message: Swift.String?
    let summary_2m: Swift.String?
    let summary_30s: Swift.String?
}
struct MeetingDebriefDoc {
    enum CodingKeys {
        case title
        case content
        case spec_message
        case generated_at
        case prep_doc_used
        case transcript_used
        case meeting_id
        case transcript_source
        case debrief_type
    }
    let title: Swift.String?
    let content: Swift.String?
    let spec_message: Swift.String?
    let generated_at: Swift.String?
    let prep_doc_used: Swift.Bool?
    let transcript_used: Swift.Bool?
    let meeting_id: Swift.String?
    let transcript_source: Swift.String?
    let debrief_type: Swift.String?
}
struct IntraDayPrep {
    enum CodingKeys {
        case prep_id
        case time_slot
        case generated_at
        case date_for
        case overview
        case spec_perspective
        case key_focus_areas
        case heads_up
        case personal_context
        case potential_blind_spots
        case additional_sections
        case full_content
    }
    let prep_id: Swift.String
    let time_slot: Swift.String
    let generated_at: Swift.String
    let date_for: Swift.String
    let overview: Swift.String?
    let spec_perspective: Swift.String?
    let key_focus_areas: Swift.String?
    let heads_up: Swift.String?
    let personal_context: Swift.String?
    let potential_blind_spots: Swift.String?
    let additional_sections: [Swift.String : Swift.String]?
    let full_content: Swift.String?
}
struct EventUrgentAction {
    enum CodingKeys {
        case title
        case associated_app
        case description
        case action_array
    }
    let title: Swift.String?
    let associated_app: Swift.String?
    let description: Swift.String?
    let action_array: [Spec.UrgentActionStep]?
}
struct UrgentActionStep {
    enum CodingKeys {
        case step_number
        case action
    }
    let step_number: Swift.Int?
    let action: Spec.UrgentActionPayload?
}
struct UrgentActionPayload {
    enum CodingKeys {
        case draft_notion
    }
    let draft_notion: Spec.DraftNotionAction?
}
struct DraftNotionAction {
    enum CodingKeys {
        case title
        case body
    }
    let title: Swift.String?
    let body: Swift.String?
}
struct SpecEvent {
    enum TimeFilter {
        case today
        case yesterday
        case thisWeek
        case thisMonth
    }
    enum EventCategory {
        case videoCall
        case phoneCall
        case inPersonMeeting
        case standup
        case messageResponse
        case emailResponse
        case socialMediaReply
        case reservation
        case taskCreation
        case documentReview
        case dataAnalysis
        case leadQualification
        case priceMonitoring
        case searchActivity
        case fileOperation
        case reminder
        case dailyChecklist
        case followUp
        case contextSync
        case aiSuggestion
        case backgroundTask
    }
    let id: Foundation.UUID
    let title: Swift.String
    let time: Swift.String
    let iconName: Swift.String
    let iconColor: SwiftUI.Color
    let contextApps: [Swift.String]
    let contextAppIcons: [Swift.String]
    let summary: Swift.String
    let actionButtons: [Spec.EventAction]
    let preview: Spec.EventPreview?
    let date: Foundation.Date
    let timeFilter: Spec.SpecEvent.TimeFilter
    let category: Spec.SpecEvent.EventCategory
    let meeting_location: Swift.String?
    let meeting_call_link: Swift.String?
    let meeting_info_link: Swift.String?
    let spec_drafted_actions: [Spec.DraftedAction]?
    let meeting_prep_doc: Spec.MeetingPrepDoc?
    let event_urgent_action: Spec.EventUrgentAction?
    let sourceDocsRaw: Swift.String?
    let endDate: Foundation.Date?
    let estimatedDurationMinutes: Swift.Int?
    let status: Swift.String?
}
struct EventAction {
    let id: Foundation.UUID
    let title: Swift.String
    let isPrimary: Swift.Bool
    let shortcut: Swift.String?
    let iconName: Swift.String?
    let action: () -> ()
}
struct EventPreview {
    let id: Foundation.UUID
    let title: Swift.String
    let subtitle: Swift.String
    let imageName: Swift.String?
    let isPlaceholder: Swift.Bool
}
enum MainViewNavigationState {
    case streamDetail(Spec.StreamData)
    case eventDetail(Spec.SpecEvent)
    case home
    case streams
    case chats
    case tasks
    case experimentalHome
}
struct SearchBarHeightPreferenceKey {}
struct MainView {
    enum IosSyncScreen {
        case scanner
        case required
        case syncing
        case complete
    }
    enum ChatAnimationPhase {
        case hidden
        case expanding
        case expanded
        case collapsing
    }
    enum EventDetailAnimationPhase {
        case hidden
        case expanding
        case expanded
        case collapsing
    }
    enum IntraDayPrepAnimationPhase {
        case hidden
        case expanding
        case expanded
        case collapsing
    }
    enum DraftedActionAnimationPhase {
        case hidden
        case expanding
        case expanded
        case collapsing
    }
    enum DraftsOverlayAnimationPhase {
        case hidden
        case expanding
        case expanded
        case collapsing
    }
    enum TodoDetailAnimationPhase {
        case hidden
        case expanding
        case expanded
        case collapsing
    }
    struct ManualHeroRect {
        let startGlobal: __C.CGRect
        let progress: CoreGraphics.CGFloat
        let color: SwiftUI.Color
        var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    }
    struct InviteGateInline {
        var onSuccess: () -> ()
        var _code: SwiftUI.State<Swift.String>
        var _isSubmitting: SwiftUI.State<Swift.Bool>
        var _errorMessage: SwiftUI.State<Swift.String?>
    }
    struct InviteGatePreAuthInline {
        var onValidated: () -> ()
        var _code: SwiftUI.State<Swift.String>
        var _isSubmitting: SwiftUI.State<Swift.Bool>
        var _errorMessage: SwiftUI.State<Swift.String?>
        var _successMessage: SwiftUI.State<Swift.String?>
    }
    struct InviteGateOverlay {
        var onDismiss: () -> ()
    }
    struct GreetingBubbleHeightKey {}
    struct TypingIndicatorHeightKey {}
    struct DraftCountsModel {
        var messages: Swift.Int
        var gmail: Swift.Int
        var slack: Swift.Int
        var x: Swift.Int
    }
    enum CycleDirection {
        case forward
        case backward
    }
    struct DraftsOverlayCard {
        let platformTitle: Swift.String
        let iconName: Swift.String
        let items: [Spec.DraftListItem]
        let onClose: () -> ()
        var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    }
    enum TimeOfDayBucket {
        case morning
        case afternoon
        case evening
    }
    struct PackedTile {
        enum Size {
            case large
            case small
        }
        let id: Foundation.UUID
        let event: Spec.SpecEvent
        let size: Spec.MainView.PackedTile.Size
    }
    struct ContextAppsPillView {
        struct IconSquare {
            let iconImage: __C.NSImage?
            let isSystemIcon: Swift.Bool
            let fallbackSymbol: Swift.String
            let isFirst: Swift.Bool
            let isDark: Swift.Bool
        }
        var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
        let event: Spec.SpecEvent
        var _showPopover: SwiftUI.State<Swift.Bool>
    }
    struct VisitSiteButton {
        let url: Foundation.URL
        var _title: SwiftUI.State<Swift.String>
        var _image: SwiftUI.State<__C.NSImage?>
        var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    }
    struct UrgentAvatarIconView {
        let size: CoreGraphics.CGFloat
        var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    }
    struct HoverHighlightPillModifier {
        var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
        var _isHovering: SwiftUI.State<Swift.Bool>
        var cornerRadius: CoreGraphics.CGFloat
    }
    struct ContextSourcePreviewView {
        let event: Spec.SpecEvent
        var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
        var _previewText: SwiftUI.State<Swift.String>
    }
    struct GiftInvitePopoverButton {
        var _isPresented: SwiftUI.State<Swift.Bool>
    }
    struct LiveChatPopoverButton {
        var _isPresented: SwiftUI.State<Swift.Bool>
        var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
        let supportNumberRaw: Swift.String
    }
    struct PasteAwareTextField {
        class PasteInterceptingTextField: __C.NSTextField {
            var onPaste: (() -> Swift.Bool)?
            var focusObserver: __C.NSObject?
        }
        class Coordinator: __C.NSObject {
            var parent: Spec.MainView.PasteAwareTextField
            weak var textField: __C.NSTextField?
            var rotationTimer: __C.NSTimer?
            var placeholderIndex: Swift.Int
            var lastReportedLines: Swift.Int
            let dayKey: Swift.String
            let countKey: Swift.String
            let indexKey: Swift.String
        }
        var _text: SwiftUI.Binding<Swift.String>
        var placeholder: Swift.String
        var _isFirstResponder: SwiftUI.Binding<Swift.Bool>
        var onSubmit: () -> ()
        var onPasteAttempt: () -> Swift.Bool
        var _isFocused: SwiftUI.FocusState<Swift.Bool>
        var rotatingPlaceholders: [Swift.String]?
        var cycleIntervalSeconds: Swift.Double
        var placeholderOpacity: Swift.Double
    }
    var _events: SwiftUI.State<[Spec.SpecEvent]>
    let onDismiss: () -> ()
    var _updaterController: SwiftUI.StateObject<Spec.SparkleUpdaterController>
    var onTitleGenerated: ((_: Swift.String) -> ())?
    var _authViewModel: SwiftUI.StateObject<Spec.AuthViewModel>
    var _showSignInOverlay: SwiftUI.State<Swift.Bool>
    var _showIntroLogo: SwiftUI.State<Swift.Bool>
    var _introLogoOffsetX: SwiftUI.State<CoreGraphics.CGFloat>
    var _showIntroTextLogo: SwiftUI.State<Swift.Bool>
    var _showGoogleButton: SwiftUI.State<Swift.Bool>
    var _showInviteInput: SwiftUI.State<Swift.Bool>
    var _showInviteGateOverlay: SwiftUI.State<Swift.Bool>
    var _pendingPostAuthAction: SwiftUI.State<(() -> ())?>
    var _forcedBlinkTick: SwiftUI.State<Swift.Int>
    var _logoOffsetX: SwiftUI.State<CoreGraphics.CGFloat>
    var _logoOffsetY: SwiftUI.State<CoreGraphics.CGFloat>
    var _logoHeight: SwiftUI.State<CoreGraphics.CGFloat>
    var _randomBlinkTask: SwiftUI.State<Swift.Task<(), Swift.Never>?>
    var _isPostSignInGreeting: SwiftUI.State<Swift.Bool>
    var _showChatBubble: SwiftUI.State<Swift.Bool>
    var _holdOverlayVisibleForAuth: SwiftUI.State<Swift.Bool>
    var _isFadingOutPreElements: SwiftUI.State<Swift.Bool>
    var _preElementsRemoved: SwiftUI.State<Swift.Bool>
    var _overlaySize: SwiftUI.State<__C.CGSize>
    var _rowSize: SwiftUI.State<__C.CGSize>
    var _rowOffsetX: SwiftUI.State<CoreGraphics.CGFloat>
    var _rowOffsetY: SwiftUI.State<CoreGraphics.CGFloat>
    var _showEarlierToday: SwiftUI.State<Swift.Bool>
    let useLegacyPostSignInSetupFlow: Swift.Bool
    var _legacySetupComplete: SwiftUI.State<Swift.Bool>
    let preAuthInviteGateEnabled: Swift.Bool
    var _visibleGreetingCount: SwiftUI.State<Swift.Int>
    var _greetingSequenceStarted: SwiftUI.State<Swift.Bool>
    var _greetingBubbleStackHeight: SwiftUI.State<CoreGraphics.CGFloat>
    let greetingBubbleSpacing: CoreGraphics.CGFloat
    var _greetingSequenceTask: SwiftUI.State<Swift.Task<(), Swift.Never>?>
    var _logoGreetingDrop: SwiftUI.State<CoreGraphics.CGFloat>
    var _isShowingTypingIndicator: SwiftUI.State<Swift.Bool>
    var _typingIndicatorHeight: SwiftUI.State<CoreGraphics.CGFloat>
    var _reservedPostTypingSpace: SwiftUI.State<CoreGraphics.CGFloat>
    var _logoSpacerHeight: SwiftUI.State<CoreGraphics.CGFloat>
    var _showYesButton: SwiftUI.State<Swift.Bool>
    var _greetingPhase: SwiftUI.State<Swift.Int>
    var _permissionRevealCount: SwiftUI.State<Swift.Int>
    var _permissionRevealStarted: SwiftUI.State<Swift.Bool>
    var _isQuickResumePermissions: SwiftUI.State<Swift.Bool>
    var _permissionGranted: SwiftUI.State<[Spec.PermissionType : Swift.Bool]>
    var _permissionVM: SwiftUI.StateObject<Spec.PermissionOnboardingViewModel>
    var _todoManager: SwiftUI.StateObject<Spec.TodoManager>
    var _pinnedChatManager: SwiftUI.StateObject<Spec.PinnedChatManager>
    var _isHoveringClose: SwiftUI.State<Swift.Bool>
    var _selectedTabIndex: SwiftUI.State<Swift.Int>
    var _selectedTabForBinding: SwiftUI.State<Swift.String>
    var _selectedTabBeforeSearch: SwiftUI.State<Swift.String>
    var _selectedTabBeforeProfile: SwiftUI.State<Swift.String>
    var _isHoveringHome: SwiftUI.State<Swift.Bool>
    var _isHoveringStreams: SwiftUI.State<Swift.Bool>
    var _isHoveringChats: SwiftUI.State<Swift.Bool>
    var _isHoveringTasks: SwiftUI.State<Swift.Bool>
    var _isHoveringGift: SwiftUI.State<Swift.Bool>
    var _isHoveringProfile: SwiftUI.State<Swift.Bool>
    var _searchText: SwiftUI.State<Swift.String>
    var _hasHoveredAnyRow: SwiftUI.State<Swift.Bool>
    var _selectedRowIndex: SwiftUI.State<Swift.Int>
    var _navigationStack: SwiftUI.State<[Spec.MainViewNavigationState]>
    var _forwardStack: SwiftUI.State<[Spec.MainViewNavigationState]>
    var _chatWasPreviouslyOpen: SwiftUI.State<Swift.Bool>
    var _isSearchFocused: SwiftUI.FocusState<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _connectivity: SwiftUI.ObservedObject<Spec.ConnectivityService>
    var _devicePresence: SwiftUI.ObservedObject<Spec.DevicePresenceService>
    var _offlineBannerDismissed: SwiftUI.State<Swift.Bool>
    var _searchBarMeasuredWidth: SwiftUI.State<CoreGraphics.CGFloat>
    var _searchBarLineCount: SwiftUI.State<Swift.Int>
    var _initialSearchBarHeight: SwiftUI.State<CoreGraphics.CGFloat?>
    var _showOverloadedToast: SwiftUI.State<Swift.Bool>
    var _overloadedToastDismissed: SwiftUI.State<Swift.Bool>
    var _forceMinimalReasoningNextCreation: SwiftUI.State<Swift.Bool>
    var _lastOverloadToastAt: SwiftUI.State<Foundation.Date?>
    var _showPulseSuccessToast: SwiftUI.State<Swift.Bool>
    var _pulseSuccessMessage: SwiftUI.State<Swift.String>
    var _showTentativeEvents: SwiftUI.State<Swift.Bool>
    var _isBackingUp: SwiftUI.State<Swift.Bool>
    var _isRestoring: SwiftUI.State<Swift.Bool>
    var _showBackupAlert: SwiftUI.State<Swift.Bool>
    var _backupAlertTitle: SwiftUI.State<Swift.String>
    var _backupAlertMessage: SwiftUI.State<Swift.String>
    var _iosSyncReminderDismissed: SwiftUI.State<Swift.Bool>
    var _showIosSyncInstructions: SwiftUI.State<Swift.Bool>
    var _showIosSyncGate: SwiftUI.State<Swift.Bool>
    var _isIOSDeviceSynced: SwiftUI.State<Swift.Bool?>
    var _iosSyncScreen: SwiftUI.State<Spec.MainView.IosSyncScreen>
    var _iosSyncInProgress: SwiftUI.State<Swift.Bool>
    var _showMacPairingOverlay: SwiftUI.State<Swift.Bool>
    var _macPairingQr: SwiftUI.State<__C.NSImage?>
    var _macPairingUrl: SwiftUI.State<Swift.String>
    var _macPairingSessionId: SwiftUI.State<Swift.String?>
    var _macPairingState: SwiftUI.State<Spec.MacPairingState>
    var _macPairingMode: SwiftUI.State<Spec.MacPairingMode>
    var _showMacSyncGate: SwiftUI.State<Swift.Bool>
    var _macSyncGateState: SwiftUI.State<Spec.MacSyncGateState>
    var _isMacDeviceSynced: SwiftUI.State<Swift.Bool?>
    var _macSyncInProgress: SwiftUI.State<Swift.Bool>
    var _macSyncLink: SwiftUI.State<Swift.String>
    var _showGmailManager: SwiftUI.State<Swift.Bool>
    var _connectedGmailAccounts: SwiftUI.State<[Spec.GmailAccount]>
    var _selectedGmailAccounts: SwiftUI.State<Swift.Set<Swift.String>>
    var _showInviteQuickSharePopup: SwiftUI.State<Swift.Bool>
    var _showRemoveGmailConfirm: SwiftUI.State<Swift.Bool>
    var _gmailToRemoveEmail: SwiftUI.State<Swift.String?>
    var _gmailRevealStarted: SwiftUI.State<Swift.Bool>
    var _gmailRevealCount: SwiftUI.State<Swift.Int>
    var _connectedSlackAccounts: SwiftUI.State<[Spec.SlackAccountSummary]>
    var _showRemoveSlackConfirm: SwiftUI.State<Swift.Bool>
    var _slackToRemoveTeamId: SwiftUI.State<Swift.String?>
    var _slackRevealStarted: SwiftUI.State<Swift.Bool>
    var _slackRevealCount: SwiftUI.State<Swift.Int>
    var _phase4RevealStarted: SwiftUI.State<Swift.Bool>
    var _isBuildingProfile: SwiftUI.State<Swift.Bool>
    var _showSetupOverlay: SwiftUI.State<Swift.Bool>
    var _inviteGateRequired: SwiftUI.State<Swift.Bool>
    var _buildPhase1Done: SwiftUI.State<Swift.Bool>
    var _buildPhase2Done: SwiftUI.State<Swift.Bool>
    var _buildStartTime: SwiftUI.State<Foundation.Date?>
    var _buildLogs: SwiftUI.State<[Swift.String]>
    var _buildElapsedTicker: SwiftUI.State<Foundation.Date>
    var _buildAppProgress: SwiftUI.State<[Swift.String : Swift.Double]>
    var _buildAppStatus: SwiftUI.State<[Swift.String : Swift.String]>
    var _buildAppActive: SwiftUI.State<Swift.Set<Swift.String>>
    var _buildAppComplete: SwiftUI.State<Swift.Set<Swift.String>>
    var _buildDataPoints: SwiftUI.State<Swift.Int>
    var _buildContacts: SwiftUI.State<Swift.Int>
    var _buildMessages: SwiftUI.State<Swift.Int>
    var _buildMessagesTotalAvailable: SwiftUI.State<Swift.Int>
    var _buildEmails: SwiftUI.State<Swift.Int>
    var _buildEvents: SwiftUI.State<Swift.Int>
    var _buildSaveErrors: SwiftUI.State<[Swift.String]>
    var _buildLastSaveTime: SwiftUI.State<Foundation.Date?>
    var _showSkipProfileButton: SwiftUI.State<Swift.Bool>
    var _tutorialStep: SwiftUI.AppStorage<Swift.Int>
    var _tutorialDismissedOnce: SwiftUI.AppStorage<Swift.Bool>
    var _showFirstTimeChatView: SwiftUI.State<Swift.Bool>
    var _firstTimeChatObservable: SwiftUI.State<Spec.MessageFunctionCallingObservable?>
    var _firstTimeChatActions: SwiftUI.State<[Spec.AIAction]>
    var _firstTimeChatLoading: SwiftUI.State<Swift.Bool>
    var _firstTimeChatInputVisible: SwiftUI.State<Swift.Bool>
    var _firstTimeChatSuggestionsVisible: SwiftUI.State<Swift.Bool>
    var _clickedSuggestions: SwiftUI.State<Swift.Set<Swift.String>>
    var _showOpenHomeButton: SwiftUI.State<Swift.Bool>
    var _firstTimeChatObserverTokens: SwiftUI.State<[__C.NSObject]>
    var _firstTimeChatPendingThinking: SwiftUI.State<Swift.String>
    var _firstTimeChatLastThinkingUpdate: SwiftUI.State<Foundation.Date>
    var _firstTimeChatThinkingTimer: SwiftUI.State<__C.NSTimer?>
    var _firstTimeChatPendingStreamText: SwiftUI.State<Swift.String>
    var _firstTimeChatLastStreamUpdate: SwiftUI.State<Foundation.Date>
    var _firstTimeChatStreamTimer: SwiftUI.State<__C.NSTimer?>
    var _isMessageListenerEnabled: SwiftUI.AppStorage<Swift.Bool>
    var _showChatView: SwiftUI.State<Swift.Bool>
    var _chatQuery: SwiftUI.State<Swift.String>
    var _chatActions: SwiftUI.State<[Spec.AIAction]>
    var _isChatLoading: SwiftUI.State<Swift.Bool>
    var _chatOpacity: SwiftUI.State<Swift.Double>
    var _inputDragProgress: SwiftUI.State<CoreGraphics.CGFloat>
    var _messageToolRefreshTrigger: SwiftUI.State<[Foundation.UUID : Swift.Int]>
    var _isSidebarCollapsed: SwiftUI.State<Swift.Bool>
    var _chatTitleModel: SwiftUI.StateObject<Spec.ChatTitleModel>
    var _observable: SwiftUI.State<Spec.MessageFunctionCallingObservable?>
    var _chatAnimationPhase: SwiftUI.State<Spec.MainView.ChatAnimationPhase>
    var _searchBarFrame: SwiftUI.State<__C.CGRect>
    var _searchBarHeight: SwiftUI.State<CoreGraphics.CGFloat>
    var _chatUpdateTrigger: SwiftUI.State<Foundation.UUID>
    var _chatObserversSetup: SwiftUI.State<Swift.Bool>
    var _chatInputText: SwiftUI.State<Swift.String>
    var _isFileImporterPresented: SwiftUI.State<Swift.Bool>
    var _chatPendingStreamText: SwiftUI.State<Swift.String>
    var _chatLastStreamUpdate: SwiftUI.State<Foundation.Date>
    var _chatStreamTimer: SwiftUI.State<__C.NSTimer?>
    var _isSlackConnected: SwiftUI.State<Swift.Bool>
    var _slackConnectedTeamLabel: SwiftUI.State<Swift.String>
    var _showDisconnectSlackConfirm: SwiftUI.State<Swift.Bool>
    var _isImageImporterPresented: SwiftUI.State<Swift.Bool>
    var _pendingAttachmentURLs: SwiftUI.State<[Foundation.URL]>
    var _showAttachmentMenu: SwiftUI.State<Swift.Bool>
    var _isStreaming: SwiftUI.State<Swift.Bool>
    var _currentThreadId: SwiftUI.State<Swift.String?>
    var _isDraggingFiles: SwiftUI.State<Swift.Bool>
    var _browserOverlayWasVisible: SwiftUI.State<Swift.Bool>
    var _homeGreetingMarkdown: SwiftUI.State<Swift.String>
    var _selectedAIModel: SwiftUI.State<Swift.String>
    var _isProfileRefreshing: SwiftUI.State<Swift.Bool>
    var _lastUpdatedText: SwiftUI.State<Swift.String>
    var _lastUpdatedTimer: SwiftUI.State<__C.NSTimer?>
    var _buttonUpdateTrigger: SwiftUI.State<Foundation.Date>
    var _buttonUpdateTimer: SwiftUI.State<__C.NSTimer?>
    var _showEventDetailView: SwiftUI.State<Swift.Bool>
    var _selectedEvent: SwiftUI.State<Spec.SpecEvent?>
    var _eventDetailAnimationPhase: SwiftUI.State<Spec.MainView.EventDetailAnimationPhase>
    var _showIntraDayPrepDetail: SwiftUI.State<Swift.Bool>
    var _selectedIntraDayPrep: SwiftUI.State<Spec.IntraDayPrep?>
    var _intraDayPrepAnimationPhase: SwiftUI.State<Spec.MainView.IntraDayPrepAnimationPhase>
    var _todaysIntraDayPrep: SwiftUI.State<Spec.IntraDayPrep?>
    var _showDraftedActionDetail: SwiftUI.State<Swift.Bool>
    var _selectedDraftedAction: SwiftUI.State<Spec.DraftedAction?>
    var _draftedActionAnimationPhase: SwiftUI.State<Spec.MainView.DraftedActionAnimationPhase>
    var _showMeetingPrepDetailView: SwiftUI.State<Swift.Bool>
    var _selectedMeetingPrepTitle: SwiftUI.State<Swift.String>
    var _selectedMeetingPrepContent: SwiftUI.State<Swift.String>
    var _selectedMeetingPrepSummary2m: SwiftUI.State<Swift.String?>
    var _selectedMeetingPrepSummary30s: SwiftUI.State<Swift.String?>
    var _showSmarterHint: SwiftUI.State<Swift.Bool>
    var _showFasterHint: SwiftUI.State<Swift.Bool>
    var _showTodoDetailView: SwiftUI.State<Swift.Bool>
    var _selectedTodo: SwiftUI.State<Spec.Todo?>
    var _todoDetailAnimationPhase: SwiftUI.State<Spec.MainView.TodoDetailAnimationPhase>
    var _eventHeroNamespace: SwiftUI.Namespace
    var _tileFrames: SwiftUI.State<[Foundation.UUID : __C.CGRect]>
    var _manualHeroRectGlobal: SwiftUI.State<__C.CGRect?>
    var _manualHeroActive: SwiftUI.State<Swift.Bool>
    var _manualHeroProgress: SwiftUI.State<CoreGraphics.CGFloat>
    var _showPhase2TaskDetailView: SwiftUI.State<Swift.Bool>
    var _selectedPhase2Task: SwiftUI.State<Spec.Phase2Task?>
    var _specLogoScale: SwiftUI.State<Swift.Double>
    var _hasShownHome: SwiftUI.State<Swift.Bool>
    var _hasShownStreams: SwiftUI.State<Swift.Bool>
    var _hasShownChats: SwiftUI.State<Swift.Bool>
    var _hasShownTasks: SwiftUI.State<Swift.Bool>
    let onSizeChange: ((_: __C.CGSize) -> ())?
    let tabs: [Swift.String]
    var _scenePhase: SwiftUI.Environment<SwiftUI.ScenePhase>
    var sidebarWidth: Swift.Double
    var _buildElapsedTimer: SwiftUI.State<__C.NSTimer?>
    var _draftCounts: SwiftUI.State<Spec.MainView.DraftCountsModel>
    var _lastDraftCountsRefresh: SwiftUI.State<Swift.Double>
    var _pendingDraftCountsRefresh: SwiftUI.State<Dispatch.DispatchWorkItem?>
    let draftCountsRefreshThrottleInterval: Swift.Double
    var _showDraftsOverlay: SwiftUI.State<Swift.Bool>
    var _selectedDraftsPage: SwiftUI.State<Swift.Int>
    var _draftsAnimationPhase: SwiftUI.State<Spec.MainView.DraftsOverlayAnimationPhase>
    var _isXApiEnabled: SwiftUI.State<Swift.Bool>
    var _messagesDraftIndex: SwiftUI.State<Swift.Int>
    var _gmailDraftIndex: SwiftUI.State<Swift.Int>
    var _slackDraftIndex: SwiftUI.State<Swift.Int>
    var _xDraftIndex: SwiftUI.State<Swift.Int>
    var _draftCycleDirection: SwiftUI.State<Spec.MainView.CycleDirection>
    var _selectedMessagesDraft: SwiftUI.State<Swift.String?>
    var _selectedGmailDraft: SwiftUI.State<Swift.String?>
    var _selectedSlackDraft: SwiftUI.State<Swift.String?>
    var _selectedXDraft: SwiftUI.State<Swift.String?>
    var _timeTicker: SwiftUI.State<Foundation.Date>
}
struct LiquidGlassContainer<A> where A: SwiftUI.View {
    let content: A
    let cornerRadius: CoreGraphics.CGFloat
    let tint: SwiftUI.Color?
    let contentPadding: CoreGraphics.CGFloat
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct GroupModifierMacCorners {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct FocusEffectSuppressor {}
struct CenterInViewport {
    let minHeight: CoreGraphics.CGFloat
}
class MainViewWindow: __C.NSWindow {
    var keyboardEventMonitor: Any?
    var localKeyboardMonitor: Any?
    var isOnboardingActive: Swift.Bool
    var isAuthOverlayVisible: Swift.Bool
    var onboardingPhase: Swift.Int
}
class MainViewWindowController: __C.NSWindowController {
    var hostingController: SwiftUI.NSHostingController<SwiftUI.AnyView>?
    var cancellables: Swift.Set<Combine.AnyCancellable>
    let defaultWidth: CoreGraphics.CGFloat
    let defaultHeight: CoreGraphics.CGFloat
    let animationDuration: Swift.Double
    let events: [Spec.SpecEvent]
    var onDismiss: () -> ()
}
struct HomeGreetingMarkdownView {
    let markdown: Swift.String
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct GlassEffectWrapper {
    let cornerRadius: CoreGraphics.CGFloat
}
struct VideoPlayerLoopView {
    let url: Foundation.URL
}
struct MarkdownText {
    enum MarkdownElement {
        case heading(Swift.String, Swift.Int)
        case paragraph(Swift.String)
        case unorderedListItem(Swift.String, Swift.Int)
        case orderedListItem(Swift.String, Swift.String, Swift.Int)
        case checklistItem(Swift.String, Swift.Bool, Swift.Int)
        case codeBlock(Swift.String, Swift.String)
        case blockquote(Swift.String)
        case table([Swift.String])
        case horizontalRule
        case emptyLine
    }
    let markdownString: Swift.String
    let fontSize: CoreGraphics.CGFloat
}
struct ChecklistItemView {
    let content: Swift.String
    let fontSize: CoreGraphics.CGFloat
    var _isChecked: SwiftUI.State<Swift.Bool>
}
struct SelectableMarkdownText {
    let markdownString: Swift.String
    let fontSize: CoreGraphics.CGFloat
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct MarkdownTextTest {
    let testMarkdown: Swift.String
}
struct $s4Spec0027MarkdownTextTestswift_ovFAhfMX62_0_33_700297F5BB2BF39432276DFAE8983393Ll7PreviewfMf_15PreviewRegistryfMu_ {}
enum MeetingPrepViewMode {
    case full
    case twoMin
    case thirtySeconds
}
struct MeetingPrepDetailView {
    let title: Swift.String
    let content: Swift.String
    let summary2m: Swift.String?
    let summary30s: Swift.String?
    let onDismiss: (() -> ())?
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _selectedMode: SwiftUI.State<Spec.MeetingPrepViewMode>
}
struct MeshGradient {
    let width: Swift.Int
    let height: Swift.Int
    let points: [[CoreGraphics.CGFloat]]
    let colors: [SwiftUI.Color]
}
struct MeshGradientButton {
    var title: Swift.String
    var icon: Swift.String
    var action: () -> ()
}
struct MessageSentNotificationView {
    let contactName: Swift.String
    let messageContent: Swift.String
    let contactInfo: [Swift.String : Any]?
    var _showCheckmark: SwiftUI.State<Swift.Bool>
    var _expandMessage: SwiftUI.State<Swift.Bool>
}
struct MessageSentSystemView {
    let contactName: Swift.String
    let messageContent: Swift.String
}
struct MessagesReplyPreviewView {
    let contactName: Swift.String
    let contactNumber: Swift.String?
    let chatGuid: Swift.String?
    let initialMessage: Swift.String
    var _messageText: SwiftUI.State<Swift.String>
    let onSend: (Swift.String, Swift.Bool) -> ()
    let onCancel: () -> ()
    var _isBodyFocused: SwiftUI.FocusState<Swift.Bool>
    var _showSendConfirmation: SwiftUI.State<Swift.Bool>
    var _isExpanded: SwiftUI.State<Swift.Bool>
    var _isLoadingHistory: SwiftUI.State<Swift.Bool>
    var _didLoadHistory: SwiftUI.State<Swift.Bool>
    var _recentMessages: SwiftUI.State<[Spec.Message]>
    var _processedMessages: SwiftUI.State<[(message: Spec.Message, reactions: [Swift.String])]>
    let contactInfo: [Swift.String : Any]?
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _avatarImageRef: SwiftUI.State<Swift.String?>
}
struct MessageTriageTestView {
    var _vm: SwiftUI.StateObject<Spec.MessageTriageTestViewModel>
}
struct $s4Spec0032MessageTriageTestViewswift_jIADjfMX218_0_33_D782ACEF5AEE841BE8F0E082BD236D96Ll7PreviewfMf_15PreviewRegistryfMu_ {}
class MessageTriageTestViewModel {
    struct TriageResult {
        enum CodingKeys {
            case needs_reply
            case reason
            case suggested_reply
        }
        let needs_reply: Swift.Bool
        let reason: Swift.String
        let suggested_reply: Swift.String
    }
    let dm: Spec.DirectMessagesManager
    let ai: Spec.AppleIntelligenceService
    var _searchText: Combine.Published<Swift.String>
    var _contacts: Combine.Published<[Spec.Contact]>
    var _isSearching: Combine.Published<Swift.Bool>
    var _selectedContact: Combine.Published<Spec.Contact?>
    var _selectedChatGuid: Combine.Published<Swift.String?>
    var _messages: Combine.Published<[Spec.Message]>
    var _lastIncomingMessage: Combine.Published<Spec.Message?>
    var _isSupported: Combine.Published<Swift.Bool>
    var _systemVersion: Combine.Published<Swift.String>
    var _status: Combine.Published<Swift.String>
    var _isAnalyzing: Combine.Published<Swift.Bool>
    var _analysisOutput: Combine.Published<Swift.String>
    var _errorMessage: Combine.Published<Swift.String?>
    var _useStreaming: Combine.Published<Swift.Bool>
    lazy var ackRegexes: [__C.NSRegularExpression]?
    let reactionEmojiSet: Swift.Set<Swift.Character>
}
struct VisualEffectBlur {
    let material: __C.Material
    let blendingMode: __C.BlendingMode
}
struct RoundedRectangleWithBite {
    var cornerRadius: CoreGraphics.CGFloat
    var biteOffset: CoreGraphics.CGFloat
}
struct AppleMapsPreviewCard {
    let location: Swift.String
    var _position: SwiftUI.State<_MapKit_SwiftUI.MapCameraPosition>
    var _isLoadingLocation: SwiftUI.State<Swift.Bool>
    var _locationName: SwiftUI.State<Swift.String>
    var _locationCoordinate: SwiftUI.State<__C.CLLocationCoordinate2D?>
    var _selectedMapItem: SwiftUI.State<__C.MKMapItem?>
    var _isHovered: SwiftUI.State<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct FeatheredAppleMapsPreviewCard {
    let location: Swift.String
}
struct CombinedMapAndDraftedCardView {
    let draftedTitle: Swift.String
    let draftedContent: Swift.String
    let onTapDrafted: () -> ()
    let meetingLocation: Swift.String
    var _isHoveringDraftedCard: SwiftUI.State<Swift.Bool>
}
struct EventRowWrapper<A> where A: SwiftUI.View {
    let index: Swift.Int
    let content: (_: Swift.Bool) -> A
    var _hasHoveredAnyRow: SwiftUI.Binding<Swift.Bool>
    var _selectedRowIndex: SwiftUI.Binding<Swift.Int>
    var _isHovered: SwiftUI.State<Swift.Bool>
}
struct MessageEventTestView {
    var _vm: SwiftUI.StateObject<Spec.MessageEventTestViewModel>
}
struct EventValidationResultRow {
    let result: Spec.EventValidationResult
}
struct $s4Spec0031MessageEventTestViewswift_yFFIifMX396_0_33_C84BCBEA4FB165B55A9EBA49CF88715ELl7PreviewfMf_15PreviewRegistryfMu_ {}
struct MovingShimmer {
    var animate: Swift.Bool
}
struct NetworkErrorBanner {
    let message: Swift.String
    let onDismiss: () -> ()
    let isStreamError: Swift.Bool
}
class OCRPreviewPanel: __C.NSPanel {}
struct OfflineToastView {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    let onDismiss: () -> ()
}
enum PermissionType {
    case accessibility
    case fullDiskAccess
    case keystroke
    case messagesAutomation
    case screenRecording
    case contacts
}
struct PermissionStatus {
    let id: Foundation.UUID
    let type: Spec.PermissionType
    var isGranted: Swift.Bool
}
struct PermissionOnboardingView {
    var _viewModel: SwiftUI.StateObject<Spec.PermissionOnboardingViewModel>
    var _isComplete: SwiftUI.Binding<Swift.Bool>
    let onComplete: () -> ()
}
struct PermissionCard {
    let permission: Spec.PermissionStatus
    let onGrant: () -> ()
}
class PermissionOnboardingViewModel {
    var _permissions: Combine.Published<[Spec.PermissionStatus]>
    var timer: __C.NSTimer?
    var scheduledAccessibilityStabilization: Swift.Bool
    var keystrokeNudgeMonitors: [Any]
    var keystrokeNudgeTap: __C.CFMachPort?
    var keystrokeNudgeRunLoopSource: __C.CFRunLoopSource?
}
struct PermissionOnboardingView_Previews {}
struct Phase2MainViewDemo {
    var _debugInfo: SwiftUI.State<Swift.String>
}
struct Phase2MainViewDemo_Previews {}
struct Phase2TaskDetailView {
    let task: Spec.Phase2Task
    let onDismiss: () -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct Phase2TasksView {
    var _taskManager: SwiftUI.StateObject<Spec.Phase2TaskManager>
    var onTaskSelected: ((_: Spec.Phase2Task) -> ())?
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct Phase2TaskCard {
    let task: Spec.Phase2Task
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _isHovered: SwiftUI.State<Swift.Bool>
    var _resolvedImageRef: SwiftUI.State<Swift.String?>
}
struct PersonalTasksRow {
    var _taskManager: SwiftUI.ObservedObject<Spec.Phase2TaskManager>
    var onTaskSelected: ((_: Spec.Phase2Task) -> ())?
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _animateExpansion: SwiftUI.State<Swift.Bool>
}
struct Phase2TasksView_Previews {}
struct PillTextField {
    var _text: SwiftUI.Binding<Swift.String>
    var placeholder: Swift.String
    var onSubmit: () -> ()
    var _isFocused: SwiftUI.State<Swift.Bool>
    var _isHovering: SwiftUI.State<Swift.Bool>
    var width: CoreGraphics.CGFloat?
    var fontSize: CoreGraphics.CGFloat
    var verticalPadding: CoreGraphics.CGFloat
}
struct OrbitSatellite {
    let id: Swift.String
    let content: SwiftUI.AnyView
    let onTap: (() -> ())?
    let sizeMultiplier: CoreGraphics.CGFloat
    let urgency: Swift.Double?
    let haloColor: SwiftUI.Color?
}
struct PlanetOrbitView {
    struct PlacedItem {
        let satIndex: Swift.Int
        let point: __C.CGPoint
    }
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    let centerContent: SwiftUI.AnyView
    let satellites: [Spec.OrbitSatellite]
    var desiredRingCount: Swift.Int?
    var itemSize: CoreGraphics.CGFloat
    var minSpacing: CoreGraphics.CGFloat
    var ringPadding: CoreGraphics.CGFloat
    var visibleAngleCenter: CoreGraphics.CGFloat
    var visibleAngleSpan: CoreGraphics.CGFloat
    var randomSeed: Swift.UInt64
    var mirrorAcross180: Swift.Bool
    var ringSpacingBias: CoreGraphics.CGFloat
    var centerYOffset: CoreGraphics.CGFloat
    var firstRingExtraOffset: CoreGraphics.CGFloat
    var ringSpanMultipliers: [CoreGraphics.CGFloat]?
    var separationLineWidth: CoreGraphics.CGFloat
    var separatorColor: SwiftUI.Color?
    var ringStrokeColor: SwiftUI.Color?
    var ringPitchOverride: CoreGraphics.CGFloat?
}
struct SeededGenerator {
    var state: Swift.UInt64
}
struct PopupChatBridge {
    struct BridgeContent {
        let observable: Spec.MessageFunctionCallingObservable?
        var _actions: SwiftUI.Binding<[Spec.AIAction]>
        let onSubmit: (_: Swift.String) -> ()
        let onEnsureChatVisible: () -> ()
        let onNewChat: (() -> ())?
        var _sub: SwiftUI.State<Combine.AnyCancellable?>
    }
    let observable: Spec.MessageFunctionCallingObservable?
    var _actions: SwiftUI.Binding<[Spec.AIAction]>
    let onSubmit: (_: Swift.String) -> ()
    let onEnsureChatVisible: () -> ()
    var onNewChat: (() -> ())?
}
struct GmailAccount {
    let id: Foundation.UUID
    let email: Swift.String
    let accessToken: Swift.String
    let displayName: Swift.String?
}
struct GranolaOnlyRefreshKey {}
struct QuillOnlyRefreshKey {}
struct ProfileBuilderTestView {
    var _granolaOnlyRefresh: SwiftUI.Environment<Swift.Bool>
    var _quillOnlyRefresh: SwiftUI.Environment<Swift.Bool>
    var _auth: SwiftUI.EnvironmentObject<Spec.AuthViewModel>
    var _multiAccountManager: SwiftUI.StateObject<Spec.GoogleMultiAccountManager>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _profileJSON: SwiftUI.State<Swift.String>
    var _errorMessage: SwiftUI.State<Swift.String>
    var _rawResponse: SwiftUI.State<Swift.String>
    var _shouldScrollToBottom: SwiftUI.State<Swift.Bool>
    var _functionCalling: SwiftUI.State<Spec.MessageFunctionCallingObservable?>
    var _timer: SwiftUI.State<__C.NSTimer?>
    var _estimatedInputTokens: SwiftUI.State<Swift.Int>
    var _actualTotalTokens: SwiftUI.State<Swift.String>
    var _actualInputTokens: SwiftUI.State<Swift.Int?>
    var _actualOutputTokens: SwiftUI.State<Swift.Int?>
    var _cacheInputTokens: SwiftUI.State<Swift.Int?>
    var _showManualTokenEntry: SwiftUI.State<Swift.Bool>
    var _manualInputTokens: SwiftUI.State<Swift.String>
    var _manualCacheTokens: SwiftUI.State<Swift.String>
    var _manualOutputTokens: SwiftUI.State<Swift.String>
    var _profileExtractionProgress: SwiftUI.State<Swift.String>
    var _showSavedProfileSheet: SwiftUI.State<Swift.Bool>
    var _showSavedStreamsEventsSheet: SwiftUI.State<Swift.Bool>
    var _savedProfileJSON: SwiftUI.State<Swift.String?>
    var _savedStreamsEventsJSON: SwiftUI.State<Swift.String?>
    var _savedStreamsData: SwiftUI.State<Swift.String>
    var _showRefreshChanges: SwiftUI.State<Swift.Bool>
    var _refreshChangesJSON: SwiftUI.State<Swift.String>
    var _showChangesPreview: SwiftUI.State<Swift.Bool>
    var _changesPreview: SwiftUI.State<Swift.String>
    var _autoRunOnAppear: SwiftUI.State<Swift.Bool>
    var _autoRunFullBuild: SwiftUI.State<Swift.Bool>
    var _runParallelFullBuild: SwiftUI.State<Swift.Bool>
    let kBuildCheckpointKey: Swift.String
    let kBuildPhaseKey: Swift.String
    let kBuildProcessedSourcesKey: Swift.String
    let kBuildOldestDateKey: Swift.String
    var _selectedModel: SwiftUI.State<Swift.String>
    var _modelManager: SwiftUI.StateObject<Spec.ModelManager>
    var _includeGmail: SwiftUI.State<Swift.Bool>
    var _gmailPrimaryOnly: SwiftUI.State<Swift.Bool>
    var _enhancedFiltering: SwiftUI.State<Swift.Bool>
    var _gmailMonthsBack: SwiftUI.State<Swift.Int>
    var _isGmailLoading: SwiftUI.State<Swift.Bool>
    var _gmailError: SwiftUI.State<Swift.String?>
    var _gmailDataFetched: SwiftUI.State<Swift.Bool>
    var _gmailEmailCount: SwiftUI.State<Swift.Int>
    var _gmailTestResults: SwiftUI.State<Swift.String>
    var _showGmailResults: SwiftUI.State<Swift.Bool>
    var _connectedGmailAccounts: SwiftUI.State<[Spec.GmailAccount]>
    var _selectedGmailAccounts: SwiftUI.State<Swift.Set<Swift.String>>
    var _isAddingGmailAccount: SwiftUI.State<Swift.Bool>
    var _showAccountManager: SwiftUI.State<Swift.Bool>
    var _includeWhatsApp: SwiftUI.State<Swift.Bool>
    var _whatsAppDaysBack: SwiftUI.State<Swift.Int>
    var _excludeLargeGroups: SwiftUI.State<Swift.Bool>
    var _isWhatsAppLoading: SwiftUI.State<Swift.Bool>
    var _whatsAppError: SwiftUI.State<Swift.String?>
    var _whatsAppDataFetched: SwiftUI.State<Swift.Bool>
    var _whatsAppMessageCount: SwiftUI.State<Swift.Int>
    var _whatsAppConversationCount: SwiftUI.State<Swift.Int>
    var _whatsAppEstimatedTokens: SwiftUI.State<Swift.Int>
    var _whatsAppTestResults: SwiftUI.State<Swift.String>
    var _showWhatsAppResults: SwiftUI.State<Swift.Bool>
    var _includeChrome: SwiftUI.State<Swift.Bool>
    var _chromeDaysBack: SwiftUI.State<Swift.Int>
    var _compressChromeHistory: SwiftUI.State<Swift.Bool>
    var _isChromeLoading: SwiftUI.State<Swift.Bool>
    var _chromeError: SwiftUI.State<Swift.String?>
    var _chromeDataFetched: SwiftUI.State<Swift.Bool>
    var _chromeHistoryCount: SwiftUI.State<Swift.Int>
    var _chromeBookmarksCount: SwiftUI.State<Swift.Int>
    var _chromeEstimatedTokens: SwiftUI.State<Swift.Int>
    var _chromeTestResults: SwiftUI.State<Swift.String>
    var _showChromeResults: SwiftUI.State<Swift.Bool>
    var _includeGranola: SwiftUI.State<Swift.Bool>
    var _granolaDaysBack: SwiftUI.State<Swift.Int>
    var _includeGranolaTranscripts: SwiftUI.State<Swift.Bool>
    var _isGranolaLoading: SwiftUI.State<Swift.Bool>
    var _granolaError: SwiftUI.State<Swift.String?>
    var _granolaDataFetched: SwiftUI.State<Swift.Bool>
    var _granolaMeetingCount: SwiftUI.State<Swift.Int>
    var _granolaTotalDuration: SwiftUI.State<Swift.Int>
    var _granolaEstimatedTokens: SwiftUI.State<Swift.Int>
    var _granolaTestResults: SwiftUI.State<Swift.String>
    var _showGranolaResults: SwiftUI.State<Swift.Bool>
    var _includeQuill: SwiftUI.State<Swift.Bool>
    var _quillDaysBack: SwiftUI.State<Swift.Int>
    var _includeQuillTranscripts: SwiftUI.State<Swift.Bool>
    var _isQuillLoading: SwiftUI.State<Swift.Bool>
    var _quillError: SwiftUI.State<Swift.String?>
    var _quillDataFetched: SwiftUI.State<Swift.Bool>
    var _quillMeetingCount: SwiftUI.State<Swift.Int>
    var _quillTotalDuration: SwiftUI.State<Swift.Int>
    var _quillEstimatedTokens: SwiftUI.State<Swift.Int>
    var _quillTestResults: SwiftUI.State<Swift.String>
    var _showQuillResults: SwiftUI.State<Swift.Bool>
    var _includeNotion: SwiftUI.State<Swift.Bool>
    var _notionDaysBack: SwiftUI.State<Swift.Int>
    var _includeNotionContent: SwiftUI.State<Swift.Bool>
    var _isNotionLoading: SwiftUI.State<Swift.Bool>
    var _notionError: SwiftUI.State<Swift.String?>
    var _notionDataFetched: SwiftUI.State<Swift.Bool>
    var _notionPageCount: SwiftUI.State<Swift.Int>
    var _notionTotalWords: SwiftUI.State<Swift.Int>
    var _notionEstimatedTokens: SwiftUI.State<Swift.Int>
    var _notionTestResults: SwiftUI.State<Swift.String>
    var _showNotionResults: SwiftUI.State<Swift.Bool>
    var _styleTestInput: SwiftUI.State<Swift.String>
    var _styleTestOutput: SwiftUI.State<Swift.String>
    var _styleTestBusy: SwiftUI.State<Swift.Bool>
    var _styleTestError: SwiftUI.State<Swift.String?>
    var _notionSharedPagesCount: SwiftUI.State<Swift.Int>
    var _notionSharedPagesHints: SwiftUI.State<[Swift.String]>
    var _includeAppleNotes: SwiftUI.State<Swift.Bool>
    var _appleNotesDaysBack: SwiftUI.State<Swift.Int>
    var _includeAppleNotesContent: SwiftUI.State<Swift.Bool>
    var _filterLargeAppleNotes: SwiftUI.State<Swift.Bool>
    var _isAppleNotesLoading: SwiftUI.State<Swift.Bool>
    var _appleNotesError: SwiftUI.State<Swift.String?>
    var _appleNotesDataFetched: SwiftUI.State<Swift.Bool>
    var _appleNotesCount: SwiftUI.State<Swift.Int>
    var _appleNotesTotalWords: SwiftUI.State<Swift.Int>
    var _appleNotesEstimatedTokens: SwiftUI.State<Swift.Int>
    var _appleNotesTestResults: SwiftUI.State<Swift.String>
    var _showAppleNotesResults: SwiftUI.State<Swift.Bool>
    var _includeReminders: SwiftUI.State<Swift.Bool>
    var _isRemindersLoading: SwiftUI.State<Swift.Bool>
    var _remindersError: SwiftUI.State<Swift.String?>
    var _remindersDataFetched: SwiftUI.State<Swift.Bool>
    var _remindersListCount: SwiftUI.State<Swift.Int>
    var _remindersTotalCount: SwiftUI.State<Swift.Int>
    var _remindersCompletedCount: SwiftUI.State<Swift.Int>
    var _remindersTestResults: SwiftUI.State<Swift.String>
    var _showRemindersResults: SwiftUI.State<Swift.Bool>
    var _includeScreenTime: SwiftUI.State<Swift.Bool>
    var _isScreenTimeLoading: SwiftUI.State<Swift.Bool>
    var _screenTimeError: SwiftUI.State<Swift.String?>
    var _screenTimeDataFetched: SwiftUI.State<Swift.Bool>
    var _screenTimeDeviceCount: SwiftUI.State<Swift.Int>
    var _screenTimeDaysCount: SwiftUI.State<Swift.Int>
    var _screenTimeAppCount: SwiftUI.State<Swift.Int>
    var _screenTimeTestResults: SwiftUI.State<Swift.String>
    var _showScreenTimeResults: SwiftUI.State<Swift.Bool>
    var _isAnalyzingUserState: SwiftUI.State<Swift.Bool>
    var _userStateJSON: SwiftUI.State<Swift.String>
    var _userStateError: SwiftUI.State<Swift.String?>
    var _showUserStateSheet: SwiftUI.State<Swift.Bool>
    var _savedUserStateJSON: SwiftUI.State<Swift.String?>
    var streamsAndEventsJSONStructure: Swift.String
}
struct GmailResultsView {
    struct EmailRowView {
        let email: [Swift.String : Any]
        let index: Swift.Int
    }
    struct ProfileBuilderTestView_Previews {}
    let results: Swift.String
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _showRawJSON: SwiftUI.State<Swift.Bool>
    var _searchText: SwiftUI.State<Swift.String>
}
struct GmailAccountManagerView {
    var _connectedAccounts: SwiftUI.Binding<[Spec.GmailAccount]>
    var _selectedAccounts: SwiftUI.Binding<Swift.Set<Swift.String>>
    let authViewModel: Spec.AuthViewModel
    var _isAddingAccount: SwiftUI.State<Swift.Bool>
    var _errorMessage: SwiftUI.State<Swift.String?>
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
}
struct GranolaResultsView {
    let results: Swift.String
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _showRawJSON: SwiftUI.State<Swift.Bool>
    var _searchText: SwiftUI.State<Swift.String>
    var _sortByDate: SwiftUI.State<Swift.Bool>
}
struct ChromeResultsView {
    struct HistoryItemView {
        let item: [Swift.String : Any]
    }
    struct BookmarkItemView {
        let item: [Swift.String : Any]
    }
    struct EmptySearchView {
        let type: Swift.String
    }
    let results: Swift.String
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _showRawJSON: SwiftUI.State<Swift.Bool>
    var _searchText: SwiftUI.State<Swift.String>
    var _selectedTab: SwiftUI.State<Swift.Int>
    var _sortByMostVisited: SwiftUI.State<Swift.Bool>
}
struct WhatsAppResultsView {
    struct ConversationView {
        let conversation: [Swift.String : Any]
        var _isExpanded: SwiftUI.State<Swift.Bool>
    }
    struct MessageBubbleView {
        let message: [Swift.String : Any]
    }
    let results: Swift.String
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _showRawJSON: SwiftUI.State<Swift.Bool>
    var _searchText: SwiftUI.State<Swift.String>
}
struct NotionResultsView {
    let results: Swift.String
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _showRawJSON: SwiftUI.State<Swift.Bool>
    var _searchText: SwiftUI.State<Swift.String>
    var _sortByDate: SwiftUI.State<Swift.Bool>
}
struct NotionPageRow {
    let page: [Swift.String : Any]
    let index: Swift.Int
    var _isExpanded: SwiftUI.State<Swift.Bool>
}
struct AppleNotesResultsView {
    let results: Swift.String
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _showRawJSON: SwiftUI.State<Swift.Bool>
    var _searchText: SwiftUI.State<Swift.String>
    var _sortByDate: SwiftUI.State<Swift.Bool>
    var _selectedFolder: SwiftUI.State<Swift.String>
}
struct AppleNoteRow {
    let note: [Swift.String : Any]
    let index: Swift.Int
    var _isExpanded: SwiftUI.State<Swift.Bool>
}
struct RemindersResultsView {
    let results: Swift.String
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _copied: SwiftUI.State<Swift.Bool>
}
struct ScreenTimeResultsView {
    let results: Swift.String
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _showRawJSON: SwiftUI.State<Swift.Bool>
    var _selectedDevice: SwiftUI.State<Swift.String>
}
struct SavedDataView {
    let title: Swift.String
    let jsonString: Swift.String
    let onDismiss: () -> ()
    var _copiedToClipboard: SwiftUI.State<Swift.Bool>
}
struct ProfileBuilderView {
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _profileService: SwiftUI.StateObject<Spec.UserProfileBuilderService>
    var _showOnboarding: SwiftUI.State<Swift.Bool>
    var _hasExistingProfile: SwiftUI.State<Swift.Bool>
    var _showDatabaseView: SwiftUI.State<Swift.Bool>
    var _modelDisplayName: SwiftUI.State<Swift.String>
    var _modelIcon: SwiftUI.State<Swift.String>
}
struct ProfileQuestionsView {
    let summary: Swift.String
    let questions: [[Swift.String : Swift.String]]
    let onSubmit: (_: [Swift.String : Swift.String]) -> ()
    let onSkip: () -> ()
    var _answers: SwiftUI.State<[Swift.String : Swift.String]>
}
struct ProfileStatusView {
    var _profileExists: SwiftUI.State<Swift.Bool>
    var _profileName: SwiftUI.State<Swift.String?>
}
struct ProfileDatabaseView {
    var _selectedTable: SwiftUI.State<Swift.String>
    var _tableData: SwiftUI.State<[[Swift.String : Any]]>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _errorMessage: SwiftUI.State<Swift.String?>
    var _expandedRows: SwiftUI.State<Swift.Set<Swift.Int>>
    var _showClearConfirmation: SwiftUI.State<Swift.Bool>
    let tables: [Swift.String]
}
struct DatabaseRowView {
    let row: [Swift.String : Any]
    let tableName: Swift.String
    let isExpanded: Swift.Bool
    let onToggle: () -> ()
}
class QuickSummarizePopupModel {
    var _showContext: Combine.Published<Swift.Bool>
    var _contextText: Combine.Published<Swift.String>
    var _suggestedReply: Combine.Published<Swift.String>
    var _showOpenRelated: Combine.Published<Swift.Bool>
}
class QuickSummarizePopupManager {
    var window: __C.NSWindow?
    var hosting: SwiftUI.NSHostingController<SwiftUI.AnyView>?
    var mouseTimer: __C.NSTimer?
    var autoDismissTimer: __C.NSTimer?
    let horizontalOffset: CoreGraphics.CGFloat
    let verticalOffset: CoreGraphics.CGFloat
    let model: Spec.QuickSummarizePopupModel
    var currentContactTitle: Swift.String?
    var currentChatGuid: Swift.String?
    var currentPlatform: Swift.String?
    var draftCache: [Swift.String : (context: Swift.String, reply: Swift.String, timestamp: Foundation.Date)]
    var titleToChatGuidCache: [Swift.String : Swift.String]
    let cacheValidityDuration: Swift.Double
    var appChangeObserver: Any?
    var chatChangeObserver: Any?
    var slackChangeObserver: Any?
    var escMonitor: Any?
    var eventTap: __C.CFMachPort?
    var runLoopSource: __C.CFRunLoopSource?
    var escEventTap: __C.CFMachPort?
    var escRunLoopSource: __C.CFRunLoopSource?
}
struct QuickSummarizePopupView {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _model: SwiftUI.EnvironmentObject<Spec.QuickSummarizePopupModel>
}
struct KeyCapView {
    let label: Swift.String
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct GlassOrFallback {
    let cornerRadius: CoreGraphics.CGFloat
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
enum ReasoningEffort {
    case fast
    case smart
}
struct ReasoningEffortPicker {
    var _selection: SwiftUI.Binding<Spec.ReasoningEffort>
    var _menuVisible: SwiftUI.State<Swift.Bool>
    var _animation: SwiftUI.Namespace
}
struct ReasoningEffortPicker_Previews {
    struct Wrapper {
        var _selection: SwiftUI.State<Spec.ReasoningEffort>
    }
}
struct RingSpinner {
    let spinDuration: Swift.Double
    let lineWidth: CoreGraphics.CGFloat
    let trimAmount: CoreGraphics.CGFloat
    var _spinning: SwiftUI.State<Swift.Bool>
}
struct ScaleButtonStyle {}
struct ShimmerEffect {
    var _phase: SwiftUI.State<CoreGraphics.CGFloat>
}
struct SidebarButton {
    var _isSidebarCollapsed: SwiftUI.Binding<Swift.Bool>
    var isInHeader: Swift.Bool
}
struct SimpleThreadDiscoveryView {
    var _kgBuilder: SwiftUI.StateObject<Spec.KnowledgeGraphBuilder>
    var _threadService: SwiftUI.StateObject<Spec.ThreadDiscoveryService>
    var _llmAgent: SwiftUI.StateObject<Spec.KnowledgeGraphLLMAgent>
    var _selectedPhase: SwiftUI.State<Swift.Int>
    var _showingThreadDetail: SwiftUI.State<Swift.Bool>
    var _selectedThread: SwiftUI.State<Spec.WorkThread?>
}
struct StatusCard {
    let title: Swift.String
    let status: Spec.KGProcessingStatus?
    let isProcessing: Swift.Bool
    let icon: Swift.String
}
struct SimpleThreadRow {
    let thread: Spec.WorkThread
}
struct ThreadDetailView {
    let thread: Spec.WorkThread
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
}
struct StatBox {
    let title: Swift.String
    let value: Swift.String
    let icon: Swift.String
}
struct FlowLayout {
    struct FlowResult {
        var size: __C.CGSize
        var positions: [__C.CGPoint]
    }
    var spacing: CoreGraphics.CGFloat
}
struct SlackReplyPreviewView {
    let teamId: Swift.String
    let channelId: Swift.String
    let channelName: Swift.String
    let threadTs: Swift.String?
    let initialMessage: Swift.String
    let onSend: (_: Swift.String) -> ()
    let onCancel: () -> ()
    var _messageText: SwiftUI.State<Swift.String>
    var _isExpanded: SwiftUI.State<Swift.Bool>
    var _isLoadingHistory: SwiftUI.State<Swift.Bool>
    var _recentMessages: SwiftUI.State<[[Swift.String : Any]]>
    var _isBodyFocused: SwiftUI.FocusState<Swift.Bool>
}
enum ActivityIndicatorType {
    case large
    case medium
    case small
}
struct MessageFeedbackState {
    var thumbsUpPressed: Swift.Bool
    var thumbsDownPressed: Swift.Bool
    var showFeedbackInput: Swift.Bool
    var feedbackText: Swift.String
}
class FeedbackStateManager {
    var _states: Combine.Published<[Foundation.UUID : Spec.MessageFeedbackState]>
}
struct InlineToolInfo {
    enum State {
        case active
        case completed
        case error
    }
    let id: Swift.String
    let name: Swift.String
    var state: Spec.InlineToolInfo.State
}
struct ActiveBannerTool {
    let id: Swift.String
    let name: Swift.String
    var input: Swift.String?
    var isCompleted: Swift.Bool
    let startedAt: Foundation.Date
}
struct SpecChatView {
    enum ChatConfig {
        case message
        case messageStream
    }
    struct ScrollOffsetReader {
        let coordinateSpace: SwiftUI.CoordinateSpace
        let onChange: (_: CoreGraphics.CGFloat) -> ()
        var _lastOffset: SwiftUI.State<CoreGraphics.CGFloat>
    }
    struct ScrollOffsetPreferenceKey {}
    struct BottomSentinelPosKey {}
    class NotificationObserver {
        var cancellable: Any?
        var _shouldFocus: Combine.Published<Swift.Bool>
    }
    struct EmailReplyPreviewData {
        let from: Swift.String
        let to: Swift.String
        let cc: Swift.String
        let subject: Swift.String
        let initialBody: Swift.String
        let toolUseId: Swift.String
        let replyAll: Swift.Bool
        let isNewDraft: Swift.Bool
        let bcc: Swift.String
    }
    struct SlackReplyPreviewData {
        let teamId: Swift.String
        let channelId: Swift.String
        let channelName: Swift.String
        let threadTs: Swift.String?
        let initialMessage: Swift.String
        let toolUseId: Swift.String
    }
    struct MessagesReplyPreviewData {
        let contactName: Swift.String
        let contactNumber: Swift.String?
        let initialMessage: Swift.String
        let toolUseId: Swift.String
        let contactInfo: [Swift.String : Any]?
        let chatGuid: Swift.String?
    }
    struct XDMReplyPreviewData {
        let conversationId: Swift.String
        let participantUsername: Swift.String
        let participantName: Swift.String?
        let initialMessage: Swift.String
        let toolUseId: Swift.String
    }
    struct SummaryResponse {
        enum CodingKeys {
            case userQuery
            case actionsTaken
            case successfulApproaches
            case failedApproaches
            case remainingActions
            case nextSteps
        }
        let userQuery: Swift.String
        let actionsTaken: [Swift.String]
        let successfulApproaches: [Swift.String]
        let failedApproaches: [Swift.String]
        let remainingActions: [Swift.String]
        let nextSteps: [Swift.String]
    }
    let observable: Spec.MessageFunctionCallingObservable
    let selectedModelId: Swift.String
    var _selectedSegment: SwiftUI.State<Spec.SpecChatView.ChatConfig>
    var _selectedItems: SwiftUI.State<[_PhotosUI_SwiftUI.PhotosPickerItem]>
    var _selectedImages: SwiftUI.State<[SwiftUI.Image]>
    var _selectedImagesEncoded: SwiftUI.State<[Swift.String]>
    var _scrollProxy: SwiftUI.State<SwiftUI.ScrollViewProxy?>
    var _lastActionId: SwiftUI.State<Foundation.UUID?>
    var _showScrollToBottom: SwiftUI.State<Swift.Bool>
    var _isBottomVisible: SwiftUI.State<Swift.Bool>
    var _viewportHeight: SwiftUI.State<CoreGraphics.CGFloat>
    var _historyLoadWindowActive: SwiftUI.State<Swift.Bool>
    var _activeTimers: SwiftUI.State<[Swift.String : Spec.TimerState]>
    var _isThreadPinned: SwiftUI.State<Swift.Bool>
    var _timerPublisher: SwiftUI.State<TimerPublisher?>
    var _timerCancellable: SwiftUI.State<Combine.Cancellable?>
    var _showNetworkError: SwiftUI.State<Swift.Bool>
    var _networkErrorMessage: SwiftUI.State<Swift.String>
    var _overlayWidth: SwiftUI.State<CoreGraphics.CGFloat>
    var _isDraggingWidth: SwiftUI.State<Swift.Bool>
    var _isStreamError: SwiftUI.State<Swift.Bool>
    var _isLLMBanned: SwiftUI.State<Swift.Bool>
    var _showSummarizationModal: SwiftUI.State<Swift.Bool>
    var _summarizationUsagePercent: SwiftUI.State<Swift.Double>
    var _isSummarizingAuto: SwiftUI.State<Swift.Bool>
    var _processedIdleToolIds: SwiftUI.State<Swift.Set<Swift.String>>
    var _activeNonIdleToolCount: SwiftUI.State<Swift.Int>
    var _toolsByMessageId: SwiftUI.State<[Foundation.UUID : [Spec.InlineToolInfo]]>
    var _pendingTools: SwiftUI.State<[Spec.InlineToolInfo]>
    var _pendingFileActivities: SwiftUI.State<[(kind: Swift.String, path: Swift.String)]>
    var _activeBannerToolsById: SwiftUI.State<[Swift.String : Spec.ActiveBannerTool]>
    var _observerTokens: SwiftUI.State<[Any]>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _showActivityIndicator: SwiftUI.State<Swift.Bool>
    var _showReadyIndicator: SwiftUI.State<Swift.Bool>
    var _showAskingUserIndicator: SwiftUI.State<Swift.Bool>
    var _chatTitleModel: SwiftUI.ObservedObject<Spec.ChatTitleModel>
    var _messageText: SwiftUI.Binding<Swift.String>
    var _isSidebarCollapsed: SwiftUI.Binding<Swift.Bool>
    var _isConversationLoading: SwiftUI.Binding<Swift.Bool>
    var _specChatViewOpacity: SwiftUI.Binding<Swift.Double>
    var previousChats: [(id: Swift.String, title: Swift.String, icon: Swift.String)]
    var onTitleGenerated: ((_: Swift.String) -> ())?
    var _actions: SwiftUI.Binding<[Spec.AIAction]>
    let onSubmit: () -> ()
    let onDismiss: () -> ()
    let simulateAIProcessing: (_: Swift.String) -> ()
    let onNewChat: () -> ()
    var onTitleUpdated: ((_: Swift.String) -> ())?
    let hideInputField: Swift.Bool
    var _isTextFieldFocused: SwiftUI.FocusState<Swift.Bool>
    var _notificationObserver: SwiftUI.StateObject<Spec.SpecChatView.NotificationObserver>
    var _lastVisibleItemId: SwiftUI.State<Foundation.UUID?>
    var _processingUserMessage: SwiftUI.State<Swift.Bool>
    var _queuedUserMessage: SwiftUI.State<Swift.String?>
    var _isProcessingToolResponse: SwiftUI.State<Swift.Bool>
    var _isMessageProcessing: SwiftUI.State<Swift.Bool>
    var _wasStreamStopped: SwiftUI.State<Swift.Bool>
    var _inputDragProgress: SwiftUI.Binding<CoreGraphics.CGFloat>
    var _lastUserMessageScrolledId: SwiftUI.State<Foundation.UUID?>
    var _pinnedUserMessageId: SwiftUI.State<Foundation.UUID?>
    var _feedbackManager: SwiftUI.StateObject<Spec.FeedbackStateManager>
    var _thinkingText: SwiftUI.State<Swift.String>
    var _showThinkingOverlay: SwiftUI.State<Swift.Bool>
    var _thinkingOverlayText: SwiftUI.State<Swift.String>
    var _thinkingState: SwiftUI.ObservedObject<Spec.ThinkingState>
    var _isThinkingCollapsed: SwiftUI.State<Swift.Bool>
    var _pendingThinkingText: SwiftUI.State<Swift.String>
    var _lastThinkingUIUpdate: SwiftUI.State<Foundation.Date>
    var _thinkingUpdateTimer: SwiftUI.State<__C.NSTimer?>
    var _selectedReasoningEffort: SwiftUI.State<Spec.ReasoningEffort>
    var _isReasoningCollapsed: SwiftUI.State<Swift.Bool>
    var _reasoningPanelText: SwiftUI.State<Swift.String>
    var _showEmailReplyPreview: SwiftUI.State<Swift.Bool>
    var _emailReplyPreviewData: SwiftUI.State<Spec.SpecChatView.EmailReplyPreviewData?>
    var _showMessagesReplyPreview: SwiftUI.State<Swift.Bool>
    var _messagesReplyPreviewData: SwiftUI.State<Spec.SpecChatView.MessagesReplyPreviewData?>
    var _showSlackReplyPreview: SwiftUI.State<Swift.Bool>
    var _slackReplyPreviewData: SwiftUI.State<Spec.SpecChatView.SlackReplyPreviewData?>
    var _showXDMReplyPreview: SwiftUI.State<Swift.Bool>
    var _xdmReplyPreviewData: SwiftUI.State<Spec.SpecChatView.XDMReplyPreviewData?>
    let updateTrigger: Foundation.UUID
    var _messageToolRefreshTrigger: SwiftUI.Binding<[Foundation.UUID : Swift.Int]>
    var _isSummarizing: SwiftUI.State<Swift.Bool>
    var _conversationSummary: SwiftUI.State<Spec.ConversationSummary?>
    var _showSummarySuccess: SwiftUI.State<Swift.Bool>
    var onModelChange: ((_: Spec.Model) -> ())?
}
struct PerActionThinkingView {
    let thinkingText: Swift.String
    let isStreaming: Swift.Bool
    let durationSeconds: Swift.Double?
    var _isCollapsed: SwiftUI.State<Swift.Bool>
}
struct ThinkingDisplayView {
    let thinkingText: Swift.String
    let isStreaming: Swift.Bool
    let durationSeconds: Swift.Double?
    var _isCollapsed: SwiftUI.Binding<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct InlineToolsList {
    let tools: [Spec.InlineToolInfo]
}
struct ActiveToolsBanner {
    struct BannerItemView {
        let item: Spec.ActiveBannerTool
        let observable: Spec.MessageFunctionCallingObservable
        var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    }
    let items: [Spec.ActiveBannerTool]
    let observable: Spec.MessageFunctionCallingObservable
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct CustomChatBubble {
    var cornerRadius: CoreGraphics.CGFloat
    var sharpCorners: Spec.RectCorner
}
struct RectCorner {
    let rawValue: Swift.Int
}
struct UserMessageView {
    let message: Swift.String
    let actionId: Foundation.UUID
    var attachments: [Spec.Attachment]
    var _isHovering: SwiftUI.State<Swift.Bool>
    var _isCopied: SwiftUI.State<Swift.Bool>
    let isLastMessage: Swift.Bool
    let hasNoResponse: Swift.Bool
    let onRetry: (() -> ())?
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct AIMessageCopyButton {
    let text: Swift.String
    let chatTitle: Swift.String
    let isCompleted: Swift.Bool
    var _isCopied: SwiftUI.State<Swift.Bool>
    var _isCreatingNote: SwiftUI.State<Swift.Bool>
    var _noteCreated: SwiftUI.State<Swift.Bool>
    var _isCreatingNotion: SwiftUI.State<Swift.Bool>
    var _notionCreated: SwiftUI.State<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
class FeedbackTextFieldState {
    var _text: Combine.Published<Swift.String>
}
struct FeedbackInputView {
    var _textState: SwiftUI.StateObject<Spec.FeedbackTextFieldState>
    let initialText: Swift.String
    let onCancel: () -> ()
    let onSend: (_: Swift.String) -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct AIMessageFeedbackButtons {
    let text: Swift.String
    let chatTitle: Swift.String
    let isCompleted: Swift.Bool
    let messageId: Foundation.UUID
    var _feedbackState: SwiftUI.Binding<Spec.MessageFeedbackState>
    var _isCopied: SwiftUI.State<Swift.Bool>
    var _isCreatingNote: SwiftUI.State<Swift.Bool>
    var _noteCreated: SwiftUI.State<Swift.Bool>
    var _isCreatingNotion: SwiftUI.State<Swift.Bool>
    var _notionCreated: SwiftUI.State<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct AttachmentPreviewView {
    let attachment: Spec.Attachment
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _cachedImage: SwiftUI.State<__C.NSImage?>
    var _cachedIcon: SwiftUI.State<__C.NSImage?>
}
struct TimelineInteractor {
    let actions: [Spec.AIAction]
    let scrollProxy: SwiftUI.ScrollViewProxy
    var _selectedIndex: SwiftUI.State<Swift.Int>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct TimelineInteractorOverlay {
    let actions: [Spec.AIAction]
    let scrollProxy: SwiftUI.ScrollViewProxy?
}
struct EquatableMarkdownText {
    let text: Swift.String
    let trimmedText: Swift.String
}
struct IsolatedUpdates {}
struct StreamingMarkdownText {
    let text: Swift.String
    let isComplete: Swift.Bool
}
struct AnimatedStreamingMarkdownText {
    let text: Swift.String
    var charactersPerSecond: Swift.Double
    var showsCaret: Swift.Bool
    var _displayedText: SwiftUI.State<Swift.String>
    var _typingTask: SwiftUI.State<Swift.Task<(), Swift.Never>?>
}
struct FadingStreamingMarkdownText {
    let text: Swift.String
    var initialOpacity: Swift.Double
    var duration: Swift.Double
    var _fadeOpacity: SwiftUI.State<Swift.Double>
    var _baseText: SwiftUI.State<Swift.String>
    var _overlayText: SwiftUI.State<Swift.String>
    var _didAppear: SwiftUI.State<Swift.Bool>
}
struct OptimizedStreamingMarkdownText {
    let text: Swift.String
    var _displayedText: SwiftUI.State<Swift.String>
}
struct InstantStreamingMarkdownText {
    let text: Swift.String
    var _displayedText: SwiftUI.State<Swift.String>
    var _contentId: SwiftUI.State<Foundation.UUID>
}
struct RateLimitedStreamingMarkdownText {
    let text: Swift.String
    var charactersPerSecond: Swift.Double
    var maxUpdatesPerSecond: Swift.Double
    var fadeInitialOpacity: Swift.Double
    var fadeDuration: Swift.Double
    var _targetText: SwiftUI.State<Swift.String>
    var _visibleText: SwiftUI.State<Swift.String>
    var _tickTask: SwiftUI.State<Swift.Task<(), Swift.Never>?>
}
struct FeedbackButtonsWrapper {
    let text: Swift.String
    let chatTitle: Swift.String
    let isCompleted: Swift.Bool
    let messageId: Foundation.UUID
    var _feedbackManager: SwiftUI.ObservedObject<Spec.FeedbackStateManager>
}
struct StreamingMessageContainer {
    let displayText: Swift.String
    let chatTitle: Swift.String
    let isCompleted: Swift.Bool
    let messageId: Foundation.UUID
    var _feedbackManager: SwiftUI.ObservedObject<Spec.FeedbackStateManager>
    var showFeedbackButtons: Swift.Bool
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct ActionItemView {
    let action: Spec.AIAction
    let chatTitle: Swift.String
    var _activeTimers: SwiftUI.Binding<[Swift.String : Spec.TimerState]>
    let observable: Spec.MessageFunctionCallingObservable
    let refreshTrigger: Swift.Int
    var _feedbackManager: SwiftUI.ObservedObject<Spec.FeedbackStateManager>
    let isLastAction: Swift.Bool
    let simulateAIProcessing: ((_: Swift.String) -> ())?
    let inlineToolsProvider: (_: Foundation.UUID) -> [Spec.InlineToolInfo]
}
struct MessageListView {
    struct AIActionGroup {
        enum GroupType {
            case toolGroup(Swift.String)
            case single
            case collapsedToolGroup
        }
        let actions: [Spec.AIAction]
        let type: Spec.MessageListView.AIActionGroup.GroupType
    }
    let actions: [Spec.AIAction]
    let chatTitle: Swift.String
    var _activeTimers: SwiftUI.Binding<[Swift.String : Spec.TimerState]>
    var _lastVisibleItemId: SwiftUI.Binding<Foundation.UUID?>
    let observable: Spec.MessageFunctionCallingObservable
    var _showEmailReplyPreview: SwiftUI.Binding<Swift.Bool>
    var _emailReplyPreviewData: SwiftUI.Binding<Spec.SpecChatView.EmailReplyPreviewData?>
    var _showMessagesReplyPreview: SwiftUI.Binding<Swift.Bool>
    var _messagesReplyPreviewData: SwiftUI.Binding<Spec.SpecChatView.MessagesReplyPreviewData?>
    var _showSlackReplyPreview: SwiftUI.Binding<Swift.Bool>
    var _slackReplyPreviewData: SwiftUI.Binding<Spec.SpecChatView.SlackReplyPreviewData?>
    var _showXDMReplyPreview: SwiftUI.Binding<Swift.Bool>
    var _xdmReplyPreviewData: SwiftUI.Binding<Spec.SpecChatView.XDMReplyPreviewData?>
    let simulateAIProcessing: (_: Swift.String) -> ()
    let selectedImages: [SwiftUI.Image]
    let messageToolRefreshTrigger: [Foundation.UUID : Swift.Int]
    var _feedbackManager: SwiftUI.ObservedObject<Spec.FeedbackStateManager>
    var onUserMessageAppear: ((_: Foundation.UUID) -> ())?
    var onBottomVisibilityChange: ((_: Swift.Bool) -> ())?
    let userMessageSnapBottomPaddingFallback: CoreGraphics.CGFloat
    let viewportHeight: CoreGraphics.CGFloat?
    let pinnedUserMessageId: Foundation.UUID?
    let inlineToolsForAction: (_: Foundation.UUID) -> [Spec.InlineToolInfo]
    var _isThinkingCollapsed: SwiftUI.Binding<Swift.Bool>
    let topSnapInset: CoreGraphics.CGFloat
    var _expandedGroups: SwiftUI.State<Swift.Set<Swift.String>>
}
struct SpecGreetingBubbleView {
    var message: Swift.String
    var leadingIcon: Swift.String?
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct SpecLogoBlinkView {
    var imageName: Swift.String
    var ringThicknessRatio: CoreGraphics.CGFloat
    var bgColor: SwiftUI.Color
    var autoBlink: Swift.Bool
    var blinkDuration: Swift.Double
    var holdClosed: Swift.Double
    var eyeOffsetRatio: __C.CGSize?
    var blinkDiameterRatio: CoreGraphics.CGFloat?
    var _blinkTrigger: SwiftUI.Binding<Swift.Int>
    var _blinkProgress: SwiftUI.State<CoreGraphics.CGFloat>
}
struct BlinkLids {
    let progress: CoreGraphics.CGFloat
    let ringThicknessRatio: CoreGraphics.CGFloat
    let lidColor: SwiftUI.Color
}
struct BlinkSmallLids {
    let progress: CoreGraphics.CGFloat
    let lidColor: SwiftUI.Color
}
struct StreamData {
    let id: Foundation.UUID
    let stream_id: Swift.String
    let stream_title: Swift.String
    let stream_description: Swift.String?
    let stream_sfsymbol_icon: Swift.String?
    let people_involved: [[Swift.String : Any]]?
    let created_at: Swift.String?
    let current_status: Swift.String?
    let is_active: Swift.Bool?
    let event_ids: [Swift.String]?
    let stream_nodes: [[Swift.String : Any]]?
    let is_professional: Swift.Bool?
    let is_personal: Swift.Bool?
    let current_urgency: Swift.Double?
}
struct StreamsOverviewViewIntegrated {
    struct StreamsScrollOffsetKey {}
    struct SeededRNG {
        var state: Swift.UInt64
    }
    let onStreamSelected: (_: Spec.StreamData) -> ()
    var _streams: SwiftUI.State<[Spec.StreamData]>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _errorMessage: SwiftUI.State<Swift.String?>
    var _hoveredStreamId: SwiftUI.State<Swift.String?>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _streamPriorityMapCache: SwiftUI.State<[Swift.String : Swift.Double]>
    let enableOrbitLogs: Swift.Bool
    var _mePhotoBase64: SwiftUI.State<Swift.String?>
    var _scrollOffsetY: SwiftUI.State<CoreGraphics.CGFloat>
    var _initialContentTopY: SwiftUI.State<CoreGraphics.CGFloat?>
    var _cachedSatellites: SwiftUI.State<[Spec.OrbitSatellite]>
}
struct StreamRowView {
    let stream: Spec.StreamData
    let isHovered: Swift.Bool
    let onTap: () -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _cachedSymbolName: SwiftUI.State<Swift.String>
}
struct StreamTimelineViewIntegrated {
    struct PersonBadge {
        let id: Foundation.UUID
        let name: Swift.String
        let avatarRef: Swift.String?
    }
    let stream: Spec.StreamData
    var _events: SwiftUI.State<[Spec.SpecEvent]>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _selectedRowIndex: SwiftUI.State<Swift.Int>
    var _hasHoveredAnyRow: SwiftUI.State<Swift.Bool>
    var _currentTimeString: SwiftUI.State<Swift.String>
    var _timeStrings: SwiftUI.State<[Swift.String]>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _eventParticipants: SwiftUI.State<[[Spec.StreamTimelineViewIntegrated.PersonBadge]]>
    var _groupedEvents: SwiftUI.State<[(header: Swift.String, subheader: Swift.String, items: [(event: Spec.SpecEvent, index: Swift.Int)])]>
    var _liveStream: SwiftUI.State<Spec.StreamData?>
    let timer: Combine.Publishers.Autoconnect<TimerPublisher>
}
struct ScrollOffsetReader {
    class ObservingView: __C.NSView {
        var onChange: (_: CoreGraphics.CGFloat) -> ()
        weak var observedContentView: __C.NSClipView?
        var observer: __C.NSObject?
        var lastUpdateTime: Swift.Double
        var pendingUpdate: Dispatch.DispatchWorkItem?
        let minimumUpdateInterval: Swift.Double
    }
    let onChange: (_: CoreGraphics.CGFloat) -> ()
}
struct TasksListView {
    var _tasks: SwiftUI.State<[Spec.SpecTask]>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _showCreateSheet: SwiftUI.State<Swift.Bool>
    var _selectedTaskForLogs: SwiftUI.State<Spec.SpecTask?>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct TaskRowView {
    let task: Spec.SpecTask
    var _hovering: SwiftUI.State<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct TaskLogsSheet {
    let task: Spec.SpecTask
    var _logs: SwiftUI.State<[Spec.ExecutionLog]>
    var _expandedLogIds: SwiftUI.State<Swift.Set<Swift.String>>
    var _dismiss: SwiftUI.Environment<SwiftUI.DismissAction>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct CreateTaskSheet {
    var _isPresented: SwiftUI.Binding<Swift.Bool>
    var onCreate: (Swift.String, Swift.String?, Swift.Bool) -> ()
    var _title: SwiftUI.State<Swift.String>
    var _description: SwiftUI.State<Swift.String>
    var _isActive: SwiftUI.State<Swift.Bool>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
class TextFieldFocusBridge {
    weak var lastField: __C.NSTextField?
}
struct TodayTodosView {
    var _todoManager: SwiftUI.ObservedObject<Spec.TodoManager>
    var onTodoSelected: ((_: Spec.Todo) -> ())?
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct TodoCard {
    let todo: Spec.Todo
    let onToggleComplete: () -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _isHovered: SwiftUI.State<Swift.Bool>
}
struct TodayTodosView_Previews {}
struct TodoDetailView {
    let todo: Spec.Todo
    var _todoManager: SwiftUI.ObservedObject<Spec.TodoManager>
    let onDismiss: () -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _titleText: SwiftUI.State<Swift.String>
    var _descriptionText: SwiftUI.State<Swift.String>
    var _dueDate: SwiftUI.State<Foundation.Date?>
    var _isCompleted: SwiftUI.State<Swift.Bool>
    var _priority: SwiftUI.State<Spec.Todo.Priority>
    var _category: SwiftUI.State<Spec.Todo.Category?>
    var _todoType: SwiftUI.State<Spec.Todo.TodoType>
}
class TodoDraftPopupModel {
    var _title: Combine.Published<Swift.String>
    var _content: Combine.Published<Swift.String>
}
class TodoDraftPopupManager {
    var window: __C.NSWindow?
    var hosting: SwiftUI.NSHostingController<Spec.TodoDraftPopupView>?
    var dismissWork: Dispatch.DispatchWorkItem?
    var mouseTimer: __C.NSTimer?
    var keyMonitor: Any?
    let popupSize: __C.CGSize
    let horizontalOffset: CoreGraphics.CGFloat
    let verticalOffset: CoreGraphics.CGFloat
    let model: Spec.TodoDraftPopupModel
}
struct TodoDraftPopupView {
    var _model: SwiftUI.ObservedObject<Spec.TodoDraftPopupModel>
}
class TodoDraftPopupCloneModel {
    var _title: Combine.Published<Swift.String>
    var _content: Combine.Published<Swift.String>
}
class TodoDraftPopupCloneManager {
    var window: __C.NSWindow?
    var hosting: SwiftUI.NSHostingController<Spec.TodoDraftPopupCloneView>?
    var dismissWork: Dispatch.DispatchWorkItem?
    var mouseTimer: __C.NSTimer?
    var keyMonitor: Any?
    var stageObserver: Any?
    var pasteAfterDismiss: Swift.String?
    var popupSize: __C.CGSize
    let horizontalOffset: CoreGraphics.CGFloat
    let verticalOffset: CoreGraphics.CGFloat
    let model: Spec.TodoDraftPopupCloneModel
}
struct TodoDraftPopupCloneView {
    var _model: SwiftUI.ObservedObject<Spec.TodoDraftPopupCloneModel>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _stage: SwiftUI.State<Swift.Int>
}
struct GlassOrFallback {
    let cornerRadius: CoreGraphics.CGFloat
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
}
struct TodoRowView {
    let todo: Spec.Todo
    let onToggleComplete: () -> ()
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _isHovered: SwiftUI.State<Swift.Bool>
}
struct TodoRowView_Previews {}
struct ToolUseRow {
    enum CommandType {
        case shellExec
        case shellWait
        case shellView
        case shellWriteToProcess
        case shellKillProcess
        case browserConsoleView
        case browserConsoleExec
        case browserScrollDown
        case browserScrollUp
        case browserSelectOption
        case browserPressKey
        case browserMoveMouse
        case browserInput
        case browserClick
        case browserRestart
        case browserNavigate
        case browserViewInputFields
        case browserViewUrls
        case browserViewSourceAsText
        case messagesRead
        case messagesDraft
        case messagesFindContact
        case emailRead
        case emailSearch
        case emailDraft
        case emailSend
        case emailListAccounts
        case emailOpenThread
        case emailDraftReply
        case emailConfirmSendReply
        case fileRead
        case fileWrite
        case fileStrReplace
        case fileFindByName
        case fileFindInContent
        case meetingNotesList
        case meetingNotesReadSummary
        case meetingNotesReadTranscript
    }
    let toolName: Swift.String
    let inputDisplay: Swift.String
    let input: Swift.String
    let response: Swift.String?
    let isCompleted: Swift.Bool
    let isError: Swift.Bool
    var _activeTimers: SwiftUI.Binding<[Swift.String : Spec.TimerState]>
    let observable: Spec.MessageFunctionCallingObservable
    let toolUseId: Swift.String
}
struct GroupedToolUseRow {
    struct ToolUseInfo {
        let toolName: Swift.String
        let inputDisplay: Swift.String
        let input: Swift.String
        let response: Swift.String?
        let isCompleted: Swift.Bool
        let isError: Swift.Bool
        let toolUseId: Swift.String
        let parsedData: Any?
    }
    enum CommandType {
        case messagesRead
        case messagesDraft
        case messagesFindContact
        case slackListAccounts
        case slackListConversations
        case slackFindUser
        case slackFindConversation
        case slackRead
        case slackSearchMessages
        case slackOpenThread
        case slackDraftReply
        case slackConfirmSendReply
        case emailRead
        case emailSearch
        case emailDraft
        case emailSend
        case emailListAccounts
        case emailOpenThread
        case emailDraftReply
        case emailConfirmSendReply
        case meetingNotesReadSummary
        case meetingNotesReadTranscript
    }
    let toolUses: [Spec.GroupedToolUseRow.ToolUseInfo]
    var _activeTimers: SwiftUI.Binding<[Swift.String : Spec.TimerState]>
    let observable: Spec.MessageFunctionCallingObservable
}
struct TopPriorityContactsView {
    struct PlacedAggregate {
        let aggregate: Spec.TopPriorityContactsView.ContactAggregate
        var point: __C.CGPoint
        let size: CoreGraphics.CGFloat
    }
    struct ContactAggregate {
        let key: Swift.String
        let name: Swift.String
        var imageRef: Swift.String?
        var count: Swift.Int
        var hasUrgent: Swift.Bool
        var maxUrgency: Swift.Double
        var score: Swift.Double
        let platform: Swift.String
        let handle: Swift.String?
        let dedupeKey: Swift.String
    }
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _aggregates: SwiftUI.State<[Spec.TopPriorityContactsView.ContactAggregate]>
    var _isLoading: SwiftUI.State<Swift.Bool>
    var _refreshID: SwiftUI.State<Foundation.UUID>
    var _replyProcessingCancellable: SwiftUI.State<Combine.AnyCancellable?>
    let maxContacts: Swift.Int
    let baseItemSize: CoreGraphics.CGFloat
}
struct AvatarImageView {
    let imageRef: Swift.String?
    let fallbackName: Swift.String
    let task: Spec.Phase2Task?
    var _resolvedRef: SwiftUI.State<Swift.String?>
}
struct SmallRNG {
    var state: Swift.UInt64
}
struct PulseView {
    struct SeededRNG {
        var state: Swift.UInt64
    }
    struct ContactAggregate {
        let key: Swift.String
        let name: Swift.String
        var imageRef: Swift.String?
        var count: Swift.Int
        var hasUrgent: Swift.Bool
        var maxUrgency: Swift.Double
        var score: Swift.Double
        var primaryTask: Spec.Phase2Task
    }
    var _taskManager: SwiftUI.StateObject<Spec.Phase2TaskManager>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _mePhotoBase64: SwiftUI.State<Swift.String?>
    var _cachedSatellites: SwiftUI.State<[Spec.OrbitSatellite]>
    var _scrollOffsetY: SwiftUI.State<CoreGraphics.CGFloat>
    var _hasBuiltOnce: SwiftUI.State<Swift.Bool>
    var _isScrollUpdateScheduled: SwiftUI.State<Swift.Bool>
    var _pendingScrollOffsetY: SwiftUI.State<CoreGraphics.CGFloat?>
    var _visibleDraftCount: SwiftUI.State<Swift.Int>
    let draftsPageSize: Swift.Int
    var _contactAggregatesCache: SwiftUI.State<[Spec.PulseView.ContactAggregate]>
    let enableOrbitLogs: Swift.Bool
    let maxSatellites: Swift.Int
}
struct PulseTodoDraftCard {
    enum QuickAction {
        case agree
        case requestChanges
        case think
    }
    struct SourceChip {
        let id: Foundation.UUID
        let app: Swift.String
        let title: Swift.String
        let url: Swift.String
        let chatGuid: Swift.String?
        let handle: Swift.String?
    }
    enum TodoAction {
        case completed
        case unneeded
    }
    struct ChipHeightPreferenceKey {}
    struct RoundedCornerShape {
        var topLeft: CoreGraphics.CGFloat
        var topRight: CoreGraphics.CGFloat
        var bottomRight: CoreGraphics.CGFloat
        var bottomLeft: CoreGraphics.CGFloat
    }
    let task: Spec.Phase2Task
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _edited: SwiftUI.State<Swift.String>
    var _hasLoaded: SwiftUI.State<Swift.Bool>
    var _selectedQuick: SwiftUI.State<Spec.PulseTodoDraftCard.QuickAction>
    var _selectedActionIndex: SwiftUI.State<Swift.Int>
    var _resolvedImageRef: SwiftUI.State<Swift.String?>
    var _isSending: SwiftUI.State<Swift.Bool>
    var _animateAway: SwiftUI.State<Swift.Bool>
    var _chipRowHeight: SwiftUI.State<CoreGraphics.CGFloat>
}
struct PulseScrollOffsetReader {
    class ObservingView: __C.NSView {
        var onChange: (_: CoreGraphics.CGFloat) -> ()
        weak var observedContentView: __C.NSClipView?
        var observer: __C.NSObject?
        var lastUpdateTime: Swift.Double
        var pendingUpdate: Dispatch.DispatchWorkItem?
        let minimumUpdateInterval: Swift.Double
    }
    let onChange: (_: CoreGraphics.CGFloat) -> ()
}
struct TypingIndicatorBubbleView {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var dotCount: Swift.Int
    var size: CoreGraphics.CGFloat
    var spacing: CoreGraphics.CGFloat
    var cycleDuration: Swift.Double
    var _phase: SwiftUI.State<Swift.Double>
}
struct TypingTextView {
    let text: Swift.String
    var typingInterval: Swift.Double
    var caretBlinkInterval: Swift.Double
    var font: SwiftUI.Font
    var caretSymbol: Swift.String
    var _displayedText: SwiftUI.State<Swift.String>
    var _caretVisible: SwiftUI.State<Swift.Bool>
    var _typingTask: SwiftUI.State<Swift.Task<(), Swift.Never>?>
    var _caretTask: SwiftUI.State<Swift.Task<(), Swift.Never>?>
}
struct UndoVisualEffectView {
    let material: __C.Material
    let blendingMode: __C.BlendingMode
}
struct VisualEffectView {
    let material: __C.Material
    let blendingMode: __C.BlendingMode
}
struct WordFadeText {
    let paragraphs: [[Swift.String]]
    let font: SwiftUI.Font
    let wordSpacing: CoreGraphics.CGFloat
    let lineSpacing: CoreGraphics.CGFloat
    let fadeDuration: Swift.Double
    let wordDelay: Swift.Double
    let textColor: SwiftUI.Color
    var _play: SwiftUI.State<Swift.Bool>
}
struct WordFadeParagraph {
    let words: [Swift.String]
    let font: SwiftUI.Font
    let wordSpacing: CoreGraphics.CGFloat
    let fadeDuration: Swift.Double
    let baseDelay: Swift.Double
    let wordDelay: Swift.Double
    let color: SwiftUI.Color
    let play: Swift.Bool
}
struct WordFlowLayout {
    let spacing: CoreGraphics.CGFloat
    let lineSpacing: CoreGraphics.CGFloat
}
struct KeyPressHandler {
    class KeyHandlingView: __C.NSView {
        var onEscape: (() -> ())?
    }
    var onEscape: () -> ()
}
struct CustomTextField {
    class Coordinator: __C.NSObject {
        var parent: Spec.CustomTextField
    }
    class PaddedTextFieldCell: __C.NSTextFieldCell {}
    var _text: SwiftUI.Binding<Swift.String>
    var _isEditing: SwiftUI.Binding<Swift.Bool>
    var onTextChange: (_: Swift.String) -> ()
    var onSubmit: () -> ()
    var onEscape: (() -> ())?
}
class AspectRatioWindowDelegate: __C.NSObject {}
class AppDelegate: __C.NSObject {
    var statusItem: __C.NSStatusItem?
    var workflowBuilderWindow: __C.NSWindow?
    var workflowBuilderWindowController: __C.NSWindowController?
    var thanosTestWindow: __C.NSWindow?
    var conversationConfirmationWindow: __C.NSWindow?
    var thanosTestWindowController: __C.NSWindowController?
    var keyboardShortcutMonitor: Any?
    var workflowWindow: __C.NSWindow?
    var preferencesWindow: __C.NSWindow?
    var cancellables: Swift.Set<Combine.AnyCancellable>
    var modelDownloadCancellable: Combine.AnyCancellable?
    var mainContentWindow: __C.NSWindow?
    var mainContentWindowController: __C.NSWindowController?
    var hotKey: Spec.DoubleCommandHotKey?
    var optionHotKey: Spec.DoubleOptionHotKey?
    var controlHotKey: Spec.DoubleControlHotKey?
    var permissionCheckTimer: __C.NSTimer?
    var optionPermissionCheckTimer: __C.NSTimer?
    var controlPermissionCheckTimer: __C.NSTimer?
    var mainViewController: Spec.MainViewWindowController?
    let doubleTapThresholdSeconds: Swift.Double
    var profileAutoRefreshTimer: __C.NSTimer?
    var replyScanTimer: __C.NSTimer?
    var backgroundRefreshWindow: __C.NSWindow?
    var isBackgroundRefreshRunning: Swift.Bool
    var eventPrepTimer: __C.NSTimer?
    var meetingPrepScanTimer: __C.NSTimer?
    var gmailIndexResolverTimer: __C.NSTimer?
    var lastGranolaRefreshAt: Swift.Double
    var lastQuillRefreshAt: Swift.Double
    var backgroundRefreshActivity: __C.NSObject?
    let granolaRefreshMinInterval: Swift.Double
    let quillRefreshMinInterval: Swift.Double
    var pendingGranolaRefreshWorkItem: Dispatch.DispatchWorkItem?
    var pendingQuillRefreshWorkItem: Dispatch.DispatchWorkItem?
    var relayListener: Spec.RelayListener?
    var authStateHandle: __C.NSObject?
    var messageMonitor: Spec.RealtimeMessageMonitor?
    var granolaWatcher: Spec.GranolaNotesWatcher?
    var quillWatcher: Spec.QuillNotesWatcher?
    var godLogsWindowController: Spec.GodLogsWindowController?
}
class DoubleControlHotKey {
    var threshold: Swift.Double
    var onTrigger: () -> ()
    var eventTap: __C.CFMachPort?
    var lastPressTime: Swift.Double?
    var sawOtherKey: Swift.Bool
    var wasControlDown: Swift.Bool
    var runLoopSource: __C.CFRunLoopSource?
    var tapCheckTimer: __C.NSTimer?
    var appObserver: __C.NSObject?
}
class UrgentLeavePopupManager {
    var window: __C.NSWindow?
    var hostingController: SwiftUI.NSHostingController<Spec.UrgentLeavePopupView>?
}
struct UrgentLeavePopupView {
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var onOrderUber: () -> ()
    var onDismiss: () -> ()
    var _now: SwiftUI.State<Foundation.Date>
    var _isVisible: SwiftUI.State<Swift.Bool>
}
struct AppInfo {
    let id: Foundation.UUID
    let name: Swift.String
    let path: Swift.String
    let icon: __C.NSImage?
}
struct ConditionalShimmer {
    let isActive: Swift.Bool
}
struct ContentView {}
class DoubleCommandHotKey {
    var threshold: Swift.Double
    var onTrigger: () -> ()
    var eventTap: __C.CFMachPort?
    var lastPressTime: Swift.Double?
    var sawOtherKey: Swift.Bool
    var wasCommandDown: Swift.Bool
    var runLoopSource: __C.CFRunLoopSource?
    var tapCheckTimer: __C.NSTimer?
    var appObserver: __C.NSObject?
}
class DoubleOptionHotKey {
    var threshold: Swift.Double
    var onTrigger: () -> ()
    var eventTap: __C.CFMachPort?
    var lastPressTime: Swift.Double?
    var sawOtherKey: Swift.Bool
    var wasOptionDown: Swift.Bool
    var runLoopSource: __C.CFRunLoopSource?
    var tapCheckTimer: __C.NSTimer?
    var appObserver: __C.NSObject?
}
struct KeepAwakeToggle {
    var _keepAwake: SwiftUI.State<Swift.Bool>
}
class RelayListener {
    let vmID: Swift.String
    var listener: __C.FIRListenerRegistration?
    var observables: [Swift.String : Spec.MessageFunctionCallingObservable]
    var observableLastAccess: [Swift.String : Foundation.Date]
    var cleanupTimer: __C.NSTimer?
    let maxObservables: Swift.Int
    let observableInactivityThreshold: Swift.Double
}
class SleepGuard {}
struct SpecApp {
    var _auth: SwiftUI.StateObject<Spec.AuthViewModel>
    var _window: SwiftUI.State<__C.NSWindow?>
    var windowObserver: __C.NSObject?
    var _appDelegate: SwiftUI.NSApplicationDelegateAdaptor<Spec.AppDelegate>
}
class ResourceBundleClass {}
class BundleFinder {}
enum AIProxy {}
actor AIProxyActor {
    var $defaultActor: 
}
class AIProxyCertificatePinningDelegate: __C.NSObject {
    var _progressCallback: (@Sendable (_: Swift.Double) -> ())?
}
struct AIProxyConfiguration {
    let resolveDNSOverTLS: Swift.Bool
    let printRequestBodies: Swift.Bool
    let printResponseBodies: Swift.Bool
    let useStableID: Swift.Bool
    var stableID: Swift.String?
}
enum AIProxyError {
    case assertion(Swift.String)
    case unsuccessfulRequest(statusCode: Swift.Int, responseBody: Swift.String)
    case deviceCheckIsUnavailable
    case deviceCheckBypassIsMissing
}
enum AIProxyHTTPVerb {
    case automatic
    case get
    case post
    case put
    case delete
    case patch
}
enum AIProxyJSONValue {
    case null(__C.NSNull)
    case bool(Swift.Bool)
    case int(Swift.Int)
    case double(Swift.Double)
    case string(Swift.String)
    case array([AIProxy.AIProxyJSONValue])
    case object([Swift.String : AIProxy.AIProxyJSONValue])
}
enum AIProxyLogLevel {
    case debug
    case info
    case warning
    case error
    case critical
}
enum AIProxyURLSession {}
struct AIProxyKeychain {
    let keychainServiceName: Swift.String
    let secClass: __C.NSCopying
    let secAttrGeneric: __C.NSCopying
    let secAttrAccount: __C.NSCopying
    let secAttrService: __C.NSCopying
    let secAttrSynchronizable: __C.NSCopying
    let secMatchLimit: __C.NSCopying
    let secReturnData: __C.NSCopying
    let secValueData: __C.NSCopying
    let cfBooleanTrue: __C.CFBoolean
}
class AIProxyStorage {}
struct AnonymousAccount {
    enum CodingKeys {
        case uuid
        case timestamp
    }
    let uuid: Swift.String
    let timestamp: Swift.Double
}
class AnonymousAccountStorage {}
struct AnthropicAsyncChunks {
    struct AsyncIterator {
        var asyncBytesIterator: Foundation.AsyncLineSequence<AsyncBytes>.AsyncIterator
    }
    let asyncLines: Foundation.AsyncLineSequence<AsyncBytes>
}
class AnthropicDirectService {
    let unprotectedAPIKey: Swift.String
    let baseURL: Swift.String
}
struct AnthropicMessageRequestBody {
    enum CodingKeys {
        case maxTokens
        case messages
        case model
        case metadata
        case stopSequences
        case stream
        case system
        case temperature
        case toolChoice
        case tools
        case topK
        case topP
    }
    let maxTokens: Swift.Int
    let messages: [AIProxy.AnthropicInputMessage]
    let model: Swift.String
    let metadata: AIProxy.AnthropicRequestMetadata?
    let stopSequences: [Swift.String]?
    var stream: Swift.Bool?
    let system: Swift.String?
    let temperature: Swift.Double?
    let toolChoice: AIProxy.AnthropicToolChoice?
    var tools: [AIProxy.AnthropicTool]?
    let topK: Swift.Int?
    let topP: Swift.Double?
}
enum AnthropicImageMediaType {
    case jpeg
    case png
    case gif
    case webp
}
enum AnthropicInputContent {
    enum CodingKeys {
        case image
        case source
        case text
        case type
        case id
        case name
        case input
        case toolUseId
        case content
    }
    enum SourceCodingKeys {
        case type
        case mediaType
        case data
    }
    case image(mediaType: AIProxy.AnthropicImageMediaType, data: Swift.String)
    case pdf(data: Swift.String)
    case text(Swift.String)
    case toolUse(id: Swift.String, name: Swift.String, input: [Swift.String : AIProxy.AIProxyJSONValue])
    case toolResult(toolUseId: Swift.String, content: Swift.String)
}
struct AnthropicInputMessage {
    enum CodingKeys {
        case content
        case role
    }
    let content: [AIProxy.AnthropicInputContent]
    let role: AIProxy.AnthropicInputMessageRole
}
enum AnthropicInputMessageRole {
    case assistant
    case user
}
struct AnthropicRequestMetadata {
    enum CodingKeys {
        case userID
    }
    let userID: Swift.String?
}
enum AnthropicToolChoice {
    enum CodingKeys {
        case type
        case name
    }
    case tool(name: Swift.String)
    case any
    case auto
}
struct AnthropicTool {
    enum CodingKeys {
        case description
        case inputSchema
        case name
    }
    let description: Swift.String
    var inputSchema: [Swift.String : AIProxy.AIProxyJSONValue]
    let name: Swift.String
}
struct AnthropicMessageResponseBody {
    enum CodingKeys {
        case content
        case id
        case model
        case role
        case stopReason
        case stopSequence
        case type
        case usage
    }
    var content: [AIProxy.AnthropicMessageResponseContent]
    let id: Swift.String
    let model: Swift.String
    let role: Swift.String
    let stopReason: Swift.String?
    let stopSequence: Swift.String?
    let type: Swift.String
    let usage: AIProxy.AnthropicMessageUsage
}
enum AnthropicMessageResponseContent {
    enum ContentType {
        case text
        case toolUse
    }
    enum CodingKeys {
        case type
        case text
        case id
        case name
        case input
    }
    case text(Swift.String)
    case toolUse(id: Swift.String, name: Swift.String, input: [Swift.String : AIProxy.AIProxyJSONValue])
}
struct AnthropicMessageUsage {
    enum CodingKeys {
        case inputTokens
        case outputTokens
    }
    let inputTokens: Swift.Int
    let outputTokens: Swift.Int
}
enum AnthropicMessageStreamingChunk {
    case text(Swift.String)
    case toolUse(name: Swift.String, input: [Swift.String : Any])
}
struct AnthropicMessageStreamingContentBlockStart {
    enum CodingKeys {
        case contentBlock
    }
    enum ContentBlock {
        enum PossibleTypes {
            case text
            case toolUse
        }
        enum CodingKeys {
            case name
            case text
            case type
        }
        case text(Swift.String)
        case toolUse(name: Swift.String)
    }
    let contentBlock: AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock
}
struct AnthropicMessageStreamingDeltaBlock {
    enum CodingKeys {
        case delta
    }
    enum Delta {
        enum PossibleTypes {
            case textDelta
            case inputJSONDelta
        }
        enum CodingKeys {
            case partialJSON
            case text
            case type
        }
        case text(Swift.String)
        case toolUse(Swift.String)
    }
    let delta: AIProxy.AnthropicMessageStreamingDeltaBlock.Delta
}
class AnthropicProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
class AudioController {
    enum Mode {
        case record
        case playback
    }
    let modes: [AIProxy.AudioController.Mode]
    let audioEngine: __C.AVAudioEngine
    var microphonePCMSampleVendor: AIProxy.MicrophonePCMSampleVendor?
    var audioPCMPlayer: AIProxy.AudioPCMPlayer?
}
class AudioPCMPlayer {
    let audioEngine: __C.AVAudioEngine
    let inputFormat: __C.AVAudioFormat
    let playableFormat: __C.AVAudioFormat
    let playerNode: __C.AVAudioPlayerNode
}
enum AudioPCMPlayerError {
    case couldNotConfigureAudioEngine(Swift.String)
}
class BraveDirectService {
    let unprotectedAPIKey: Swift.String
}
class BraveProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct BraveWebSearchResponseBody {
    struct Query {
        enum CodingKeys {
            case badResults
            case city
            case country
            case headerCountry
            case isNavigational
            case isNewsBreaking
            case moreResultsAvailable
            case original
            case postalCode
            case shouldFallback
            case showStrictWarning
            case spellcheckOff
            case state
        }
        let badResults: Swift.Bool?
        let city: Swift.String?
        let country: Swift.String?
        let headerCountry: Swift.String?
        let isNavigational: Swift.Bool?
        let isNewsBreaking: Swift.Bool?
        let moreResultsAvailable: Swift.Bool?
        let original: Swift.String?
        let postalCode: Swift.String?
        let shouldFallback: Swift.Bool?
        let showStrictWarning: Swift.Bool?
        let spellcheckOff: Swift.Bool?
        let state: Swift.String?
    }
    struct Mixed {
        struct MixedItem {
            enum CodingKeys {
                case all
                case index
                case type
            }
            let all: Swift.Bool
            let index: Swift.Int?
            let type: Swift.String
        }
        enum CodingKeys {
            case main
            case side
            case top
            case type
        }
        let main: [AIProxy.BraveWebSearchResponseBody.Mixed.MixedItem]?
        let side: [AIProxy.BraveWebSearchResponseBody.Mixed.MixedItem]?
        let top: [AIProxy.BraveWebSearchResponseBody.Mixed.MixedItem]?
        let type: Swift.String?
    }
    struct Web {
        struct SearchResult {
            struct Profile {
                enum CodingKeys {
                    case img
                    case longName
                    case name
                    case url
                }
                let img: Swift.String?
                let longName: Swift.String?
                let name: Swift.String?
                let url: Swift.String?
            }
            struct MetaURL {
                enum CodingKeys {
                    case favicon
                    case hostname
                    case netloc
                    case path
                    case scheme
                }
                let favicon: Swift.String?
                let hostname: Swift.String?
                let netloc: Swift.String?
                let path: Swift.String?
                let scheme: Swift.String?
            }
            struct Thumbnail {
                enum CodingKeys {
                    case logo
                    case original
                    case src
                }
                let logo: Swift.Bool?
                let original: Swift.String?
                let src: Swift.String?
            }
            enum CodingKeys {
                case age
                case description
                case familyFriendly
                case isLive
                case isSourceBoth
                case isSourceLocal
                case language
                case metaURL
                case pageAge
                case profile
                case subtype
                case title
                case type
                case thumbnail
                case url
            }
            let age: Swift.String?
            let description: Swift.String?
            let familyFriendly: Swift.Bool?
            let isLive: Swift.Bool?
            let isSourceBoth: Swift.Bool?
            let isSourceLocal: Swift.Bool?
            let language: Swift.String?
            let metaURL: AIProxy.BraveWebSearchResponseBody.Web.SearchResult.MetaURL?
            let pageAge: Swift.String?
            let profile: AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Profile?
            let subtype: Swift.String?
            let title: Swift.String?
            let type: Swift.String?
            let thumbnail: AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Thumbnail?
            let url: Swift.String?
        }
        enum CodingKeys {
            case familyFriendly
            case results
            case type
        }
        let familyFriendly: Swift.Bool?
        let results: [AIProxy.BraveWebSearchResponseBody.Web.SearchResult]?
        let type: Swift.String?
    }
    enum CodingKeys {
        case mixed
        case query
        case type
        case web
    }
    let mixed: AIProxy.BraveWebSearchResponseBody.Mixed?
    let query: AIProxy.BraveWebSearchResponseBody.Query?
    let type: Swift.String?
    let web: AIProxy.BraveWebSearchResponseBody.Web?
}
struct Payload {
    enum CodingKeys {
        case appName
        case appVersion
        case buildNumber
        case deviceModel
        case systemName
        case osVersion
        case errorType
        case errorMessage
        case timestamp
    }
    let appName: Swift.String
    let appVersion: Swift.String
    let buildNumber: Swift.String
    let deviceModel: Swift.String
    let systemName: Swift.String
    let osVersion: Swift.String
    let errorType: Swift.String
    let errorMessage: Swift.String?
    let timestamp: Swift.Double
}
enum DeepLAccountType {
    case free
    case paid
}
class DeepLDirectService {
    let unprotectedAPIKey: Swift.String
    let accountType: AIProxy.DeepLAccountType
}
class DeepLProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct DeepLTranslateRequestBody {
    enum CodingKeys {
        case targetLang
        case text
        case context
        case formality
        case glossaryID
        case ignoreTags
        case nonSplittingTags
        case outlineDetection
        case preserveFormatting
        case sourceLang
        case splitSentences
        case splittingTags
        case tagHandling
    }
    let targetLang: Swift.String
    let text: [Swift.String]
    let context: Swift.String?
    let formality: AIProxy.DeepLFormality?
    let glossaryID: Swift.String?
    let ignoreTags: [Swift.String]?
    let nonSplittingTags: [Swift.String]?
    let outlineDetection: Swift.Bool?
    let preserveFormatting: Swift.Bool?
    let sourceLang: Swift.String?
    let splitSentences: AIProxy.DeepLSplitSentencesOption?
    let splittingTags: [Swift.String]?
    let tagHandling: AIProxy.DeepLTagHandling?
}
enum DeepLFormality {
    case default
    case more
    case less
    case preferMore
    case preferLess
}
enum DeepLSplitSentencesOption {
    case none
    case punctuation
    case punctuationAndNewlines
}
enum DeepLTagHandling {
    case xml
    case xhtml
}
struct DeepLTranslateResponseBody {
    enum CodingKeys {
        case translations
    }
    let translations: [AIProxy.DeepLTranslation]
}
struct DeepLTranslation {
    enum CodingKeys {
        case detectedSourceLanguage
        case text
    }
    let detectedSourceLanguage: Swift.String
    let text: Swift.String
}
struct DeepSeekChatCompletionRequestBody {
    enum Message {
        enum RootKey {
            case content
            case name
            case prefix
            case reasoningContent
            case role
            case toolCallID
        }
        case assistant(content: Swift.String, name: Swift.String?, prefix: Swift.Bool?, reasoningContent: Swift.String?)
        case system(content: Swift.String, name: Swift.String?)
        case tool(content: Swift.String, toolCallID: Swift.String)
        case user(content: Swift.String, name: Swift.String?)
    }
    enum ResponseFormat {
        enum RootKey {
            case type
        }
        case jsonObject
        case text
    }
    struct StreamOptions {
        enum CodingKeys {
            case includeUsage
        }
        let includeUsage: Swift.Bool
    }
    enum Tool {
        enum RootKey {
            case type
            case function
        }
        enum FunctionKey {
            case description
            case name
            case parameters
        }
        case function(name: Swift.String, description: Swift.String?, parameters: [Swift.String : AIProxy.AIProxyJSONValue]?)
    }
    enum ToolChoice {
        enum RootKey {
            case type
            case function
        }
        enum FunctionKey {
            case name
        }
        case specific(functionName: Swift.String)
        case none
        case auto
        case required
    }
    enum CodingKeys {
        case messages
        case model
        case frequencyPenalty
        case logprobs
        case maxTokens
        case presencePenalty
        case responseFormat
        case stop
        case stream
        case streamOptions
        case temperature
        case tools
        case toolChoice
        case topLogprobs
        case topP
    }
    let messages: [AIProxy.DeepSeekChatCompletionRequestBody.Message]
    let model: Swift.String
    let frequencyPenalty: Swift.Double?
    let logprobs: Swift.Bool?
    let maxTokens: Swift.Int?
    let presencePenalty: Swift.Double?
    let responseFormat: AIProxy.DeepSeekChatCompletionRequestBody.ResponseFormat?
    let stop: [Swift.String]?
    var stream: Swift.Bool?
    var streamOptions: AIProxy.DeepSeekChatCompletionRequestBody.StreamOptions?
    let temperature: Swift.Double?
    let tools: [AIProxy.DeepSeekChatCompletionRequestBody.Tool]?
    let toolChoice: AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice?
    let topLogprobs: Swift.Int?
    let topP: Swift.Double?
}
struct DeepSeekChatCompletionResponseBody {
    struct Choice {
        struct Message {
            struct ToolCall {
                struct Function {
                    enum CodingKeys {
                        case name
                        case arguments
                    }
                    let name: Swift.String
                    let arguments: [Swift.String : Any]?
                    let argumentsRaw: Swift.String?
                }
                enum CodingKeys {
                    case id
                    case type
                    case function
                }
                let id: Swift.String
                let type: Swift.String
                let function: AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.Function
            }
            enum CodingKeys {
                case content
                case reasoningContent
                case role
                case toolCalls
            }
            let content: Swift.String?
            let reasoningContent: Swift.String?
            let role: Swift.String?
            let toolCalls: [AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall]?
        }
        enum CodingKeys {
            case finishReason
            case index
            case message
        }
        let finishReason: Swift.String?
        let index: Swift.Int?
        let message: AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message
    }
    enum CodingKeys {
        case choices
        case created
        case id
        case model
        case usage
        case systemFingerprint
    }
    let choices: [AIProxy.DeepSeekChatCompletionResponseBody.Choice]
    let created: Swift.Int
    let id: Swift.String
    let model: Swift.String
    let systemFingerprint: Swift.String?
    let usage: AIProxy.DeepSeekUsage?
}
struct DeepSeekChatCompletionChunk {
    struct Choice {
        struct Delta {
            enum CodingKeys {
                case content
                case reasoningContent
                case role
            }
            let content: Swift.String?
            let reasoningContent: Swift.String?
            let role: Swift.String?
        }
        enum CodingKeys {
            case delta
            case finishReason
            case index
        }
        let delta: AIProxy.DeepSeekChatCompletionChunk.Choice.Delta
        let finishReason: Swift.String?
        let index: Swift.Int?
    }
    enum CodingKeys {
        case choices
        case created
        case id
        case model
        case systemFingerprint
        case usage
    }
    let choices: [AIProxy.DeepSeekChatCompletionChunk.Choice]
    let created: Swift.Int?
    let id: Swift.String?
    let model: Swift.String?
    let systemFingerprint: Swift.String?
    let usage: AIProxy.DeepSeekUsage?
}
class DeepSeekDirectService {
    let unprotectedAPIKey: Swift.String
    let baseURL: Swift.String
}
class DeepSeekProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct DeepSeekUsage {
    struct CompletionTokenDetails {
        enum CodingKeys {
            case reasoningTokens
        }
        let reasoningTokens: Swift.Int?
    }
    enum CodingKeys {
        case completionTokens
        case completionTokensDetails
        case promptCacheHitTokens
        case promptCacheMissTokens
        case promptTokens
        case totalTokens
    }
    let completionTokens: Swift.Int?
    let completionTokensDetails: AIProxy.DeepSeekUsage.CompletionTokenDetails?
    let promptCacheHitTokens: Swift.Int?
    let promptCacheMissTokens: Swift.Int?
    let promptTokens: Swift.Int?
    let totalTokens: Swift.Int?
}
struct EachAICreatePredictionRequestBody<A> where A: Swift.Encodable {
    enum CodingKeys {
        case input
        case model
        case version
    }
    let input: A
    let model: Swift.String
    let version: Swift.String
}
struct EachAICreatePredictionResponseBody {
    enum CodingKeys {
        case predictionID
        case message
        case status
    }
    let predictionID: Swift.String
    let message: Swift.String?
    let status: Swift.String?
}
class EachAIDirectService: AIProxy.EachAIService {}
enum EachAIError {
    case reachedRetryLimit
    case predictionDidNotIncludeOutput
}
struct EachAIImagenInput {
    enum CodingKeys {
        case prompt
        case aspectRatio
        case outputFormat
        case safetyFilterLevel
    }
    let prompt: Swift.String
    let aspectRatio: Swift.String?
    let outputFormat: Swift.String?
    let safetyFilterLevel: Swift.String?
}
struct EachAIPrediction {
    struct Input {
        enum CodingKeys {
            case prompt
        }
        let prompt: Swift.String?
    }
    struct Metrics {
        enum CodingKeys {
            case predictTime
            case cost
        }
        let predictTime: Swift.Double?
        let cost: Swift.Double?
    }
    struct ActionURLs {
        enum CodingKeys {
            case cancel
            case get
        }
        let cancel: Swift.String?
        let get: Swift.String?
    }
    enum CodingKeys {
        case id
        case input
        case logs
        case metrics
        case output
        case status
        case urls
    }
    let id: Swift.String?
    let input: AIProxy.EachAIPrediction.Input?
    let logs: Swift.String?
    let metrics: AIProxy.EachAIPrediction.Metrics?
    let output: Foundation.URL?
    let status: Swift.String?
    let urls: AIProxy.EachAIPrediction.ActionURLs?
}
class EachAIProxiedService: AIProxy.EachAIService {}
class EachAIService {
    let requestBuilder: AIProxy.OpenAIRequestBuilder
    let serviceNetworker: AIProxy.ServiceMixin
}
struct EachAITriggerWorkflowRequestBody {
    enum CodingKeys {
        case parameters
    }
    let parameters: [Swift.String : AIProxy.AIProxyJSONValue]
}
struct EachAITriggerWorkflowResponseBody {
    enum CodingKeys {
        case triggerID
        case message
        case status
    }
    let triggerID: Swift.String
    let message: Swift.String?
    let status: Swift.String?
}
struct EachAIVeoInput {
    enum CodingKeys {
        case imageURL
        case prompt
        case generateAudio
    }
    let imageURL: Foundation.URL
    let prompt: Swift.String
    let generateAudio: Swift.Bool?
}
struct EachAIWorkflowExecutionResponseBody {
    struct StepResult {
        enum CodingKeys {
            case endedAt
            case input
            case model
            case output
            case outputJson
            case startedAt
            case status
            case stepId
            case stepName
            case version
        }
        let endedAt: Swift.String?
        let input: Swift.String?
        let model: Swift.String?
        let output: Swift.String?
        let outputJson: Swift.String?
        let startedAt: Swift.String?
        let status: Swift.String?
        let stepId: Swift.String?
        let stepName: Swift.String?
        let version: Swift.String?
    }
    enum CodingKeys {
        case averagePercent
        case createdAt
        case deletedAt
        case endedAt
        case executionId
        case flowId
        case flowName
        case organizationId
        case output
        case outputJson
        case sourceIpAddress
        case startedAt
        case status
        case stepResults
        case updatedAt
    }
    let averagePercent: Swift.Double?
    let createdAt: Swift.String?
    let deletedAt: Swift.String?
    let endedAt: Swift.String?
    let executionId: Swift.String?
    let flowId: Swift.String?
    let flowName: Swift.String?
    let organizationId: Swift.String?
    let output: Swift.String?
    let outputJson: Swift.String?
    let sourceIpAddress: Swift.String?
    let startedAt: Swift.String?
    let status: Swift.String?
    let stepResults: [AIProxy.EachAIWorkflowExecutionResponseBody.StepResult]?
    let updatedAt: Swift.String?
}
class ElevenLabsDirectService {
    let unprotectedAPIKey: Swift.String
}
class ElevenLabsProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct ElevenLabsSpeechToSpeechRequestBody {
    let audio: Foundation.Data
    let modelID: Swift.String?
    let removeBackgroundNoise: Swift.Bool?
    let seed: Swift.Int?
}
struct ElevenLabsSpeechToTextRequestBody {
    enum ModelID {
        case scribeV1
        case scribeV1Experimental
    }
    enum TimestampGranularity {
        case none
        case word
        case character
    }
    let modelID: AIProxy.ElevenLabsSpeechToTextRequestBody.ModelID
    let cloudStorageURL: Swift.String?
    let file: Foundation.Data?
    let languageCode: Swift.String?
    let tagAudioEvents: Swift.Bool?
    let numSpeakers: Swift.Int?
    let timestampGranularity: AIProxy.ElevenLabsSpeechToTextRequestBody.TimestampGranularity?
    let diarize: Swift.Bool?
}
struct ElevenLabsSpeechToTextResponseBody {
    struct Word {
        struct Character {
            enum CodingKeys {
                case text
                case start
                case end
            }
            let text: Swift.String
            let start: Swift.Double?
            let end: Swift.Double?
        }
        enum WordType {
            case word
            case spacing
            case audioEvent
        }
        enum CodingKeys {
            case text
            case type
            case start
            case end
            case speakerID
            case characters
        }
        let text: Swift.String
        let type: AIProxy.ElevenLabsSpeechToTextResponseBody.Word.WordType?
        let start: Swift.Double?
        let end: Swift.Double?
        let speakerID: Swift.String?
        let characters: [AIProxy.ElevenLabsSpeechToTextResponseBody.Word.Character]?
    }
    struct AdditionalFormat {
        enum CodingKeys {
            case requestedFormat
            case fileExtension
            case contentType
            case isBase64Encoded
            case content
        }
        let requestedFormat: Swift.String
        let fileExtension: Swift.String
        let contentType: Swift.String
        let isBase64Encoded: Swift.Bool
        let content: Swift.String?
    }
    enum CodingKeys {
        case languageCode
        case languageProbability
        case text
        case words
        case additionalFormats
    }
    let languageCode: Swift.String?
    let languageProbability: Swift.Double?
    let text: Swift.String?
    let words: [AIProxy.ElevenLabsSpeechToTextResponseBody.Word]?
    let additionalFormats: [AIProxy.ElevenLabsSpeechToTextResponseBody.AdditionalFormat]?
}
struct ElevenLabsTTSRequestBody {
    struct PronunciationDictionaryLocator {
        enum CodingKeys {
            case pronunciationDictionaryID
            case versionID
        }
        let pronunciationDictionaryID: Swift.String
        let versionID: Swift.String
    }
    struct VoiceSettings {
        enum CodingKeys {
            case similarityBoost
            case stability
            case speakerBoost
            case style
        }
        let similarityBoost: Swift.Double
        let stability: Swift.Double
        let speakerBoost: Swift.Bool?
        let style: Swift.Double?
    }
    enum CodingKeys {
        case text
        case languageCode
        case modelID
        case nextRequestIDs
        case nextText
        case previousRequestIDs
        case previousText
        case pronunciationDictionaryLocators
        case seed
        case voiceSettings
    }
    let text: Swift.String
    let languageCode: Swift.String?
    let modelID: Swift.String?
    let nextRequestIDs: [Swift.String]?
    let nextText: Swift.String?
    let previousRequestIDs: [Swift.String]?
    let previousText: Swift.String?
    let pronunciationDictionaryLocators: [AIProxy.ElevenLabsTTSRequestBody.PronunciationDictionaryLocator]?
    let seed: Swift.Int?
    let voiceSettings: AIProxy.ElevenLabsTTSRequestBody.VoiceSettings?
}
class FalDirectService {
    let unprotectedAPIKey: Swift.String
}
enum FalError {
    case missingResultURL
    case missingStatusURL
    case reachedRetryLimit
}
struct FalFastSDXLInputSchema {
    enum ImageSize {
        case landscape4x3
        case landscape16x9
        case portrait4x3
        case portrait16x9
        case square
        case squareHD
    }
    struct LoraWeight {
        enum CodingKeys {
            case path
            case force
            case scale
        }
        let path: Swift.String
        let force: Swift.Bool?
        let scale: Swift.Double?
    }
    struct Embedding {
        enum CodingKeys {
            case path
            case tokens
        }
        let path: Swift.String
        let tokens: Swift.String?
    }
    enum SafetyCheckerVersion {
        case v1
        case v2
    }
    enum Format {
        case jpeg
        case png
    }
    enum CodingKeys {
        case embeddings
        case enableSafetyChecker
        case expandPrompt
        case format
        case guidanceScale
        case imageSize
        case loras
        case negativePrompt
        case numImages
        case numInferenceSteps
        case prompt
        case requestID
        case safetyCheckerVersion
        case seed
        case syncMode
    }
    let prompt: Swift.String
    let embeddings: [AIProxy.FalFastSDXLInputSchema.Embedding]?
    let enableSafetyChecker: Swift.Bool?
    let expandPrompt: Swift.Bool?
    let format: AIProxy.FalFastSDXLInputSchema.Format?
    let guidanceScale: Swift.Double?
    let imageSize: AIProxy.FalFastSDXLInputSchema.ImageSize?
    let loras: [AIProxy.FalFastSDXLInputSchema.LoraWeight]?
    let negativePrompt: Swift.String?
    let numImages: Swift.Int?
    let numInferenceSteps: Swift.Int?
    let requestID: Swift.String?
    let safetyCheckerVersion: AIProxy.FalFastSDXLInputSchema.SafetyCheckerVersion?
    let seed: Swift.Int?
    let syncMode: Swift.Bool?
}
struct FalFastSDXLOutputSchema {
    enum CodingKeys {
        case hasNSFWConcepts
        case images
        case prompt
        case seed
        case timings
    }
    let hasNSFWConcepts: [Swift.Bool]?
    let images: [AIProxy.FalOutputImage]?
    let prompt: Swift.String?
    let seed: Swift.UInt64?
    let timings: AIProxy.FalTimings?
}
struct FalFluxLoRAFastTrainingInputSchema {
    enum CodingKeys {
        case createMasks
        case dataArchiveFormat
        case imagesDataURL
        case isInputFormatAlreadyPreprocessed
        case isStyle
        case iterMultiplier
        case triggerWord
    }
    let imagesDataURL: Foundation.URL
    let createMasks: Swift.Bool?
    let dataArchiveFormat: Swift.String?
    let isInputFormatAlreadyPreprocessed: Swift.Bool?
    let isStyle: Swift.Bool?
    let iterMultiplier: Swift.Double?
    let triggerWord: Swift.String?
}
struct FalFluxLoRAFastTrainingOutputSchema {
    struct File {
        enum CodingKeys {
            case contentType
            case fileName
            case fileSize
            case url
        }
        let contentType: Swift.String?
        let fileName: Swift.String?
        let fileSize: Swift.Int?
        let url: Foundation.URL?
    }
    enum CodingKeys {
        case configFile
        case diffusersLoraFile
    }
    let configFile: AIProxy.FalFluxLoRAFastTrainingOutputSchema.File?
    let diffusersLoraFile: AIProxy.FalFluxLoRAFastTrainingOutputSchema.File?
}
struct FalFluxLoRAInputSchema {
    enum ImageSize {
        case landscape16x9
        case landscape4x3
        case portrait16x9
        case portrait4x3
        case square
        case squareHD
    }
    struct Lora {
        enum CodingKeys {
            case path
            case scale
        }
        let path: Foundation.URL
        let scale: Swift.Double?
    }
    enum OutputFormat {
        case jpeg
        case png
    }
    enum CodingKeys {
        case enableSafetyChecker
        case guidanceScale
        case imageSize
        case loras
        case numImages
        case numInferenceSteps
        case outputFormat
        case prompt
        case seed
        case syncMode
    }
    let prompt: Swift.String
    let enableSafetyChecker: Swift.Bool?
    let guidanceScale: Swift.Double?
    let imageSize: AIProxy.FalFluxLoRAInputSchema.ImageSize?
    let loras: [AIProxy.FalFluxLoRAInputSchema.Lora]?
    let numImages: Swift.Int?
    let numInferenceSteps: Swift.Int?
    let outputFormat: AIProxy.FalFluxLoRAInputSchema.OutputFormat?
    let seed: Swift.Int?
    let syncMode: Swift.Bool?
}
struct FalFluxLoRAOutputSchema {
    enum CodingKeys {
        case hasNSFWConcepts
        case images
        case prompt
        case seed
        case timings
    }
    let hasNSFWConcepts: [Swift.Bool]?
    let images: [AIProxy.FalOutputImage]?
    let prompt: Swift.String?
    let seed: Swift.UInt64?
    let timings: AIProxy.FalTimings?
}
struct FalFluxProKontextInputSchema {
    enum OutputFormat {
        case jpeg
        case png
    }
    enum AspectRatio {
        case _21x9
        case _16x9
        case _4x3
        case _3x2
        case _1x1
        case _2x3
        case _3x4
        case _9x16
        case _9x21
    }
    enum CodingKeys {
        case imageURL
        case prompt
        case aspectRatio
        case guidanceScale
        case numImages
        case outputFormat
        case safetyTolerance
        case seed
        case syncMode
    }
    let imageURL: Foundation.URL
    let prompt: Swift.String
    let aspectRatio: AIProxy.FalFluxProKontextInputSchema.AspectRatio?
    let guidanceScale: Swift.Float?
    let numImages: Swift.Int?
    let outputFormat: AIProxy.FalFluxProKontextInputSchema.OutputFormat?
    let safetyTolerance: Swift.Int?
    let seed: Swift.Int?
    let syncMode: Swift.Bool?
}
struct FalFluxProKontextOutputSchema {
    enum CodingKeys {
        case images
        case prompt
    }
    let images: [AIProxy.FalOutputImage]?
    let prompt: Swift.String?
}
struct FalFluxSchnellInputSchema {
    enum ImageSize {
        case landscape16x9
        case landscape4x3
        case portrait16x9
        case portrait4x3
        case square
        case squareHD
    }
    enum CodingKeys {
        case enableSafetyChecker
        case imageSize
        case numImages
        case numInferenceSteps
        case prompt
        case seed
        case syncMode
    }
    let prompt: Swift.String
    let enableSafetyChecker: Swift.Bool?
    let imageSize: AIProxy.FalFluxSchnellInputSchema.ImageSize?
    let numImages: Swift.Int?
    let numInferenceSteps: Swift.Int?
    let seed: Swift.Int?
    let syncMode: Swift.Bool?
}
struct FalFluxSchnellOutputSchema {
    enum CodingKeys {
        case hasNSFWConcepts
        case images
        case prompt
        case seed
        case timings
    }
    let hasNSFWConcepts: [Swift.Bool]?
    let images: [AIProxy.FalOutputImage]?
    let prompt: Swift.String?
    let seed: Swift.UInt64?
    let timings: AIProxy.FalTimings?
}
struct FalInitiateUploadRequestBody {
    enum CodingKeys {
        case contentType
        case fileName
    }
    let contentType: Swift.String
    let fileName: Swift.String
}
struct FalInitiateUploadResponseBody {
    enum CodingKeys {
        case fileURL
        case uploadURL
    }
    let fileURL: Foundation.URL
    let uploadURL: Foundation.URL
}
struct FalOutputImage {
    enum CodingKeys {
        case contentType
        case height
        case url
        case width
    }
    let contentType: Swift.String?
    let height: Swift.Int?
    let url: Foundation.URL?
    let width: Swift.Int?
}
class FalProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct FalQueueResponseBody {
    enum Status {
        case inQueue
        case inProgress
        case completed
    }
    struct Metrics {
        enum CodingKeys {
            case inferenceTime
        }
        let inferenceTime: Swift.Double?
    }
    enum CodingKeys {
        case cancelURL
        case logs
        case metrics
        case responseURL
        case requestID
        case status
        case statusURL
        case queuePosition
    }
    let cancelURL: Foundation.URL?
    let logs: Swift.String?
    let metrics: AIProxy.FalQueueResponseBody.Metrics?
    let responseURL: Foundation.URL?
    let requestID: Swift.String?
    let status: AIProxy.FalQueueResponseBody.Status?
    let statusURL: Foundation.URL?
    let queuePosition: Swift.Int?
}
struct FalTimings {
    enum CodingKeys {
        case inference
    }
    let inference: Swift.Double?
}
struct FalTryonInputSchema {
    enum Category {
        case tops
        case bottoms
        case onePieces
    }
    enum GarmentPhotoType {
        case auto
        case model
        case flatLay
    }
    enum CodingKeys {
        case adjustHands
        case coverFeet
        case category
        case guidanceScale
        case garmentImage
        case garmentPhotoType
        case longTop
        case modelImage
        case numSamples
        case nsfwFilter
        case restoreClothes
        case restoreBackground
        case seed
        case timesteps
    }
    let category: AIProxy.FalTryonInputSchema.Category
    let garmentImage: Foundation.URL
    let modelImage: Foundation.URL
    let adjustHands: Swift.Bool?
    let coverFeet: Swift.Bool?
    let guidanceScale: Swift.Float?
    let garmentPhotoType: AIProxy.FalTryonInputSchema.GarmentPhotoType?
    let longTop: Swift.Bool?
    let numSamples: Swift.Int?
    let nsfwFilter: Swift.Bool?
    let restoreClothes: Swift.Bool?
    let restoreBackground: Swift.Bool?
    let seed: Swift.Int?
    let timesteps: Swift.Int?
}
struct FalTryonOutputSchema {
    struct TryonImage {
        enum CodingKeys {
            case contentType
            case fileData
            case fileName
            case fileSize
            case height
            case url
            case width
        }
        let contentType: Swift.String?
        let fileData: Swift.String?
        let fileName: Swift.String?
        let fileSize: Swift.Int?
        let height: Swift.Int?
        let url: Foundation.URL
        let width: Swift.Int?
    }
    enum CodingKeys {
        case images
    }
    let images: [AIProxy.FalTryonOutputSchema.TryonImage]
}
class FireworksAIDirectService {
    let unprotectedAPIKey: Swift.String
}
class FireworksAIProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct GeminiBatchRequestBody {
    enum CodingKeys {
        case batch
    }
    enum BatchKeys {
        case displayName
        case inputConfig
    }
    enum InputConfigKeys {
        case fileName
    }
    let fileName: Swift.String
    let displayName: Swift.String
}
struct GeminiBatchResponseBody {
    struct BatchMetadata {
        enum State {
            case unspecified
            case pending
            case running
            case succeeded
            case failed
            case cancelled
            case expired
        }
        struct InputConfig {
            enum CodingKeys {
                case fileName
            }
            let fileName: Swift.String?
        }
        struct OutputConfig {
            enum CodingKeys {
                case responsesFile
            }
            let responsesFile: Swift.String?
        }
        struct BatchStats {
            enum CodingKeys {
                case requestCount
                case successfulRequestCount
            }
            let requestCount: Swift.String?
            let successfulRequestCount: Swift.String?
        }
        enum CodingKeys {
            case type
            case model
            case displayName
            case inputConfig
            case output
            case createTime
            case endTime
            case updateTime
            case batchStats
            case state
            case name
        }
        let type: Swift.String?
        let model: Swift.String?
        let displayName: Swift.String?
        let inputConfig: AIProxy.GeminiBatchResponseBody.BatchMetadata.InputConfig?
        let output: AIProxy.GeminiBatchResponseBody.BatchMetadata.OutputConfig?
        let createTime: Swift.String?
        let endTime: Swift.String?
        let updateTime: Swift.String?
        let batchStats: AIProxy.GeminiBatchResponseBody.BatchMetadata.BatchStats?
        let state: AIProxy.GeminiBatchResponseBody.BatchMetadata.State?
        let name: Swift.String?
    }
    struct BatchResponse {
        enum CodingKeys {
            case type
            case responsesFile
        }
        let type: Swift.String?
        let responsesFile: Swift.String?
    }
    enum CodingKeys {
        case name
        case metadata
        case done
        case response
    }
    let name: Swift.String
    let metadata: AIProxy.GeminiBatchResponseBody.BatchMetadata?
    let done: Swift.Bool?
    let response: AIProxy.GeminiBatchResponseBody.BatchResponse?
}
class GeminiDirectService {
    let unprotectedAPIKey: Swift.String
}
enum GeminiError {
    case reachedRetryLimit
}
struct GeminiFile {
    enum State {
        case processing
        case active
    }
    struct VideoMetadata {
        enum CodingKeys {
            case videoDuration
        }
        let videoDuration: Swift.String
    }
    enum CodingKeys {
        case createTime
        case expirationTime
        case mimeType
        case name
        case sha256Hash
        case sizeBytes
        case state
        case updateTime
        case uri
        case videoMetadata
    }
    let createTime: Swift.String?
    let expirationTime: Swift.String?
    let mimeType: Swift.String?
    let name: Swift.String?
    let sha256Hash: Swift.String?
    let sizeBytes: Swift.String?
    let state: AIProxy.GeminiFile.State
    let updateTime: Swift.String?
    let uri: Foundation.URL
    let videoMetadata: AIProxy.GeminiFile.VideoMetadata?
}
struct GeminiFileUploadRequestBody {
    let fileData: Foundation.Data
    let mimeType: Swift.String
}
struct GeminiFileUploadResponseBody {
    enum CodingKeys {
        case file
    }
    let file: AIProxy.GeminiFile
}
struct GeminiGenerateContentRequestBody {
    struct Content {
        enum Part {
            enum CodingKeys {
                case text
                case inlineData
                case fileData
            }
            enum InlineDataNestedKeys {
                case data
                case mimeType
            }
            enum FileDataNestedKeys {
                case fileUri
                case mimeType
            }
            case text(Swift.String)
            case inline(data: Foundation.Data, mimeType: Swift.String)
            case file(url: Foundation.URL, mimeType: Swift.String)
        }
        enum CodingKeys {
            case parts
            case role
        }
        let parts: [AIProxy.GeminiGenerateContentRequestBody.Content.Part]
        let role: Swift.String?
    }
    enum Tool {
        struct DynamicRetrievalConfig {
            enum Mode {
                case always
                case dynamic
            }
            enum RootKey {
                case dynamicRetrievalConfig
            }
            enum NestedKey {
                case dynamicThreshold
                case mode
            }
            let dynamicThreshold: Swift.Double?
            let mode: AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.Mode?
        }
        struct FunctionDeclaration {
            enum CodingKeys {
                case name
                case description
                case parameters
            }
            let name: Swift.String
            let description: Swift.String?
            let parameters: [Swift.String : AIProxy.AIProxyJSONValue]?
        }
        enum RootKey {
            case functionDeclarations
            case googleSearch
            case googleSearchRetrieval
        }
        case functionDeclarations([AIProxy.GeminiGenerateContentRequestBody.Tool.FunctionDeclaration])
        case googleSearchRetrieval(AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig)
        case googleSearch(AIProxy.GeminiGenerateContentRequestBody.GoogleSearch)
    }
    struct GoogleSearch {
        enum CodingKeys {}
    }
    struct ToolConfig {
        struct FunctionCallingConfig {
            enum Mode {
                case anyFunction
                case auto
                case noFunction
            }
            enum CodingKeys {
                case mode
                case allowedFunctionNames
            }
            let allowedFunctionNames: [Swift.String]?
            let mode: AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.Mode?
        }
        enum CodingKeys {
            case functionCallingConfig
        }
        let functionCallingConfig: AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig?
    }
    struct SafetySetting {
        enum SafetyCategory {
            case harassment
            case hateSpeech
            case sexuallyExplicit
            case dangerousContent
            case civicIntegrity
        }
        enum HarmBlockThreshold {
            case none
            case high
            case mediumAndAbove
            case lowAndAbove
            case unspecified
        }
        enum CodingKeys {
            case category
            case threshold
        }
        let category: AIProxy.GeminiGenerateContentRequestBody.SafetySetting.SafetyCategory
        let threshold: AIProxy.GeminiGenerateContentRequestBody.SafetySetting.HarmBlockThreshold
    }
    struct SystemInstruction {
        enum CodingKeys {
            case role
            case parts
        }
        let role: Swift.String
        let parts: [AIProxy.GeminiGenerateContentRequestBody.Content.Part]
    }
    struct GenerationConfig {
        struct ThinkingConfig {
            enum CodingKeys {
                case thinkingBudget
            }
            let thinkingBudget: Swift.Int
        }
        struct SpeechConfig {
            struct VoiceConfig {
                enum CodingKeys {
                    case prebuiltVoiceConfig
                }
                let prebuiltVoiceConfig: AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.PrebuiltVoiceConfig
            }
            struct MultiSpeakerVoiceConfig {
                enum CodingKeys {
                    case speakerVoiceConfigs
                }
                let speakerVoiceConfigs: [AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.SpeakerVoiceConfig]
            }
            struct PrebuiltVoiceConfig {
                enum CodingKeys {
                    case voiceName
                }
                let voiceName: AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceName
            }
            struct SpeakerVoiceConfig {
                enum CodingKeys {
                    case speaker
                    case voiceConfig
                }
                let speaker: Swift.String
                let voiceConfig: AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceConfig
            }
            enum VoiceName {
                case zephyr
                case puck
                case charon
                case kore
                case fenrir
                case leda
                case orus
                case aoede
                case callirrhoe
                case autonoe
                case enceladus
                case iapetus
                case umbriel
                case algieba
                case despina
                case erinome
                case algenib
                case rasalgethi
                case laomedeia
                case achernar
                case alnilam
                case schedar
                case gacrux
                case pulcherrima
                case achird
                case zubenelgenubi
                case vindemiatrix
                case sadachbia
                case sadaltager
                case sulafat
            }
            enum CodingKeys {
                case multiSpeakerVoiceConfig
                case voiceConfig
            }
            let multiSpeakerVoiceConfig: AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.MultiSpeakerVoiceConfig?
            let voiceConfig: AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceConfig?
        }
        enum CodingKeys {
            case maxOutputTokens
            case temperature
            case topP
            case topK
            case presencePenalty
            case frequencyPenalty
            case responseModalities
            case responseMimeType
            case responseSchema
            case speechConfig
            case thinkingConfig
        }
        let maxOutputTokens: Swift.Int?
        let temperature: Swift.Double?
        let topP: Swift.Double?
        let topK: Swift.Int?
        let presencePenalty: Swift.Double?
        let frequencyPenalty: Swift.Double?
        let responseModalities: [Swift.String]?
        let responseMimeType: Swift.String?
        let responseSchema: [Swift.String : AIProxy.AIProxyJSONValue]?
        let speechConfig: AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig?
        let thinkingConfig: AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.ThinkingConfig?
    }
    enum CodingKeys {
        case contents
        case cachedContent
        case generationConfig
        case safetySettings
        case systemInstruction
        case toolConfig
        case tools
    }
    let contents: [AIProxy.GeminiGenerateContentRequestBody.Content]
    let cachedContent: Swift.String?
    let generationConfig: AIProxy.GeminiGenerateContentRequestBody.GenerationConfig?
    let safetySettings: [AIProxy.GeminiGenerateContentRequestBody.SafetySetting]?
    let systemInstruction: AIProxy.GeminiGenerateContentRequestBody.SystemInstruction?
    let toolConfig: AIProxy.GeminiGenerateContentRequestBody.ToolConfig?
    let tools: [AIProxy.GeminiGenerateContentRequestBody.Tool]?
}
struct GeminiGenerateContentResponseBody {
    struct Candidate {
        struct Content {
            enum Part {
                struct _InlineData {
                    enum CodingKeys {
                        case mimeType
                        case data
                    }
                    let mimeType: Swift.String
                    let data: Swift.String
                }
                struct _FunctionCall {
                    enum CodingKeys {
                        case name
                        case args
                    }
                    let name: Swift.String
                    let args: [Swift.String : AIProxy.AIProxyJSONValue]?
                }
                enum CodingKeys {
                    case text
                    case functionCall
                    case inlineData
                }
                case text(Swift.String)
                case functionCall(name: Swift.String, args: [Swift.String : Any]?)
                case inlineData(mimeType: Swift.String, base64Data: Swift.String)
            }
            enum CodingKeys {
                case parts
                case role
            }
            let parts: [AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part]?
            let role: Swift.String?
        }
        struct SafetyRating {
            enum CodingKeys {
                case blocked
                case category
                case probability
            }
            let blocked: Swift.Bool?
            let category: Swift.String?
            let probability: Swift.String?
        }
        struct GroundingMetadata {
            enum CodingKeys {
                case searchEntryPoint
                case groundingChunks
                case groundingSupports
                case webSearchQueries
            }
            let searchEntryPoint: AIProxy.GeminiGenerateContentResponseBody.Candidate.SearchEntryPoint?
            let groundingChunks: [AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingChunk]?
            let groundingSupports: [AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingSupport]?
            let webSearchQueries: [Swift.String]?
        }
        struct SearchEntryPoint {
            enum CodingKeys {
                case renderedContent
            }
            let renderedContent: Swift.String?
        }
        struct GroundingChunk {
            enum CodingKeys {
                case web
            }
            let web: AIProxy.GeminiGenerateContentResponseBody.Candidate.WebInfo?
        }
        struct WebInfo {
            enum CodingKeys {
                case uri
                case title
            }
            let uri: Swift.String?
            let title: Swift.String?
        }
        struct GroundingSupport {
            enum CodingKeys {
                case segment
                case groundingChunkIndices
                case confidenceScores
            }
            let segment: AIProxy.GeminiGenerateContentResponseBody.Candidate.Segment?
            let groundingChunkIndices: [Swift.Int]?
            let confidenceScores: [Swift.Double]?
        }
        struct Segment {
            enum CodingKeys {
                case startIndex
                case endIndex
                case text
            }
            let startIndex: Swift.Int?
            let endIndex: Swift.Int?
            let text: Swift.String?
        }
        enum CodingKeys {
            case content
            case finishReason
            case groundingMetadata
            case index
            case safetyRatings
        }
        let content: AIProxy.GeminiGenerateContentResponseBody.Candidate.Content?
        let finishReason: Swift.String?
        let groundingMetadata: AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingMetadata?
        let index: Swift.Int?
        let safetyRatings: [AIProxy.GeminiGenerateContentResponseBody.Candidate.SafetyRating]?
    }
    struct UsageMetadata {
        enum CodingKeys {
            case cachedContentTokenCount
            case candidatesTokenCount
            case promptTokenCount
            case totalTokenCount
            case thoughtsTokenCount
        }
        let cachedContentTokenCount: Swift.Int?
        let candidatesTokenCount: Swift.Int?
        let promptTokenCount: Swift.Int?
        let totalTokenCount: Swift.Int?
        let thoughtsTokenCount: Swift.Int?
    }
    enum CodingKeys {
        case candidates
        case usageMetadata
    }
    let candidates: [AIProxy.GeminiGenerateContentResponseBody.Candidate]?
    let usageMetadata: AIProxy.GeminiGenerateContentResponseBody.UsageMetadata?
}
struct GeminiImagenRequestBody {
    struct Instance {
        struct InputImage {
            enum CodingKeys {
                case bytesBase64Encoded
            }
            let data: Foundation.Data
        }
        enum CodingKeys {
            case prompt
            case image
        }
        let prompt: Swift.String
        let image: AIProxy.GeminiImagenRequestBody.Instance.InputImage?
    }
    struct Parameters {
        enum SafetyLevel {
            case blockLowAndAbove
            case blockMediumAndAbove
            case blockOnlyHigh
            case blockNone
        }
        enum PersonGeneration {
            case dontAllow
            case allowAdult
            case allowAll
        }
        struct UpscaleConfig {
            enum UpscaleFactor {
                case x2
                case x4
            }
            enum CodingKeys {
                case upscaleFactor
            }
            let upscaleFactor: AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig.UpscaleFactor
        }
        enum CodingKeys {
            case aspectRatio
            case mode
            case personGeneration
            case safetyLevel
            case sampleCount
            case upscaleConfig
        }
        let aspectRatio: Swift.String?
        let mode: Swift.String?
        let personGeneration: AIProxy.GeminiImagenRequestBody.Parameters.PersonGeneration?
        let safetyLevel: AIProxy.GeminiImagenRequestBody.Parameters.SafetyLevel?
        let sampleCount: Swift.Int
        let upscaleConfig: AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig?
    }
    enum CodingKeys {
        case instances
        case parameters
    }
    let instances: [AIProxy.GeminiImagenRequestBody.Instance]
    let parameters: AIProxy.GeminiImagenRequestBody.Parameters
}
struct GeminiImagenResponseBody {
    struct Prediction {
        enum CodingKeys {
            case mimeType
            case bytesBase64Encoded
        }
        let mimeType: Swift.String?
        let bytesBase64Encoded: Swift.String
    }
    enum CodingKeys {
        case predictions
    }
    let predictions: [AIProxy.GeminiImagenResponseBody.Prediction]
}
class GeminiProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct GroqChatCompletionResponseBody {
    struct Choice {
        struct Message {
            enum CodingKeys {
                case content
                case role
            }
            let content: Swift.String?
            let role: Swift.String
        }
        enum CodingKeys {
            case finishReason
            case message
        }
        let finishReason: Swift.String?
        let message: AIProxy.GroqChatCompletionResponseBody.Choice.Message
    }
    struct Usage {
        enum CodingKeys {
            case completionTime
            case completionTokens
            case promptTime
            case promptTokens
            case totalTime
            case totalTokens
        }
        let completionTime: Swift.Double?
        let completionTokens: Swift.Int?
        let promptTime: Swift.Double?
        let promptTokens: Swift.Int?
        let totalTime: Swift.Double?
        let totalTokens: Swift.Int?
    }
    enum CodingKeys {
        case choices
        case created
        case model
        case usage
    }
    let choices: [AIProxy.GroqChatCompletionResponseBody.Choice]
    let created: Swift.Int
    let model: Swift.String
    let usage: AIProxy.GroqChatCompletionResponseBody.Usage?
}
struct GroqChatCompletionRequestBody {
    enum Message {
        enum UserContent {
            enum ContentPart {
                enum ImageDetail {
                    case auto
                    case low
                    case high
                }
                enum RootKey {
                    case type
                    case text
                    case imageURL
                }
                enum ImageKey {
                    case url
                    case detail
                }
                case text(Swift.String)
                case imageURL(Foundation.URL, detail: AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.ImageDetail?)
            }
            case text(Swift.String)
            case parts([AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart])
        }
        enum RootKey {
            case content
            case role
            case name
        }
        case assistant(content: Swift.String, name: Swift.String?)
        case system(content: Swift.String, name: Swift.String?)
        case user(content: AIProxy.GroqChatCompletionRequestBody.Message.UserContent, name: Swift.String?)
    }
    enum ResponseFormat {
        enum RootKey {
            case type
        }
        case jsonObject
        case text
    }
    enum CodingKeys {
        case frequencyPenalty
        case maxTokens
        case messages
        case model
        case n
        case parallelToolCalls
        case presencePenalty
        case responseFormat
        case seed
        case stop
        case stream
        case temperature
        case topP
        case user
    }
    let messages: [AIProxy.GroqChatCompletionRequestBody.Message]
    let model: Swift.String
    let frequencyPenalty: Swift.Double?
    let maxTokens: Swift.Int?
    let n: Swift.Int?
    let parallelToolCalls: Swift.Bool?
    let presencePenalty: Swift.Double?
    let responseFormat: AIProxy.GroqChatCompletionRequestBody.ResponseFormat?
    let seed: Swift.Int?
    let stop: [Swift.String]?
    var stream: Swift.Bool?
    let temperature: Swift.Double?
    let topP: Swift.Double?
    let user: Swift.String?
}
struct GroqChatCompletionStreamingChunk {
    struct Choice {
        struct Delta {
            enum CodingKeys {
                case role
                case content
            }
            let role: Swift.String?
            let content: Swift.String?
        }
        enum CodingKeys {
            case delta
            case finishReason
        }
        let delta: AIProxy.GroqChatCompletionStreamingChunk.Choice.Delta
        let finishReason: Swift.String?
    }
    enum CodingKeys {
        case choices
    }
    let choices: [AIProxy.GroqChatCompletionStreamingChunk.Choice]
}
class GroqDirectService {
    let unprotectedAPIKey: Swift.String
    let baseURL: Swift.String
}
class GroqProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct GroqTranscriptionRequestBody {
    let file: Foundation.Data
    let model: Swift.String
    let language: Swift.String?
    let prompt: Swift.String?
    let responseFormat: Swift.String?
    let temperature: Swift.Double?
}
struct GroqTranscriptionResponseBody {
    struct Word {
        enum CodingKeys {
            case end
            case start
            case word
        }
        let end: Swift.Double?
        let start: Swift.Double?
        let word: Swift.String?
    }
    struct Segment {
        enum CodingKeys {
            case seek
            case start
            case end
            case text
            case tokens
            case temperature
            case avgLogprob
            case compressionRatio
            case noSpeechProb
        }
        let avgLogprob: Swift.Double?
        let compressionRatio: Swift.Double?
        let end: Swift.Double?
        let noSpeechProb: Swift.Double?
        let seek: Swift.Int?
        let start: Swift.Double?
        let temperature: Swift.Double?
        let text: Swift.String?
        let tokens: [Swift.Int]?
    }
    enum CodingKeys {
        case duration
        case language
        case segments
        case text
        case words
    }
    let duration: Swift.Double?
    let language: Swift.String?
    let segments: [AIProxy.GroqTranscriptionResponseBody.Segment]?
    let text: Swift.String?
    let words: [AIProxy.GroqTranscriptionResponseBody.Word]?
}
class MicrophonePCMSampleVendorAE {
    let audioEngine: __C.AVAudioEngine
    let inputNode: __C.AVAudioInputNode
    let microphonePCMSampleVendorCommon: AIProxy.MicrophonePCMSampleVendorCommon
    var continuation: Swift.AsyncStream<__C.AVAudioPCMBuffer>.Continuation?
}
class MicrophonePCMSampleVendorAT {
    var audioUnit: Swift.UnsafeMutablePointer<__C.ComponentInstanceRecord>?
    let microphonePCMSampleVendorCommon: AIProxy.MicrophonePCMSampleVendorCommon
    var continuation: Swift.AsyncStream<__C.AVAudioPCMBuffer>.Continuation?
}
class MicrophonePCMSampleVendorCommon {
    var bufferAccumulator: __C.AVAudioPCMBuffer?
    var audioConverter: __C.AVAudioConverter?
}
enum MicrophonePCMSampleVendorError {
    case couldNotConfigureAudioUnit(Swift.String)
}
struct MistralChatCompletionRequestBody {
    enum Message {
        enum RootKey {
            case content
            case role
        }
        case assistant(content: Swift.String)
        case system(content: Swift.String)
        case user(content: Swift.String)
    }
    enum ResponseFormat {
        enum RootKey {
            case type
        }
        case jsonObject
        case text
    }
    enum CodingKeys {
        case messages
        case model
        case frequencyPenalty
        case maxTokens
        case n
        case presencePenalty
        case responseFormat
        case safePrompt
        case seed
        case stop
        case stream
        case temperature
        case topP
    }
    let messages: [AIProxy.MistralChatCompletionRequestBody.Message]
    let model: Swift.String
    let frequencyPenalty: Swift.Double?
    let maxTokens: Swift.Int?
    let n: Swift.Int?
    let presencePenalty: Swift.Double?
    let responseFormat: AIProxy.MistralChatCompletionRequestBody.ResponseFormat?
    let safePrompt: Swift.Bool?
    let seed: Swift.Int?
    let stop: [Swift.String]?
    var stream: Swift.Bool?
    let temperature: Swift.Double?
    let topP: Swift.Double?
}
struct MistralChatCompletionResponseBody {
    struct Choice {
        struct Message {
            enum CodingKeys {
                case content
                case role
            }
            let content: Swift.String
            let role: Swift.String
        }
        enum CodingKeys {
            case finishReason
            case message
        }
        let finishReason: Swift.String?
        let message: AIProxy.MistralChatCompletionResponseBody.Choice.Message
    }
    enum CodingKeys {
        case choices
        case created
        case model
        case usage
    }
    let choices: [AIProxy.MistralChatCompletionResponseBody.Choice]
    let created: Swift.Int
    let model: Swift.String
    let usage: AIProxy.MistralChatUsage?
}
struct MistralChatCompletionStreamingChunk {
    struct Choice {
        struct Delta {
            enum CodingKeys {
                case role
                case content
            }
            let role: Swift.String?
            let content: Swift.String?
        }
        enum CodingKeys {
            case delta
            case finishReason
        }
        let delta: AIProxy.MistralChatCompletionStreamingChunk.Choice.Delta
        let finishReason: Swift.String?
    }
    enum CodingKeys {
        case choices
        case usage
    }
    let choices: [AIProxy.MistralChatCompletionStreamingChunk.Choice]
    let usage: AIProxy.MistralChatUsage?
}
struct MistralChatUsage {
    enum CodingKeys {
        case completionTokens
        case promptTokens
        case totalTokens
    }
    let completionTokens: Swift.Int?
    let promptTokens: Swift.Int?
    let totalTokens: Swift.Int?
}
class MistralDirectService {
    let unprotectedAPIKey: Swift.String
}
struct MistralOCRRequestBody {
    enum Model {
        case mistralOCRLatest
    }
    enum Document {
        enum RootKey {
            case imageURL
            case type
        }
        case imageURLChunk(Foundation.URL)
    }
    enum CodingKeys {
        case document
        case model
        case imageLimit
        case imageMinSize
        case includeImageBase64
    }
    let document: AIProxy.MistralOCRRequestBody.Document
    let model: AIProxy.MistralOCRRequestBody.Model
    let imageLimit: Swift.Int?
    let imageMinSize: Swift.Int?
    let includeImageBase64: Swift.Bool?
}
struct MistralOCRResponseBody {
    struct Page {
        struct ExtractedImage {
            enum CodingKeys {
                case imageBase64
            }
            let imageBase64: Swift.String?
        }
        struct Dimensions {
            enum CodingKeys {
                case dpi
                case height
                case width
            }
            let dpi: Swift.Int?
            let height: Swift.Int?
            let width: Swift.Int?
        }
        enum CodingKeys {
            case dimensions
            case images
            case index
            case markdown
        }
        let dimensions: AIProxy.MistralOCRResponseBody.Page.Dimensions?
        let images: [AIProxy.MistralOCRResponseBody.Page.ExtractedImage]?
        let index: Swift.Int?
        let markdown: Swift.String?
    }
    struct UsageInfo {
        enum CodingKeys {
            case docSizeBytes
            case pagesProcessed
        }
        let docSizeBytes: Swift.Int?
        let pagesProcessed: Swift.Int?
    }
    enum CodingKeys {
        case model
        case pages
        case usageInfo
    }
    let model: Swift.String?
    let pages: [AIProxy.MistralOCRResponseBody.Page]
    let usageInfo: AIProxy.MistralOCRResponseBody.UsageInfo?
}
class MistralProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
enum FormField {
    case fileField(name: Swift.String, content: Foundation.Data, contentType: Swift.String, filename: Swift.String)
    case textField(name: Swift.String, content: Swift.String)
}
struct OpenAIChatCompletionRequestBody {
    enum Message {
        enum MessageContent<A, B> where A: Swift.Encodable, B: Swift.Encodable {
            case text(A)
            case parts(B)
        }
        enum ContentPart {
            enum ImageDetail {
                case auto
                case low
                case high
            }
            enum RootKey {
                case type
                case text
                case imageURL
            }
            enum ImageKey {
                case url
                case detail
            }
            case text(Swift.String)
            case imageURL(Foundation.URL, detail: AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.ImageDetail?)
        }
        struct ToolCall {
            struct Function {
                enum CodingKeys {
                    case name
                    case arguments
                }
                let name: Swift.String
                let arguments: Swift.String?
            }
            enum CodingKeys {
                case id
                case type
                case function
            }
            let id: Swift.String
            let type: Swift.String
            let function: AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.Function
        }
        enum RootKey {
            case content
            case name
            case refusal
            case role
            case toolCallID
            case toolCalls
        }
        case assistant(content: AIProxy.OpenAIChatCompletionRequestBody.Message.MessageContent<Swift.String, [Swift.String]>?, name: Swift.String?, refusal: Swift.String?, toolCalls: [AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall]?)
        case developer(content: AIProxy.OpenAIChatCompletionRequestBody.Message.MessageContent<Swift.String, [Swift.String]>, name: Swift.String?)
        case system(content: AIProxy.OpenAIChatCompletionRequestBody.Message.MessageContent<Swift.String, [Swift.String]>, name: Swift.String?)
        case tool(content: AIProxy.OpenAIChatCompletionRequestBody.Message.MessageContent<Swift.String, [Swift.String]>, toolCallID: Swift.String)
        case user(content: AIProxy.OpenAIChatCompletionRequestBody.Message.MessageContent<Swift.String, [AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart]>, name: Swift.String?)
    }
    enum ResponseFormat {
        enum RootKey {
            case type
            case jsonSchema
        }
        enum SchemaKey {
            case description
            case name
            case schema
            case strict
        }
        case jsonSchema(name: Swift.String, description: Swift.String?, schema: [Swift.String : AIProxy.AIProxyJSONValue]?, strict: Swift.Bool?)
        case generableJSONSchema(name: Swift.String, description: Swift.String?, schema: Swift.Encodable, strict: Swift.Bool?)
        case jsonObject
        case text
    }
    struct StreamOptions {
        enum CodingKeys {
            case includeUsage
        }
        let includeUsage: Swift.Bool
    }
    enum Tool {
        enum RequireApproval {
            case auto
            case manual
            case never
        }
        enum RootKey {
            case type
            case function
        }
        enum FunctionKey {
            case description
            case name
            case parameters
            case strict
        }
        enum MCPKey {
            case type
            case serverLabel
            case serverUrl
            case requireApproval
            case allowedTools
        }
        case function(name: Swift.String, description: Swift.String?, parameters: [Swift.String : AIProxy.AIProxyJSONValue]?, strict: Swift.Bool?)
        case mcp(serverLabel: Swift.String, serverUrl: Swift.String, requireApproval: AIProxy.OpenAIChatCompletionRequestBody.Tool.RequireApproval, allowedTools: [Swift.String]?)
        case webSearch
    }
    enum ToolChoice {
        enum RootKey {
            case type
            case function
        }
        enum FunctionKey {
            case name
        }
        case specific(functionName: Swift.String)
        case none
        case auto
        case required
    }
    struct WebSearchOptions {
        enum SearchContextSize {
            case low
            case medium
            case high
        }
        struct UserLocation {
            struct Approximate {
                enum CodingKeys {
                    case city
                    case country
                    case region
                    case timezone
                    case type
                }
                let city: Swift.String?
                let country: Swift.String?
                let region: Swift.String?
                let timezone: Swift.String?
                let type: Swift.String
            }
            enum CodingKeys {
                case approximate
            }
            let approximate: AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.Approximate
        }
        enum CodingKeys {
            case searchContextSize
            case userLocation
        }
        let searchContextSize: AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.SearchContextSize?
        let userLocation: AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation?
    }
    enum CodingKeys {
        case model
        case messages
        case frequencyPenalty
        case logitBias
        case logprobs
        case maxTokens
        case maxCompletionTokens
        case metadata
        case n
        case parallelToolCalls
        case presencePenalty
        case responseFormat
        case seed
        case stop
        case store
        case stream
        case streamOptions
        case temperature
        case tools
        case toolChoice
        case topLogprobs
        case topP
        case user
        case webSearchOptions
    }
    let model: Swift.String
    let messages: [AIProxy.OpenAIChatCompletionRequestBody.Message]
    let frequencyPenalty: Swift.Double?
    let logitBias: [Swift.String : Swift.Double]?
    let logprobs: Swift.Bool?
    let maxTokens: Swift.Int?
    let maxCompletionTokens: Swift.Int?
    let metadata: [Swift.String : AIProxy.AIProxyJSONValue]?
    let n: Swift.Int?
    let parallelToolCalls: Swift.Bool?
    let presencePenalty: Swift.Double?
    let responseFormat: AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat?
    let seed: Swift.Int?
    let stop: [Swift.String]?
    let store: Swift.Bool?
    var stream: Swift.Bool?
    var streamOptions: AIProxy.OpenAIChatCompletionRequestBody.StreamOptions?
    let temperature: Swift.Double?
    let tools: [AIProxy.OpenAIChatCompletionRequestBody.Tool]?
    let toolChoice: AIProxy.OpenAIChatCompletionRequestBody.ToolChoice?
    let topLogprobs: Swift.Int?
    let topP: Swift.Double?
    let user: Swift.String?
    let webSearchOptions: AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions?
}
struct OpenAIChatCompletionResponseBody {
    struct Choice {
        struct Message {
            struct ToolCall {
                struct Function {
                    enum CodingKeys {
                        case name
                        case arguments
                    }
                    let name: Swift.String
                    let arguments: [Swift.String : Any]?
                    let argumentsRaw: Swift.String?
                }
                enum CodingKeys {
                    case id
                    case type
                    case function
                }
                let id: Swift.String
                let type: Swift.String
                let function: AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.Function
            }
            enum CodingKeys {
                case content
                case role
                case toolCalls
            }
            let content: Swift.String?
            let role: Swift.String
            let toolCalls: [AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall]?
        }
        enum CodingKeys {
            case finishReason
            case message
        }
        let finishReason: Swift.String?
        let message: AIProxy.OpenAIChatCompletionResponseBody.Choice.Message
    }
    enum CodingKeys {
        case choices
        case created
        case model
        case usage
        case systemFingerprint
    }
    let choices: [AIProxy.OpenAIChatCompletionResponseBody.Choice]
    let created: Swift.Int
    let model: Swift.String
    let usage: AIProxy.OpenAIChatUsage?
    let systemFingerprint: Swift.String?
}
struct OpenAIChatCompletionChunk {
    struct Choice {
        struct Delta {
            struct ToolCall {
                struct Function {
                    enum CodingKeys {
                        case name
                        case arguments
                    }
                    let name: Swift.String?
                    let arguments: Swift.String?
                }
                enum CodingKeys {
                    case index
                    case id
                    case type
                    case function
                }
                let index: Swift.Int?
                let id: Swift.String?
                let type: Swift.String?
                let function: AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.Function?
            }
            enum CodingKeys {
                case content
                case refusal
                case role
                case toolCalls
            }
            let content: Swift.String?
            let refusal: Swift.String?
            let role: Swift.String?
            let toolCalls: [AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall]?
        }
        enum CodingKeys {
            case delta
            case finishReason
            case index
        }
        let delta: AIProxy.OpenAIChatCompletionChunk.Choice.Delta
        let finishReason: Swift.String?
        let index: Swift.Int?
    }
    enum CodingKeys {
        case choices
        case created
        case id
        case model
        case serviceTier
        case systemFingerprint
        case usage
    }
    let choices: [AIProxy.OpenAIChatCompletionChunk.Choice]
    let created: Swift.Int?
    let id: Swift.String?
    let model: Swift.String?
    let serviceTier: Swift.String?
    let systemFingerprint: Swift.String?
    let usage: AIProxy.OpenAIChatUsage?
}
struct OpenAIChatUsage {
    struct Details {
        enum CodingKeys {
            case reasoningTokens
        }
        let reasoningTokens: Swift.Int?
    }
    enum CodingKeys {
        case completionTokens
        case promptTokens
        case totalTokens
        case completionTokensDetails
    }
    let completionTokens: Swift.Int?
    let promptTokens: Swift.Int?
    let totalTokens: Swift.Int?
    let completionTokensDetails: AIProxy.OpenAIChatUsage.Details?
}
struct OpenAICreateImageEditRequestBody {
    enum Background {
        case auto
        case opaque
        case transparent
    }
    enum InputFidelity {
        case low
        case high
    }
    enum InputImage {
        case png(Foundation.Data)
        case jpeg(Foundation.Data)
    }
    enum Model {
        case dallE2
        case gptImage1
    }
    enum OutputFormat {
        case jpeg
        case png
        case webp
    }
    enum Quality {
        case auto
        case high
        case medium
        case low
        case standard
    }
    enum ResponseFormat {
        case b64JSON
        case url
    }
    let images: [AIProxy.OpenAICreateImageEditRequestBody.InputImage]
    let prompt: Swift.String
    let background: AIProxy.OpenAICreateImageEditRequestBody.Background?
    let inputFidelity: AIProxy.OpenAICreateImageEditRequestBody.InputFidelity?
    let mask: Foundation.Data?
    let model: AIProxy.OpenAICreateImageEditRequestBody.Model?
    let n: Swift.Int?
    let outputFormat: AIProxy.OpenAICreateImageEditRequestBody.OutputFormat?
    let quality: AIProxy.OpenAICreateImageEditRequestBody.Quality?
    let responseFormat: AIProxy.OpenAICreateImageEditRequestBody.ResponseFormat?
    let size: Swift.String?
    let user: Swift.String?
}
struct OpenAICreateImageRequestBody {
    enum Background {
        case auto
        case opaque
        case transparent
    }
    enum Model {
        case dallE2
        case dallE3
        case gptImage1
    }
    enum Moderation {
        case auto
        case low
    }
    enum OutputFormat {
        case jpeg
        case png
        case webp
    }
    enum Quality {
        case auto
        case high
        case medium
        case low
        case hd
        case standard
    }
    enum ResponseFormat {
        case b64JSON
        case url
    }
    enum Style {
        case vivid
        case natural
    }
    enum CodingKeys {
        case prompt
        case background
        case model
        case moderation
        case outputCompression
        case outputFormat
        case n
        case quality
        case responseFormat
        case size
        case style
        case user
    }
    let prompt: Swift.String
    let background: AIProxy.OpenAICreateImageRequestBody.Background?
    let model: AIProxy.OpenAICreateImageRequestBody.Model?
    let moderation: AIProxy.OpenAICreateImageRequestBody.Moderation?
    let n: Swift.Int?
    let outputCompression: Swift.Int?
    let outputFormat: AIProxy.OpenAICreateImageRequestBody.OutputFormat?
    let quality: AIProxy.OpenAICreateImageRequestBody.Quality?
    let responseFormat: AIProxy.OpenAICreateImageRequestBody.ResponseFormat?
    let size: Swift.String?
    let style: AIProxy.OpenAICreateImageRequestBody.Style?
    let user: Swift.String?
}
struct OpenAICreateImageResponseBody {
    struct ImageData {
        enum CodingKeys {
            case b64JSON
            case revisedPrompt
            case url
        }
        let b64JSON: Swift.String?
        let revisedPrompt: Swift.String?
        let url: Foundation.URL?
    }
    enum CodingKeys {
        case data
    }
    let data: [AIProxy.OpenAICreateImageResponseBody.ImageData]
}
struct OpenAICreateResponseRequestBody {
    enum Include {
        case codeInterpreterCallOutputs
        case computerCallOutputImageUrl
        case fileSearchCallResults
        case messageInputImageImageUrl
        case messageOutputTextLogprobs
        case reasoningEncryptedContent
        case webSearchCallActionSources
    }
    enum Truncation {
        case auto
        case disabled
    }
    struct Prompt {
        enum CodingKeys {
            case id
            case variables
            case version
        }
        let id: Swift.String
        let variables: [Swift.String : AIProxy.OpenAICreateResponseRequestBody.Variable]?
        let version: Swift.String?
    }
    enum Variable {
        case text(Swift.String)
    }
    enum Tool {
        enum CodingKeys {
            case description
            case displayHeight
            case displayWidth
            case environment
            case filters
            case maxNumResults
            case name
            case parameters
            case rankingOptions
            case searchContextSize
            case strict
            case type
            case userLocation
            case vectorStoreIDs
        }
        case computerUse(AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool)
        case fileSearch(AIProxy.OpenAICreateResponseRequestBody.FileSearchTool)
        case function(AIProxy.OpenAICreateResponseRequestBody.FunctionTool)
        case webSearch(AIProxy.OpenAICreateResponseRequestBody.WebSearchTool)
        case webSearchPreview(AIProxy.OpenAICreateResponseRequestBody.WebSearchTool)
    }
    struct FileSearchTool {
        struct RankingOptions {
            enum CodingKeys {
                case ranker
                case scoreThreshold
            }
            let ranker: Swift.String?
            let scoreThreshold: Swift.Double?
        }
        enum CodingKeys {
            case type
            case vectorStoreIDs
            case filters
            case maxNumResults
            case rankingOptions
        }
        let type: Swift.String
        let vectorStoreIDs: [Swift.String]
        let filters: AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter?
        let maxNumResults: Swift.Int?
        let rankingOptions: AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.RankingOptions?
    }
    enum FileSearchFilter {
        struct ComparisonFilter {
            enum CodingKeys {
                case key
                case type
                case value
            }
            let key: Swift.String
            let type: AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonOperator
            let value: AIProxy.AIProxyJSONValue
        }
        enum ComparisonOperator {
            case eq
            case ne
            case gt
            case gte
            case lt
            case lte
        }
        struct CompoundFilter {
            enum CodingKeys {
                case filters
                case type
            }
            let filters: [AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter]
            let type: AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundOperator
        }
        enum CompoundOperator {
            case and
            case or
        }
        enum CodingKeys {
            case comparison
            case compound
        }
        enum ComparisonCodingKeys {
            case _0
        }
        enum CompoundCodingKeys {
            case _0
        }
        case comparison(AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonFilter)
        case compound(AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundFilter)
    }
    struct WebSearchTool {
        enum SearchContextSize {
            case high
            case medium
            case low
        }
        struct UserLocation {
            enum CodingKeys {
                case type
                case city
                case country
                case region
                case timezone
            }
            var type: Swift.String
            let city: Swift.String?
            let country: Swift.String?
            let region: Swift.String?
            let timezone: Swift.String?
        }
        enum CodingKeys {
            case type
            case searchContextSize
            case userLocation
        }
        let type: Swift.String
        let searchContextSize: AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.SearchContextSize?
        let userLocation: AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.UserLocation?
    }
    struct ComputerUseTool {
        enum Environment {
            case browser
            case mac
            case windows
            case ubuntu
        }
        enum CodingKeys {
            case type
            case displayWidth
            case displayHeight
            case environment
        }
        let type: Swift.String
        let displayWidth: Swift.Int
        let displayHeight: Swift.Int
        let environment: AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.Environment
    }
    struct FunctionTool {
        enum CodingKeys {
            case description
            case name
            case parameters
            case strict
            case type
        }
        let name: Swift.String
        let parameters: [Swift.String : AIProxy.AIProxyJSONValue]
        let strict: Swift.Bool
        let type: Swift.String
        let description: Swift.String?
    }
    struct Reasoning {
        enum Effort {
            case minimal
            case low
            case medium
            case high
        }
        enum SummaryType {
            case auto
            case concise
            case detailed
        }
        enum CodingKeys {
            case effort
            case generateSummary
            case summary
        }
        let effort: AIProxy.OpenAICreateResponseRequestBody.Reasoning.Effort?
        let generateSummary: AIProxy.OpenAICreateResponseRequestBody.Reasoning.SummaryType?
        let summary: AIProxy.OpenAICreateResponseRequestBody.Reasoning.SummaryType?
    }
    enum ToolChoice {
        enum CodingKeys {
            case type
            case name
        }
        case function(name: Swift.String)
        case none
        case auto
        case required
    }
    enum CodingKeys {
        case include
        case input
        case model
        case tools
        case toolChoice
        case reasoning
        case safetyIdentifier
        case parallelToolCalls
        case previousResponseId
        case prompt
        case truncation
        case stream
        case temperature
        case topP
        case user
        case text
    }
    let include: [AIProxy.OpenAICreateResponseRequestBody.Include]?
    let input: AIProxy.OpenAIResponse.Input?
    let model: Swift.String?
    let parallelToolCalls: Swift.Bool?
    let previousResponseId: Swift.String?
    let prompt: AIProxy.OpenAICreateResponseRequestBody.Prompt?
    let reasoning: AIProxy.OpenAICreateResponseRequestBody.Reasoning?
    let safetyIdentifier: Swift.String?
    var stream: Swift.Bool?
    let temperature: Swift.Double?
    let text: AIProxy.OpenAIResponse.TextConfiguration?
    let toolChoice: AIProxy.OpenAICreateResponseRequestBody.ToolChoice?
    let tools: [AIProxy.OpenAICreateResponseRequestBody.Tool]?
    let topP: Swift.Double?
    let truncation: AIProxy.OpenAICreateResponseRequestBody.Truncation?
    let user: Swift.String?
}
struct OpenAICreateTranscriptionRequestBody {
    enum TimestampGranularity {
        case word
        case segment
    }
    let file: Foundation.Data
    let model: Swift.String
    let language: Swift.String?
    let prompt: Swift.String?
    let responseFormat: Swift.String?
    let temperature: Swift.Double?
    let timestampGranularities: [AIProxy.OpenAICreateTranscriptionRequestBody.TimestampGranularity]?
}
struct OpenAICreateTranscriptionResponseBody {
    struct Word {
        enum CodingKeys {
            case word
            case start
            case end
        }
        let word: Swift.String
        let start: Swift.Double
        let end: Swift.Double
    }
    struct Segment {
        enum CodingKeys {
            case seek
            case start
            case end
            case text
            case tokens
            case temperature
            case avgLogprob
            case compressionRatio
            case noSpeechProb
        }
        let seek: Swift.Int
        let start: Swift.Double
        let end: Swift.Double
        let text: Swift.String
        let tokens: [Swift.Int]
        let temperature: Swift.Double
        let avgLogprob: Swift.Double
        let compressionRatio: Swift.Double
        let noSpeechProb: Swift.Double
    }
    enum CodingKeys {
        case text
        case language
        case duration
        case words
        case segments
    }
    let text: Swift.String
    let language: Swift.String?
    let duration: Swift.Double?
    let words: [AIProxy.OpenAICreateTranscriptionResponseBody.Word]?
    let segments: [AIProxy.OpenAICreateTranscriptionResponseBody.Segment]?
}
struct OpenAICreateVectorStoreFileRequestBody {
    enum CodingKeys {
        case fileID
        case chunkingStrategy
        case metadata
    }
    let fileID: Swift.String
    let chunkingStrategy: AIProxy.OpenAIVectorStoreChunkingStrategy?
    let metadata: [Swift.String : Swift.String]?
}
struct OpenAICreateVectorStoreRequestBody {
    enum ChunkingStrategy {
        enum CodingKeys {
            case type
            case static
        }
        enum NestedKeys {
            case chunkOverlapTokens
            case maxChunkSizeTokens
        }
        case static(chunkOverlapTokens: Swift.Int, maxChunkSizeTokens: Swift.Int)
        case auto
    }
    enum CodingKeys {
        case chunkingStrategy
        case expiresAfter
        case fileIds
        case metadata
        case name
    }
    let chunkingStrategy: AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy?
    let expiresAfter: AIProxy.OpenAIVectorStoreExpiresAfter?
    let fileIds: [Swift.String]?
    let metadata: [Swift.String : Swift.String]?
    let name: Swift.String?
}
struct OpenAIDirectRequestBuilder {
    let baseURL: Swift.String
    let unprotectedAuthHeader: (key: Swift.String, value: Swift.String)
}
class OpenAIDirectService: AIProxy.OpenAIService {}
struct OpenAIDirectServiceNetworker {}
struct OpenAIEmbeddingRequestBody {
    enum EmbeddingInput {
        case text(Swift.String)
        case textArray([Swift.String])
        case intArray([Swift.Int])
    }
    enum EncodingFormat {
        case float
        case base64
    }
    enum CodingKeys {
        case input
        case model
        case encodingFormat
        case dimensions
        case user
    }
    let input: AIProxy.OpenAIEmbeddingRequestBody.EmbeddingInput
    let model: Swift.String
    let encodingFormat: AIProxy.OpenAIEmbeddingRequestBody.EncodingFormat?
    let dimensions: Swift.Int?
    let user: Swift.String?
}
struct OpenAIEmbeddingResponseBody {
    struct Embedding {
        enum CodingKeys {
            case embedding
            case index
        }
        let vector: [Swift.Double]
        let index: Swift.Int?
    }
    struct Usage {
        enum CodingKeys {
            case promptTokens
            case totalTokens
        }
        let promptTokens: Swift.Int
        let totalTokens: Swift.Int
    }
    enum CodingKeys {
        case data
        case model
        case usage
    }
    let embeddings: [AIProxy.OpenAIEmbeddingResponseBody.Embedding]
    let model: Swift.String?
    let usage: AIProxy.OpenAIEmbeddingResponseBody.Usage?
}
enum OpenAIFilePurpose {
    case assistants
    case batch
    case evals
    case fineTune
    case userData
    case vision
}
struct OpenAIFileUploadRequestBody {
    let contents: Foundation.Data
    let contentType: Swift.String
    let fileName: Swift.String
    let purpose: AIProxy.OpenAIFilePurpose
}
struct OpenAIFileUploadResponseBody {
    enum CodingKeys {
        case bytes
        case createdAt
        case expiresAt
        case filename
        case id
        case purpose
    }
    let bytes: Swift.Int?
    let createdAt: Swift.Int?
    let expiresAt: Swift.Int?
    let filename: Swift.String?
    let id: Swift.String
    let purpose: Swift.String?
}
struct OpenAIModerationRequestBody {
    enum ModerationInput {
        enum RootKey {
            case imageURL
            case text
            case type
        }
        enum NestedKey {
            case url
        }
        case text(Swift.String)
        case image(Foundation.URL)
    }
    enum CodingKeys {
        case input
        case model
    }
    let input: [AIProxy.OpenAIModerationRequestBody.ModerationInput]
    let model: Swift.String
}
struct OpenAIModerationResponseBody {
    struct ModerationResult {
        struct Categories {
            enum CodingKeys {
                case hate
                case hateThreatening
                case harassment
                case harassmentThreatening
                case illicit
                case illicitViolent
                case sexual
                case sexualMinors
                case selfHarm
                case selfHarmIntent
                case selfHarmInstructions
                case violence
                case violenceGraphic
            }
            let hate: Swift.Bool?
            let hateThreatening: Swift.Bool?
            let harassment: Swift.Bool?
            let harassmentThreatening: Swift.Bool?
            let illicit: Swift.Bool?
            let illicitViolent: Swift.Bool?
            let sexual: Swift.Bool?
            let sexualMinors: Swift.Bool?
            let selfHarm: Swift.Bool?
            let selfHarmIntent: Swift.Bool?
            let selfHarmInstructions: Swift.Bool?
            let violence: Swift.Bool?
            let violenceGraphic: Swift.Bool?
        }
        struct CategoryScores {
            enum CodingKeys {
                case hate
                case hateThreatening
                case harassment
                case harassmentThreatening
                case illicit
                case illicitViolent
                case sexual
                case sexualMinors
                case selfHarm
                case selfHarmIntent
                case selfHarmInstructions
                case violence
                case violenceGraphic
            }
            let hate: Swift.Double?
            let hateThreatening: Swift.Double?
            let harassment: Swift.Double?
            let harassmentThreatening: Swift.Double?
            let illicit: Swift.Double?
            let illicitViolent: Swift.Double?
            let sexual: Swift.Double?
            let sexualMinors: Swift.Double?
            let selfHarm: Swift.Double?
            let selfHarmIntent: Swift.Double?
            let selfHarmInstructions: Swift.Double?
            let violence: Swift.Double?
            let violenceGraphic: Swift.Double?
        }
        struct CategoryAppliedInputTypes {
            enum InputType {
                case image
                case text
            }
            enum CodingKeys {
                case hate
                case hateThreatening
                case harassment
                case harassmentThreatening
                case illicit
                case illicitViolent
                case sexual
                case sexualMinors
                case selfHarm
                case selfHarmIntent
                case selfHarmInstructions
                case violence
                case violenceGraphic
            }
            let hate: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let hateThreatening: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let harassment: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let harassmentThreatening: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let illicit: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let illicitViolent: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let sexual: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let sexualMinors: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let selfHarm: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let selfHarmIntent: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let selfHarmInstructions: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let violence: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
            let violenceGraphic: [AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType]?
        }
        enum CodingKeys {
            case categoryAppliedInputTypes
            case categoryScores
            case categories
            case flagged
        }
        let categoryAppliedInputTypes: AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes?
        let categoryScores: AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryScores?
        let categories: AIProxy.OpenAIModerationResponseBody.ModerationResult.Categories?
        let flagged: Swift.Bool
    }
    enum CodingKeys {
        case id
        case model
        case results
    }
    let id: Swift.String?
    let model: Swift.String?
    let results: [AIProxy.OpenAIModerationResponseBody.ModerationResult]
}
struct OpenAIProxiedRequestBuilder {
    let partialKey: Swift.String
    let serviceURL: Swift.String?
    let clientID: Swift.String?
}
class OpenAIProxiedService: AIProxy.OpenAIService {}
struct OpenAIProxiedServiceNetworker {}
struct OpenAIRealtimeConversationItemCreate {
    struct Item {
        struct Content {
            enum CodingKeys {
                case type
                case text
            }
            let type: Swift.String
            let text: Swift.String
        }
        enum CodingKeys {
            case type
            case role
            case content
        }
        let type: Swift.String
        let role: Swift.String
        let content: [AIProxy.OpenAIRealtimeConversationItemCreate.Item.Content]
    }
    enum CodingKeys {
        case type
        case item
    }
    let type: Swift.String
    let item: AIProxy.OpenAIRealtimeConversationItemCreate.Item
}
struct OpenAIRealtimeInputAudioBufferAppend {
    enum CodingKeys {
        case type
        case audio
    }
    let type: Swift.String
    let audio: Swift.String
}
struct OpenAIRealtimeInputAudioBufferSpeechStarted {
    enum CodingKeys {
        case audioStartMs
    }
    let type: Swift.String
    let audioStartMs: Swift.Int
}
enum OpenAIRealtimeMessage {
    case error(Swift.String?)
    case responseAudioDelta(Swift.String)
    case responseFunctionCallArgumentsDone(Swift.String, Swift.String)
    case responseTranscriptDelta(Swift.String)
    case responseTranscriptDone(Swift.String)
    case inputAudioBufferTranscript(Swift.String)
    case inputAudioTranscriptionDelta(Swift.String)
    case inputAudioTranscriptionCompleted(Swift.String)
    case sessionCreated
    case sessionUpdated
    case responseCreated
    case inputAudioBufferSpeechStarted
}
struct OpenAIRealtimeResponseCreate {
    struct Response {
        struct Tool {
            enum CodingKeys {
                case name
                case description
                case parameters
                case type
            }
            let name: Swift.String
            let description: Swift.String
            let parameters: [Swift.String : AIProxy.AIProxyJSONValue]
            let type: Swift.String
        }
        enum CodingKeys {
            case instructions
            case modalities
            case tools
        }
        let instructions: Swift.String?
        let modalities: [Swift.String]?
        let tools: [AIProxy.OpenAIRealtimeResponseCreate.Response.Tool]?
    }
    enum CodingKeys {
        case type
        case response
    }
    let type: Swift.String
    let response: AIProxy.OpenAIRealtimeResponseCreate.Response?
}
struct OpenAIRealtimeResponseFunctionCallArgumentsDone {
    enum CodingKeys {
        case type
        case name
        case arguments
    }
    let type: Swift.String
    let name: Swift.String?
    let arguments: Swift.String?
}
class OpenAIRealtimeSession {
    var isTearingDown: Swift.Bool
    let webSocketTask: __C.NSURLSessionWebSocketTask
    var continuation: Swift.AsyncStream<AIProxy.OpenAIRealtimeMessage>.Continuation?
    let setupTime: Foundation.Date
    let sessionConfiguration: AIProxy.OpenAIRealtimeSessionConfiguration
}
struct OpenAIRealtimeSessionConfiguration {
    enum ToolChoice {
        enum RootKey {
            case type
            case function
        }
        enum FunctionKey {
            case name
        }
        case specific(functionName: Swift.String)
        case none
        case auto
        case required
    }
    struct InputAudioTranscription {
        enum CodingKeys {
            case model
        }
        let model: Swift.String
    }
    enum MaxResponseOutputTokens {
        case int(Swift.Int)
        case infinite
    }
    struct Tool {
        enum CodingKeys {
            case description
            case name
            case parameters
            case type
        }
        let description: Swift.String
        let name: Swift.String
        let parameters: [Swift.String : AIProxy.AIProxyJSONValue]
        let type: Swift.String
    }
    struct TurnDetection {
        enum DetectionType {
            enum Eagerness {
                case low
                case medium
                case high
            }
            enum CodingKeys {
                case serverVAD
                case semanticVAD
            }
            enum ServerVADCodingKeys {
                case prefixPaddingMs
                case silenceDurationMs
                case threshold
            }
            enum SemanticVADCodingKeys {
                case eagerness
            }
            case serverVAD(prefixPaddingMs: Swift.Int, silenceDurationMs: Swift.Int, threshold: Swift.Double)
            case semanticVAD(eagerness: AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.Eagerness)
        }
        enum CodingKeys {
            case prefixPaddingMs
            case silenceDurationMs
            case threshold
            case type
            case eagerness
        }
        let type: AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType
    }
    enum AudioFormat {
        case pcm16
        case g711Ulaw
        case g711Alaw
    }
    enum Modality {
        case audio
        case text
    }
    enum CodingKeys {
        case inputAudioFormat
        case inputAudioTranscription
        case instructions
        case maxResponseOutputTokens
        case modalities
        case outputAudioFormat
        case temperature
        case tools
        case toolChoice
        case turnDetection
        case voice
    }
    let inputAudioFormat: AIProxy.OpenAIRealtimeSessionConfiguration.AudioFormat?
    let inputAudioTranscription: AIProxy.OpenAIRealtimeSessionConfiguration.InputAudioTranscription?
    let instructions: Swift.String?
    let maxResponseOutputTokens: AIProxy.OpenAIRealtimeSessionConfiguration.MaxResponseOutputTokens?
    let modalities: [AIProxy.OpenAIRealtimeSessionConfiguration.Modality]?
    let outputAudioFormat: AIProxy.OpenAIRealtimeSessionConfiguration.AudioFormat?
    let temperature: Swift.Double?
    let tools: [AIProxy.OpenAIRealtimeSessionConfiguration.Tool]?
    let toolChoice: AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice?
    let turnDetection: AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection?
    let voice: Swift.String?
}
struct OpenAIRealtimeSessionUpdate {
    enum CodingKeys {
        case eventId
        case session
        case type
    }
    let eventId: Swift.String?
    let session: AIProxy.OpenAIRealtimeSessionConfiguration
    let type: Swift.String
}
enum OpenAIRequestFormat {
    case azureDeployment(apiVersion: Swift.String)
    case standard
    case noVersionPrefix
}
struct OpenAIResponse {
    enum Instructions {
        case text(Swift.String)
        case inputs([AIProxy.OpenAIResponse.Input.InputItem])
        case unknown
    }
    struct IncompleteDetails {
        enum CodingKeys {
            case reason
        }
        let reason: Swift.String
    }
    struct ResponseError {
        enum CodingKeys {
            case code
            case message
        }
        let code: Swift.String
        let message: Swift.String
    }
    struct Reasoning {
        enum Effort {
            case low
            case medium
            case high
        }
        enum CodingKeys {
            case effort
            case generateSummary
        }
        let effort: AIProxy.OpenAIResponse.Reasoning.Effort?
        let generateSummary: Swift.String?
    }
    enum Status {
        case completed
        case failed
        case incomplete
        case inProgress
    }
    enum ToolChoiceOptions {
        case none
        case auto
        case required
    }
    struct OutputTokensDetails {
        enum CodingKeys {
            case reasoningTokens
        }
        let reasoningTokens: Swift.Int
    }
    struct ResponseUsage {
        enum CodingKeys {
            case inputTokens
            case outputTokens
            case outputTokensDetails
            case totalTokens
        }
        let inputTokens: Swift.Int?
        let outputTokens: Swift.Int?
        let outputTokensDetails: AIProxy.OpenAIResponse.OutputTokensDetails?
        let totalTokens: Swift.Int?
    }
    enum ResponseOutputItem {
        enum CodingKeys {
            case type
        }
        case message(AIProxy.OpenAIResponse.ResponseOutputMessage)
        case webSearchCall(AIProxy.OpenAIResponse.WebSearchCall)
        case fileSearchCall(AIProxy.OpenAIResponse.FileSearchCall)
        case functionCall(AIProxy.OpenAIResponse.FunctionCall)
        case computerCall(AIProxy.OpenAIResponse.ComputerCall)
        case reasoning(AIProxy.OpenAIResponse.Reasoning)
    }
    struct WebSearchCall {
        struct WebSearchAction {
            enum CodingKeys {
                case type
                case query
                case sources
            }
            let type: Swift.String
            let query: Swift.String?
            let sources: [AIProxy.OpenAIResponse.WebSearchCall.WebSearchSource]?
        }
        struct WebSearchSource {
            enum CodingKeys {
                case type
                case url
            }
            let type: Swift.String
            let url: Swift.String
        }
        enum CodingKeys {
            case type
            case id
            case status
            case action
        }
        var type: Swift.String
        let id: Swift.String
        let status: Swift.String
        let action: AIProxy.OpenAIResponse.WebSearchCall.WebSearchAction?
    }
    struct FileSearchCall {
        struct FileSearchResult {
            enum CodingKeys {
                case content
                case metadata
                case score
            }
            let content: Swift.String
            let metadata: [Swift.String : Swift.String]?
            let score: Swift.Double?
        }
        enum CodingKeys {
            case type
            case id
            case status
            case queries
            case results
        }
        var type: Swift.String
        let id: Swift.String
        let status: Swift.String
        let queries: [Swift.String]
        let results: [AIProxy.OpenAIResponse.FileSearchCall.FileSearchResult]?
    }
    struct FunctionCall {
        enum CodingKeys {
            case id
            case callId
            case name
            case arguments
            case status
        }
        let type: Swift.String
        let id: Swift.String
        let callId: Swift.String
        let name: Swift.String
        let arguments: Swift.String
        let status: Swift.String
    }
    struct ComputerCall {
        enum CodingKeys {
            case id
            case callId
            case action
            case pendingSafetyChecks
            case status
        }
        let type: Swift.String
        let id: Swift.String
        let callId: Swift.String
        let action: AIProxy.OpenAIResponse.ComputerAction
        let pendingSafetyChecks: [AIProxy.OpenAIResponse.SafetyCheck]?
        let status: Swift.String
    }
    struct ComputerAction {
        enum CodingKeys {
            case type
            case button
            case x
            case y
            case scrollX
            case scrollY
            case keys
            case text
        }
        let type: Swift.String
        let button: Swift.String?
        let x: Swift.Int?
        let y: Swift.Int?
        let scrollX: Swift.Int?
        let scrollY: Swift.Int?
        let keys: [Swift.String]?
        let text: Swift.String?
    }
    struct SafetyCheck {
        enum CodingKeys {
            case id
            case code
            case message
        }
        let id: Swift.String
        let code: Swift.String
        let message: Swift.String
    }
    struct ResponseOutputMessage {
        enum CodingKeys {
            case content
            case id
            case role
            case status
        }
        let content: [AIProxy.OpenAIResponse.Content]
        let id: Swift.String?
        let role: Swift.String?
        let status: Swift.String?
    }
    enum Content {
        enum CodingKeys {
            case type
        }
        case outputText(AIProxy.OpenAIResponse.OutputText)
        case refusal(Swift.String)
    }
    struct OutputText {
        enum CodingKeys {
            case text
            case annotations
        }
        let text: Swift.String
        let annotations: [AIProxy.OpenAIResponse.Annotation]?
    }
    enum Annotation {
        enum CodingKeys {
            case type
        }
        case urlCitation(AIProxy.OpenAIResponse.URLCitation)
        case fileCitation(AIProxy.OpenAIResponse.FileCitation)
        case filePath(AIProxy.OpenAIResponse.FilePath)
    }
    struct URLCitation {
        enum CodingKeys {
            case startIndex
            case endIndex
            case url
            case title
        }
        let startIndex: Swift.Int
        let endIndex: Swift.Int
        let url: Foundation.URL
        let title: Swift.String
    }
    struct FileCitation {
        enum CodingKeys {
            case index
            case fileId
            case filename
        }
        let index: Swift.Int
        let fileId: Swift.String
        let filename: Swift.String
    }
    struct FilePath {
        enum CodingKeys {
            case index
            case fileId
        }
        let index: Swift.Int
        let fileId: Swift.String
    }
    enum CodingKeys {
        case createdAt
        case error
        case id
        case incompleteDetails
        case instructions
        case maxOutputTokens
        case metadata
        case model
        case output
        case parallelToolCalls
        case previousResponseId
        case reasoning
        case status
        case text
        case temperature
        case toolChoice
        case tools
        case topP
        case truncation
        case usage
        case user
    }
    enum Input {
        enum InputItem {
            enum Role {
                case user
                case assistant
                case system
                case developer
            }
            enum Content {
                enum ItemContent {
                    enum CodingKeys {
                        case fileID
                        case imageURL
                        case type
                        case text
                    }
                    case file(fileID: Swift.String)
                    case imageURL(Foundation.URL)
                    case text(Swift.String)
                }
                case text(Swift.String)
                case list([AIProxy.OpenAIResponse.Input.InputItem.Content.ItemContent])
            }
            struct _Message {
                enum CodingKeys {
                    case content
                    case role
                    case type
                }
                let role: AIProxy.OpenAIResponse.Input.InputItem.Role
                let content: AIProxy.OpenAIResponse.Input.InputItem.Content
            }
            case message(role: AIProxy.OpenAIResponse.Input.InputItem.Role, content: AIProxy.OpenAIResponse.Input.InputItem.Content)
        }
        case text(Swift.String)
        case items([AIProxy.OpenAIResponse.Input.InputItem])
    }
    struct TextConfiguration {
        enum Format {
            enum RootKey {
                case type
                case name
                case schema
                case strict
                case description
            }
            case jsonSchema(name: Swift.String, schema: [Swift.String : AIProxy.AIProxyJSONValue], description: Swift.String?, strict: Swift.Bool?)
            case jsonObject
            case text
        }
        enum Verbosity {
            case low
            case medium
            case high
        }
        enum CodingKeys {
            case format
            case verbosity
        }
        let format: AIProxy.OpenAIResponse.TextConfiguration.Format?
        let verbosity: AIProxy.OpenAIResponse.TextConfiguration.Verbosity?
    }
    let createdAt: Swift.Double?
    let error: AIProxy.OpenAIResponse.ResponseError?
    let id: Swift.String?
    let incompleteDetails: AIProxy.OpenAIResponse.IncompleteDetails?
    let instructions: AIProxy.OpenAIResponse.Instructions?
    let maxOutputTokens: Swift.Int?
    let metadata: [Swift.String : Swift.String]?
    let model: Swift.String?
    let output: [AIProxy.OpenAIResponse.ResponseOutputItem]
    let parallelToolCalls: Swift.Bool?
    let previousResponseId: Swift.String?
    let reasoning: AIProxy.OpenAIResponse.Reasoning?
    let status: AIProxy.OpenAIResponse.Status?
    let text: AIProxy.OpenAIResponse.TextConfiguration?
    let temperature: Swift.Double?
    let toolChoice: AIProxy.OpenAICreateResponseRequestBody.ToolChoice?
    let tools: [AIProxy.OpenAICreateResponseRequestBody.Tool]?
    let topP: Swift.Double?
    let truncation: Swift.String?
    let usage: AIProxy.OpenAIResponse.ResponseUsage?
    let user: Swift.String?
}
enum OpenAIResponseStreamEventType {
    case responseCreated
    case responseInProgress
    case responseCompleted
    case responseFailed
    case responseIncomplete
    case responseOutputItemAdded
    case responseOutputItemDone
    case responseContentPartAdded
    case responseContentPartDone
    case responseOutputTextDelta
    case responseOutputTextAnnotationAdded
    case responseOutputTextDone
    case responseRefusalDelta
    case responseRefusalDone
    case responseFunctionCallArgumentsDelta
    case responseFunctionCallArgumentsDone
    case responseFileSearchCallInProgress
    case responseFileSearchCallSearching
    case responseFileSearchCallCompleted
    case responseWebSearchCallInProgress
    case responseWebSearchCallSearching
    case responseWebSearchCallCompleted
    case responseReasoningDelta
    case responseReasoningDone
    case responseReasoningSummaryPartAdded
    case responseReasoningSummaryPartDone
    case responseReasoningSummaryTextDelta
    case responseReasoningSummaryTextDone
    case responseReasoningSummaryDelta
    case responseReasoningSummaryDone
    case responseImageGenerationCallInProgress
    case responseImageGenerationCallGenerating
    case responseImageGenerationCallCompleted
    case responseImageGenerationCallPartialImage
    case responseMcpCallArgumentsDelta
    case responseMcpCallArgumentsDone
    case responseMcpCallCompleted
    case responseMcpCallFailed
    case responseMcpListToolsInProgress
    case responseMcpListToolsCompleted
    case responseMcpListToolsFailed
    case responseQueued
    case error
}
enum OpenAIResponseStreamingEvent {
    struct ResponseCreated {
        enum CodingKeys {
            case response
            case sequenceNumber
        }
        let response: AIProxy.OpenAIResponse
        let sequenceNumber: Swift.Int?
    }
    struct ResponseInProgress {
        enum CodingKeys {
            case response
            case sequenceNumber
        }
        let response: AIProxy.OpenAIResponse
        let sequenceNumber: Swift.Int?
    }
    struct ResponseCompleted {
        enum CodingKeys {
            case response
            case sequenceNumber
        }
        let response: AIProxy.OpenAIResponse
        let sequenceNumber: Swift.Int?
    }
    struct ResponseFailed {
        enum CodingKeys {
            case response
            case sequenceNumber
        }
        let response: AIProxy.OpenAIResponse
        let sequenceNumber: Swift.Int?
    }
    struct ResponseIncomplete {
        enum CodingKeys {
            case response
            case sequenceNumber
        }
        let response: AIProxy.OpenAIResponse
        let sequenceNumber: Swift.Int?
    }
    struct OutputItemAdded {
        enum CodingKeys {
            case sequenceNumber
            case index
            case item
        }
        let sequenceNumber: Swift.Int?
        let index: Swift.Int?
        let item: AIProxy.OpenAIResponse.ResponseOutputItem
    }
    struct OutputItemDone {
        enum CodingKeys {
            case item
            case outputIndex
            case sequenceNumber
        }
        let item: AIProxy.OpenAIResponse.ResponseOutputItem
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct ContentPartAdded {
        enum CodingKeys {
            case sequenceNumber
            case contentIndex
            case outputIndex
            case part
        }
        let sequenceNumber: Swift.Int?
        let contentIndex: Swift.Int?
        let outputIndex: Swift.Int?
        let part: AIProxy.OpenAIResponse.Content
    }
    struct ContentPartDone {
        enum CodingKeys {
            case contentIndex
            case itemID
            case outputIndex
            case part
            case sequenceNumber
        }
        let contentIndex: Swift.Int?
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let part: AIProxy.OpenAIResponse.Content
        let sequenceNumber: Swift.Int?
    }
    struct OutputTextDelta {
        enum CodingKeys {
            case contentIndex
            case delta
            case itemID
            case outputIndex
            case sequenceNumber
        }
        let contentIndex: Swift.Int?
        let delta: Swift.String
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct OutputTextAnnotationAdded {
        enum CodingKeys {
            case sequenceNumber
            case itemID
            case outputIndex
            case contentIndex
            case annotationIndex
            case annotation
        }
        let sequenceNumber: Swift.Int?
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let contentIndex: Swift.Int?
        let annotationIndex: Swift.Int?
        let annotation: AIProxy.OpenAIResponse.Annotation?
    }
    struct OutputTextDone {
        enum CodingKeys {
            case contentIndex
            case itemID
            case outputIndex
            case sequenceNumber
            case text
        }
        let contentIndex: Swift.Int?
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
        let text: Swift.String
    }
    struct RefusalDelta {
        enum CodingKeys {
            case contentIndex
            case delta
            case itemID
            case outputIndex
            case sequenceNumber
        }
        let contentIndex: Swift.Int?
        let delta: Swift.String
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct RefusalDone {
        enum CodingKeys {
            case contentIndex
            case itemID
            case outputIndex
            case refusal
            case sequenceNumber
        }
        let contentIndex: Swift.Int?
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let refusal: Swift.String
        let sequenceNumber: Swift.Int?
    }
    struct FunctionCallArgumentsDelta {
        enum CodingKeys {
            case delta
            case itemID
            case outputIndex
            case sequenceNumber
        }
        let delta: Swift.String
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct FunctionCallArgumentsDone {
        enum CodingKeys {
            case arguments
            case itemID
            case outputIndex
            case sequenceNumber
        }
        let arguments: Swift.String
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct FileSearchCallInProgress {
        enum CodingKeys {
            case itemID
            case outputIndex
            case sequenceNumber
        }
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct FileSearchCallSearching {
        enum CodingKeys {
            case itemID
            case outputIndex
            case sequenceNumber
        }
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct FileSearchCallCompleted {
        enum CodingKeys {
            case itemID
            case outputIndex
            case sequenceNumber
        }
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct WebSearchCallInProgress {
        enum CodingKeys {
            case itemID
            case outputIndex
            case sequenceNumber
        }
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct WebSearchCallSearching {
        enum CodingKeys {
            case itemID
            case outputIndex
            case sequenceNumber
        }
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct WebSearchCallCompleted {
        enum CodingKeys {
            case itemID
            case outputIndex
            case sequenceNumber
        }
        let itemID: Swift.String?
        let outputIndex: Swift.Int?
        let sequenceNumber: Swift.Int?
    }
    struct AudioDelta {
        enum CodingKeys {
            case sequenceNumber
            case outputItemIndex
            case contentPartIndex
            case delta
        }
        let sequenceNumber: Swift.Int
        let outputItemIndex: Swift.Int
        let contentPartIndex: Swift.Int
        let delta: Swift.String
    }
    struct AudioDone {
        enum CodingKeys {
            case sequenceNumber
            case outputItemIndex
            case contentPartIndex
        }
        let sequenceNumber: Swift.Int
        let outputItemIndex: Swift.Int
        let contentPartIndex: Swift.Int
    }
    struct AudioTranscriptDelta {
        enum CodingKeys {
            case sequenceNumber
            case outputItemIndex
            case contentPartIndex
            case delta
        }
        let sequenceNumber: Swift.Int
        let outputItemIndex: Swift.Int
        let contentPartIndex: Swift.Int
        let delta: Swift.String
    }
    struct AudioTranscriptDone {
        enum CodingKeys {
            case sequenceNumber
            case outputItemIndex
            case contentPartIndex
            case transcript
        }
        let sequenceNumber: Swift.Int
        let outputItemIndex: Swift.Int
        let contentPartIndex: Swift.Int
        let transcript: Swift.String
    }
    struct CodeInterpreterCallProgress {
        enum CodingKeys {
            case sequenceNumber
            case outputItemIndex
            case id
            case status
        }
        let sequenceNumber: Swift.Int
        let outputItemIndex: Swift.Int
        let id: Swift.String
        let status: Swift.String
    }
    struct ComputerCallProgress {
        enum CodingKeys {
            case sequenceNumber
            case outputItemIndex
            case id
            case callId
            case status
            case action
            case pendingSafetyChecks
        }
        let sequenceNumber: Swift.Int
        let outputItemIndex: Swift.Int
        let id: Swift.String
        let callId: Swift.String
        let status: Swift.String
        let action: AIProxy.OpenAIResponse.ComputerAction?
        let pendingSafetyChecks: [AIProxy.OpenAIResponse.SafetyCheck]?
    }
    struct ReasoningDelta {
        enum CodingKeys {
            case sequenceNumber
            case outputItemIndex
            case delta
        }
        let sequenceNumber: Swift.Int
        let outputItemIndex: Swift.Int
        let delta: Swift.String
    }
    struct ReasoningDone {
        enum CodingKeys {
            case sequenceNumber
            case outputItemIndex
            case reasoning
        }
        let sequenceNumber: Swift.Int
        let outputItemIndex: Swift.Int
        let reasoning: Swift.String
    }
    struct ReasoningSummaryPart {
        enum CodingKeys {
            case type
            case text
        }
        let type: Swift.String
        let text: Swift.String?
    }
    struct ReasoningSummaryPartAdded {
        enum CodingKeys {
            case sequenceNumber
            case outputIndex
            case summaryIndex
            case part
        }
        let sequenceNumber: Swift.Int
        let outputIndex: Swift.Int
        let summaryIndex: Swift.Int
        let part: AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPart
    }
    struct ReasoningSummaryPartDone {
        enum CodingKeys {
            case sequenceNumber
            case outputIndex
            case summaryIndex
            case part
        }
        let sequenceNumber: Swift.Int
        let outputIndex: Swift.Int
        let summaryIndex: Swift.Int
        let part: AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPart
    }
    struct ReasoningSummaryTextDelta {
        enum CodingKeys {
            case sequenceNumber
            case outputIndex
            case summaryIndex
            case delta
        }
        let sequenceNumber: Swift.Int
        let outputIndex: Swift.Int
        let summaryIndex: Swift.Int
        let delta: Swift.String
    }
    struct ReasoningSummaryTextDone {
        enum CodingKeys {
            case sequenceNumber
            case outputIndex
            case summaryIndex
            case text
        }
        let sequenceNumber: Swift.Int
        let outputIndex: Swift.Int
        let summaryIndex: Swift.Int
        let text: Swift.String
    }
    struct ReasoningSummaryDelta {
        enum CodingKeys {
            case sequenceNumber
            case outputIndex
            case summaryIndex
            case delta
        }
        let sequenceNumber: Swift.Int
        let outputIndex: Swift.Int
        let summaryIndex: Swift.Int
        let delta: AIProxy.AIProxyJSONValue
    }
    struct ReasoningSummaryDone {
        enum CodingKeys {
            case sequenceNumber
            case outputIndex
            case summaryIndex
            case text
        }
        let sequenceNumber: Swift.Int
        let outputIndex: Swift.Int
        let summaryIndex: Swift.Int
        let text: Swift.String
    }
    struct ImageGenerationCallProgress {
        enum CodingKeys {
            case sequenceNumber
            case outputIndex
            case status
        }
        let sequenceNumber: Swift.Int
        let outputIndex: Swift.Int
        let status: Swift.String
    }
    struct ImageGenerationCallPartialImage {
        enum CodingKeys {
            case sequenceNumber
            case outputIndex
            case partialImageIndex
            case partialImageB64
        }
        let sequenceNumber: Swift.Int
        let outputIndex: Swift.Int
        let partialImageIndex: Swift.Int
        let partialImageB64: Swift.String
    }
    struct McpCallArgumentsDelta {
        enum CodingKeys {
            case sequenceNumber
            case outputIndex
            case delta
        }
        let sequenceNumber: Swift.Int
        let outputIndex: Swift.Int
        let delta: AIProxy.AIProxyJSONValue
    }
    struct McpCallArgumentsDone {
        enum CodingKeys {
            case sequenceNumber
            case outputIndex
            case arguments
        }
        let sequenceNumber: Swift.Int
        let outputIndex: Swift.Int
        let arguments: AIProxy.AIProxyJSONValue
    }
    struct McpCallProgress {
        enum CodingKeys {
            case sequenceNumber
            case status
        }
        let sequenceNumber: Swift.Int
        let status: Swift.String
    }
    struct McpListToolsProgress {
        enum CodingKeys {
            case sequenceNumber
            case status
        }
        let sequenceNumber: Swift.Int
        let status: Swift.String
    }
    struct ResponseQueued {
        enum CodingKeys {
            case sequenceNumber
            case response
        }
        let sequenceNumber: Swift.Int
        let response: AIProxy.AIProxyJSONValue
    }
    struct ErrorEvent {
        enum CodingKeys {
            case sequenceNumber
            case code
            case message
            case param
        }
        let sequenceNumber: Swift.Int
        let code: Swift.String
        let message: Swift.String
        let param: Swift.String?
    }
    enum CodingKeys {
        case type
    }
    case responseCreated(AIProxy.OpenAIResponseStreamingEvent.ResponseCreated)
    case responseInProgress(AIProxy.OpenAIResponseStreamingEvent.ResponseInProgress)
    case responseCompleted(AIProxy.OpenAIResponseStreamingEvent.ResponseCompleted)
    case responseFailed(AIProxy.OpenAIResponseStreamingEvent.ResponseFailed)
    case responseIncomplete(AIProxy.OpenAIResponseStreamingEvent.ResponseIncomplete)
    case outputItemAdded(AIProxy.OpenAIResponseStreamingEvent.OutputItemAdded)
    case outputItemDone(AIProxy.OpenAIResponseStreamingEvent.OutputItemDone)
    case contentPartAdded(AIProxy.OpenAIResponseStreamingEvent.ContentPartAdded)
    case contentPartDone(AIProxy.OpenAIResponseStreamingEvent.ContentPartDone)
    case outputTextDelta(AIProxy.OpenAIResponseStreamingEvent.OutputTextDelta)
    case outputTextDone(AIProxy.OpenAIResponseStreamingEvent.OutputTextDone)
    case outputTextAnnotationAdded(AIProxy.OpenAIResponseStreamingEvent.OutputTextAnnotationAdded)
    case refusalDelta(AIProxy.OpenAIResponseStreamingEvent.RefusalDelta)
    case refusalDone(AIProxy.OpenAIResponseStreamingEvent.RefusalDone)
    case functionCallArgumentsDelta(AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDelta)
    case functionCallArgumentsDone(AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDone)
    case fileSearchCallInProgress(AIProxy.OpenAIResponseStreamingEvent.FileSearchCallInProgress)
    case fileSearchCallSearching(AIProxy.OpenAIResponseStreamingEvent.FileSearchCallSearching)
    case fileSearchCallCompleted(AIProxy.OpenAIResponseStreamingEvent.FileSearchCallCompleted)
    case webSearchCallInProgress(AIProxy.OpenAIResponseStreamingEvent.WebSearchCallInProgress)
    case webSearchCallSearching(AIProxy.OpenAIResponseStreamingEvent.WebSearchCallSearching)
    case webSearchCallCompleted(AIProxy.OpenAIResponseStreamingEvent.WebSearchCallCompleted)
    case audioDelta(AIProxy.OpenAIResponseStreamingEvent.AudioDelta)
    case audioDone(AIProxy.OpenAIResponseStreamingEvent.AudioDone)
    case audioTranscriptDelta(AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDelta)
    case audioTranscriptDone(AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDone)
    case codeInterpreterCallProgress(AIProxy.OpenAIResponseStreamingEvent.CodeInterpreterCallProgress)
    case computerCallProgress(AIProxy.OpenAIResponseStreamingEvent.ComputerCallProgress)
    case reasoningDelta(AIProxy.OpenAIResponseStreamingEvent.ReasoningDelta)
    case reasoningDone(AIProxy.OpenAIResponseStreamingEvent.ReasoningDone)
    case reasoningSummaryPartAdded(AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartAdded)
    case reasoningSummaryPartDone(AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartDone)
    case reasoningSummaryTextDelta(AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDelta)
    case reasoningSummaryTextDone(AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDone)
    case reasoningSummaryDelta(AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDelta)
    case reasoningSummaryDone(AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDone)
    case imageGenerationCallProgress(AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallProgress)
    case imageGenerationCallPartialImage(AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallPartialImage)
    case mcpCallArgumentsDelta(AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDelta)
    case mcpCallArgumentsDone(AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDone)
    case mcpCallProgress(AIProxy.OpenAIResponseStreamingEvent.McpCallProgress)
    case mcpListToolsProgress(AIProxy.OpenAIResponseStreamingEvent.McpListToolsProgress)
    case responseQueued(AIProxy.OpenAIResponseStreamingEvent.ResponseQueued)
    case error(AIProxy.OpenAIResponseStreamingEvent.ErrorEvent)
}
class OpenAIService {
    let requestFormat: AIProxy.OpenAIRequestFormat
    let requestBuilder: AIProxy.OpenAIRequestBuilder
    let serviceNetworker: AIProxy.ServiceMixin
}
struct OpenAITextToSpeechRequestBody {
    enum Model {
        case gpt4oMiniTTS
        case tts1
        case tts1HD
    }
    enum ResponseFormat {
        case aac
        case flac
        case mp3
        case pcm
        case opus
        case wav
    }
    enum Voice {
        case alloy
        case ash
        case ballad
        case coral
        case echo
        case fable
        case onyx
        case nova
        case sage
        case shimmer
    }
    enum CodingKeys {
        case input
        case model
        case voice
        case instructions
        case responseFormat
        case speed
    }
    let input: Swift.String
    let model: AIProxy.OpenAITextToSpeechRequestBody.Model
    let voice: AIProxy.OpenAITextToSpeechRequestBody.Voice
    let instructions: Swift.String?
    let responseFormat: AIProxy.OpenAITextToSpeechRequestBody.ResponseFormat?
    let speed: Swift.Float?
}
struct OpenAIVectorStore {
    struct FileCounts {
        enum CodingKeys {
            case cancelled
            case completed
            case failed
            case inProgress
            case total
        }
        let cancelled: Swift.Int?
        let completed: Swift.Int?
        let failed: Swift.Int?
        let inProgress: Swift.Int?
        let total: Swift.Int?
    }
    enum Status {
        case completed
        case expired
        case inProgress
    }
    enum CodingKeys {
        case createdAt
        case expiresAfter
        case expiresAt
        case fileCounts
        case id
        case lastActiveAt
        case metadata
        case name
        case status
        case usageBytes
    }
    let createdAt: Swift.Int?
    let expiresAfter: AIProxy.OpenAIVectorStoreExpiresAfter?
    let expiresAt: Swift.Int?
    let fileCounts: AIProxy.OpenAIVectorStore.FileCounts?
    let id: Swift.String
    let lastActiveAt: Swift.Int?
    let metadata: [Swift.String : Swift.String]?
    let name: Swift.String?
    let status: AIProxy.OpenAIVectorStore.Status?
    let usageBytes: Swift.Int?
}
enum OpenAIVectorStoreChunkingStrategy {
    enum CodingKeys {
        case type
        case static
    }
    enum NestedKeys {
        case chunkOverlapTokens
        case maxChunkSizeTokens
    }
    case static(chunkOverlapTokens: Swift.Int, maxChunkSizeTokens: Swift.Int)
    case auto
}
struct OpenAIVectorStoreExpiresAfter {
    enum Anchor {
        case lastActiveAt
    }
    enum CodingKeys {
        case anchor
        case days
    }
    let anchor: AIProxy.OpenAIVectorStoreExpiresAfter.Anchor
    let days: Swift.Int
}
struct OpenAIVectorStoreFile {
    struct LastError {
        enum Code {
            case serverError
            case rateLimitExceeded
        }
        enum CodingKeys {
            case code
            case message
        }
        let code: AIProxy.OpenAIVectorStoreFile.LastError.Code?
        let message: Swift.String?
    }
    enum Status {
        case inProgress
        case completed
        case cancelled
        case failed
    }
    enum CodingKeys {
        case attributes
        case chunkingStrategy
        case createdAt
        case id
        case lastError
        case status
        case usageBytes
        case vectorStoreId
    }
    let attributes: [Swift.String : Swift.String]?
    let chunkingStrategy: AIProxy.OpenAIVectorStoreChunkingStrategy?
    let createdAt: Swift.Int?
    let id: Swift.String?
    let lastError: AIProxy.OpenAIVectorStoreFile.LastError?
    let status: AIProxy.OpenAIVectorStoreFile.Status?
    let usageBytes: Swift.Int?
    let vectorStoreId: Swift.String?
}
struct OpenRouterChatCompletionChunk {
    struct Choice {
        struct Delta {
            struct ToolCall {
                struct Function {
                    enum CodingKeys {
                        case name
                        case arguments
                    }
                    let name: Swift.String?
                    let arguments: Swift.String?
                }
                enum CodingKeys {
                    case index
                    case function
                }
                let index: Swift.Int?
                let function: AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.Function?
            }
            enum CodingKeys {
                case role
                case content
                case reasoning
                case toolCalls
            }
            let role: Swift.String
            let content: Swift.String?
            let reasoning: Swift.String?
            let toolCalls: [AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall]?
        }
        enum CodingKeys {
            case delta
            case finishReason
        }
        let delta: AIProxy.OpenRouterChatCompletionChunk.Choice.Delta
        let finishReason: Swift.String?
    }
    enum CodingKeys {
        case choices
        case model
        case provider
        case usage
    }
    let choices: [AIProxy.OpenRouterChatCompletionChunk.Choice]
    let model: Swift.String?
    let provider: Swift.String?
    let usage: AIProxy.OpenRouterChatCompletionResponseBody.Usage?
}
struct OpenRouterChatCompletionRequestBody {
    enum Route {
        case fallback
    }
    enum Message {
        enum AssistantContent {
            case text(Swift.String)
        }
        enum SystemContent {
            case text(Swift.String)
        }
        enum UserContent {
            enum Part {
                enum ImageDetail {
                    case auto
                    case low
                    case high
                }
                enum RootKey {
                    case type
                    case text
                    case imageURL
                }
                enum ImageKey {
                    case url
                    case detail
                }
                case text(Swift.String)
                case imageURL(Foundation.URL, detail: AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.ImageDetail?)
            }
            case text(Swift.String)
            case parts([AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part])
        }
        enum RootKey {
            case content
            case role
            case name
        }
        case assistant(content: AIProxy.OpenRouterChatCompletionRequestBody.Message.AssistantContent, name: Swift.String?)
        case system(content: AIProxy.OpenRouterChatCompletionRequestBody.Message.SystemContent, name: Swift.String?)
        case user(content: AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent, name: Swift.String?)
    }
    struct Reasoning {
        enum Effort {
            case low
            case medium
            case high
        }
        enum CodingKeys {
            case effort
            case maxTokens
            case exclude
        }
        let effort: AIProxy.OpenRouterChatCompletionRequestBody.Reasoning.Effort?
        let maxTokens: Swift.Int?
        let exclude: Swift.Bool?
    }
    enum ResponseFormat {
        enum RootKey {
            case type
            case jsonSchema
        }
        enum SchemaKey {
            case description
            case name
            case schema
            case strict
        }
        case jsonSchema(name: Swift.String, description: Swift.String?, schema: [Swift.String : AIProxy.AIProxyJSONValue]?, strict: Swift.Bool?)
        case jsonObject
        case text
    }
    struct StreamOptions {
        enum CodingKeys {
            case includeUsage
        }
        let includeUsage: Swift.Bool
    }
    enum Tool {
        enum RootKey {
            case type
            case function
        }
        enum FunctionKey {
            case description
            case name
            case parameters
            case strict
        }
        case function(name: Swift.String, description: Swift.String?, parameters: [Swift.String : AIProxy.AIProxyJSONValue]?, strict: Swift.Bool?)
    }
    enum ToolChoice {
        enum RootKey {
            case type
            case function
        }
        enum FunctionKey {
            case name
        }
        case specific(functionName: Swift.String)
        case none
        case auto
        case required
    }
    struct Prediction {
        enum CodingKeys {
            case content
            case type
        }
        let content: Swift.String
    }
    struct ProviderPreferences {
        enum Quantization {
            case int4
            case int8
            case fp6
            case fp8
            case fp16
            case bf16
            case unknown
        }
        enum DataCollection {
            case allow
            case deny
        }
        enum CodingKeys {
            case allowFallbacks
            case dataCollection
            case ignore
            case order
            case quantizations
            case requireParameters
        }
        let allowFallbacks: Swift.Bool?
        let dataCollection: AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.DataCollection?
        let ignore: [Swift.String]?
        let order: [Swift.String]?
        let quantizations: [AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.Quantization]?
        let requireParameters: Swift.Bool?
    }
    enum CodingKeys {
        case messages
        case frequencyPenalty
        case includeReasoning
        case logitBias
        case logprobs
        case maxTokens
        case metadata
        case model
        case models
        case n
        case parallelToolCalls
        case prediction
        case provider
        case presencePenalty
        case reasoning
        case repetitionPenalty
        case responseFormat
        case route
        case seed
        case stop
        case store
        case stream
        case streamOptions
        case temperature
        case tools
        case toolChoice
        case topA
        case topLogprobs
        case topP
        case transforms
        case user
    }
    let messages: [AIProxy.OpenRouterChatCompletionRequestBody.Message]
    let frequencyPenalty: Swift.Double?
    let includeReasoning: Swift.Bool?
    let logitBias: [Swift.String : Swift.Double]?
    let logprobs: Swift.Bool?
    let maxTokens: Swift.Int?
    let metadata: [Swift.String : AIProxy.AIProxyJSONValue]?
    let model: Swift.String?
    let models: [Swift.String]?
    let n: Swift.Int?
    let parallelToolCalls: Swift.Bool?
    let prediction: AIProxy.OpenRouterChatCompletionRequestBody.Prediction?
    let presencePenalty: Swift.Double?
    let provider: AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences?
    let reasoning: AIProxy.OpenRouterChatCompletionRequestBody.Reasoning?
    let repetitionPenalty: Swift.Double?
    let responseFormat: AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat?
    let route: AIProxy.OpenRouterChatCompletionRequestBody.Route?
    let seed: Swift.Int?
    let stop: [Swift.String]?
    let store: Swift.Bool?
    var stream: Swift.Bool?
    var streamOptions: AIProxy.OpenRouterChatCompletionRequestBody.StreamOptions?
    let temperature: Swift.Double?
    let tools: [AIProxy.OpenRouterChatCompletionRequestBody.Tool]?
    let toolChoice: AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice?
    let topA: Swift.Double?
    let topLogprobs: Swift.Int?
    let topP: Swift.Double?
    let transforms: [Swift.String]?
    let user: Swift.String?
}
struct OpenRouterChatCompletionResponseBody {
    struct Usage {
        enum CodingKeys {
            case completionTokens
            case promptTokens
            case totalTokens
        }
        let completionTokens: Swift.Int?
        let promptTokens: Swift.Int?
        let totalTokens: Swift.Int?
    }
    struct Choice {
        struct Message {
            struct Annotation {
                enum CodingKeys {
                    case urlCitation
                }
                let urlCitation: AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.URLCitation?
            }
            struct URLCitation {
                enum CodingKeys {
                    case content
                    case endIndex
                    case startIndex
                    case title
                    case url
                }
                let content: Swift.String?
                let endIndex: Swift.Int?
                let startIndex: Swift.Int?
                let title: Swift.String?
                let url: Swift.String?
            }
            struct ToolCall {
                struct Function {
                    enum CodingKeys {
                        case name
                        case arguments
                    }
                    let name: Swift.String
                    let arguments: [Swift.String : Any]?
                    let argumentsRaw: Swift.String?
                }
                enum CodingKeys {
                    case function
                    case id
                    case index
                    case type
                }
                let function: AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.Function?
                let id: Swift.String?
                let index: Swift.Int?
                let type: Swift.String?
            }
            enum CodingKeys {
                case annotations
                case content
                case reasoning
                case role
                case toolCalls
            }
            let annotations: [AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.Annotation]?
            let content: Swift.String?
            let reasoning: Swift.String?
            let role: Swift.String?
            let toolCalls: [AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall]?
        }
        enum CodingKeys {
            case finishReason
            case message
            case nativeFinishReason
        }
        let finishReason: Swift.String?
        let message: AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message
        let nativeFinishReason: Swift.String?
    }
    enum CodingKeys {
        case choices
        case created
        case id
        case model
        case provider
        case usage
    }
    let choices: [AIProxy.OpenRouterChatCompletionResponseBody.Choice]
    let created: Swift.Int?
    let id: Swift.String?
    let model: Swift.String?
    let provider: Swift.String?
    let usage: AIProxy.OpenRouterChatCompletionResponseBody.Usage?
}
class OpenRouterDirectService {
    let unprotectedAPIKey: Swift.String
    let baseURL: Swift.String
}
class OpenRouterProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct PerplexityChatCompletionRequestBody {
    enum Message {
        enum RootKey {
            case content
            case role
        }
        case assistant(content: Swift.String)
        case system(content: Swift.String)
        case user(content: Swift.String)
    }
    enum SearchRecencyFilter {
        case hour
        case day
        case week
        case month
    }
    struct WebSearchOptions {
        enum CodingKeys {
            case searchContextSize
        }
        let searchContextSize: AIProxy.PerplexityChatCompletionRequestBody.SearchContextSize
    }
    enum SearchContextSize {
        case high
        case medium
        case low
    }
    enum CodingKeys {
        case messages
        case model
        case frequencyPenalty
        case maxTokens
        case presencePenalty
        case returnCitations
        case returnImages
        case returnRelatedQuestions
        case searchDomainFilter
        case searchRecencyFilter
        case stream
        case temperature
        case topK
        case topP
        case webSearchOptions
    }
    let messages: [AIProxy.PerplexityChatCompletionRequestBody.Message]
    let model: Swift.String
    let frequencyPenalty: Swift.Double?
    let maxTokens: Swift.Int?
    let presencePenalty: Swift.Double?
    let returnCitations: Swift.Bool?
    let returnImages: Swift.Bool?
    let returnRelatedQuestions: Swift.Bool?
    let searchDomainFilter: [Swift.String]?
    let searchRecencyFilter: AIProxy.PerplexityChatCompletionRequestBody.SearchRecencyFilter?
    var stream: Swift.Bool?
    let temperature: Swift.Double?
    let topK: Swift.Double?
    let topP: Swift.Double?
    let webSearchOptions: AIProxy.PerplexityChatCompletionRequestBody.WebSearchOptions?
}
struct PerplexityChatCompletionResponseBody {
    struct Choice {
        struct Delta {
            enum CodingKeys {
                case content
                case role
            }
            let content: Swift.String
            let role: AIProxy.PerplexityRole
        }
        enum FinishReason {
            case stop
            case length
        }
        struct Message {
            enum CodingKeys {
                case content
                case role
            }
            let content: Swift.String
            let role: AIProxy.PerplexityRole
        }
        enum CodingKeys {
            case delta
            case finishReason
            case index
            case message
        }
        let delta: AIProxy.PerplexityChatCompletionResponseBody.Choice.Delta?
        let finishReason: AIProxy.PerplexityChatCompletionResponseBody.Choice.FinishReason?
        let index: Swift.Int?
        let message: AIProxy.PerplexityChatCompletionResponseBody.Choice.Message?
    }
    struct Usage {
        enum CodingKeys {
            case promptTokens
            case completionTokens
            case totalTokens
        }
        let promptTokens: Swift.Int?
        let completionTokens: Swift.Int?
        let totalTokens: Swift.Int?
    }
    enum CodingKeys {
        case choices
        case citations
        case created
        case id
        case model
        case object
        case usage
    }
    let choices: [AIProxy.PerplexityChatCompletionResponseBody.Choice]
    let citations: [Swift.String]?
    let created: Swift.Int?
    let id: Swift.String?
    let model: Swift.String?
    let object: Swift.String?
    let usage: AIProxy.PerplexityChatCompletionResponseBody.Usage?
}
class PerplexityDirectService {
    let unprotectedAPIKey: Swift.String
}
class PerplexityProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
enum PerplexityRole {
    case system
    case user
    case assistant
}
struct ReceiptValidationRequestBody {
    enum CodingKeys {
        case jsonRepresentationBase64
        case appID
        case appVersion
        case appVersionID
        case bundleID
        case environment
        case originalAppVersion
        case originalPurchaseDate
        case deviceVerificationBase64
        case deviceVerificationNonce
        case signedDate
        case verificationError
    }
    let jsonRepresentationBase64: Swift.String
    let appID: Swift.UInt64?
    let appVersion: Swift.String
    let appVersionID: Swift.UInt64?
    let bundleID: Swift.String
    let environment: Swift.String
    let originalAppVersion: Swift.String
    let originalPurchaseDate: Swift.Double
    let deviceVerificationBase64: Swift.String
    let deviceVerificationNonce: Swift.String
    let signedDate: Swift.Double
    let verificationError: Swift.String?
}
struct ReceiptValidationResponseBody {
    enum CodingKeys {
        case isValid
    }
    let isValid: Swift.Bool
}
class ReceiptValidationService {
    let publishableKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
class RemoteLoggerService {
    let publishableKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct ReplicateCreateModelRequestBody {
    enum CodingKeys {
        case description
        case hardware
        case name
        case owner
        case visibility
    }
    let description: Swift.String
    let hardware: Swift.String?
    let name: Swift.String
    let owner: Swift.String
    let visibility: AIProxy.ReplicateModelVisibility
}
struct ReplicateDeepSeekVL7BInputSchema {
    enum CodingKeys {
        case image
        case maxNewTokens
        case prompt
    }
    let image: Foundation.URL
    let maxNewTokens: Swift.Int?
    let prompt: Swift.String?
}
class ReplicateDirectService {
    let unprotectedAPIKey: Swift.String
}
enum ReplicateError {
    case predictionFailed(Swift.String?)
    case predictionCanceled
    case predictionDidNotIncludeOutput
    case predictionDidNotIncludeURL
    case missingModelURL
    case reachedRetryLimit
}
struct ReplicateFileUploadResponseBody {
    struct Checksums {
        enum CodingKeys {
            case md5
            case sha256
        }
        let md5: Swift.String
        let sha256: Swift.String
    }
    struct ActionURLs {
        enum CodingKeys {
            case get
        }
        let get: Foundation.URL
    }
    enum CodingKeys {
        case contentType
        case checksums
        case createdAt
        case etag
        case expiresAt
        case id
        case name
        case size
        case urls
    }
    let contentType: Swift.String?
    let checksums: AIProxy.ReplicateFileUploadResponseBody.Checksums?
    let createdAt: Swift.String?
    let etag: Swift.String?
    let expiresAt: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let size: Swift.Int?
    let urls: AIProxy.ReplicateFileUploadResponseBody.ActionURLs
}
struct ReplicateFluxDevControlNetInputSchema {
    enum ControlType {
        case canny
        case depth
        case softEdge
    }
    enum DepthPreprocessor {
        case midas
        case zoe
        case depthAnything
        case zoeDepthAnything
    }
    enum OutputFormat {
        case webp
        case jpg
        case png
    }
    enum SoftEdgePreprocessor {
        case hed
        case teed
        case piDiNet
    }
    enum CodingKeys {
        case controlImage
        case controlStrength
        case controlType
        case depthPreprocessor
        case guidanceScale
        case imageToImageStrength
        case loraStrength
        case loraUrl
        case negativePrompt
        case outputFormat
        case outputQuality
        case prompt
        case returnPreprocessedImage
        case seed
        case softEdgePreprocessor
        case steps
    }
    let controlImage: Foundation.URL
    let prompt: Swift.String
    let controlStrength: Swift.Double?
    let controlType: AIProxy.ReplicateFluxDevControlNetInputSchema.ControlType?
    let depthPreprocessor: AIProxy.ReplicateFluxDevControlNetInputSchema.DepthPreprocessor?
    let guidanceScale: Swift.Double?
    let imageToImageStrength: Swift.Double?
    let loraStrength: Swift.Double?
    let loraUrl: Swift.String?
    let negativePrompt: Swift.String?
    let outputFormat: AIProxy.ReplicateFluxDevControlNetInputSchema.OutputFormat?
    let outputQuality: Swift.Int?
    let returnPreprocessedImage: Swift.Bool?
    let seed: Swift.Int?
    let softEdgePreprocessor: AIProxy.ReplicateFluxDevControlNetInputSchema.SoftEdgePreprocessor?
    let steps: Swift.Int?
}
struct ReplicateFluxDevInputSchema {
    enum OutputFormat {
        case jpg
        case png
        case webp
    }
    enum CodingKeys {
        case aspectRatio
        case disableSafetyChecker
        case goFast
        case guidance
        case image
        case numInferenceSteps
        case numOutputs
        case outputFormat
        case outputQuality
        case prompt
        case promptStrength
        case seed
    }
    let prompt: Swift.String
    let aspectRatio: Swift.String?
    let disableSafetyChecker: Swift.Bool?
    let goFast: Swift.Bool?
    let guidance: Swift.Double?
    let image: Foundation.URL?
    let numInferenceSteps: Swift.Int?
    let numOutputs: Swift.Int?
    let outputFormat: AIProxy.ReplicateFluxDevInputSchema.OutputFormat?
    let outputQuality: Swift.Int?
    let promptStrength: Swift.Double?
    let seed: Swift.Int?
}
struct ReplicateFluxFineTuneInputSchema {
    enum FluxModel {
        case dev
        case schnell
    }
    enum OutputFormat {
        case jpeg
        case png
        case webp
    }
    enum CodingKeys {
        case prompt
        case aspectRatio
        case disableSafetyChecker
        case extraLora
        case extraLoraScale
        case guidanceScale
        case height
        case loraScale
        case model
        case numInferenceSteps
        case numOutputs
        case outputFormat
        case outputQuality
        case seed
        case width
    }
    let prompt: Swift.String
    let aspectRatio: Swift.String?
    let disableSafetyChecker: Swift.Bool?
    let extraLora: Swift.String?
    let extraLoraScale: Swift.Double?
    let guidanceScale: Swift.Double?
    let height: Swift.Int?
    let loraScale: Swift.Double?
    let model: AIProxy.ReplicateFluxFineTuneInputSchema.FluxModel?
    let numInferenceSteps: Swift.Int?
    let numOutputs: Swift.Int?
    let outputFormat: AIProxy.ReplicateFluxFineTuneInputSchema.OutputFormat?
    let outputQuality: Swift.Int?
    let seed: Swift.Int?
    let width: Swift.Int?
}
struct ReplicateFluxKontextInputSchema {
    enum CodingKeys {
        case inputImage
        case prompt
        case aspectRatio
        case seed
    }
    let inputImage: Foundation.URL
    let prompt: Swift.String
    let aspectRatio: Swift.String?
    let seed: Swift.Int?
}
struct ReplicateFluxProInputSchema {
    enum OutputFormat {
        case jpg
        case png
        case webp
    }
    enum CodingKeys {
        case aspectRatio
        case guidance
        case interval
        case outputFormat
        case outputQuality
        case prompt
        case safetyTolerance
        case seed
        case steps
    }
    let prompt: Swift.String
    let aspectRatio: Swift.String?
    let guidance: Swift.Double?
    let interval: Swift.Double?
    let outputFormat: AIProxy.ReplicateFluxProInputSchema.OutputFormat?
    let outputQuality: Swift.Int?
    let safetyTolerance: Swift.Int
    let seed: Swift.Int?
    let steps: Swift.Int?
}
struct ReplicateFluxProInputSchema_v1_1 {
    enum OutputFormat {
        case jpg
        case png
        case webp
    }
    enum CodingKeys {
        case aspectRatio
        case height
        case outputFormat
        case outputQuality
        case prompt
        case promptUpsampling
        case safetyTolerance
        case seed
        case width
    }
    let prompt: Swift.String
    let aspectRatio: Swift.String?
    let height: Swift.Int?
    let outputFormat: AIProxy.ReplicateFluxProInputSchema_v1_1.OutputFormat?
    let outputQuality: Swift.Int?
    let promptUpsampling: Swift.Bool?
    let safetyTolerance: Swift.Int?
    let seed: Swift.Int?
    let width: Swift.Int?
}
struct ReplicateFluxProUltraInputSchema_v1_1 {
    enum OutputFormat {
        case jpg
        case png
    }
    enum CodingKeys {
        case aspectRatio
        case outputFormat
        case prompt
        case safetyTolerance
        case seed
        case raw
    }
    let prompt: Swift.String
    let aspectRatio: Swift.String?
    let outputFormat: AIProxy.ReplicateFluxProUltraInputSchema_v1_1.OutputFormat?
    let safetyTolerance: Swift.Int?
    let seed: Swift.Int?
    let raw: Swift.Bool?
}
struct ReplicateFluxPulidInputSchema {
    enum CodingKeys {
        case guidanceScale
        case height
        case idWeight
        case mainFaceImage
        case maxSequenceLength
        case negativePrompt
        case numOutputs
        case numSteps
        case outputFormat
        case outputQuality
        case prompt
        case seed
        case startStep
        case trueCFG
        case width
    }
    let mainFaceImage: Foundation.URL
    let prompt: Swift.String
    let guidanceScale: Swift.Double?
    let height: Swift.Int?
    let idWeight: Swift.Double?
    let maxSequenceLength: Swift.Int?
    let negativePrompt: Swift.String?
    let numOutputs: Swift.Int?
    let numSteps: Swift.Int?
    let outputFormat: Swift.String?
    let outputQuality: Swift.Int?
    let seed: Swift.Int?
    let startStep: Swift.Int?
    let trueCFG: Swift.Double?
    let width: Swift.Int?
}
struct ReplicateFluxSchnellInputSchema {
    enum OutputFormat {
        case jpg
        case png
        case webp
    }
    enum CodingKeys {
        case aspectRatio
        case disableSafetyChecker
        case goFast
        case numOutputs
        case outputFormat
        case outputQuality
        case prompt
        case seed
    }
    let prompt: Swift.String
    let aspectRatio: Swift.String?
    let disableSafetyChecker: Swift.Bool?
    let goFast: Swift.Bool?
    let numOutputs: Swift.Int?
    let outputFormat: AIProxy.ReplicateFluxSchnellInputSchema.OutputFormat?
    let outputQuality: Swift.Int?
    let seed: Swift.Int?
}
struct ReplicateFluxTrainingInput {
    enum CodingKeys {
        case inputImages
        case autocaption
        case autocaptionPrefix
        case autocaptionSuffix
        case layersToOptimizeRegex
        case learningRate
        case loraRank
        case steps
        case triggerWord
    }
    let inputImages: Foundation.URL
    let autocaption: Swift.Bool?
    let autocaptionPrefix: Swift.String?
    let autocaptionSuffix: Swift.String?
    let layersToOptimizeRegex: Swift.String?
    let learningRate: Swift.Double?
    let loraRank: Swift.Int?
    let steps: Swift.Int?
    let triggerWord: Swift.String?
}
struct ReplicateModelResponseBody {
    enum CodingKeys {
        case description
        case name
        case owner
        case url
        case visibility
    }
    let description: Swift.String?
    let name: Swift.String?
    let owner: Swift.String?
    let url: Foundation.URL?
    let visibility: AIProxy.ReplicateModelVisibility?
}
enum ReplicateModelVisibility {
    case public
    case private
}
struct ReplicatePredictionRequestBody {
    enum RootKey {
        case input
        case version
    }
    let input: Swift.Encodable
    let version: Swift.String?
}
struct ReplicatePrediction<A> where A: Swift.Decodable {
    struct ActionURLs {
        enum CodingKeys {
            case cancel
            case get
        }
        let cancel: Foundation.URL?
        let get: Foundation.URL?
    }
    struct Metrics {
        enum CodingKeys {
            case predictTime
        }
        let predictTime: Swift.Double
    }
    enum Status {
        case starting
        case processing
        case succeeded
        case failed
        case canceled
    }
    enum CodingKeys {
        case completedAt
        case createdAt
        case dataRemoved
        case error
        case id
        case logs
        case metrics
        case model
        case output
        case startedAt
        case status
        case urls
        case version
    }
    let completedAt: Swift.String?
    let createdAt: Swift.String?
    let dataRemoved: Swift.Bool?
    let error: Swift.String?
    let id: Swift.String?
    let logs: Swift.String?
    let metrics: AIProxy.ReplicatePrediction<A>.Metrics?
    let model: Swift.String?
    let output: A?
    let startedAt: Swift.String?
    let status: AIProxy.ReplicatePrediction<A>.Status?
    let urls: AIProxy.ReplicatePrediction<A>.ActionURLs?
    let version: Swift.String?
}
class ReplicateProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct ReplicateSDXLFreshInkInputSchema {
    enum Refiner {
        case baseImageRefiner
        case expertEnsembleRefiner
        case noRefiner
    }
    enum Scheduler {
        case ddim
        case dpmSolverMultistep
        case heunDiscrete
        case kEuler
        case kEulerAncestral
        case karrasDPM
        case pndm
    }
    enum CodingKeys {
        case prompt
        case applyWatermark
        case disableSafetyChecker
        case guidanceScale
        case height
        case highNoiseFrac
        case image
        case loraScale
        case mask
        case negativePrompt
        case numInferenceSteps
        case numOutputs
        case promptStrength
        case refine
        case refineSteps
        case scheduler
        case seed
        case width
    }
    let prompt: Swift.String
    let applyWatermark: Swift.Bool?
    let disableSafetyChecker: Swift.Bool?
    let guidanceScale: Swift.Int?
    let height: Swift.Int?
    let highNoiseFrac: Swift.Double?
    let image: Foundation.URL?
    let loraScale: Swift.Double?
    let mask: Foundation.URL?
    let negativePrompt: Swift.String?
    let numInferenceSteps: Swift.Int?
    let numOutputs: Swift.Int?
    let promptStrength: Swift.Double?
    let refine: AIProxy.ReplicateSDXLFreshInkInputSchema.Refiner?
    let refineSteps: Swift.Int?
    let seed: Swift.Int?
    let scheduler: AIProxy.ReplicateSDXLFreshInkInputSchema.Scheduler?
    let width: Swift.Int?
}
struct ReplicateSDXLInputSchema {
    enum Refiner {
        case baseImageRefiner
        case expertEnsembleRefiner
        case noRefiner
    }
    enum Scheduler {
        case ddim
        case dpmSolverMultistep
        case heunDiscrete
        case kEuler
        case kEulerAncestral
        case karrasDPM
        case pndm
    }
    enum CodingKeys {
        case applyWatermark
        case disableSafetyChecker
        case guidanceScale
        case height
        case highNoiseFrac
        case image
        case loraScale
        case mask
        case negativePrompt
        case numInferenceSteps
        case numOutputs
        case prompt
        case promptStrength
        case refine
        case refineSteps
        case scheduler
        case seed
        case width
    }
    let prompt: Swift.String
    let applyWatermark: Swift.Bool?
    let disableSafetyChecker: Swift.Bool?
    let guidanceScale: Swift.Double?
    let height: Swift.Int?
    let highNoiseFrac: Swift.Double?
    let image: Foundation.URL?
    let loraScale: Swift.Double?
    let mask: Foundation.URL?
    let negativePrompt: Swift.String?
    let numInferenceSteps: Swift.Int?
    let numOutputs: Swift.Int?
    let promptStrength: Swift.Double?
    let refine: AIProxy.ReplicateSDXLInputSchema.Refiner?
    let refineSteps: Swift.Int?
    let scheduler: AIProxy.ReplicateSDXLInputSchema.Scheduler?
    let seed: Swift.Int?
    let width: Swift.Int?
}
struct ReplicateSynchronousResponseBody<A> where A: Swift.Decodable {
    enum CodingKeys {
        case error
        case output
        case status
        case urls
    }
    enum NestedKeys {
        case get
    }
    let error: Swift.String?
    let output: A?
    let status: Swift.String?
    let predictionResultURL: Foundation.URL?
}
struct ReplicateTrainingRequestBody<A> where A: Swift.Encodable {
    enum CodingKeys {
        case destination
        case input
    }
    let destination: Swift.String
    let input: A
}
struct ReplicateTrainingResponseBody {
    struct Metrics {
        enum CodingKeys {
            case predictTime
        }
        let predictTime: Swift.Double?
    }
    struct TrainingOutput {
        enum CodingKeys {
            case version
            case weights
        }
        let version: Swift.String?
        let weights: Swift.String?
    }
    struct ActionURLs {
        enum CodingKeys {
            case cancel
            case get
        }
        let cancel: Foundation.URL?
        let get: Foundation.URL?
    }
    enum Status {
        case starting
        case processing
        case succeeded
        case failed
        case canceled
    }
    enum CodingKeys {
        case completedAt
        case createdAt
        case error
        case id
        case logs
        case metrics
        case model
        case output
        case startedAt
        case status
        case urls
        case version
    }
    let completedAt: Swift.String?
    let createdAt: Swift.String?
    let error: Swift.String?
    let id: Swift.String?
    let logs: Swift.String?
    let metrics: AIProxy.ReplicateTrainingResponseBody.Metrics?
    let model: Swift.String?
    let output: AIProxy.ReplicateTrainingResponseBody.TrainingOutput?
    let startedAt: Swift.String?
    let status: AIProxy.ReplicateTrainingResponseBody.Status?
    let urls: AIProxy.ReplicateTrainingResponseBody.ActionURLs?
    let version: Swift.String?
}
class StabilityAIDirectService {
    let unprotectedAPIKey: Swift.String
}
struct StabilityAIImageResponse {
    let imageData: Foundation.Data
    let contentType: Swift.String?
    let finishReason: Swift.String?
    let seed: Swift.String?
}
class StabilityAIProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
struct StabilityAIStableDiffusionRequestBody {
    let prompt: Swift.String
    let aspectRatio: Swift.String?
    let image: Foundation.Data?
    let mode: AIProxy.StabilityAIGenerationMode?
    let model: AIProxy.StabilityAIStableDiffusionModel?
    let negativePrompt: Swift.String?
    let outputFormat: AIProxy.StabilityAIStableDiffusionOutputFormat?
    let seed: Swift.Int?
    let strength: Swift.Double?
}
enum StabilityAIStableDiffusionOutputFormat {
    case jpeg
    case png
}
enum StabilityAIGenerationMode {
    case textToImage
    case imageToImage
}
enum StabilityAIStableDiffusionModel {
    case sd3Medium
    case sd3Large
    case sd3LargeTurbo
}
struct StabilityAIUltraRequestBody {
    let prompt: Swift.String
    let aspectRatio: Swift.String?
    let negativePrompt: Swift.String?
    let outputFormat: AIProxy.StabilityAIUltraOutputFormat?
    let seed: Swift.Int?
}
enum StabilityAIUltraOutputFormat {
    case jpeg
    case png
    case webp
}
struct TogetherAIChatCompletionRequestBody {
    enum CodingKeys {
        case messages
        case model
        case echo
        case frequencyPenalty
        case logprobs
        case maxTokens
        case minP
        case n
        case presencePenalty
        case repetitionPenalty
        case responseFormat
        case safetyModel
        case stream
        case stop
        case temperature
        case toolChoice
        case tools
        case topK
        case topP
    }
    let messages: [AIProxy.TogetherAIMessage]
    let model: Swift.String
    let echo: Swift.Bool?
    let frequencyPenalty: Swift.Double?
    let logprobs: Swift.Bool?
    let maxTokens: Swift.Int?
    let minP: Swift.Double?
    let n: Swift.Int?
    let presencePenalty: Swift.Double?
    let repetitionPenalty: Swift.Double?
    let responseFormat: AIProxy.TogetherAIResponseFormat?
    let safetyModel: Swift.String?
    var stream: Swift.Bool?
    let stop: [Swift.String]?
    let temperature: Swift.Double?
    let toolChoice: Swift.String?
    let tools: [AIProxy.TogetherAITool]?
    let topK: Swift.Int?
    let topP: Swift.Double?
}
struct TogetherAIMessage {
    enum CodingKeys {
        case content
        case role
    }
    let content: Swift.String?
    let role: AIProxy.TogetherAIRole
}
enum TogetherAIRole {
    case assistant
    case system
    case user
}
enum TogetherAIResponseFormat {
    enum CodingKeys {
        case type
        case schema
    }
    case json(schema: [Swift.String : AIProxy.AIProxyJSONValue])
}
struct TogetherAITool {
    enum CodingKeys {
        case type
        case function
    }
    let type: Swift.String
    let function: AIProxy.TogetherAIFunction
}
struct TogetherAIFunction {
    enum CodingKeys {
        case description
        case name
        case parameters
    }
    let description: Swift.String
    let name: Swift.String
    let parameters: [Swift.String : AIProxy.AIProxyJSONValue]
}
struct TogetherAIChatCompletionResponseBody {
    enum CodingKeys {
        case choices
        case created
        case id
        case model
        case usage
    }
    let choices: [AIProxy.TogetherAIChatCompletionChoice]
    let created: Swift.Int
    let id: Swift.String
    let model: Swift.String
    let usage: AIProxy.TogetherAIChatUsage?
}
struct TogetherAIChatCompletionChoice {
    enum CodingKeys {
        case message
        case finishReason
        case logprobs
    }
    let message: AIProxy.TogetherAIMessage
    let finishReason: AIProxy.TogetherAIFinishReason?
    let logprobs: AIProxy.TogetherAILogprobs?
}
enum TogetherAIFinishReason {
    case eos
    case stop
    case length
    case toolCalls
}
struct TogetherAILogprobs {
    enum CodingKeys {
        case tokens
        case tokenLogprobs
    }
    let tokens: [Swift.String]
    let tokenLogprobs: [Swift.Double]
}
struct TogetherAIChatUsage {
    enum CodingKeys {
        case promptTokens
        case completionTokens
        case totalTokens
    }
    let promptTokens: Swift.Int
    let completionTokens: Swift.Int
    let totalTokens: Swift.Int
}
struct TogetherAIChatCompletionStreamingChunk {
    enum CodingKeys {
        case choices
        case created
        case model
        case usage
    }
    let choices: [AIProxy.TogetherAIStreamingChunkChoice]
    let created: Swift.Int
    let model: Swift.String
    let usage: AIProxy.TogetherAIChatUsage?
}
struct TogetherAIStreamingChunkChoice {
    enum CodingKeys {
        case delta
        case finishReason
    }
    let delta: AIProxy.TogetherAIStreamingChunkDelta
    let finishReason: AIProxy.TogetherAIFinishReason?
}
struct TogetherAIStreamingChunkDelta {
    enum CodingKeys {
        case content
        case role
    }
    let content: Swift.String
    let role: AIProxy.TogetherAIRole
}
class TogetherAIDirectService {
    let unprotectedAPIKey: Swift.String
}
class TogetherAIProxiedService {
    let partialKey: Swift.String
    let serviceURL: Swift.String
    let clientID: Swift.String?
}
enum Alphabet {
    case Standard
    case URLAndFilenameSafe
}
class BundleFinder {}
struct Heartbeat {
    enum CodingKeys {
        case agent
        case date
        case version
        case timePeriods
    }
    let agent: Swift.String
    let date: Foundation.Date
    let version: Swift.Int
    let timePeriods: [FirebaseCoreInternal.TimePeriod]
}
enum TimePeriod {
    case daily
}
class HeartbeatController {
    let storage: FirebaseCoreInternal.HeartbeatStorageProtocol
    let dateProvider: 
}
class HeartbeatStorage {
    let id: Swift.String
    let storage: FirebaseCoreInternal.Storage
    let encoder: Foundation.JSONEncoder
    let decoder: Foundation.JSONDecoder
    let queue: __C.OS_dispatch_queue
}
struct HeartbeatsBundle {
    enum CodingKeys {
        case capacity
        case lastAddedHeartbeatDates
        case buffer
    }
    let capacity: Swift.Int
    var lastAddedHeartbeatDates: [FirebaseCoreInternal.TimePeriod : Foundation.Date]
    var buffer: FirebaseCoreInternal.RingBuffer<FirebaseCoreInternal.Heartbeat>
}
struct HeartbeatsPayload {
    enum CodingKeys {
        case userAgentPayloads
        case version
    }
    struct UserAgentPayload {
        enum CodingKeys {
            case agent
            case dates
        }
        let agent: Swift.String
        let dates: [Foundation.Date]
    }
    let userAgentPayloads: [FirebaseCoreInternal.HeartbeatsPayload.UserAgentPayload]
    let version: Swift.Int
}
struct RingBuffer<A> {
    enum Error {
        case outOfBoundsPush(pushIndex: Swift.Int, endIndex: Swift.Int)
    }
    enum CodingKeys {
        case circularQueue
        case tailIndex
    }
    var circularQueue: [A?]
    var tailIndex: Swift.Int
}
class FileStorage {
    let url: Foundation.URL
}
class UserDefaultsStorage {
    let suiteName: Swift.String
    let key: Swift.String
}
enum StorageError {
    case readError
    case writeError
}
struct WeakContainer<A> where A: AnyObject {
    weak var object: A?
}
class _ObjC_HeartbeatController: __C.NSObject {
    let heartbeatController: FirebaseCoreInternal.HeartbeatController
}
class _ObjC_HeartbeatsPayload: __C.NSObject {
    let heartbeatsPayload: FirebaseCoreInternal.HeartbeatsPayload
}
class UnfairLock<A> {
    var lockPointer: Swift.UnsafeMutablePointer<__C.os_unfair_lock_s>
    var _value: A
}
class FirebaseDataEncoder {
    enum DateEncodingStrategy {
        case formatted(__C.NSDateFormatter)
        case custom((Foundation.Date, Swift.Encoder) throws -> ())
        case deferredToDate
        case secondsSince1970
        case millisecondsSince1970
        case iso8601
    }
    enum DataEncodingStrategy {
        case custom((Foundation.Data, Swift.Encoder) throws -> ())
        case deferredToData
        case base64
        case blob
    }
    enum NonConformingFloatEncodingStrategy {
        case convertToString(positiveInfinity: Swift.String, negativeInfinity: Swift.String, nan: Swift.String)
        case throw
    }
    enum KeyEncodingStrategy {
        case custom((_: [Swift.CodingKey]) -> Swift.CodingKey)
        case useDefaultKeys
        case convertToSnakeCase
    }
    struct _Options {
        let dateEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.DateEncodingStrategy
        let dataEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.DataEncodingStrategy
        let nonConformingFloatEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.NonConformingFloatEncodingStrategy
        let keyEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.KeyEncodingStrategy
        let passthroughTypeResolver: FirebaseSharedSwift.StructureCodingPassthroughTypeResolver.Type
        let userInfo: [Swift.CodingUserInfoKey : Any]
    }
    var dateEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.DateEncodingStrategy
    var dataEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.DataEncodingStrategy
    var nonConformingFloatEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.NonConformingFloatEncodingStrategy
    var keyEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.KeyEncodingStrategy
    var passthroughTypeResolver: FirebaseSharedSwift.StructureCodingPassthroughTypeResolver.Type
    var userInfo: [Swift.CodingUserInfoKey : Any]
}
class __JSONEncoder {
    var storage: FirebaseSharedSwift._JSONEncodingStorage
    let options: FirebaseSharedSwift.FirebaseDataEncoder._Options
    var codingPath: [Swift.CodingKey]
}
class __JSONReferencingEncoder: FirebaseSharedSwift.__JSONEncoder {
    enum Reference {
        case array(__C.NSMutableArray, Swift.Int)
        case dictionary(__C.NSMutableDictionary, Swift.String)
    }
    let encoder: FirebaseSharedSwift.__JSONEncoder
    let reference: FirebaseSharedSwift.__JSONReferencingEncoder.Reference
}
class FirebaseDataDecoder {
    enum DateDecodingStrategy {
        case formatted(__C.NSDateFormatter)
        case custom((_: Swift.Decoder) throws -> Foundation.Date)
        case deferredToDate
        case secondsSince1970
        case millisecondsSince1970
        case iso8601
    }
    enum DataDecodingStrategy {
        case custom((_: Swift.Decoder) throws -> Foundation.Data)
        case deferredToData
        case base64
        case blob
    }
    enum NonConformingFloatDecodingStrategy {
        case convertFromString(positiveInfinity: Swift.String, negativeInfinity: Swift.String, nan: Swift.String)
        case throw
    }
    enum KeyDecodingStrategy {
        case custom((_: [Swift.CodingKey]) -> Swift.CodingKey)
        case useDefaultKeys
        case convertFromSnakeCase
    }
    struct _Options {
        let dateDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.DateDecodingStrategy
        let dataDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.DataDecodingStrategy
        let nonConformingFloatDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.NonConformingFloatDecodingStrategy
        let keyDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.KeyDecodingStrategy
        let passthroughTypeResolver: FirebaseSharedSwift.StructureCodingPassthroughTypeResolver.Type
        let userInfo: [Swift.CodingUserInfoKey : Any]
    }
    var dateDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.DateDecodingStrategy
    var dataDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.DataDecodingStrategy
    var nonConformingFloatDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.NonConformingFloatDecodingStrategy
    var keyDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.KeyDecodingStrategy
    var passthroughTypeResolver: FirebaseSharedSwift.StructureCodingPassthroughTypeResolver.Type
    var userInfo: [Swift.CodingUserInfoKey : Any]
}
class __JSONDecoder {
    var storage: FirebaseSharedSwift._JSONDecodingStorage
    let options: FirebaseSharedSwift.FirebaseDataDecoder._Options
    var codingPath: [Swift.CodingKey]
}
struct _JSONDecodingStorage {
    var containers: [Any]
}
struct _JSONEncodingStorage {
    var containers: [__C.NSObject]
}
struct NoPassthroughTypes {}
struct _JSONKeyedEncodingContainer<A> where A: Swift.CodingKey {
    let encoder: FirebaseSharedSwift.__JSONEncoder
    let container: __C.NSMutableDictionary
    var codingPath: [Swift.CodingKey]
}
struct _JSONUnkeyedEncodingContainer {
    let encoder: FirebaseSharedSwift.__JSONEncoder
    let container: __C.NSMutableArray
    var codingPath: [Swift.CodingKey]
}
struct _JSONKey {
    var stringValue: Swift.String
    var intValue: Swift.Int?
}
struct _JSONKeyedDecodingContainer<A> where A: Swift.CodingKey {
    let decoder: FirebaseSharedSwift.__JSONDecoder
    let container: [Swift.String : Any]
    var codingPath: [Swift.CodingKey]
}
struct _JSONUnkeyedDecodingContainer {
    let decoder: FirebaseSharedSwift.__JSONDecoder
    let container: [Any]
    var codingPath: [Swift.CodingKey]
    var currentIndex: Swift.Int
}
class BundleFinder {}
enum FirestoreDecodingError {
    case decodingIsNotSupported(Swift.String)
    case fieldNameConflict(Swift.String)
}
enum FirestoreEncodingError {
    case encodingIsNotSupported(Swift.String)
}
struct FirestorePassthroughTypes {}
struct DocumentID<A> where A: FirebaseFirestore.DocumentIDWrappable, A: Swift.Decodable, A: Swift.Encodable {
    var value: A?
}
struct ExplicitNull<A> {
    var value: A?
}
enum GeoPointKeys {
    case latitude
    case longitude
}
struct ServerTimestamp<A> where A: FirebaseFirestore.ServerTimestampWrappable, A: Swift.Decodable, A: Swift.Encodable {
    var value: A?
}
enum TimestampKeys {
    case seconds
    case nanoseconds
}
enum VectorValueKeys {
    case array
}
enum DecodingFailureStrategy {
    case ignore
    case raise
}
struct FirestoreQuery<A> {
    struct Configuration {
        var path: Swift.String
        var predicates: [FirebaseFirestore.QueryPredicate]
        var decodingFailureStrategy: FirebaseFirestore.DecodingFailureStrategy
        var error: Swift.Error?
        var animation: SwiftUI.Animation?
    }
    var _firestoreQueryObservable: SwiftUI.StateObject<FirebaseFirestore.FirestoreQueryObservable<A>>
}
class FirestoreQueryObservable<A> {
    var _items: Combine.Published<A>
    let firestore: __C.FIRFirestore
    var listener: __C.FIRListenerRegistration?
    var setupListener: (() -> ())?
    var shouldUpdateListener: Swift.Bool
    var configuration: FirebaseFirestore.FirestoreQuery<A>.Configuration
}
enum QueryPredicate {
    case isEqualTo(Swift.String, Any)
    case isIn(Swift.String, [Any])
    case isNotIn(Swift.String, [Any])
    case arrayContains(Swift.String, Any)
    case arrayContainsAny(Swift.String, [Any])
    case isLessThan(Swift.String, Any)
    case isGreaterThan(Swift.String, Any)
    case isLessThanOrEqualTo(Swift.String, Any)
    case isGreaterThanOrEqualTo(Swift.String, Any)
    case orderBy(Swift.String, Swift.Bool)
    case limitTo(Swift.Int)
    case limitToLast(Swift.Int)
}
class BundleFinder {}
class AuthSession: __C.NSObject {
    enum Error {
        case cannotAuthorizeRequest(Foundation.URLRequest)
        case accessTokenEmptyForRequest(Foundation.URLRequest)
    }
    enum ErrorCode {}
    let authState: __C.OIDAuthState
    let serviceProvider: Swift.String?
    let userID: Swift.String?
    let userEmail: Swift.String?
    let _userEmailIsVerified: Swift.String?
    var shouldAuthorizeAllRequests: Swift.Bool
    weak var delegate: __C.GTMAuthSessionDelegate?
    weak var fetcherService: __C.GTMSessionFetcherServiceProtocol?
    let serialAuthArgsQueue: __C.OS_dispatch_queue
    var authorizationArgs: [GTMAppAuth.AuthorizationArguments]
}
struct AuthorizationArguments {
    enum CallbackStyle {
        case completion((_: Swift.Error?) -> ())
        case delegate(Any, ObjectiveC.Selector)
    }
    let request: __C.NSMutableURLRequest
    let callbackStyle: GTMAppAuth.AuthorizationArguments.CallbackStyle
    var error: Swift.Error?
}
class GTMOAuth2Compatibility: __C.NSObject {}
class KeychainAttribute: __C.NSObject {
    enum Attribute {
        case accessGroup(Swift.String)
        case useDataProtectionKeychain
    }
    let attribute: GTMAppAuth.KeychainAttribute.Attribute
}
class KeychainWrapper {
    let accountName: Swift.String
    let keychainAttributes: Swift.Set<GTMAppAuth.KeychainAttribute>
}
class KeychainStore: __C.NSObject {
    enum Error {
        case unhandled(status: Swift.Int32)
        case passwordNotFound(forItemName: Swift.String)
        case unexpectedPasswordData(forItemName: Swift.String)
        case failedToCreateResponseStringFromAuthSession(GTMAppAuth.AuthSession)
        case failedToConvertRedirectURItoURL(Swift.String)
        case failedToConvertKeychainDataToAuthSession(itemName: Swift.String)
        case failedToDeletePassword(forItemName: Swift.String)
        case failedToDeletePasswordBecauseItemNotFound(itemName: Swift.String)
        case failedToSetPassword(forItemName: Swift.String)
        case noService
        case failedToConvertAuthSessionToData
    }
    enum ErrorCode {}
    let keychainHelper: __C.GTMKeychainHelper
    var lastUsedKeyedArchiver: __C.NSKeyedArchiver?
    var lastUsedKeyedUnarchiver: __C.NSKeyedUnarchiver?
    var itemName: Swift.String
    var keychainAttributes: Swift.Set<GTMAppAuth.KeychainAttribute>
}
struct Shimmer {
    enum Mode {
        case overlay(blendMode: SwiftUI.BlendMode)
        case mask
        case background
    }
    let animation: SwiftUI.Animation
    let gradient: SwiftUI.Gradient
    let min: CoreGraphics.CGFloat
    let max: CoreGraphics.CGFloat
    let mode: Shimmer.Shimmer.Mode
    var _isInitialState: SwiftUI.State<Swift.Bool>
    var _layoutDirection: SwiftUI.Environment<SwiftUI.LayoutDirection>
}
struct AIProxyService {
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    var deviceCheckBypass: Swift.String?
    let sessionID: Swift.String
    let partialKey: Swift.String
    let organizationID: Swift.String?
}
enum AzureOpenAIAPI {
    enum VectorStoreFileCategory {
        case create(vectorStoreID: Swift.String)
        case list(vectorStoreID: Swift.String)
        case retrieve(vectorStoreID: Swift.String, fileID: Swift.String)
        case delete(vectorStoreID: Swift.String, fileID: Swift.String)
    }
    enum VectorStoreCategory {
        case retrieve(vectorStoreID: Swift.String)
        case modify(vectorStoreID: Swift.String)
        case delete(vectorStoreID: Swift.String)
        case create
        case list
    }
    enum ThreadCategory {
        case retrieve(threadID: Swift.String)
        case modify(threadID: Swift.String)
        case delete(threadID: Swift.String)
        case create
    }
    enum RunStepCategory {
        case retrieve(threadID: Swift.String, runID: Swift.String, stepID: Swift.String)
        case list(threadID: Swift.String, runID: Swift.String)
    }
    enum RunCategory {
        case create(threadID: Swift.String)
        case retrieve(threadID: Swift.String, runID: Swift.String)
        case modify(threadID: Swift.String, runID: Swift.String)
        case list(threadID: Swift.String)
        case cancel(threadID: Swift.String, runID: Swift.String)
        case submitToolOutput(threadID: Swift.String, runID: Swift.String)
        case createThreadAndRun
    }
    enum MessageCategory {
        case create(threadID: Swift.String)
        case retrieve(threadID: Swift.String, messageID: Swift.String)
        case modify(threadID: Swift.String, messageID: Swift.String)
        case list(threadID: Swift.String)
    }
    enum AssistantCategory {
        case retrieve(assistantID: Swift.String)
        case modify(assistantID: Swift.String)
        case delete(assistantID: Swift.String)
        case create
        case list
    }
    case assistant(SwiftOpenAI.AzureOpenAIAPI.AssistantCategory)
    case chat(deploymentID: Swift.String)
    case message(SwiftOpenAI.AzureOpenAIAPI.MessageCategory)
    case run(SwiftOpenAI.AzureOpenAIAPI.RunCategory)
    case runStep(SwiftOpenAI.AzureOpenAIAPI.RunStepCategory)
    case thread(SwiftOpenAI.AzureOpenAIAPI.ThreadCategory)
    case vectorStore(SwiftOpenAI.AzureOpenAIAPI.VectorStoreCategory)
    case vectorStoreFile(SwiftOpenAI.AzureOpenAIAPI.VectorStoreFileCategory)
}
struct AzureOpenAIConfiguration {
    let resourceName: Swift.String
    let openAIAPIKey: SwiftOpenAI.Authorization
    let apiVersion: Swift.String
    let extraHeaders: [Swift.String : Swift.String]?
}
class DefaultOpenAIAzureService {
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let apiKey: SwiftOpenAI.Authorization
    let initialQueryItems: [Foundation.URLQueryItem]
    let extraHeaders: [Swift.String : Swift.String]?
}
enum MultipartFormDataEntry {
    case file(paramName: Swift.String, fileName: Swift.String, fileData: Foundation.Data, contentType: Swift.String)
    case string(paramName: Swift.String, value: Any?)
}
enum OpenAIAPI {
    enum VectorStoreFileBatch {
        case create(vectorStoreID: Swift.String)
        case retrieve(vectorStoreID: Swift.String, batchID: Swift.String)
        case cancel(vectorStoreID: Swift.String, batchID: Swift.String)
        case list(vectorStoreID: Swift.String, batchID: Swift.String)
    }
    enum VectorStoreFileCategory {
        case create(vectorStoreID: Swift.String)
        case list(vectorStoreID: Swift.String)
        case retrieve(vectorStoreID: Swift.String, fileID: Swift.String)
        case delete(vectorStoreID: Swift.String, fileID: Swift.String)
    }
    enum VectorStoreCategory {
        case retrieve(vectorStoreID: Swift.String)
        case modify(vectorStoreID: Swift.String)
        case delete(vectorStoreID: Swift.String)
        case create
        case list
    }
    enum BatchCategory {
        case retrieve(batchID: Swift.String)
        case cancel(batchID: Swift.String)
        case create
        case list
    }
    enum ThreadCategory {
        case retrieve(threadID: Swift.String)
        case modify(threadID: Swift.String)
        case delete(threadID: Swift.String)
        case create
    }
    enum RunStepCategory {
        case retrieve(threadID: Swift.String, runID: Swift.String, stepID: Swift.String)
        case list(threadID: Swift.String, runID: Swift.String)
    }
    enum RunCategory {
        case create(threadID: Swift.String)
        case retrieve(threadID: Swift.String, runID: Swift.String)
        case modify(threadID: Swift.String, runID: Swift.String)
        case list(threadID: Swift.String)
        case cancel(threadID: Swift.String, runID: Swift.String)
        case submitToolOutput(threadID: Swift.String, runID: Swift.String)
        case createThreadAndRun
    }
    enum ModelCategory {
        case retrieve(modelID: Swift.String)
        case deleteFineTuneModel(modelID: Swift.String)
        case list
    }
    enum MessageCategory {
        case create(threadID: Swift.String)
        case retrieve(threadID: Swift.String, messageID: Swift.String)
        case modify(threadID: Swift.String, messageID: Swift.String)
        case list(threadID: Swift.String)
    }
    enum ImageCategory {
        case generations
        case edits
        case variations
    }
    enum FineTuningCategory {
        case retrieve(jobID: Swift.String)
        case cancel(jobID: Swift.String)
        case events(jobID: Swift.String)
        case create
        case list
    }
    enum FileCategory {
        case delete(fileID: Swift.String)
        case retrieve(fileID: Swift.String)
        case retrieveFileContent(fileID: Swift.String)
        case list
        case upload
    }
    enum AudioCategory {
        case transcriptions
        case translations
        case speech
    }
    enum AssistantCategory {
        case retrieve(assistantID: Swift.String)
        case modify(assistantID: Swift.String)
        case delete(assistantID: Swift.String)
        case create
        case list
    }
    case assistant(SwiftOpenAI.OpenAIAPI.AssistantCategory)
    case audio(SwiftOpenAI.OpenAIAPI.AudioCategory)
    case file(SwiftOpenAI.OpenAIAPI.FileCategory)
    case fineTuning(SwiftOpenAI.OpenAIAPI.FineTuningCategory)
    case images(SwiftOpenAI.OpenAIAPI.ImageCategory)
    case message(SwiftOpenAI.OpenAIAPI.MessageCategory)
    case model(SwiftOpenAI.OpenAIAPI.ModelCategory)
    case run(SwiftOpenAI.OpenAIAPI.RunCategory)
    case runStep(SwiftOpenAI.OpenAIAPI.RunStepCategory)
    case thread(SwiftOpenAI.OpenAIAPI.ThreadCategory)
    case batch(SwiftOpenAI.OpenAIAPI.BatchCategory)
    case vectorStore(SwiftOpenAI.OpenAIAPI.VectorStoreCategory)
    case vectorStoreFile(SwiftOpenAI.OpenAIAPI.VectorStoreFileCategory)
    case vectorStoreFileBatch(SwiftOpenAI.OpenAIAPI.VectorStoreFileBatch)
    case chat
    case embeddings
    case moderations
}
struct AssistantParameters {
    enum Action {
        case create(model: Swift.String)
        case modify(model: Swift.String?)
    }
    enum CodingKeys {
        case model
        case name
        case description
        case instructions
        case tools
        case metadata
        case temperature
        case topP
        case responseFormat
        case toolResources
    }
    var model: Swift.String?
    var name: Swift.String?
    var description: Swift.String?
    var instructions: Swift.String?
    var tools: [SwiftOpenAI.AssistantObject.Tool]
    var toolResources: SwiftOpenAI.ToolResources?
    var metadata: [Swift.String : Swift.String]?
    var temperature: Swift.Double?
    var topP: Swift.Double?
    var responseFormat: SwiftOpenAI.ResponseFormat?
}
struct AudioSpeechParameters {
    enum TTSModel {
        case tts1
        case tts1HD
    }
    enum Voice {
        case alloy
        case echo
        case fable
        case onyx
        case nova
        case shimmer
    }
    enum ResponseFormat {
        case mp3
        case opus
        case aac
        case flac
    }
    enum CodingKeys {
        case model
        case input
        case voice
        case responseFormat
        case speed
    }
    let model: Swift.String
    let input: Swift.String
    let voice: Swift.String
    let responseFormat: Swift.String?
    let speed: Swift.Double?
}
struct AudioTranscriptionParameters {
    enum Model {
        case whisperOne
    }
    enum CodingKeys {
        case file
        case model
        case prompt
        case responseFormat
        case temperature
        case language
        case timestampGranularities
    }
    let fileName: Swift.String
    let file: Foundation.Data
    let model: Swift.String
    let language: Swift.String?
    let prompt: Swift.String?
    let responseFormat: Swift.String?
    let temperature: Swift.Double?
    let timestampGranularities: [Swift.String]?
}
struct AudioTranslationParameters {
    enum Model {
        case whisperOne
    }
    enum CodingKeys {
        case file
        case model
        case prompt
        case responseFormat
        case temperature
    }
    let fileName: Swift.String
    let file: Foundation.Data
    let model: Swift.String
    let prompt: Swift.String?
    let responseFormat: Swift.String?
    let temperature: Swift.Double?
}
struct BatchParameter {
    enum CodingKeys {
        case inputFileID
        case endpoint
        case completionWindow
        case metadata
    }
    let inputFileID: Swift.String
    let endpoint: Swift.String
    let completionWindow: Swift.String
    let metadata: [Swift.String : Swift.String]?
}
struct ChatCompletionParameters {
    struct Message {
        enum ContentType {
            enum MessageContent {
                struct ImageDetail {
                    enum CodingKeys {
                        case url
                        case detail
                    }
                    let url: Foundation.URL
                    let detail: Swift.String?
                }
                enum CodingKeys {
                    case type
                    case text
                    case imageUrl
                }
                case text(Swift.String)
                case imageUrl(SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.ImageDetail)
            }
            case text(Swift.String)
            case contentArray([SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent])
        }
        enum Role {
            case system
            case user
            case assistant
            case tool
        }
        enum CodingKeys {
            case role
            case content
            case name
            case functionCall
            case toolCalls
            case toolCallID
        }
        let role: Swift.String
        let content: SwiftOpenAI.ChatCompletionParameters.Message.ContentType
        let name: Swift.String?
        let functionCall: SwiftOpenAI.ChatCompletionParameters.FunctionCall?
        let toolCalls: [SwiftOpenAI.ToolCall]?
        let toolCallID: Swift.String?
    }
    enum FunctionCall {
        enum CodingKeys {
            case none
            case auto
            case function
        }
        case function(Swift.String)
        case none
        case auto
    }
    struct Tool {
        enum CodingKeys {
            case type
            case function
        }
        let type: Swift.String
        let function: SwiftOpenAI.ChatCompletionParameters.ChatFunction
    }
    struct ChatFunction {
        struct JSONSchema {
            struct Property {
                enum CodingKeys {
                    case type
                    case description
                    case format
                    case items
                    case required
                    case pattern
                    case const
                    case enumValues
                    case multipleOf
                    case minimum
                    case maximum
                    case minItems
                    case maxItems
                    case uniqueItems
                }
                let type: SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.JSONType
                let description: Swift.String?
                let format: Swift.String?
                let items: SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Items?
                let required: [Swift.String]?
                let pattern: Swift.String?
                let const: Swift.String?
                let enumValues: [Swift.String]?
                let multipleOf: Swift.Int?
                let minimum: Swift.Double?
                let maximum: Swift.Double?
                let minItems: Swift.Int?
                let maxItems: Swift.Int?
                let uniqueItems: Swift.Bool?
            }
            enum JSONType {
                case integer
                case string
                case boolean
                case array
                case object
                case number
                case null
            }
            struct Items {
                enum CodingKeys {
                    case type
                    case properties
                    case pattern
                    case const
                    case enumValues
                    case multipleOf
                    case minimum
                    case maximum
                    case minItems
                    case maxItems
                    case uniqueItems
                }
                let type: SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.JSONType
                let properties: [Swift.String : SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property]?
                let pattern: Swift.String?
                let const: Swift.String?
                let enumValues: [Swift.String]?
                let multipleOf: Swift.Int?
                let minimum: Swift.Double?
                let maximum: Swift.Double?
                let minItems: Swift.Int?
                let maxItems: Swift.Int?
                let uniqueItems: Swift.Bool?
            }
            enum CodingKeys {
                case type
                case properties
                case required
                case pattern
                case const
                case enumValues
                case multipleOf
                case minimum
                case maximum
            }
            let type: SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.JSONType
            let properties: [Swift.String : SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property]?
            let required: [Swift.String]?
            let pattern: Swift.String?
            let const: Swift.String?
            let enumValues: [Swift.String]?
            let multipleOf: Swift.Int?
            let minimum: Swift.Int?
            let maximum: Swift.Int?
        }
        enum CodingKeys {
            case name
            case description
            case parameters
        }
        let name: Swift.String
        let description: Swift.String?
        let parameters: SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema?
    }
    enum CodingKeys {
        case messages
        case model
        case frequencyPenalty
        case toolChoice
        case functionCall
        case tools
        case functions
        case logitBias
        case logprobs
        case topLogprobs
        case maxTokens
        case n
        case responseFormat
        case presencePenalty
        case seed
        case stop
        case stream
        case temperature
        case topP
        case user
    }
    var messages: [SwiftOpenAI.ChatCompletionParameters.Message]
    var model: Swift.String
    var frequencyPenalty: Swift.Double?
    var functionCall: SwiftOpenAI.ChatCompletionParameters.FunctionCall?
    var toolChoice: SwiftOpenAI.ToolChoice?
    var functions: [SwiftOpenAI.ChatCompletionParameters.ChatFunction]?
    var tools: [SwiftOpenAI.ChatCompletionParameters.Tool]?
    var logitBias: [Swift.Int : Swift.Double]?
    var logprobs: Swift.Bool?
    var topLogprobs: Swift.Int?
    var maxTokens: Swift.Int?
    var n: Swift.Int?
    var presencePenalty: Swift.Double?
    var responseFormat: SwiftOpenAI.ResponseFormat?
    var seed: Swift.Int?
    var stop: [Swift.String]?
    var stream: Swift.Bool?
    var temperature: Swift.Double?
    var topP: Swift.Double?
    var user: Swift.String?
}
struct EmbeddingParameter {
    enum Model {
        case textEmbeddingAda002
    }
    enum CodingKeys {
        case input
        case model
        case encodingFormat
        case dimensions
        case user
    }
    let input: Swift.String
    let model: Swift.String
    let encodingFormat: Swift.String?
    let dimensions: Swift.Int?
    let user: Swift.String?
}
struct FileParameters {
    enum CodingKeys {
        case fileName
        case file
        case purpose
    }
    let fileName: Swift.String
    let file: Foundation.Data
    let purpose: Swift.String
}
struct FineTuningJobParameters {
    enum Model {
        case gpt35
        case babbage002
        case davinci002
    }
    struct HyperParameters {
        enum CodingKeys {
            case nEpochs
        }
        let nEpochs: Swift.Int?
    }
    struct Integration {
        struct Wandb {
            enum CodingKeys {
                case project
                case name
                case entity
                case tags
            }
            let project: Swift.String
            let name: Swift.String?
            let entity: Swift.String?
            let tags: [Swift.String]?
        }
        enum CodingKeys {
            case type
            case wandb
        }
        let type: Swift.String
        let wandb: SwiftOpenAI.FineTuningJobParameters.Integration.Wandb
    }
    enum CodingKeys {
        case model
        case trainingFile
        case hyperparameters
        case suffix
        case validationFile
        case integrations
        case seed
    }
    let model: Swift.String
    let trainingFile: Swift.String
    let hyperparameters: SwiftOpenAI.FineTuningJobParameters.HyperParameters?
    let suffix: Swift.String?
    let validationFile: Swift.String?
    let integrations: [SwiftOpenAI.FineTuningJobParameters.Integration]?
    let seed: Swift.Int?
}
enum Dalle {
    enum Dalle2ImageSize {
        case small
        case medium
        case large
    }
    enum Dalle3ImageSize {
        case largeSquare
        case landscape
        case portrait
    }
    case dalle2(SwiftOpenAI.Dalle.Dalle2ImageSize)
    case dalle3(SwiftOpenAI.Dalle.Dalle3ImageSize)
}
struct ImageCreateParameters {
    enum ImageSize {
        case small
        case medium
        case large
    }
    enum ImageResponseFormat {
        case url
        case b64Json
    }
    enum CodingKeys {
        case prompt
        case model
        case n
        case quality
        case responseFormat
        case size
        case style
        case user
    }
    let prompt: Swift.String
    let model: Swift.String?
    let n: Swift.Int?
    let quality: Swift.String?
    let responseFormat: Swift.String?
    let size: Swift.String?
    let style: Swift.String?
    let user: Swift.String?
}
struct ImageEditParameters {
    enum ImageResponseFormat {
        case url
        case b64Json
    }
    enum CodingKeys {
        case image
        case prompt
        case mask
        case model
        case n
        case size
        case responseFormat
        case user
    }
    let image: Foundation.Data
    let prompt: Swift.String
    let mask: Foundation.Data?
    let model: Swift.String?
    let n: Swift.Int?
    let size: Swift.String?
    let responseFormat: Swift.String?
    let user: Swift.String?
}
struct ImageVariationParameters {
    enum ImageResponseFormat {
        case url
        case b64Json
    }
    enum CodingKeys {
        case image
        case model
        case n
        case responseFormat
        case size
        case user
    }
    let image: Foundation.Data
    let model: Swift.String?
    let n: Swift.Int?
    let responseFormat: Swift.String?
    let size: Swift.String?
    let user: Swift.String?
}
struct MessageParameter {
    enum Role {
        case user
        case assistant
    }
    enum CodingKeys {
        case role
        case content
        case attachments
        case metadata
    }
    let role: Swift.String
    let content: Swift.String
    let attachments: [SwiftOpenAI.MessageAttachment]?
    let metadata: [Swift.String : Swift.String]?
}
struct ModifyMessageParameters {
    enum CodingKeys {
        case metadata
    }
    var metadata: [Swift.String : Swift.String]
}
enum Model {
    case custom(Swift.String)
    case gpt4o
    case gpt4o20240513
    case gpt35Turbo
    case gpt35Turbo1106
    case gpt35Turbo0125
    case gpt4
    case gpt41106Preview
    case gpt35Turbo0613
    case gpt35Turbo16k0613
    case gpt4TurboPreview
    case gpt40125Preview
    case gpt4Turbo20240409
    case gpt4turbo
    case gpt4VisionPreview
    case dalle2
    case dalle3
}
struct ModerationParameter<A> where A: Swift.Encodable {
    enum Model {
        case stable
        case latest
    }
    enum CodingKeys {
        case input
        case model
    }
    let input: A
    let model: Swift.String?
}
struct CreateThreadAndRunParameter {
    enum CodingKeys {
        case assistantId
        case thread
        case model
        case instructions
        case tools
        case metadata
        case temperature
        case topP
        case stream
        case maxPromptTokens
        case maxCompletionTokens
        case truncationStrategy
        case toolChoice
        case responseFormat
    }
    let assistantId: Swift.String
    let thread: SwiftOpenAI.CreateThreadParameters?
    let model: Swift.String?
    let instructions: Swift.String?
    let tools: [SwiftOpenAI.AssistantObject.Tool]?
    let metadata: [Swift.String : Swift.String]?
    let temperature: Swift.Double?
    let topP: Swift.Double?
    var stream: Swift.Bool
    let maxPromptTokens: Swift.Int?
    let maxCompletionTokens: Swift.Int?
    let truncationStrategy: SwiftOpenAI.TruncationStrategy?
    let toolChoice: SwiftOpenAI.ToolChoice?
    let responseFormat: SwiftOpenAI.ResponseFormat?
}
struct ModifyRunParameters {
    enum CodingKeys {
        case metadata
    }
    var metadata: [Swift.String : Swift.String]
}
struct RunParameter {
    enum CodingKeys {
        case assistantID
        case model
        case instructions
        case additionalInstructions
        case additionalMessages
        case tools
        case metadata
        case stream
        case temperature
        case maxPromptTokens
        case maxCompletionTokens
        case truncationStrategy
        case toolChoice
        case responseFormat
    }
    let assistantID: Swift.String
    let model: Swift.String?
    let instructions: Swift.String?
    let additionalInstructions: Swift.String?
    let additionalMessages: [SwiftOpenAI.MessageParameter]?
    let tools: [SwiftOpenAI.AssistantObject.Tool]?
    let metadata: [Swift.String : Swift.String]?
    let temperature: Swift.Double?
    var stream: Swift.Bool
    let maxPromptTokens: Swift.Int?
    let maxCompletionTokens: Swift.Int?
    let truncationStrategy: SwiftOpenAI.TruncationStrategy?
    let toolChoice: SwiftOpenAI.ToolChoice?
    let responseFormat: SwiftOpenAI.ResponseFormat?
}
struct RunToolsOutputParameter {
    struct ToolOutput {
        enum CodingKeys {
            case toolCallId
            case output
        }
        let toolCallId: Swift.String?
        let output: Swift.String?
    }
    enum CodingKeys {
        case toolOutputs
        case stream
    }
    let toolOutputs: [SwiftOpenAI.RunToolsOutputParameter.ToolOutput]
    var stream: Swift.Bool
}
struct CreateThreadParameters {
    enum CodingKeys {
        case messages
        case toolResources
        case metadata
    }
    var messages: [SwiftOpenAI.MessageObject]?
    var toolResources: SwiftOpenAI.ToolResources?
    var metadata: [Swift.String : Swift.String]?
}
struct ModifyThreadParameters {
    enum CodingKeys {
        case metadata
    }
    var metadata: [Swift.String : Swift.String]
}
struct VectorStoreParameter {
    enum CodingKeys {
        case fileIDS
        case name
        case expiresAfter
        case metadata
    }
    let fileIDS: [Swift.String]?
    let name: Swift.String?
    let expiresAfter: SwiftOpenAI.ExpirationPolicy?
    let metadata: [Swift.String : Swift.String]?
}
struct VectorStoreFileBatchParameter {
    enum CodingKeys {
        case fileIDS
    }
    let fileIDS: [Swift.String]
}
struct VectorStoreFileParameter {
    enum CodingKeys {
        case fileID
    }
    let fileID: Swift.String
}
struct AssistantObject {
    struct Tool {
        enum ToolType {
            case codeInterpreter
            case fileSearch
            case function
        }
        enum CodingKeys {
            case type
            case function
        }
        let type: Swift.String
        let function: SwiftOpenAI.ChatCompletionParameters.ChatFunction?
    }
    enum CodingKeys {
        case id
        case object
        case createdAt
        case name
        case description
        case model
        case instructions
        case tools
        case toolResources
        case metadata
        case temperature
        case topP
        case responseFormat
    }
    let id: Swift.String
    let object: Swift.String
    let createdAt: Swift.Int
    let name: Swift.String?
    let description: Swift.String?
    let model: Swift.String
    let instructions: Swift.String?
    let tools: [SwiftOpenAI.AssistantObject.Tool]
    let toolResources: SwiftOpenAI.ToolResources?
    let metadata: [Swift.String : Swift.String]?
    var temperature: Swift.Double?
    var topP: Swift.Double?
    var responseFormat: SwiftOpenAI.ResponseFormat?
}
enum AssistantStreamEvent {
    case threadRunStepDelta(SwiftOpenAI.RunStepDeltaObject)
    case threadMessageDelta(SwiftOpenAI.MessageDeltaObject)
    case threadCreated
    case threadRunCreated
    case threadRunQueued
    case threadRunInProgress
    case threadRunRequiresAction
    case threadRunCompleted
    case threadRunFailed
    case threadRunCancelling
    case threadRunCancelled
    case threadRunExpired
    case threadRunStepCreated
    case threadRunStepInProgress
    case threadRunStepCompleted
    case threadRunStepFailed
    case threadRunStepCancelled
    case threadRunStepExpired
    case threadMessageCreated
    case threadMessageInProgress
    case threadMessageCompleted
    case threadMessageIncomplete
    case error
    case done
}
enum AssistantStreamEventObject {
    case threadCreated
    case threadRunCreated
    case threadRunQueued
    case threadRunInProgress
    case threadRunRequiresAction
    case threadRunCompleted
    case threadRunFailed
    case threadRunCancelling
    case threadRunCancelled
    case threadRunExpired
    case threadRunStepCreated
    case threadRunStepInProgress
    case threadRunStepDelta
    case threadRunStepCompleted
    case threadRunStepFailed
    case threadRunStepCancelled
    case threadRunStepExpired
    case threadMessageCreated
    case threadMessageInProgress
    case threadMessage
    case threadMessageDelta
    case threadMessageCompleted
    case threadMessageIncomplete
    case error
    case done
}
struct AudioObject {
    struct Word {
        enum CodingKeys {
            case word
            case start
            case end
        }
        let word: Swift.String
        let start: Swift.Double
        let end: Swift.Double
    }
    struct Segment {
        enum CodingKeys {
            case id
            case seek
            case start
            case end
            case text
            case tokens
            case temperature
            case avgLogprob
            case compressionRatio
            case noSpeechProb
        }
        let id: Swift.Int
        let seek: Swift.Int
        let start: Swift.Double
        let end: Swift.Double
        let text: Swift.String
        let tokens: [Swift.Int]
        let temperature: Swift.Double
        let avgLogprob: Swift.Double
        let compressionRatio: Swift.Double
        let noSpeechProb: Swift.Double
    }
    enum CodingKeys {
        case language
        case duration
        case text
        case words
        case segments
    }
    let language: Swift.String?
    let duration: Swift.String?
    let text: Swift.String
    let words: [SwiftOpenAI.AudioObject.Word]?
    let segments: [SwiftOpenAI.AudioObject.Segment]?
}
struct AudioSpeechObject {
    enum CodingKeys {
        case output
    }
    let output: Foundation.Data
}
struct BatchObject {
    struct Error {
        struct Data {
            enum CodingKeys {
                case code
                case message
                case param
                case line
            }
            let code: Swift.String
            let message: Swift.String
            let param: Swift.String?
            let line: Swift.Int?
        }
        enum CodingKeys {
            case object
            case data
        }
        let object: Swift.String
        let data: [SwiftOpenAI.BatchObject.Error.Data]
    }
    struct RequestCount {
        enum CodingKeys {
            case total
            case completed
            case failed
        }
        let total: Swift.Int
        let completed: Swift.Int
        let failed: Swift.Int
    }
    enum CodingKeys {
        case id
        case object
        case endpoint
        case errors
        case inputFileID
        case completionWindow
        case status
        case outputFileID
        case errorFileID
        case createdAt
        case inProgressAt
        case expiresAt
        case finalizingAt
        case completedAt
        case failedAt
        case expiredAt
        case cancellingAt
        case cancelledAt
        case requestCounts
        case metadata
    }
    let id: Swift.String
    let object: Swift.String
    let endpoint: Swift.String
    let errors: SwiftOpenAI.BatchObject.Error
    let inputFileID: Swift.String
    let completionWindow: Swift.String
    let status: Swift.String
    let outputFileID: Swift.String
    let errorFileID: Swift.String
    let createdAt: Swift.Int
    let inProgressAt: Swift.Int
    let expiresAt: Swift.Int
    let finalizingAt: Swift.Int
    let completedAt: Swift.Int
    let failedAt: Swift.Int
    let expiredAt: Swift.Int
    let cancellingAt: Swift.Int
    let cancelledAt: Swift.Int
    let requestCounts: SwiftOpenAI.BatchObject.RequestCount
    let metadata: [Swift.String : Swift.String]
}
struct ChatCompletionChunkObject {
    struct ChatChoice {
        struct Delta {
            enum CodingKeys {
                case content
                case toolCalls
                case functionCall
                case role
            }
            let content: Swift.String?
            let toolCalls: [SwiftOpenAI.ToolCall]?
            let functionCall: SwiftOpenAI.FunctionCall?
            let role: Swift.String?
        }
        struct LogProb {
            enum CodingKeys {
                case content
            }
            let content: [SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail]
        }
        struct TokenDetail {
            struct TopLogProb {
                enum CodingKeys {
                    case token
                    case logprob
                    case bytes
                }
                let token: Swift.String
                let logprob: Swift.Double
                let bytes: [Swift.Int]?
            }
            enum CodingKeys {
                case token
                case logprob
                case bytes
                case topLogprobs
            }
            let token: Swift.String
            let logprob: Swift.Double
            let bytes: [Swift.Int]?
            let topLogprobs: [SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.TopLogProb]
        }
        struct FinishDetails {
            enum CodingKeys {
                case type
            }
            let type: Swift.String
        }
        enum CodingKeys {
            case delta
            case finishReason
            case index
            case finishDetails
            case logprobs
        }
        let delta: SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.Delta
        let finishReason: SwiftOpenAI.IntOrStringValue?
        let index: Swift.Int
        let finishDetails: SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.FinishDetails?
        let logprobs: SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.LogProb?
    }
    enum CodingKeys {
        case id
        case choices
        case created
        case model
        case systemFingerprint
        case object
    }
    let id: Swift.String
    let choices: [SwiftOpenAI.ChatCompletionChunkObject.ChatChoice]
    let created: Swift.Int
    let model: Swift.String
    let systemFingerprint: Swift.String?
    let object: Swift.String
}
struct ChatCompletionObject {
    struct ChatChoice {
        struct ChatMessage {
            struct FinishDetails {
                enum CodingKeys {
                    case type
                }
                let type: Swift.String
            }
            enum CodingKeys {
                case content
                case toolCalls
                case functionCall
                case role
                case finishDetails
            }
            let content: Swift.String?
            let toolCalls: [SwiftOpenAI.ToolCall]?
            let functionCall: SwiftOpenAI.FunctionCall?
            let role: Swift.String
            let finishDetails: SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.FinishDetails?
        }
        struct LogProb {
            enum CodingKeys {
                case content
            }
            let content: [SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail]
        }
        struct TokenDetail {
            struct TopLogProb {
                enum CodingKeys {
                    case token
                    case logprob
                    case bytes
                }
                let token: Swift.String
                let logprob: Swift.Double
                let bytes: [Swift.Int]?
            }
            enum CodingKeys {
                case token
                case logprob
                case bytes
                case topLogprobs
            }
            let token: Swift.String
            let logprob: Swift.Double
            let bytes: [Swift.Int]?
            let topLogprobs: [SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.TopLogProb]
        }
        enum CodingKeys {
            case finishReason
            case index
            case message
            case logprobs
        }
        let finishReason: SwiftOpenAI.IntOrStringValue?
        let index: Swift.Int
        let message: SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage
        let logprobs: SwiftOpenAI.ChatCompletionObject.ChatChoice.LogProb?
    }
    struct ChatUsage {
        enum CodingKeys {
            case completionTokens
            case promptTokens
            case totalTokens
        }
        let completionTokens: Swift.Int
        let promptTokens: Swift.Int
        let totalTokens: Swift.Int
    }
    enum CodingKeys {
        case id
        case choices
        case created
        case model
        case systemFingerprint
        case object
        case usage
    }
    let id: Swift.String
    let choices: [SwiftOpenAI.ChatCompletionObject.ChatChoice]
    let created: Swift.Int
    let model: Swift.String
    let systemFingerprint: Swift.String?
    let object: Swift.String
    let usage: SwiftOpenAI.ChatCompletionObject.ChatUsage
}
struct EmbeddingObject {
    enum CodingKeys {
        case object
        case embedding
        case index
    }
    let object: Swift.String
    let embedding: [Swift.Float]
    let index: Swift.Int
}
struct FileObject {
    enum Status {
        case uploaded
        case processed
        case pending
        case error
        case deleting
        case deleted
    }
    enum CodingKeys {
        case id
        case bytes
        case createdAt
        case filename
        case object
        case purpose
        case status
        case statusDetails
    }
    let id: Swift.String
    let bytes: Swift.Int?
    let createdAt: Swift.Int
    let filename: Swift.String
    let object: Swift.String
    let purpose: Swift.String
    let status: Swift.String?
    let statusDetails: Swift.String?
}
struct FineTuningJobEventObject {
    struct Data {
        enum CodingKeys {
            case step
            case trainLoss
            case trainMeanTokenAccuracy
        }
        let step: Swift.Int
        let trainLoss: Swift.Double
        let trainMeanTokenAccuracy: Swift.Double
    }
    enum CodingKeys {
        case id
        case createdAt
        case level
        case message
        case object
        case type
        case data
    }
    let id: Swift.String
    let createdAt: Swift.Int
    let level: Swift.String
    let message: Swift.String
    let object: Swift.String
    let type: Swift.String?
    let data: SwiftOpenAI.FineTuningJobEventObject.Data?
}
struct FineTuningJobObject {
    enum Status {
        case validatingFiles
        case queued
        case running
        case succeeded
        case failed
        case cancelled
    }
    struct HyperParameters {
        enum CodingKeys {
            case nEpochs
        }
        let nEpochs: SwiftOpenAI.IntOrStringValue
    }
    enum CodingKeys {
        case id
        case createdAt
        case error
        case fineTunedModel
        case finishedAt
        case hyperparameters
        case model
        case object
        case organizationId
        case resultFiles
        case status
        case trainedTokens
        case trainingFile
        case validationFile
    }
    let id: Swift.String
    let createdAt: Swift.Int
    let error: SwiftOpenAI.OpenAIErrorResponse.Error?
    let fineTunedModel: Swift.String?
    let finishedAt: Swift.Int?
    let hyperparameters: SwiftOpenAI.FineTuningJobObject.HyperParameters
    let model: Swift.String
    let object: Swift.String
    let organizationId: Swift.String
    let resultFiles: [Swift.String]
    let status: Swift.String
    let trainedTokens: Swift.Int?
    let trainingFile: Swift.String
    let validationFile: Swift.String?
}
enum IntOrStringValue {
    case int(Swift.Int)
    case string(Swift.String)
}
struct ImageObject {
    enum CodingKeys {
        case url
        case b64Json
        case revisedPrompt
    }
    let url: Foundation.URL?
    let b64Json: Swift.String?
    let revisedPrompt: Swift.String?
}
enum MessageContent {
    enum CodingKeys {
        case type
        case imageFile
        case text
    }
    enum ContentTypeKey {
        case type
    }
    case imageFile(SwiftOpenAI.ImageFile)
    case text(SwiftOpenAI.Text)
}
struct ImageFile {
    struct ImageFileContent {
        enum CodingKeys {
            case fileID
        }
        let fileID: Swift.String
    }
    enum CodingKeys {
        case imageFile
        case type
    }
    let type: Swift.String
    let imageFile: SwiftOpenAI.ImageFile.ImageFileContent
}
struct Text {
    struct TextContent {
        enum CodingKeys {
            case value
            case annotations
        }
        let value: Swift.String
        let annotations: [SwiftOpenAI.Annotation]?
    }
    enum CodingKeys {
        case type
        case text
    }
    let type: Swift.String
    let text: SwiftOpenAI.Text.TextContent
}
enum Annotation {
    enum CodingKeys {
        case type
        case text
        case fileCitation
        case filePath
        case startIndex
        case endIndex
    }
    enum AnnotationTypeKey {
        case type
    }
    case fileCitation(SwiftOpenAI.FileCitation)
    case filePath(SwiftOpenAI.FilePath)
}
struct FileCitation {
    struct FileCitationDetails {
        enum CodingKeys {
            case fileID
            case quote
        }
        let fileID: Swift.String
        let quote: Swift.String
    }
    enum CodingKeys {
        case type
        case text
        case fileCitation
        case startIndex
        case endIndex
    }
    let type: Swift.String
    let text: Swift.String
    let fileCitation: SwiftOpenAI.FileCitation.FileCitationDetails
    let startIndex: Swift.Int
    let endIndex: Swift.Int
}
struct FilePath {
    struct FilePathDetails {
        enum CodingKeys {
            case fileID
        }
        let fileID: Swift.String
    }
    enum CodingKeys {
        case type
        case text
        case filePath
        case startIndex
        case endIndex
    }
    let type: Swift.String
    let text: Swift.String
    let filePath: SwiftOpenAI.FilePath.FilePathDetails
    let startIndex: Swift.Int
    let endIndex: Swift.Int
}
struct MessageDeltaObject {
    struct Delta {
        enum CodingKeys {
            case role
            case content
        }
        let role: Swift.String?
        let content: [SwiftOpenAI.MessageContent]
    }
    enum CodingKeys {
        case id
        case object
        case delta
    }
    let id: Swift.String
    let object: Swift.String
    let delta: SwiftOpenAI.MessageDeltaObject.Delta
}
struct MessageObject {
    enum CodingKeys {
        case id
        case object
        case createdAt
        case threadID
        case status
        case incompleteDetails
        case completedAt
        case role
        case content
        case assistantID
        case runID
        case attachments
        case metadata
    }
    let id: Swift.String
    let object: Swift.String
    let createdAt: Swift.Int
    let threadID: Swift.String
    let status: Swift.String?
    let incompleteDetails: SwiftOpenAI.IncompleteDetails?
    let completedAt: Swift.Int?
    let role: Swift.String
    let content: [SwiftOpenAI.MessageContent]
    let assistantID: Swift.String?
    let runID: Swift.String?
    let attachments: [SwiftOpenAI.MessageAttachment]?
    let metadata: [Swift.String : Swift.String]?
}
struct ModelObject {
    struct Permission {
        enum CodingKeys {
            case id
            case object
            case created
            case allowCreateEngine
            case allowSampling
            case allowLogprobs
            case allowSearchIndices
            case allowView
            case allowFineTuning
            case organization
            case group
            case isBlocking
        }
        let id: Swift.String?
        let object: Swift.String?
        let created: Swift.Int?
        let allowCreateEngine: Swift.Bool?
        let allowSampling: Swift.Bool?
        let allowLogprobs: Swift.Bool?
        let allowSearchIndices: Swift.Bool?
        let allowView: Swift.Bool?
        let allowFineTuning: Swift.Bool?
        let organization: Swift.String?
        let group: Swift.String?
        let isBlocking: Swift.Bool?
    }
    enum CodingKeys {
        case id
        case created
        case object
        case ownedBy
        case permission
    }
    let id: Swift.String
    let created: Swift.Int
    let object: Swift.String
    let ownedBy: Swift.String
    let permission: [SwiftOpenAI.ModelObject.Permission]?
}
struct ModerationObject {
    struct Moderation {
        struct Category<A> where A: Swift.Decodable {
            enum CodingKeys {
                case hate
                case hateThreatening
                case harassment
                case harassmentThreatening
                case selfHarm
                case selfHarmIntent
                case selfHarmInstructions
                case sexual
                case sexualMinors
                case violence
                case violenceGraphic
            }
            let hate: A
            let hateThreatening: A
            let harassment: A
            let harassmentThreatening: A
            let selfHarm: A
            let selfHarmIntent: A
            let selfHarmInstructions: A
            let sexual: A
            let sexualMinors: A
            let violence: A
            let violenceGraphic: A
        }
        enum CodingKeys {
            case categories
            case categoryScores
            case flagged
        }
        let flagged: Swift.Bool
        let categories: SwiftOpenAI.ModerationObject.Moderation.Category<Swift.Bool>
        let categoryScores: SwiftOpenAI.ModerationObject.Moderation.Category<Swift.Double>
    }
    enum CodingKeys {
        case id
        case model
        case results
    }
    let id: Swift.String
    let model: Swift.String
    let results: [SwiftOpenAI.ModerationObject.Moderation]
}
struct OpenAIErrorResponse {
    struct Error {
        enum CodingKeys {
            case message
            case type
            case param
            case code
        }
        let message: Swift.String?
        let type: Swift.String?
        let param: Swift.String?
        let code: Swift.String?
    }
    enum CodingKeys {
        case error
    }
    let error: SwiftOpenAI.OpenAIErrorResponse.Error
}
struct OpenAIResponse<A> where A: Swift.Decodable {
    struct Usage {
        enum CodingKeys {
            case promptTokens
            case totalTokens
        }
        let promptTokens: Swift.Int
        let totalTokens: Swift.Int
    }
    enum CodingKeys {
        case object
        case data
        case model
        case usage
        case hasMore
        case created
        case firstID
        case lastID
    }
    let object: Swift.String?
    let data: [A]
    let model: Swift.String?
    let usage: SwiftOpenAI.OpenAIResponse<A>.Usage?
    let hasMore: Swift.Bool?
    let created: Swift.Int?
    let firstID: Swift.String?
    let lastID: Swift.String?
}
struct RunObject {
    enum Status {
        case queued
        case inProgress
        case requiresAction
        case cancelling
        case cancelled
        case failed
        case completed
        case expired
    }
    struct RequiredAction {
        struct SubmitToolOutput {
            enum CodingKeys {
                case toolCalls
            }
            let toolCalls: [SwiftOpenAI.ToolCall]
        }
        enum CodingKeys {
            case type
            case submitToolsOutputs
        }
        let type: Swift.String
        let submitToolsOutputs: SwiftOpenAI.RunObject.RequiredAction.SubmitToolOutput
    }
    enum CodingKeys {
        case id
        case object
        case createdAt
        case threadID
        case assistantID
        case status
        case requiredAction
        case lastError
        case expiresAt
        case startedAt
        case cancelledAt
        case failedAt
        case completedAt
        case incompleteDetails
        case model
        case instructions
        case tools
        case metadata
        case usage
        case temperature
        case topP
        case maxPromptTokens
        case maxCompletionTokens
        case truncationStrategy
        case toolChoice
        case responseFormat
    }
    let id: Swift.String
    let object: Swift.String
    let createdAt: Swift.Int?
    let threadID: Swift.String
    let assistantID: Swift.String
    let status: Swift.String
    let requiredAction: SwiftOpenAI.RunObject.RequiredAction?
    let lastError: SwiftOpenAI.LastError?
    let expiresAt: Swift.Int?
    let startedAt: Swift.Int?
    let cancelledAt: Swift.Int?
    let failedAt: Swift.Int?
    let completedAt: Swift.Int?
    let incompleteDetails: SwiftOpenAI.IncompleteDetails?
    let model: Swift.String
    let instructions: Swift.String?
    let tools: [SwiftOpenAI.AssistantObject.Tool]
    let metadata: [Swift.String : Swift.String]
    let usage: SwiftOpenAI.Usage?
    let temperature: Swift.Double?
    let topP: Swift.Double?
    let maxPromptTokens: Swift.Int?
    let maxCompletionTokens: Swift.Int?
    let truncationStrategy: SwiftOpenAI.TruncationStrategy?
    let toolChoice: SwiftOpenAI.ToolChoice?
    let responseFormat: SwiftOpenAI.ResponseFormat?
}
struct RunStepDeltaObject {
    struct Delta {
        enum CodingKeys {
            case stepDetails
        }
        let stepDetails: SwiftOpenAI.RunStepDetails
    }
    enum CodingKeys {
        case id
        case object
        case delta
    }
    let id: Swift.String
    let object: Swift.String
    let delta: SwiftOpenAI.RunStepDeltaObject.Delta
}
struct RunStepDetails {
    struct MessageCreation {
        enum CodingKeys {
            case messageID
        }
        let messageID: Swift.String
    }
    struct ToolCall {
        enum CodingKeys {
            case index
            case id
            case type
            case codeInterpreter
            case fileSearch
            case function
        }
        let index: Swift.Int?
        let id: Swift.String?
        let type: Swift.String
        let toolCall: SwiftOpenAI.RunStepToolCall
    }
    enum CodingKeys {
        case type
        case messageCreation
        case toolCalls
    }
    let type: Swift.String
    let messageCreation: SwiftOpenAI.RunStepDetails.MessageCreation?
    let toolCalls: [SwiftOpenAI.RunStepDetails.ToolCall]?
}
enum RunStepToolCall {
    enum TypeEnum {
        case codeInterpreter
        case fileSearch
        case function
    }
    case codeInterpreterToolCall(SwiftOpenAI.CodeInterpreterToolCall)
    case fileSearchToolCall(SwiftOpenAI.FileSearchToolCall)
    case functionToolCall(SwiftOpenAI.FunctionToolCall)
}
struct CodeInterpreterToolCall {
    enum CodingKeys {
        case input
        case outputs
    }
    var input: Swift.String?
    let outputs: [SwiftOpenAI.CodeInterpreterOutput]?
}
enum CodeInterpreterOutput {
    enum CodingKeys {
        case type
    }
    enum OutputType {
        case logs
        case images
    }
    case logs(SwiftOpenAI.CodeInterpreterLogOutput)
    case images(SwiftOpenAI.CodeInterpreterImageOutput)
}
struct CodeInterpreterLogOutput {
    enum CodingKeys {
        case type
        case logs
    }
    let type: Swift.String
    let logs: Swift.String
}
struct CodeInterpreterImageOutput {
    struct Image {
        enum CodingKeys {
            case fileID
        }
        let fileID: Swift.String
    }
    enum CodingKeys {
        case type
        case image
    }
    let type: Swift.String
    let image: SwiftOpenAI.CodeInterpreterImageOutput.Image
}
struct FileSearchToolCall {
    enum CodingKeys {
        case fileSearch
    }
    let fileSearch: [Swift.String : Swift.String]?
}
struct FunctionToolCall {
    enum CodingKeys {
        case name
        case arguments
        case output
    }
    let name: Swift.String?
    let arguments: Swift.String
    let output: Swift.String?
}
struct RunStepObject {
    enum Status {
        case inProgress
        case cancelled
        case failed
        case completed
        case expired
    }
    enum CodingKeys {
        case id
        case object
        case createdAt
        case assistantId
        case threadId
        case runId
        case type
        case status
        case stepDetails
        case lastError
        case expiredAt
        case cancelledAt
        case failedAt
        case completedAt
        case metadata
        case usage
    }
    let id: Swift.String
    let object: Swift.String
    let createdAt: Swift.Int
    let assistantId: Swift.String
    let threadId: Swift.String
    let runId: Swift.String
    let type: Swift.String
    let status: Swift.String
    let stepDetails: SwiftOpenAI.RunStepDetails
    let lastError: SwiftOpenAI.LastError?
    let expiredAt: Swift.Int?
    let cancelledAt: Swift.Int?
    let failedAt: Swift.Int?
    let completedAt: Swift.Int?
    let metadata: [Swift.String : Swift.String]?
    let usage: SwiftOpenAI.Usage?
}
struct ThreadObject {
    enum CodingKeys {
        case id
        case object
        case createdAt
        case toolResources
        case metadata
    }
    let id: Swift.String
    let object: Swift.String
    let createdAt: Swift.Int
    var toolResources: SwiftOpenAI.ToolResources?
    let metadata: [Swift.String : Swift.String]
}
struct VectorStoreObject {
    enum CodingKeys {
        case id
        case object
        case createdAt
        case name
        case usageBytes
        case fileCounts
        case status
        case expiresAfter
        case expiresAt
        case lastActiveAt
        case metadata
    }
    let id: Swift.String
    let object: Swift.String
    let createdAt: Swift.Int
    let name: Swift.String
    let usageBytes: Swift.Int
    let fileCounts: SwiftOpenAI.FileCount
    let status: Swift.String
    let expiresAfter: SwiftOpenAI.ExpirationPolicy?
    let expiresAt: Swift.Int?
    let lastActiveAt: Swift.Int?
    let metadata: [Swift.String : Swift.String]
}
struct VectorStoreFileObject {
    enum CodingKeys {
        case id
        case object
        case usageBytes
        case createdAt
        case vectorStoreID
        case status
        case lastError
    }
    let id: Swift.String
    let object: Swift.String
    let usageBytes: Swift.Int
    let createdAt: Swift.Int
    let vectorStoreID: Swift.String
    let status: Swift.String
    let lastError: SwiftOpenAI.LastError?
}
struct VectorStoreFileBatchObject {
    enum CodingKeys {
        case id
        case object
        case createdAt
        case vectorStoreID
        case status
        case fileCounts
    }
    let id: Swift.String
    let object: Swift.String
    let createdAt: Swift.Int
    let vectorStoreID: Swift.String
    let status: Swift.String
    let fileCounts: SwiftOpenAI.FileCount
}
struct DefaultOpenAIService {
    let session: __C.NSURLSession
    let decoder: Foundation.JSONDecoder
    let sessionID: Swift.String
    let apiKey: SwiftOpenAI.Authorization
    let organizationID: Swift.String?
}
enum APIError {
    case requestFailed(description: Swift.String)
    case responseUnsuccessful(description: Swift.String)
    case jsonDecodingFailure(description: Swift.String)
    case dataCouldNotBeReadMissingData(description: Swift.String)
    case invalidData
    case bothDecodingStrategiesFailed
    case timeOutError
}
enum Authorization {
    case apiKey(Swift.String)
    case bearer(Swift.String)
}
class OpenAIServiceFactory {}
struct DeletionStatus {
    enum CodingKeys {
        case id
        case object
        case deleted
    }
    let id: Swift.String
    let object: Swift.String
    let deleted: Swift.Bool
}
struct ExpirationPolicy {
    enum CodingKeys {
        case anchor
        case days
    }
    let anchor: Swift.String
    let days: Swift.Int
}
struct FileCount {
    enum CodingKeys {
        case inProgress
        case completed
        case failed
        case cancelled
        case total
    }
    let inProgress: Swift.Int
    let completed: Swift.Int
    let failed: Swift.Int
    let cancelled: Swift.Int
    let total: Swift.Int
}
struct IncompleteDetails {
    enum CodingKeys {
        case reason
    }
    let reason: Swift.String
}
struct LastError {
    enum CodingKeys {
        case code
        case message
    }
    let code: Swift.String
    let message: Swift.String
}
struct MessageAttachment {
    enum CodingKeys {
        case fileID
        case tools
    }
    let fileID: Swift.String
    let tools: [SwiftOpenAI.AssistantObject.Tool]
}
enum ResponseFormat {
    enum CodingKeys {
        case type
    }
    case type(Swift.String)
    case auto
}
struct ToolCall {
    enum CodingKeys {
        case index
        case id
        case type
        case function
    }
    let index: Swift.Int?
    let id: Swift.String?
    let type: Swift.String?
    let function: SwiftOpenAI.FunctionCall
}
struct FunctionCall {
    enum CodingKeys {
        case arguments
        case name
    }
    let arguments: Swift.String
    let name: Swift.String?
}
enum ToolChoice {
    enum CodingKeys {
        case none
        case auto
        case required
        case type
        case function
    }
    enum FunctionCodingKeys {
        case name
    }
    case function(type: Swift.String, name: Swift.String)
    case none
    case auto
    case required
}
struct ToolResources {
    struct FileSearch {
        enum CodingKeys {
            case vectorStoreIds
        }
        let vectorStoreIds: [Swift.String]
    }
    struct CodeInterpreter {
        enum CodingKeys {
            case fileIds
        }
        let fileIds: [Swift.String]
    }
    enum CodingKeys {
        case fileSearch
        case codeInterpreter
    }
    let fileSearch: SwiftOpenAI.ToolResources.FileSearch?
    let codeInterpreter: SwiftOpenAI.ToolResources.CodeInterpreter?
}
struct TruncationStrategy {
    enum CodingKeys {
        case type
        case lastMessage
    }
    let type: Swift.String
    let lastMessage: Swift.Int?
}
struct Usage {
    enum CodingKeys {
        case completionTokens
        case promptTokens
        case totalTokens
    }
    let completionTokens: Swift.Int
    let promptTokens: Swift.Int
    let totalTokens: Swift.Int
}
class Downloader {
    class ChildDownloader {
        class Delegate: __C.NSObject {
            enum State {
                case error(Swift.Error)
                case initial
                case downloading
                case completed
            }
            let progress: __C.NSProgress
            let state: 
        }
        let url: Foundation.URL
        let destinationURL: Foundation.URL
        let session: 
        let headSession: __C.NSURLSession
        let delegate: LocalLLMClientUtility.Downloader.ChildDownloader.Delegate
        let currentTask: 
    }
    var downloaders: [LocalLLMClientUtility.Downloader.ChildDownloader]
    let progress: __C.NSProgress
    var observer: Foundation.NSKeyValueObservation?
}
struct FileDownloader {
    enum Source {
        case huggingFace(id: Swift.String, globs: LocalLLMClientUtility.Globs)
    }
    struct DownloadConfiguration {
        var identifier: Swift.String?
        var protocolClasses: [Swift.AnyObject.Type]?
    }
    let source: LocalLLMClientUtility.FileDownloader.Source
    let rootDestination: Foundation.URL
    let downloadConfiguration: LocalLLMClientUtility.FileDownloader.DownloadConfiguration
}
struct FilesMetadata {
    struct FileMetadata {
        enum CodingKeys {
            case name
            case size
        }
        let name: Swift.String
        let size: Swift.Int
    }
    enum CodingKeys {
        case files
    }
    let files: [LocalLLMClientUtility.FilesMetadata.FileMetadata]
}
struct Globs {
    var rawValue: [Swift.String]
}
struct HuggingFaceAPI {
    enum RepoType {
        case models
        case datasets
        case spaces
    }
    struct Repo {
        let id: Swift.String
        let type: LocalLLMClientUtility.HuggingFaceAPI.RepoType
    }
    struct DownloadConfiguration {
        var identifier: Swift.String?
        var protocolClasses: [Swift.AnyObject.Type]?
    }
    struct FileInfo {
        let filename: Swift.String
        let size: Swift.Int
    }
    struct FileMetadata {
        let commitHash: Swift.String?
        let etag: Swift.String?
        let location: Swift.String
        let size: Swift.Int?
    }
    struct SiblingsResponse {
        enum CodingKeys {
            case siblings
        }
        struct Sibling {
            enum CodingKeys {
                case rfilename
                case size
            }
            let rfilename: Swift.String
            let size: Swift.Int
        }
        let siblings: [LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.Sibling]
    }
    let endpoint: Foundation.URL
    let hfToken: Swift.String?
    let repo: LocalLLMClientUtility.HuggingFaceAPI.Repo
}
class Locked<A> where A: SwiftDumpInvertedProtocols {
    let lock: os.OSAllocatedUnfairLock<()>
    var value: A
}
enum Node {
    enum CodingKeys {
        case text
        case expression
        case statement
        case comment
    }
    enum TextCodingKeys {
        case _0
    }
    enum ExpressionCodingKeys {
        case _0
    }
    enum StatementCodingKeys {
        case _0
    }
    enum CommentCodingKeys {
        case _0
    }
    indirect case text(Swift.String)
    indirect case expression(Jinja.Expression)
    indirect case statement(Jinja.Statement)
    indirect case comment(Swift.String)
}
enum Expression {
    enum UnaryOp {
        case not
        case minus
        case plus
        case splat
    }
    enum BinaryOp {
        case add
        case subtract
        case multiply
        case divide
        case floorDivide
        case power
        case modulo
        case concat
        case equal
        case notEqual
        case less
        case lessEqual
        case greater
        case greaterEqual
        case and
        case or
        case in
        case notIn
    }
    enum CodingKeys {
        case string
        case number
        case integer
        case boolean
        case null
        case array
        case tuple
        case object
        case identifier
        case unary
        case binary
        case ternary
        case call
        case member
        case slice
        case filter
        case test
    }
    enum StringCodingKeys {
        case _0
    }
    enum NumberCodingKeys {
        case _0
    }
    enum IntegerCodingKeys {
        case _0
    }
    enum BooleanCodingKeys {
        case _0
    }
    enum NullCodingKeys {}
    enum ArrayCodingKeys {
        case _0
    }
    enum TupleCodingKeys {
        case _0
    }
    enum ObjectCodingKeys {
        case _0
    }
    enum IdentifierCodingKeys {
        case _0
    }
    enum UnaryCodingKeys {
        case _0
        case _1
    }
    enum BinaryCodingKeys {
        case _0
        case _1
        case _2
    }
    enum TernaryCodingKeys {
        case _0
        case test
        case alternate
    }
    enum CallCodingKeys {
        case _0
        case _1
        case _2
    }
    enum MemberCodingKeys {
        case _0
        case _1
        case computed
    }
    enum SliceCodingKeys {
        case _0
        case start
        case stop
        case step
    }
    enum FilterCodingKeys {
        case _0
        case _1
        case _2
        case _3
    }
    enum TestCodingKeys {
        case _0
        case _1
        case _2
        case negated
    }
    indirect case string(Swift.String)
    indirect case number(Swift.Double)
    indirect case integer(Swift.Int)
    indirect case boolean(Swift.Bool)
    indirect case array([Jinja.Expression])
    indirect case tuple([Jinja.Expression])
    indirect case object(OrderedCollections.OrderedDictionary<Swift.String, Jinja.Expression>)
    indirect case identifier(Swift.String)
    indirect case unary(Jinja.Expression.UnaryOp, Jinja.Expression)
    indirect case binary(Jinja.Expression.BinaryOp, Jinja.Expression, Jinja.Expression)
    indirect case ternary(Jinja.Expression, test: Jinja.Expression, alternate: Jinja.Expression?)
    indirect case call(Jinja.Expression, [Jinja.Expression], [Swift.String : Jinja.Expression])
    indirect case member(Jinja.Expression, Jinja.Expression, computed: Swift.Bool)
    indirect case slice(Jinja.Expression, start: Jinja.Expression?, stop: Jinja.Expression?, step: Jinja.Expression?)
    indirect case filter(Jinja.Expression, Swift.String, [Jinja.Expression], [Swift.String : Jinja.Expression])
    indirect case test(Jinja.Expression, Swift.String, [Jinja.Expression], negated: Swift.Bool)
    case null
}
enum Statement {
    enum LoopVar {
        enum CodingKeys {
            case single
            case tuple
        }
        enum SingleCodingKeys {
            case _0
        }
        enum TupleCodingKeys {
            case _0
        }
        case single(Swift.String)
        case tuple([Swift.String])
    }
    enum CodingKeys {
        case program
        case set
        case if
        case for
        case macro
        case break
        case continue
        case call
        case filter
    }
    enum ProgramCodingKeys {
        case _0
    }
    enum SetCodingKeys {
        case target
        case value
        case body
    }
    enum IfCodingKeys {
        case _0
        case _1
        case _2
    }
    enum ForCodingKeys {
        case _0
        case _1
        case _2
        case _3
        case test
    }
    enum MacroCodingKeys {
        case _0
        case _1
        case _2
        case _3
    }
    enum BreakCodingKeys {}
    enum ContinueCodingKeys {}
    enum CallCodingKeys {
        case callable
        case callerArgs
        case body
    }
    enum FilterCodingKeys {
        case filterExpr
        case body
    }
    case program([Jinja.Node])
    case set(target: Jinja.Expression, value: Jinja.Expression?, body: [Jinja.Node])
    case if(Jinja.Expression, [Jinja.Node], [Jinja.Node])
    case for(Jinja.Statement.LoopVar, Jinja.Expression, [Jinja.Node], [Jinja.Node], test: Jinja.Expression?)
    case macro(Swift.String, [Swift.String], OrderedCollections.OrderedDictionary<Swift.String, Jinja.Expression>, [Jinja.Node])
    case call(callable: Jinja.Expression, callerArgs: [Jinja.Expression]?, body: [Jinja.Node])
    case filter(filterExpr: Jinja.Expression, body: [Jinja.Node])
    case break
    case continue
}
enum JinjaError {
    case lexer(Swift.String)
    case parser(Swift.String)
    case runtime(Swift.String)
    case syntax(Swift.String)
}
enum Filters {}
struct TemplateException {
    var message: Swift.String?
}
enum Globals {
    class Cycler {
        let items: [Jinja.Value]
        let lock: __C.NSLock
        var currentIndex: Swift.Int
    }
    class Joiner {
        let separator: Swift.String
        let lock: __C.NSLock
        var first: Swift.Bool
    }
}
class Environment {
    let parent: Jinja.Environment?
    var variables: [Swift.String : Jinja.Value]
    var lstripBlocks: Swift.Bool
    var trimBlocks: Swift.Bool
}
enum Interpreter {}
enum ControlFlow {
    case break
    case continue
}
enum Lexer {}
struct Macro {
    enum CodingKeys {
        case name
        case parameters
        case defaults
        case body
    }
    let name: Swift.String
    let parameters: [Swift.String]
    let defaults: OrderedCollections.OrderedDictionary<Swift.String, Jinja.Expression>
    let body: [Jinja.Node]
}
struct Parser {
    let tokens: [Jinja.Token]
    var current: Swift.Int
}
enum PropertyMembers {}
struct Template {
    struct Options {
        var lstripBlocks: Swift.Bool
        var trimBlocks: Swift.Bool
    }
    let nodes: [Jinja.Node]
}
enum Tests {}
struct Token {
    enum Kind {
        enum CodingKeys {
            case text
            case openExpression
            case closeExpression
            case openStatement
            case closeStatement
            case string
            case number
            case boolean
            case null
            case identifier
            case openParen
            case closeParen
            case openBracket
            case closeBracket
            case openBrace
            case closeBrace
            case comma
            case dot
            case colon
            case pipe
            case equals
            case plus
            case minus
            case multiply
            case divide
            case floorDivide
            case power
            case modulo
            case concat
            case equal
            case notEqual
            case less
            case lessEqual
            case greater
            case greaterEqual
            case and
            case or
            case not
            case in
            case notIn
            case is
            case if
            case else
            case elif
            case endif
            case for
            case endfor
            case set
            case endset
            case macro
            case endmacro
            case break
            case continue
            case call
            case endcall
            case filter
            case endfilter
            case comment
            case eof
        }
        enum TextCodingKeys {}
        enum OpenExpressionCodingKeys {}
        enum CloseExpressionCodingKeys {}
        enum OpenStatementCodingKeys {}
        enum CloseStatementCodingKeys {}
        enum StringCodingKeys {}
        enum NumberCodingKeys {}
        enum BooleanCodingKeys {}
        enum NullCodingKeys {}
        enum IdentifierCodingKeys {}
        enum OpenParenCodingKeys {}
        enum CloseParenCodingKeys {}
        enum OpenBracketCodingKeys {}
        enum CloseBracketCodingKeys {}
        enum OpenBraceCodingKeys {}
        enum CloseBraceCodingKeys {}
        enum CommaCodingKeys {}
        enum DotCodingKeys {}
        enum ColonCodingKeys {}
        enum PipeCodingKeys {}
        enum EqualsCodingKeys {}
        enum PlusCodingKeys {}
        enum MinusCodingKeys {}
        enum MultiplyCodingKeys {}
        enum DivideCodingKeys {}
        enum FloorDivideCodingKeys {}
        enum PowerCodingKeys {}
        enum ModuloCodingKeys {}
        enum ConcatCodingKeys {}
        enum EqualCodingKeys {}
        enum NotEqualCodingKeys {}
        enum LessCodingKeys {}
        enum LessEqualCodingKeys {}
        enum GreaterCodingKeys {}
        enum GreaterEqualCodingKeys {}
        enum AndCodingKeys {}
        enum OrCodingKeys {}
        enum NotCodingKeys {}
        enum InCodingKeys {}
        enum NotInCodingKeys {}
        enum IsCodingKeys {}
        enum IfCodingKeys {}
        enum ElseCodingKeys {}
        enum ElifCodingKeys {}
        enum EndifCodingKeys {}
        enum ForCodingKeys {}
        enum EndforCodingKeys {}
        enum SetCodingKeys {}
        enum EndsetCodingKeys {}
        enum MacroCodingKeys {}
        enum EndmacroCodingKeys {}
        enum BreakCodingKeys {}
        enum ContinueCodingKeys {}
        enum CallCodingKeys {}
        enum EndcallCodingKeys {}
        enum FilterCodingKeys {}
        enum EndfilterCodingKeys {}
        enum CommentCodingKeys {}
        enum EofCodingKeys {}
        case text
        case openExpression
        case closeExpression
        case openStatement
        case closeStatement
        case string
        case number
        case boolean
        case null
        case identifier
        case openParen
        case closeParen
        case openBracket
        case closeBracket
        case openBrace
        case closeBrace
        case comma
        case dot
        case colon
        case pipe
        case equals
        case plus
        case minus
        case multiply
        case divide
        case floorDivide
        case power
        case modulo
        case concat
        case equal
        case notEqual
        case less
        case lessEqual
        case greater
        case greaterEqual
        case and
        case or
        case not
        case in
        case notIn
        case is
        case if
        case else
        case elif
        case endif
        case for
        case endfor
        case set
        case endset
        case macro
        case endmacro
        case break
        case continue
        case call
        case endcall
        case filter
        case endfilter
        case comment
        case eof
    }
    enum CodingKeys {
        case kind
        case value
        case position
    }
    let kind: Jinja.Token.Kind
    let value: Swift.Substring
    let position: Swift.Int
}
enum Value {
    case boolean(Swift.Bool)
    case int(Swift.Int)
    case double(Swift.Double)
    case string(Swift.String)
    case array([Jinja.Value])
    case object(OrderedCollections.OrderedDictionary<Swift.String, Jinja.Value>)
    case function(@Sendable ([Jinja.Value], [Swift.String : Jinja.Value], Jinja.Environment) throws -> Jinja.Value)
    case macro(Jinja.Macro)
    case null
    case undefined
}
struct _HashTable {
    struct Bucket {
        var offset: Swift.Int
    }
    struct BucketIterator {
        let _hashTable: OrderedCollections._HashTable.UnsafeHandle
        var _currentBucket: OrderedCollections._HashTable.Bucket
        var _currentRawValue: Swift.UInt64
        var _nextBits: Swift.UInt64
        var _remainingBitCount: Swift.Int
        var _wrappedAround: Swift.Bool
    }
    struct UnsafeHandle {
        var _header: Swift.UnsafeMutablePointer<OrderedCollections._HashTable.Header>
        var _buckets: Swift.UnsafeMutablePointer<Swift.UInt64>
    }
    class Storage: Swift.ManagedBuffer<OrderedCollections._HashTable.Header, Swift.UInt64> {}
    struct Header {
        var _scaleAndSeed: Swift.UInt64
        var _reservedScaleAndBias: Swift.UInt64
    }
    var _storage: OrderedCollections._HashTable.Storage
}
struct OrderedDictionary<A, B> where A: Swift.Hashable {
    struct Elements {
        struct SubSequence {
            struct Iterator {
                var _base: OrderedCollections.OrderedDictionary<A, B>
                var _end: Swift.Int
                var _index: Swift.Int
            }
            var _base: OrderedCollections.OrderedDictionary<A, B>
            var _bounds: Swift.Range<Swift.Int>
        }
        var _base: OrderedCollections.OrderedDictionary<A, B>
    }
    struct Iterator {
        let _base: OrderedCollections.OrderedDictionary<A, B>
        var _position: Swift.Int
    }
    struct Values {
        var _base: OrderedCollections.OrderedDictionary<A, B>
    }
    var _keys: OrderedCollections.OrderedSet<A>
    var _values: Swift.ContiguousArray<B>
}
struct OrderedSet<A> where A: Swift.Hashable {
    struct SubSequence {
        var _base: OrderedCollections.OrderedSet<A>
        var _bounds: Swift.Range<Swift.Int>
    }
    struct UnorderedView {
        var _base: OrderedCollections.OrderedSet<A>
    }
    struct _UnstableInternals {
        var base: OrderedCollections.OrderedSet<A>
    }
    var __storage: OrderedCollections._HashTable.Storage?
    var _elements: Swift.ContiguousArray<A>
}
struct _UnsafeBitSet {
    struct Index {
        var value: Swift.UInt
    }
    struct _Word {
        var value: Swift.UInt
    }
    struct Iterator {
        let _bitset: InternalCollectionsUtilities._UnsafeBitSet
        var _index: Swift.Int
        var _word: InternalCollectionsUtilities._UnsafeBitSet._Word
    }
    let _words: Swift.UnsafeBufferPointer<InternalCollectionsUtilities._UnsafeBitSet._Word>
}
struct AnyLLMClient {
    let _generateText: @Sendable (_: LocalLLMClientCore.LLMInput) async throws -> Swift.String
    let _textStream: @Sendable (_: LocalLLMClientCore.LLMInput) async throws -> Swift.AsyncThrowingStream<Swift.String, Swift.Error>
    let _generateToolCalls: @Sendable (_: LocalLLMClientCore.LLMInput) async throws -> LocalLLMClientCore.GeneratedContent
    let _resume: @Sendable ([LocalLLMClientCore.LLMToolCall], [(Swift.String, Swift.String)], LocalLLMClientCore.LLMInput) async throws -> Swift.String
    let _resumeStream: @Sendable ([LocalLLMClientCore.LLMToolCall], [(Swift.String, Swift.String)], LocalLLMClientCore.LLMInput) async throws -> Swift.AsyncThrowingStream<LocalLLMClientCore.StreamingChunk, Swift.Error>
    let _responseStream: @Sendable (_: LocalLLMClientCore.LLMInput) async throws -> Swift.AsyncThrowingStream<LocalLLMClientCore.StreamingChunk, Swift.Error>
    let _pauseGeneration: @Sendable () async -> ()
    let _resumeGeneration: @Sendable () async -> ()
    let _isGenerationPaused: @Sendable () async -> Swift.Bool
}
enum LocalLLMClient {}
enum LLMError {
    case failedToLoad(reason: Swift.String)
    case invalidParameter(reason: Swift.String)
    case failedToDecode(reason: Swift.String)
    case unsupportedOperation(reason: Swift.String)
    case visionUnsupported
}
struct LLMInput {
    enum Input {
        case plain(Swift.String)
        case chatTemplate([LocalLLMClientCore.LLMInput.ChatTemplateMessage])
        case chat([LocalLLMClientCore.LLMInput.Message])
    }
    struct ChatTemplateMessage {
        var value: [Swift.String : Any]
        var attachments: [LocalLLMClientCore.LLMAttachment]
    }
    struct Message {
        enum Role {
            case custom(Swift.String)
            case system
            case user
            case assistant
            case tool
        }
        var id: Foundation.UUID
        var role: LocalLLMClientCore.LLMInput.Message.Role
        var content: Swift.String
        var attachments: [LocalLLMClientCore.LLMAttachment]
        var metadata: [Swift.String : Swift.String]
    }
    var value: LocalLLMClientCore.LLMInput.Input
}
struct LLMAttachment {
    enum Content {
        case image(__C.NSImage)
    }
    let id: Foundation.UUID
    var content: LocalLLMClientCore.LLMAttachment.Content
}
class LLMSession {
    class Generator {
        let model: LocalLLMClientCore.LLMSession.Model
        let tools: [LocalLLMClientCore.AnyLLMTool]
        let client: 
        let _messages: 
        let _$observationRegistrar: Observation.ObservationRegistrar
    }
    struct ToolCallError {
        let tool: LocalLLMClientCore.LLMTool
        let underlyingError: Swift.Error
    }
    struct SystemModel {
        let prewarm: @Sendable () async throws -> ()
        let makeClient: @Sendable (_: [LocalLLMClientCore.AnyLLMTool]) async throws -> LocalLLMClientCore.AnyLLMClient
    }
    struct DownloadModel {
        let source: LocalLLMClientUtility.FileDownloader.Source
        let downloader: LocalLLMClientUtility.FileDownloader
        let makeClient: @Sendable (_: [LocalLLMClientCore.AnyLLMTool]) async throws -> LocalLLMClientCore.AnyLLMClient
    }
    struct LocalModel {
        let makeClient: @Sendable (_: [LocalLLMClientCore.AnyLLMTool]) async throws -> LocalLLMClientCore.AnyLLMClient
        let modelPath: Foundation.URL
    }
    protocol Model {
        // Kind: Getter, isAsync: false, isInstance: true
        // Kind: Method, isAsync: true, isInstance: true
    }
    let generator: LocalLLMClientCore.LLMSession.Generator
    let _$observationRegistrar: Observation.ObservationRegistrar
}
actor PauseHandler {
    var $defaultActor: 
    var isPaused: Swift.Bool
    var pauseContinuations: [Swift.CheckedContinuation<(), Swift.Never>]
}
enum ToolError {
    case invalidArgumentEncoding(toolName: Swift.String, encoding: Encoding)
    case argumentDecodingFailed(toolName: Swift.String, underlyingError: Swift.Error)
    case executionFailed(toolName: Swift.String, underlyingError: Swift.Error)
}
struct AnyLLMTool {
    let _name: Swift.String
    let _description: Swift.String
    let _argumentsSchema: [Swift.String : Any]
    let _call: @Sendable (_: Swift.String) async throws -> LocalLLMClientCore.ToolOutput
    let _tool: LocalLLMClientCore.LLMTool
}
struct GeneratedContent {
    let text: Swift.String
    let toolCalls: [LocalLLMClientCore.LLMToolCall]
}
struct LLMToolCall {
    let id: Swift.String
    let name: Swift.String
    let arguments: Swift.String
}
enum StreamingChunk {
    case text(Swift.String)
    case toolCall(LocalLLMClientCore.LLMToolCall)
}
class StreamingToolCallProcessor {
    struct ProcessorState {
        var state: LocalLLMClientCore.StreamingToolCallProcessor.State
        var buffer: Swift.String
        var toolCalls: [LocalLLMClientCore.LLMToolCall]
    }
    enum State {
        case normal
        case potentialToolCall
        case collectingToolCall
    }
    let processorState: 
    let startTag: Swift.String
    let endTag: Swift.String
}
struct ToolArgument<A> where A: LocalLLMClientCore.ToolArgumentType {
    let description: Swift.String
    let enum: [Any]?
    let format: Swift.String?
}
actor ToolExecutor {
    var $defaultActor: 
    let tools: [LocalLLMClientCore.AnyLLMTool]
    let toolLookup: [Swift.String : LocalLLMClientCore.AnyLLMTool]
    let maxConcurrency: Swift.Int
}
enum ToolExecutionError {
    case multipleFailed(errors: [Swift.Error])
}
struct ToolOutput {
    let data: [Swift.String : Any]
}
enum LLMToolArgumentType {
    struct ArrayWithFormatToolArgument {
        let elementType: Swift.String
        let elementDescription: Swift.String
        let format: Swift.String
        let description: Swift.String
    }
    struct NestedArrayToolArgument {
        let nestedElementType: LocalLLMClientCore.LLMToolArgumentType
        let description: Swift.String
    }
    struct ArrayOfObjectsToolArgument {
        let objectType: LocalLLMClientCore.ToolArgumentObject.Type
        let description: Swift.String
    }
    struct ArrayOfEnumsToolArgument {
        let values: [Any]
        let elementDescription: Swift.String
        let description: Swift.String
    }
    struct ArrayOfOptionalsToolArgument {
        let wrappedType: LocalLLMClientCore.LLMToolArgumentType
        let description: Swift.String
    }
    struct ObjectToolArgument {
        let objectType: LocalLLMClientCore.ToolArgumentObject.Type
        let description: Swift.String
    }
    struct OptionalToolArgument {
        let wrapped: LocalLLMClientCore.ToolArgumentConvertible
    }
    indirect case string(description: Swift.String, format: Swift.String?)
    indirect case integer(description: Swift.String)
    indirect case number(description: Swift.String)
    indirect case boolean(description: Swift.String)
    indirect case array(of: LocalLLMClientCore.LLMToolArgumentType, description: Swift.String)
    indirect case object(LocalLLMClientCore.ToolArgumentObject.Type, description: Swift.String)
    indirect case enum(values: [Any], description: Swift.String)
    indirect case optional(LocalLLMClientCore.LLMToolArgumentType)
}
struct MaxRadiusNDTreeDelegate<A> where A: ForceSimulation.SimulatableVector {
    var radiusBufferPointer: Swift.UnsafeMutablePointer<A.SIMDStorage.Scalar>
    var maxNodeRadius: A.SIMDStorage.Scalar
}
struct CompositedForce<A, B, C> where A == B.ForceProtocol.Vector, B: ForceSimulation.ForceProtocol, C: ForceSimulation.ForceProtocol, B.ForceProtocol.Vector == C.ForceProtocol.Vector {
    var force1: B?
    var force2: C
}
struct ForceBuilder<A> where A: ForceSimulation.L2NormCalculatable, A: ForceSimulation.SimulatableVector {}
struct LinkLookup<A> where A: Swift.Hashable {
    let sourceToTarget: [A : [A]]
    let targetToSource: [A : [A]]
    let count: [A : Swift.Int]
}
struct MassCentroidKDTreeDelegate<A> where A: ForceSimulation.SimulatableVector {
    var accumulatedMass: A.SIMDStorage.Scalar
    var accumulatedCount: Swift.Int
    var accumulatedMassWeightedPositions: A
    let massArray: Swift.UnsafeMutablePointer<A.SIMDStorage.Scalar>
}
struct SealedForce2D {
    enum ForceEntry {
        case center(ForceSimulation.Kinetics<Swift.SIMD2<Swift.Double>>.CenterForce)
        case radial(ForceSimulation.Kinetics<Swift.SIMD2<Swift.Double>>.RadialForce)
        case manyBody(ForceSimulation.Kinetics<Swift.SIMD2<Swift.Double>>.ManyBodyForce)
        case link(ForceSimulation.Kinetics<Swift.SIMD2<Swift.Double>>.LinkForce)
        case collide(ForceSimulation.Kinetics<Swift.SIMD2<Swift.Double>>.CollideForce)
        case position(ForceSimulation.Kinetics<Swift.SIMD2<Swift.Double>>.PositionForce)
        case empty
    }
    var entries: [ForceSimulation.SealedForce2D.ForceEntry]
}
struct SealedForce2DBuilder {}
struct SealedForce3D {
    enum ForceEntry {
        case center(ForceSimulation.Kinetics<Swift.SIMD3<Swift.Float>>.CenterForce)
        case radial(ForceSimulation.Kinetics<Swift.SIMD3<Swift.Float>>.RadialForce)
        case manyBody(ForceSimulation.Kinetics<Swift.SIMD3<Swift.Float>>.ManyBodyForce)
        case link(ForceSimulation.Kinetics<Swift.SIMD3<Swift.Float>>.LinkForce)
        case collide(ForceSimulation.Kinetics<Swift.SIMD3<Swift.Float>>.CollideForce)
        case position(ForceSimulation.Kinetics<Swift.SIMD3<Swift.Float>>.PositionForce)
        case empty
    }
    var entries: [ForceSimulation.SealedForce3D.ForceEntry]
}
struct SealedForce3DBuilder {}
struct BufferedKDTree<A, B> where A: ForceSimulation.L2NormCalculatable, A: ForceSimulation.SimulatableVector, A == B.KDTreeDelegate.Vector, B: ForceSimulation.KDTreeDelegate, B.KDTreeDelegate.NodeID == Swift.Int {
    var validCount: Swift.Int
    var treeNodeBuffer: ForceSimulation.UnsafeArray<ForceSimulation.KDTreeNode<A, B>>
    var rootDelegate: B
}
struct KDBox<A> where A: Swift.SIMD, A.SIMDStorage.Scalar: Swift.ExpressibleByFloatLiteral, A.SIMDStorage.Scalar: Swift.FloatingPoint {
    var p0: A
    var p1: A
}
struct KDTree<A, B> where A: ForceSimulation.L2NormCalculatable, A: ForceSimulation.SimulatableVector, A == B.KDTreeDelegate.Vector, B: ForceSimulation.KDTreeDelegate, B.KDTreeDelegate.NodeID == Swift.Int {
    var box: ForceSimulation.KDBox<A>
    var children: [ForceSimulation.KDTree<A, B>]?
    var nodePosition: A?
    var nodeIndices: [Swift.Int]
    var delegate: B
}
struct KDTreeNode<A, B> where A: ForceSimulation.L2NormCalculatable, A: ForceSimulation.SimulatableVector, A == B.KDTreeDelegate.Vector, B: ForceSimulation.KDTreeDelegate, B.KDTreeDelegate.NodeID == Swift.Int {
    struct NodeIndex {
        var index: Swift.Int
        var next: Swift.UnsafeMutablePointer<ForceSimulation.KDTreeNode<A, B>.NodeIndex>?
    }
    var box: ForceSimulation.KDBox<A>
    var nodePosition: A
    var childrenBufferPointer: Swift.UnsafeMutablePointer<ForceSimulation.KDTreeNode<A, B>>?
    var nodeIndices: ForceSimulation.KDTreeNode<A, B>.NodeIndex?
    var delegate: B
}
struct Kinetics<A> where A: ForceSimulation.L2NormCalculatable, A: ForceSimulation.SimulatableVector {
    struct CenterForce {
        var center: A
        var strength: A.SIMDStorage.Scalar
    }
    struct CollideForce {
        var radius: ForceSimulation.AttributeDescriptor<A.SIMDStorage.Scalar>
        let iterationsPerTick: Swift.UInt
        var strength: A.SIMDStorage.Scalar
        var calculatedRadius: ForceSimulation.UnsafeArray<A.SIMDStorage.Scalar>?
        var tree: Swift.UnsafeMutablePointer<ForceSimulation.BufferedKDTree<A, ForceSimulation.MaxRadiusNDTreeDelegate<A>>>?
    }
    struct EmptyForce {}
    enum LinkStiffness {
        case constant(A.SIMDStorage.Scalar)
        case varied((ForceSimulation.EdgeID<Swift.Int>, ForceSimulation.LinkLookup<Swift.Int>) -> A.SIMDStorage.Scalar)
        case weightedByDegree(k: (ForceSimulation.EdgeID<Swift.Int>, ForceSimulation.LinkLookup<Swift.Int>) -> A.SIMDStorage.Scalar)
    }
    enum LinkLength {
        case constant(A.SIMDStorage.Scalar)
        case varied((ForceSimulation.EdgeID<Swift.Int>, ForceSimulation.LinkLookup<Swift.Int>) -> A.SIMDStorage.Scalar)
    }
    struct LinkForce {
        var linkStiffness: ForceSimulation.Kinetics<A>.LinkStiffness
        var calculatedStiffness: [A.SIMDStorage.Scalar]
        var linkLength: ForceSimulation.Kinetics<A>.LinkLength
        var calculatedLength: [A.SIMDStorage.Scalar]
        var calculatedBias: [A.SIMDStorage.Scalar]
        var links: [ForceSimulation.EdgeID<Swift.Int>]?
        var linkLookup: ForceSimulation.LinkLookup<Swift.Int>
        var iterationsPerTick: Swift.UInt
    }
    struct ManyBodyForce {
        let strength: A.SIMDStorage.Scalar
        var theta2: A.SIMDStorage.Scalar
        var theta: A.SIMDStorage.Scalar
        let distanceMin: A.SIMDStorage.Scalar
        let distanceMin2: A.SIMDStorage.Scalar
        let distanceMax2: A.SIMDStorage.Scalar
        let distanceMax: A.SIMDStorage.Scalar
        let mass: ForceSimulation.AttributeDescriptor<A.SIMDStorage.Scalar>
        var precalculatedMass: ForceSimulation.UnsafeArray<A.SIMDStorage.Scalar>?
        var tree: Swift.UnsafeMutablePointer<ForceSimulation.BufferedKDTree<A, ForceSimulation.MassCentroidKDTreeDelegate<A>>>?
    }
    enum DirectionOfPositionForce {
        case entryOfVector(Swift.Int)
        case x
        case y
        case z
    }
    struct PositionForce {
        var strength: ForceSimulation.AttributeDescriptor<A.SIMDStorage.Scalar>
        var direction: Swift.Int
        var calculatedStrength: ForceSimulation.UnsafeArray<A.SIMDStorage.Scalar>?
        var targetOnDirection: ForceSimulation.AttributeDescriptor<A.SIMDStorage.Scalar>
        var calculatedTargetOnDirection: ForceSimulation.UnsafeArray<A.SIMDStorage.Scalar>?
    }
    struct RadialForce {
        var radius: ForceSimulation.AttributeDescriptor<A.SIMDStorage.Scalar>
        var strength: ForceSimulation.AttributeDescriptor<A.SIMDStorage.Scalar>
        var center: A
        var calculatedRadius: ForceSimulation.UnsafeArray<A.SIMDStorage.Scalar>?
        var calculatedStrength: ForceSimulation.UnsafeArray<A.SIMDStorage.Scalar>?
    }
    var position: ForceSimulation.UnsafeArray<A>
    var velocity: ForceSimulation.UnsafeArray<A>
    var fixation: ForceSimulation.UnsafeArray<A?>
    var validCount: Swift.Int
    var alpha: A.SIMDStorage.Scalar
    let alphaMin: A.SIMDStorage.Scalar
    let alphaDecay: A.SIMDStorage.Scalar
    let alphaTarget: A.SIMDStorage.Scalar
    let velocityDecay: A.SIMDStorage.Scalar
    var randomGenerator: A.SIMDStorage.Scalar.HasDeterministicRandomGenerator.Generator
    let links: [ForceSimulation.EdgeID<Swift.Int>]
}
enum Ticks<A> where A: Swift.FloatingPoint {
    case untilReachingAlpha(A?)
    case iteration(Swift.Int)
}
class Simulation<A, B> where A == B.ForceProtocol.Vector, B: ForceSimulation.ForceProtocol {
    var forceField: B
    var kinetics: ForceSimulation.Kinetics<A>
}
enum AttributeDescriptor<A> {
    case varied((_: Swift.Int) -> A)
    case constant(A)
}
struct EdgeID<A> where A: Swift.Hashable {
    var source: A
    var target: A
}
struct DoubleLinearCongruentialGenerator {
    var s: Swift.UInt32
}
struct FloatLinearCongruentialGenerator {
    var s: Swift.UInt16
}
class UnsafeArray<A>: Swift.ManagedBuffer<Swift.Int, A> {}
struct BM25Index {
    let k1: Swift.Float
    let b: Swift.Float
    var documents: [VecturaKit.VecturaDocument]
    var documentFrequencies: [Swift.String : Swift.Int]
    var documentLengths: [Foundation.UUID : Swift.Int]
    var averageDocumentLength: Swift.Float
}
class FileStorageProvider {
    let storageDirectory: Foundation.URL
    var documents: [Foundation.UUID : VecturaKit.VecturaDocument]
    var normalizedEmbeddings: [Foundation.UUID : [Swift.Float]]
}
struct VecturaConfig {
    struct SearchOptions {
        var defaultNumResults: Swift.Int
        var minThreshold: Swift.Float?
        var hybridWeight: Swift.Float
        var k1: Swift.Float
        var b: Swift.Float
    }
    let name: Swift.String
    let directoryURL: Foundation.URL?
    let dimension: Swift.Int?
    var searchOptions: VecturaKit.VecturaConfig.SearchOptions
}
struct VecturaDocument {
    enum CodingKeys {
        case id
        case text
        case embedding
        case createdAt
    }
    let id: Foundation.UUID
    let text: Swift.String
    let embedding: [Swift.Float]
    let createdAt: Foundation.Date
}
enum VecturaError {
    case collectionAlreadyExists(Swift.String)
    case collectionNotFound(Swift.String)
    case dimensionMismatch(expected: Swift.Int, got: Swift.Int)
    case loadFailed(Swift.String)
    case invalidInput(Swift.String)
}
class VecturaKit {
    let config: VecturaKit.VecturaConfig
    var actualDimension: Swift.Int?
    var documents: [Foundation.UUID : VecturaKit.VecturaDocument]
    let storageDirectory: Foundation.URL
    let storageProvider: VecturaKit.VecturaStorage
    var normalizedEmbeddings: [Foundation.UUID : [Swift.Float]]
    var bm25Index: VecturaKit.BM25Index?
    var bertModel: Embeddings.Bert.ModelBundle?
    var model2vecModel: Embeddings.Model2Vec.ModelBundle?
}
enum VecturaModelSource {
    case id(Swift.String)
    case folder(Foundation.URL)
}
struct VecturaSearchResult {
    let id: Foundation.UUID
    let text: Swift.String
    let score: Swift.Float
    let createdAt: Foundation.Date
}
enum Bert {
    struct ModelConfig {
        enum CodingKeys {
            case modelType
            case numHiddenLayers
            case numAttentionHeads
            case hiddenSize
            case intermediateSize
            case maxPositionEmbeddings
            case hiddenDropoutProb
            case attentionProbsDropoutProb
            case typeVocabSize
            case initializerRange
            case layerNormEps
            case vocabSize
        }
        var modelType: Swift.String
        var numHiddenLayers: Swift.Int
        var numAttentionHeads: Swift.Int
        var hiddenSize: Swift.Int
        var intermediateSize: Swift.Int
        var maxPositionEmbeddings: Swift.Int
        var hiddenDropoutProb: Swift.Float
        var attentionProbsDropoutProb: Swift.Float
        var typeVocabSize: Swift.Int
        var initializerRange: Swift.Float
        var layerNormEps: Swift.Float
        var vocabSize: Swift.Int
    }
    struct Pooler {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct Embeddings {
        let wordEmbeddings: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let positionEmbeddings: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let tokenTypeEmbeddings: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let layerNorm: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct Output {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let layerNorm: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct Intermediate {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct SelfOutput {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let layerNorm: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct SelfAttention {
        let query: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let key: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let value: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let numAttentionHeads: Swift.Int
        let attentionHeadSize: Swift.Int
        let allHeadSize: Swift.Int
    }
    struct Attention {
        let selfAttention: Embeddings.Bert.SelfAttention
        let output: Embeddings.Bert.SelfOutput
    }
    struct Layer {
        let attention: Embeddings.Bert.Attention
        let intermediate: Embeddings.Bert.Intermediate
        let output: Embeddings.Bert.Output
    }
    struct Encoder {
        let layers: [Embeddings.Bert.Layer]
    }
    struct Model {
        let embeddings: Embeddings.Bert.Embeddings
        let encoder: Embeddings.Bert.Encoder
        let pooler: Embeddings.Bert.Pooler
    }
    struct ModelBundle {
        let model: Embeddings.Bert.Model
        let tokenizer: Embeddings.TextTokenizer
    }
}
enum Clip {
    struct TextConfig {
        enum CodingKeys {
            case numHiddenLayers
            case hiddenSize
            case intermediateSize
            case numAttentionHeads
            case layerNormEps
            case maxPositionEmbeddings
            case vocabSize
        }
        var numHiddenLayers: Swift.Int
        var hiddenSize: Swift.Int
        var intermediateSize: Swift.Int
        var numAttentionHeads: Swift.Int
        var layerNormEps: Swift.Float
        var maxPositionEmbeddings: Swift.Int
        var vocabSize: Swift.Int
    }
    struct VisionConfig {
        enum CodingKeys {
            case numHiddenLayers
            case hiddenSize
            case intermediateSize
            case numAttentionHeads
            case layerNormEps
            case numChannels
            case imageSize
            case patchSize
        }
        var numHiddenLayers: Swift.Int
        var hiddenSize: Swift.Int
        var intermediateSize: Swift.Int
        var numAttentionHeads: Swift.Int
        var layerNormEps: Swift.Float
        var numChannels: Swift.Int?
        var imageSize: Swift.Int
        var patchSize: Swift.Int
    }
    struct ModelConfig {
        enum CodingKeys {
            case textConfig
            case visionConfig
            case projectionDim
        }
        var textConfig: Embeddings.Clip.TextConfig
        var visionConfig: Embeddings.Clip.VisionConfig
        var projectionDim: Swift.Int
    }
    struct Embeddings {
        let tokenEmbedding: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let positionEmbeddingWeight: CoreML.MLTensor
    }
    struct MLP {
        let fc1: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let fc2: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct Attention {
        let qProj: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let kProj: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let vProj: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let outProj: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let numHeads: Swift.Int
    }
    struct EncoderLayer {
        let selfAttnention: Embeddings.Clip.Attention
        let mlp: Embeddings.Clip.MLP
        let layerNorm1: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let layerNorm2: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct Encoder {
        let layers: [Embeddings.Clip.EncoderLayer]
    }
    struct TextModel {
        let embeddings: Embeddings.Clip.Embeddings
        let encoder: Embeddings.Clip.Encoder
        let finalLayerNorm: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let textProjection: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct ModelBundle {
        let textModel: Embeddings.Clip.TextModel
        let tokenizer: Embeddings.TextTokenizer
    }
}
enum TokenizerConfigType {
    case filePath(Swift.String)
    case data([Swift.String : Any])
}
struct TokenizerConfig {
    let data: Embeddings.TokenizerConfigType
    let config: Embeddings.TokenizerConfigType
}
struct ModelConfig {
    let configFileName: Swift.String
    let weightsFileName: Swift.String
    let weightKeyTransform: (_: Swift.String) -> Swift.String
}
struct LoadConfig {
    let modelConfig: Embeddings.ModelConfig
    let tokenizerConfig: Embeddings.TokenizerConfig?
}
enum EmbeddingsError {
    case fileNotFound
    case invalidFile
}
enum Model2Vec {
    struct ModelConfig {
        enum CodingKeys {
            case normalize
        }
        var normalize: Swift.Bool?
    }
    struct ModelBundle {
        let model: Embeddings.Model2Vec.Model
        let tokenizer: Embeddings.TextTokenizer
    }
    struct Model {
        let embeddings: CoreML.MLTensor
        let dimienstion: Swift.Int
        let normalize: Swift.Bool
    }
}
enum Roberta {
    struct ModelConfig {
        enum CodingKeys {
            case modelType
            case numHiddenLayers
            case numAttentionHeads
            case hiddenSize
            case intermediateSize
            case maxPositionEmbeddings
            case hiddenDropoutProb
            case attentionProbsDropoutProb
            case typeVocabSize
            case initializerRange
            case layerNormEps
            case vocabSize
            case padTokenId
        }
        var modelType: Swift.String
        var numHiddenLayers: Swift.Int
        var numAttentionHeads: Swift.Int
        var hiddenSize: Swift.Int
        var intermediateSize: Swift.Int
        var maxPositionEmbeddings: Swift.Int
        var hiddenDropoutProb: Swift.Float
        var attentionProbsDropoutProb: Swift.Float
        var typeVocabSize: Swift.Int
        var initializerRange: Swift.Float
        var layerNormEps: Swift.Float
        var vocabSize: Swift.Int
        var padTokenId: Swift.Int
    }
    struct Embeddings {
        let wordEmbeddings: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let positionEmbeddings: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let tokenTypeEmbeddings: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let layerNorm: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let paddingIdx: Swift.Int32
    }
    struct Output {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let layerNorm: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct Intermediate {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct SelfOutput {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let layerNorm: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct SelfAttention {
        let query: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let key: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let value: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let numAttentionHeads: Swift.Int
        let attentionHeadSize: Swift.Int
        let allHeadSize: Swift.Int
    }
    struct Attention {
        let selfAttention: Embeddings.Roberta.SelfAttention
        let output: Embeddings.Roberta.SelfOutput
    }
    struct Layer {
        let attention: Embeddings.Roberta.Attention
        let intermediate: Embeddings.Roberta.Intermediate
        let output: Embeddings.Roberta.Output
    }
    struct Encoder {
        let layers: [Embeddings.Roberta.Layer]
    }
    struct Model {
        let embeddings: Embeddings.Roberta.Embeddings
        let encoder: Embeddings.Roberta.Encoder
    }
    struct ModelBundle {
        let model: Embeddings.Roberta.Model
        let tokenizer: Embeddings.TextTokenizer
    }
}
enum StaticEmbeddings {
    struct ModelBundle {
        let model: Embeddings.StaticEmbeddings.Model
        let tokenizer: Embeddings.TextTokenizer
    }
    struct Model {
        let embeddings: CoreML.MLTensor
        let dimension: Swift.Int
    }
}
class ClipTokenizer {
    let bos: Swift.String
    let bosToken: Swift.Int
    let eos: Swift.String
    let eosToken: Swift.Int
    let unk: Swift.String
    let unkToken: Swift.Int
    let bpeRanks: [Embeddings.Pair<Swift.String> : Swift.Int]
    let vocab: [Swift.String : Swift.Int]
    let splitStringPattern: _StringProcessing.Regex<_StringProcessing.AnyRegexOutput>
    let emptyStringPattern: _StringProcessing.Regex<_StringProcessing.AnyRegexOutput>
    let cache: 
}
struct Pair<A> {
    let first: A
    let second: A
}
struct TokenizerWrapper {
    let tokenizer: Tokenizers.Tokenizer
}
class XLMRobetaTokenizer {
    let tokenizer: 
    let addedTokens: [Swift.String : Swift.Int]
}
enum Word2Vec {
    struct ModelBundle {
        let keyToIndex: [Swift.String : Swift.Int]
        let indexToKey: [Swift.Int : Swift.String]
        let embeddings: CoreML.MLTensor
    }
}
enum XLMRoberta {
    struct ModelConfig {
        enum CodingKeys {
            case hiddenSize
            case numHiddenLayers
            case intermediateSize
            case numAttentionHeads
            case maxPositionEmbeddings
            case layerNormEps
            case vocabSize
            case addPoolingLayer
            case attentionProbsDropoutProb
            case hiddenDropoutProb
            case typeVocabSize
            case padTokenId
            case positionEmbeddingType
            case poolingConfig
        }
        let hiddenSize: Swift.Int
        let numHiddenLayers: Swift.Int
        let intermediateSize: Swift.Int
        let numAttentionHeads: Swift.Int
        let maxPositionEmbeddings: Swift.Int
        let layerNormEps: Swift.Float
        let vocabSize: Swift.Int
        let addPoolingLayer: Swift.Bool?
        let attentionProbsDropoutProb: Swift.Float
        let hiddenDropoutProb: Swift.Float
        let typeVocabSize: Swift.Int
        let padTokenId: Swift.Int
        let positionEmbeddingType: Swift.String
        let poolingConfig: [Swift.String : Swift.String]?
    }
    struct Pooler {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct Embeddings {
        let wordEmbeddings: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let positionEmbeddings: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let tokenTypeEmbeddings: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let layerNorm: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let paddingIndex: Swift.Int32
    }
    struct Intermediate {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct SelfOutput {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let layerNorm: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct SelfAttention {
        let query: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let key: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let value: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let numAttentionHeads: Swift.Int
        let attentionHeadSize: Swift.Int
        let allHeadSize: Swift.Int
        let scale: Swift.Float
    }
    struct Attention {
        let selfAttention: Embeddings.XLMRoberta.SelfAttention
        let output: Embeddings.XLMRoberta.SelfOutput
    }
    struct Output {
        let dense: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
        let layerNorm: @Sendable (_: CoreML.MLTensor) -> CoreML.MLTensor
    }
    struct Layer {
        let attention: Embeddings.XLMRoberta.Attention
        let intermediate: Embeddings.XLMRoberta.Intermediate
        let output: Embeddings.XLMRoberta.Output
    }
    struct Encoder {
        let layers: [Embeddings.XLMRoberta.Layer]
    }
    struct Model {
        let embeddings: Embeddings.XLMRoberta.Embeddings
        let encoder: Embeddings.XLMRoberta.Encoder
        let pooler: Embeddings.XLMRoberta.Pooler?
        let numHiddenLayers: Swift.Int
    }
    struct ModelBundle {
        let model: Embeddings.XLMRoberta.Model
        let tokenizer: Embeddings.TextTokenizer
    }
}
enum GELUApproximation {
    case fast
    case precise
    case tanh
}
enum HeaderElement {
    case metadata([Swift.String : Swift.String]?)
    case tensorData(Safetensors.TensorData)
}
struct OffsetRange {
    let start: Swift.Int
    let end: Swift.Int
}
struct ParsedSafetensors {
    let headerOffset: Swift.Int
    let headerData: [Swift.String : Safetensors.HeaderElement]
    let rawData: Foundation.Data
}
struct ParsedSafetensorsIndexData {
    struct Metadata {
        enum CodingKeys {
            case totalSize
        }
        var totalSize: Swift.Int
    }
    enum CodingKeys {
        case metadata
        case weightMap
    }
    var metadata: Safetensors.ParsedSafetensorsIndexData.Metadata?
    var weightMap: [Swift.String : Swift.String]
}
struct ParsedSafetensorsIndex {
    var metadata: Safetensors.ParsedSafetensorsIndexData.Metadata?
    var weightMap: [Swift.String : Swift.String]
    var baseURL: Foundation.URL
}
enum Safetensors {
    enum Error {
        case missingTensorDataForKey(Swift.String)
        case unsupportedDataType(Swift.String)
        case invalidHeaderSize
        case invalidHeaderData
        case dataTypeMismatch
        case metadataIncompleteBuffer
    }
}
struct TensorData {
    enum CodingKeys {
        case dtype
        case shape
        case dataOffsets
    }
    let dtype: Swift.String
    let shape: [Swift.Int]
    let dataOffsets: Safetensors.OffsetRange
}
class BPETokenizer {
    let bpeRanks: [Tokenizers.BytePair : Swift.Int]
    let tokensToIds: [__C.NSString : Swift.Int]
    let idsToTokens: [Swift.Int : __C.NSString]
    let bosToken: Swift.String?
    let bosTokenId: Swift.Int?
    let eosToken: Swift.String?
    let eosTokenId: Swift.Int?
    let unknownToken: Swift.String?
    let unknownTokenId: Swift.Int?
    let fuseUnknownTokens: Swift.Bool
}
struct BytePair {
    let a: Swift.String
    let b: Swift.String
}
class BertTokenizer {
    let basicTokenizer: Tokenizers.BasicTokenizer
    let wordpieceTokenizer: Tokenizers.WordpieceTokenizer
    let maxLen: Swift.Int
    let tokenizeChineseChars: Swift.Bool
    let vocab: [Swift.String : Swift.Int]
    let ids_to_tokens: [Swift.Int : Swift.String]
    let bosToken: Swift.String?
    let bosTokenId: Swift.Int?
    let eosToken: Swift.String?
    let eosTokenId: Swift.Int?
    let fuseUnknownTokens: Swift.Bool
}
class BasicTokenizer {
    let doLowerCase: Swift.Bool
    let neverSplit: [Swift.String]
}
class WordpieceTokenizer {
    let unkToken: Swift.String
    let maxInputCharsPerWord: Swift.Int
    let vocab: [Swift.String : Swift.Int]
}
class WordPieceDecoder {
    let prefix: Swift.String
    let cleanup: Swift.Bool
    let re: __C.NSRegularExpression
}
class DecoderSequence {
    let decoders: [Tokenizers.Decoder]
}
class ByteLevelDecoder {
    let addedTokens: Swift.Set<Swift.String>
}
class ReplaceDecoder {
    let pattern: Tokenizers.StringReplacePattern?
}
class ByteFallbackDecoder {}
class FuseDecoder {}
class StripDecoder {
    let content: Swift.String
    let start: Swift.Int
    let stop: Swift.Int
}
class MetaspaceDecoder {
    let addPrefixSpace: Swift.Bool
    let replacement: Swift.String
}
class NormalizerSequence {
    let normalizers: [Tokenizers.Normalizer]
}
class PrependNormalizer {
    let prepend: Swift.String
}
class ReplaceNormalizer {
    let pattern: Tokenizers.StringReplacePattern?
}
class LowercaseNormalizer {}
class NFDNormalizer {}
class NFCNormalizer {}
class NFKDNormalizer {}
class NFKCNormalizer {}
class BertNormalizer {
    let shouldCleanText: Swift.Bool
    let shouldHandleChineseChars: Swift.Bool
    let shouldStripAccents: Swift.Bool
    let shouldLowercase: Swift.Bool
}
class PrecompiledNormalizer {}
class StripAccentsNormalizer {}
class StripNormalizer {
    let leftStrip: Swift.Bool
    let rightStrip: Swift.Bool
}
enum StringReplacePattern {
    case regexp(regexp: __C.NSRegularExpression, replacement: Swift.String)
    case string(pattern: Swift.String, replacement: Swift.String)
}
class TemplateProcessing {
    let single: [Hub.Config]
    let pair: [Hub.Config]
}
class ByteLevelPostProcessor {}
class RobertaProcessing {
    let sep: (Swift.UInt, Swift.String)
    let cls: (Swift.UInt, Swift.String)
    let trimOffset: Swift.Bool
    let addPrefixSpace: Swift.Bool
}
class BertProcessing {
    let sep: (Swift.UInt, Swift.String)
    let cls: (Swift.UInt, Swift.String)
}
class SequenceProcessing {
    let processors: [Tokenizers.PostProcessor]
}
enum PreTokenizerOption {
    case firstSection
}
class BertPreTokenizer {
    let re: Swift.String
}
class PreTokenizerSequence {
    let preTokenizers: [Tokenizers.PreTokenizer]
}
class WhitespacePreTokenizer {
    let re: Swift.String
}
class MetaspacePreTokenizer {
    enum PrependScheme {
        case first
        case never
        case always
    }
    let addPrefixSpace: Swift.Bool
    let replacement: Swift.String
    let stringReplacement: Swift.String
    let prependScheme: Tokenizers.MetaspacePreTokenizer.PrependScheme
}
class ByteLevelPreTokenizer {
    let addPrefixSpace: Swift.Bool
    let trimOffsets: Swift.Bool
    let useRegex: Swift.Bool
    let RE: Swift.String
}
class PunctuationPreTokenizer {
    let re: Swift.String
}
class DigitsPreTokenizer {
    let re: Swift.String
}
class SplitPreTokenizer {
    let pattern: Tokenizers.StringSplitPattern?
    let invert: Swift.Bool
}
enum StringSplitPattern {
    case regexp(regexp: Swift.String)
    case string(pattern: Swift.String)
}
class TokenLatticeNode {
    let tokenId: Swift.Int
    let startOffset: Swift.Int
    let length: Swift.Int
    let score: Swift.Float
    var prev: Tokenizers.TokenLatticeNode?
    var backtraceScore: Swift.Float
}
struct TokenLattice {
    let sentence: Swift.String
    let bosTokenId: Swift.Int
    let eosTokenId: Swift.Int
    var nodes: [Tokenizers.TokenLatticeNode]
    var beginNodes: [[Tokenizers.TokenLatticeNode]]
    var endNodes: [[Tokenizers.TokenLatticeNode]]
}
enum TokenizerError {
    case unsupportedTokenizer(Swift.String)
    case chatTemplate(Swift.String)
    case tooLong(Swift.String)
    case mismatchedConfig(Swift.String)
    case missingConfig
    case missingTokenizerClassInConfig
    case missingVocab
    case malformedVocab
    case missingChatTemplate
}
enum ChatTemplateArgument {
    case literal(Swift.String)
    case name(Swift.String)
}
class PreTrainedTokenizer {
    let model: Tokenizers.TokenizingModel
    let addedTokens: Swift.Set<Swift.String>
    let specialTokens: [Swift.String : Swift.Int]
    let addedTokensRegex: __C.NSRegularExpression?
    let preTokenizer: Tokenizers.PreTokenizer?
    let normalizer: Tokenizers.Normalizer?
    let postProcessor: Tokenizers.PostProcessor?
    let decoder: Tokenizers.Decoder?
    let tokenizerConfig: Hub.Config
    let cleanUpTokenizationSpaces: Swift.Bool
    var compiledChatTemplateCache: [Swift.String : Jinja.Template]
    let cacheLock: __C.NSLock
}
enum AutoTokenizer {}
class T5Tokenizer: Tokenizers.UnigramTokenizer {}
class LlamaPreTrainedTokenizer: Tokenizers.PreTrainedTokenizer {
    let isLegacy: Swift.Bool
}
class TrieNode<A> where A: Swift.Hashable {
    var isLeaf: Swift.Bool
    var children: [A : Tokenizers.TrieNode<A>]
}
struct Trie<A> where A: Swift.Hashable {
    var root: Tokenizers.TrieNode<A>
}
struct LeavesWithCommonPrefixIterator<A> where A: Swift.Hashable {
    var node: Tokenizers.TrieNode<A>
    var text: A
    var seq: [A]
    lazy var iterator: (A)?
}
class UnigramTokenizer {
    struct SentencePieceToken {
        var token: Swift.String
        var score: Swift.Float
    }
    let vocab: [Tokenizers.UnigramTokenizer.SentencePieceToken]
    let unknownPiece: Tokenizers.UnigramTokenizer.SentencePieceToken
    let unknownTokenId: Swift.Int?
    let minScore: Swift.Float
    let tokensToIds: [__C.NSString : Swift.Int]
    let bosToken: Swift.String?
    let bosTokenId: Swift.Int?
    let eosToken: Swift.String?
    let eosTokenId: Swift.Int?
    let fuseUnknownTokens: Swift.Bool
    let trie: Tokenizers.Trie<Swift.Character>
}
enum GenerationMode {
    case contrastiveSearch
    case greedy
    case sample
    case beam
    case groupBeam
    case unsupported
}
struct GenerationConfig {
    enum CodingKeys {
        case maxLength
        case maxNewTokens
        case doSample
        case numBeams
        case numBeamGroups
        case penaltyAlpha
        case temperature
        case topK
        case topP
        case repetitionPenalty
        case padTokenId
        case bosTokenId
        case eosTokenId
    }
    var maxLength: Swift.Int
    var maxNewTokens: Swift.Int
    var doSample: Swift.Bool
    var numBeams: Swift.Int
    var numBeamGroups: Swift.Int
    var penaltyAlpha: Swift.Double?
    var temperature: Swift.Float
    var topK: Swift.Int
    var topP: Swift.Double
    var repetitionPenalty: Swift.Double
    var padTokenId: Swift.Int?
    var bosTokenId: Swift.Int?
    var eosTokenId: Swift.Int?
}
class LanguageModel {
    let model: __C.MLModel
    let minContextLength: Swift.Int
    let maxContextLength: Swift.Int
    var configuration: Hub.LanguageModelConfigurationFromHub?
    var _tokenizer: Tokenizers.Tokenizer?
}
class LanguageModelWithStatefulKVCache: Models.LanguageModel {
    enum Mode {
        case prefilling
        case extending
    }
    var mode: Models.LanguageModelWithStatefulKVCache.Mode
    var state: __C.MLState?
}
enum TokenizerError {
    case tokenizerConfigNotFound
}
struct Weights {
    enum WeightsError {
        case notSupported(message: Swift.String)
        case invalidFile
    }
    let dictionary: [Swift.String : __C.MLMultiArray]
}
enum Safetensor {
    enum Header {
        struct Offset {
            enum CodingKeys {
                case dataOffsets
                case dtype
                case shape
            }
            let dataOffsets: [Swift.Int]?
            let dtype: Swift.String?
            let shape: [Swift.Int]?
        }
    }
}
class BundleFinder {}
struct BinaryDistinctString {
    let value: [Swift.UInt16]
}
struct BinaryDistinctCharacter {
    let bytes: [Swift.UInt16]
}
struct Config {
    enum Data {
        case string(Hub.BinaryDistinctString)
        case integer(Swift.Int)
        case boolean(Swift.Bool)
        case floating(Swift.Float)
        case dictionary([Hub.BinaryDistinctString : Hub.Config])
        case array([Hub.Config])
        case token(Swift.UInt, Hub.BinaryDistinctString)
        case null
    }
    struct CodingKeys {
        var stringValue: Swift.String
    }
    let value: Hub.Config.Data
}
enum ConfigError {
    case typeMismatch(expected: Hub.Config.Data, actual: Hub.Config.Data)
    case typeConversionFailed(value: Any, targetType: Any.Type)
}
class Downloader: __C.NSObject {
    enum DownloadState {
        case downloading(Swift.Double, Swift.Double?)
        case completed(Foundation.URL)
        case failed(Swift.Error)
        case notStarted
    }
    enum DownloadError {
        case invalidDownloadLocation
        case unexpectedError
        case tempFileNotFound
    }
    let destination: Foundation.URL
    let incompleteDestination: Foundation.URL
    let downloadResumeState: Hub.DownloadResumeState
    let chunkSize: Swift.Int
    let broadcaster: Hub.Broadcaster<Hub.Downloader.DownloadState>
    let sessionConfig: __C.NSURLSessionConfiguration
    let session: Hub.SessionActor
    let task: Hub.TaskActor
}
actor DownloadResumeState {
    var $defaultActor: 
    var expectedSize: Swift.Int?
    var downloadedSize: Swift.Int
}
actor Broadcaster<A> {
    var $defaultActor: 
    let initialState: @Sendable () async -> A?
    var latestState: A?
    var continuations: [Foundation.UUID : Swift.AsyncStream<A>.Continuation]
}
actor SessionActor {
    var $defaultActor: 
    var urlSession: __C.NSURLSession?
}
actor TaskActor {
    var $defaultActor: 
    var task: Swift.Task<(), Swift.Error>?
}
enum Hub {
    enum HubClientError {
        case httpStatusCode(Swift.Int)
        case jsonSerialization(fileURL: Foundation.URL, message: Swift.String)
        case downloadError(Swift.String)
        case fileNotFound(Swift.String)
        case networkError(Foundation.URLError)
        case resourceNotFound(Swift.String)
        case configurationMissing(Swift.String)
        case fileSystemError(Swift.Error)
        case parseError(Swift.String)
        case authorizationRequired
        case parse
        case unexpectedError
    }
    enum RepoType {
        case models
        case datasets
        case spaces
    }
    struct Repo {
        enum CodingKeys {
            case id
            case type
        }
        let id: Swift.String
        let type: Hub.Hub.RepoType
    }
}
class LanguageModelConfigurationFromHub {
    struct Configurations {
        var modelConfig: Hub.Config?
        var tokenizerConfig: Hub.Config?
        var tokenizerData: Hub.Config
    }
    let configPromise: Swift.Task<Hub.LanguageModelConfigurationFromHub.Configurations, Swift.Error>
}
struct XetFileData {
    let fileHash: Swift.String
    let refreshRoute: Swift.String
}
struct HubApi {
    struct Sibling {
        enum CodingKeys {
            case rfilename
        }
        let rfilename: Swift.String
    }
    struct SiblingsResponse {
        enum CodingKeys {
            case siblings
        }
        let siblings: [Hub.HubApi.Sibling]
    }
    enum EnvironmentError {
        case invalidMetadataError(Swift.String)
        case offlineModeError(Swift.String)
        case fileIntegrityError(Swift.String)
        case fileWriteError(Swift.String)
    }
    struct HubFileDownloader {
        let hub: Hub.HubApi
        let repo: Hub.Hub.Repo
        let revision: Swift.String
        let repoDestination: Foundation.URL
        let repoMetadataDestination: Foundation.URL
        let relativeFilename: Swift.String
        let hfToken: Swift.String?
        let endpoint: Swift.String?
        let backgroundSession: Swift.Bool
    }
    struct FileMetadata {
        let commitHash: Swift.String?
        let etag: Swift.String?
        let location: Swift.String
        let size: Swift.Int?
        let xetFileData: Hub.XetFileData?
    }
    struct LocalDownloadFileMetadata {
        let commitHash: Swift.String
        let etag: Swift.String
        let filename: Swift.String
        let timestamp: Foundation.Date
    }
    actor NetworkStateActor {
        var $defaultActor: 
        var isConnected: Swift.Bool
        var isExpensive: Swift.Bool
        var isConstrained: Swift.Bool
    }
    class NetworkMonitor {
        let monitor: Network.NWPathMonitor
        let queue: __C.OS_dispatch_queue
        let state: Hub.HubApi.NetworkStateActor
    }
    var downloadBase: Foundation.URL
    var hfToken: Swift.String?
    var endpoint: Swift.String
    var useBackgroundSession: Swift.Bool
    var useOfflineMode: Swift.Bool?
    let networkMonitor: Hub.HubApi.NetworkMonitor
    let sha256Pattern: Swift.String
    let commitHashPattern: Swift.String
}
class RedirectDelegate: __C.NSObject {}
class SentencepieceTokenizer {
    enum Error {
        case failedToCreateProcessor
        case failedToLoadModel
        case failedToProcess
    }
    let processor: Swift.UnsafeMutableRawPointer
    let tokenOffset: Swift.Int
}
class TinyHTTPServer {
    class HTTPHandler {
        var server: TinyHTTPServer.TinyHTTPServer
        var handler: (TinyHTTPServer.TinyHTTPServer, NIOHTTP1.HTTPRequestHead) -> (Swift.String, NIOHTTP1.HTTPResponseStatus)
    }
    var channel: NIOCore.Channel?
    var group: NIOPosix.MultiThreadedEventLoopGroup?
    var threadPool: NIOPosix.NIOThreadPool?
}
class NIOAtomic<A> where A: NIOConcurrencyHelpers.NIOAtomicPrimitive {}
enum LockOperations {}
class LockStorage<A>: Swift.ManagedBuffer<A, __C._opaque_pthread_mutex_t> {}
struct NIOLock {
    let _storage: NIOConcurrencyHelpers.LockStorage<()>
}
struct NIOLockedValueBox<A> {
    struct Unsafe {
        let _storage: NIOConcurrencyHelpers.LockStorage<A>
    }
    let _storage: NIOConcurrencyHelpers.LockStorage<A>
}
struct UnsafeEmbeddedAtomic<A> where A: NIOConcurrencyHelpers.AtomicPrimitive {
    let value: Swift.OpaquePointer
}
class Atomic<A> where A: NIOConcurrencyHelpers.AtomicPrimitive {
    let embedded: NIOConcurrencyHelpers.UnsafeEmbeddedAtomic<A>
}
class AtomicBox<A> where A: AnyObject {
    let storage: NIOConcurrencyHelpers.NIOAtomic<Swift.UInt>
}
class Lock {
    let mutex: Swift.UnsafeMutablePointer<__C._opaque_pthread_mutex_t>
}
class ConditionLock<A> where A: Swift.Equatable {
    var _value: A
    let mutex: NIOConcurrencyHelpers.NIOLock
    let cond: Swift.UnsafeMutablePointer<__C._opaque_pthread_cond_t>
}
enum Base64Error {
    case invalidLength
    case invalidCharacter
}
enum Base64 {}
struct Heap<A> where A: Swift.Comparable {
    var storage: [A]
}
struct HeapIterator<A> where A: Swift.Comparable {
    var _heap: _NIODataStructures.Heap<A>
}
struct PriorityQueue<A> where A: Swift.Comparable {
    struct Iterator {
        var _queue: _NIODataStructures.PriorityQueue<A>
    }
    var _heap: _NIODataStructures.Heap<A>
}
struct _TinyArray<A> {
    enum Storage {
        case one(A)
        case arbitrary([A])
    }
    struct Iterator {
        let _storage: _NIODataStructures._TinyArray<A>.Storage
        var _index: Swift.Int
    }
    var storage: _NIODataStructures._TinyArray<A>.Storage
}
struct Deque<A> {
    struct Iterator {
        var _storage: DequeModule.Deque<A>._Storage
        var _nextSlot: DequeModule._DequeSlot
        var _endSlot: DequeModule._DequeSlot
    }
    struct _Storage {
        var _buffer: Swift.ManagedBufferPointer<DequeModule._DequeBufferHeader, A>
    }
    struct _UnsafeHandle {
        let _header: Swift.UnsafeMutablePointer<DequeModule._DequeBufferHeader>
        let _elements: Swift.UnsafeMutablePointer<A>
    }
    var _storage: DequeModule.Deque<A>._Storage
}
class _DequeBuffer<A>: Swift.ManagedBuffer<DequeModule._DequeBufferHeader, A> {}
struct _DequeBufferHeader {
    var capacity: Swift.Int
    var count: Swift.Int
    var startSlot: DequeModule._DequeSlot
}
struct _DequeSlot {
    var position: Swift.Int
}
struct _UnsafeWrappedBuffer<A> {
    let first: Swift.UnsafeBufferPointer<A>
    let second: Swift.UnsafeBufferPointer<A>?
}
struct _UnsafeMutableWrappedBuffer<A> {
    let first: Swift.UnsafeMutableBufferPointer<A>
    let second: Swift.UnsafeMutableBufferPointer<A>?
}
struct AtomicOptionalRawRepresentableStorage<A> where A: Swift.RawRepresentable, A.RawRepresentable.RawValue: Atomics.AtomicOptionalWrappable, A.RawRepresentable.RawValue == A.RawRepresentable.RawValue.AtomicValue.AtomicRepresentation.AtomicStorage.Value {
    var _storage: A.RawRepresentable.RawValue.AtomicOptionalWrappable.AtomicOptionalRepresentation
}
struct AtomicRawRepresentableStorage<A> where A: Swift.RawRepresentable, A.RawRepresentable.RawValue: Atomics.AtomicValue, A.RawRepresentable.RawValue == A.RawRepresentable.RawValue.AtomicValue.AtomicRepresentation.AtomicStorage.Value {
    var _storage: A.RawRepresentable.RawValue.AtomicValue.AtomicRepresentation
}
struct _AtomicInt8Storage {
    var _value: 
}
struct _AtomicInt16Storage {
    var _value: 
}
struct _AtomicInt32Storage {
    var _value: 
}
struct _AtomicInt64Storage {
    var _value: 
}
struct _AtomicInt128Storage {
    var _value: 
}
struct _AtomicReferenceStorage {
    var _storage: Atomics.DoubleWord.AtomicRepresentation
}
struct AtomicReferenceStorage<A> where A: AnyObject {
    var _storage: Atomics._AtomicReferenceStorage
}
struct AtomicOptionalReferenceStorage<A> where A: AnyObject {
    var _storage: Atomics._AtomicReferenceStorage
}
struct AtomicLoadOrdering {
    var _rawValue: Swift.Int
}
struct AtomicStoreOrdering {
    var _rawValue: Swift.Int
}
struct AtomicUpdateOrdering {
    var _rawValue: Swift.Int
}
struct DoubleWord {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt128Storage
    }
    var first: Swift.UInt
    var second: Swift.UInt
}
class ManagedAtomic<A> where A: Atomics.AtomicValue, A == A.AtomicValue.AtomicRepresentation.AtomicStorage.Value {
    var __storage: A.AtomicValue.AtomicRepresentation
}
class ManagedAtomicLazyReference<A> where A: AnyObject {
    let _storage: AtomicOptionalRepresentation
}
struct UnsafeAtomic<A> where A: Atomics.AtomicValue, A == A.AtomicValue.AtomicRepresentation.AtomicStorage.Value {
    let _ptr: Swift.UnsafeMutablePointer<A.AtomicValue.AtomicRepresentation>
}
struct UnsafeAtomicLazyReference<A> where A: AnyObject {
    struct Storage {
        var _storage: AtomicOptionalRepresentation
    }
    let _ptr: Swift.UnsafeMutablePointer<AtomicOptionalRepresentation>
}
struct AddressedEnvelope<A> {
    struct Metadata {
        var ecnState: NIOCore.NIOExplicitCongestionNotificationState
        var packetInfo: NIOCore.NIOPacketInfo?
    }
    var remoteAddress: NIOCore.SocketAddress
    var data: A
    var metadata: NIOCore.AddressedEnvelope<A>.Metadata?
}
enum NIOExplicitCongestionNotificationState {
    case transportNotCapable
    case transportCapableFlag0
    case transportCapableFlag1
    case congestionExperienced
}
struct NIOPacketInfo {
    var destinationAddress: NIOCore.SocketAddress
    var interfaceIndex: Swift.Int
}
struct NIOTooManyBytesError {
    var maxBytes: Swift.Int?
}
struct AsyncSequenceFromIterator<A> where A: Swift.AsyncIteratorProtocol {
    var iterator: A
}
struct NIOAsyncChannel<A, B> {
    struct Configuration {
        var backPressureStrategy: NIOCore.NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark
        var isOutboundHalfClosureEnabled: Swift.Bool
        var inboundType: A.Type
        var outboundType: B.Type
    }
    let channel: NIOCore.Channel
    let _inbound: NIOCore.NIOAsyncChannelInboundStream<A>
    let _outbound: NIOCore.NIOAsyncChannelOutboundWriter<B>
}
class NIOAsyncChannelHandler<A, B, C> {
    enum _ProducingState {
        case keepProducing
        case producingPaused
        case producingPausedWithOutstandingRead
    }
    enum Transformation {
        case syncWrapping((_: A) -> B)
        case transformation()
    }
    var source: NIOCore.NIOThrowingAsyncSequenceProducer<B, Swift.Error, NIOCore.NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark, NIOCore.NIOAsyncChannelHandlerProducerDelegate>.Source?
    var context: NIOCore.ChannelHandlerContext?
    var buffer: [B]
    var producingState: NIOCore.NIOAsyncChannelHandler<A, B, C>._ProducingState
    let eventLoop: NIOCore.EventLoop
    let transformation: NIOCore.NIOAsyncChannelHandler<A, B, C>.Transformation
    var sink: NIOCore.NIOAsyncWriter<C, NIOCore.NIOAsyncChannelHandlerWriterDelegate<C>>.Sink?
    var writer: NIOCore.NIOAsyncWriter<C, NIOCore.NIOAsyncChannelHandlerWriterDelegate<C>>?
    let isOutboundHalfClosureEnabled: Swift.Bool
}
struct NIOAsyncChannelHandlerProducerDelegate {
    let eventLoop: NIOCore.EventLoop
    let _didTerminate: () -> ()
    let _produceMore: () -> ()
}
struct NIOAsyncChannelHandlerWriterDelegate<A> {
    let eventLoop: NIOCore.EventLoop
    let _didYieldContentsOf: (_: DequeModule.Deque<A>) -> ()
    let _didYield: (_: A) -> ()
    let _didTerminate: (_: Swift.Error?) -> ()
}
struct NIOAsyncChannelInboundStream<A> {
    struct TestSource {
        let continuation: Swift.AsyncThrowingStream<A, Swift.Error>.Continuation
    }
    enum _Backing {
        case asyncStream(Swift.AsyncThrowingStream<A, Swift.Error>)
        case producer(NIOCore.NIOThrowingAsyncSequenceProducer<A, Swift.Error, NIOCore.NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark, NIOCore.NIOAsyncChannelHandlerProducerDelegate>)
    }
    struct AsyncIterator {
        enum _Backing {
            case asyncStream(Swift.AsyncThrowingStream<A, Swift.Error>.Iterator)
            case producer(NIOCore.NIOThrowingAsyncSequenceProducer<A, Swift.Error, NIOCore.NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark, NIOCore.NIOAsyncChannelHandlerProducerDelegate>.AsyncIterator)
        }
        var _backing: NIOCore.NIOAsyncChannelInboundStream<A>.AsyncIterator._Backing
    }
    let _backing: NIOCore.NIOAsyncChannelInboundStream<A>._Backing
}
struct NIOAsyncChannelOutboundWriter<A> {
    struct TestSink {
        struct AsyncIterator {
            var iterator: Swift.AsyncStream<A>.Iterator
        }
        let stream: Swift.AsyncStream<A>
        let continuation: Swift.AsyncStream<A>.Continuation
    }
    enum Backing {
        case asyncStream(Swift.AsyncStream<A>.Continuation)
        case writer(NIOCore.NIOAsyncWriter<A, NIOCore.NIOAsyncChannelHandlerWriterDelegate<A>>)
    }
    let _backing: NIOCore.NIOAsyncChannelOutboundWriter<A>.Backing
}
struct NIOAsyncSequenceProducer<A, B, C> where B: NIOCore.NIOAsyncSequenceProducerBackPressureStrategy, C: NIOCore.NIOAsyncSequenceProducerDelegate {
    struct NewSequence {
        let source: NIOCore.NIOAsyncSequenceProducer<A, B, C>.Source
        let sequence: NIOCore.NIOAsyncSequenceProducer<A, B, C>
    }
    struct AsyncIterator {
        let _throwingIterator: NIOCore.NIOThrowingAsyncSequenceProducer<A, Swift.Never, B, C>.AsyncIterator
    }
    struct Source {
        enum YieldResult {
            case produceMore
            case stopProducing
            case dropped
        }
        var _throwingSource: NIOCore.NIOThrowingAsyncSequenceProducer<A, Swift.Never, B, C>.Source
    }
    let _throwingSequence: NIOCore.NIOThrowingAsyncSequenceProducer<A, Swift.Never, B, C>
}
enum NIOAsyncSequenceProducerBackPressureStrategies {
    struct HighLowWatermark {
        let lowWatermark: Swift.Int
        let highWatermark: Swift.Int
        var hasOustandingDemand: Swift.Bool
    }
}
struct NIOAsyncWriterError {
    enum _Code {
        case alreadyFinished
    }
    let _code: NIOCore.NIOAsyncWriterError._Code
    var file: Swift.String
    var line: Swift.Int
}
struct NIOAsyncWriter<A, B> where A == B.NIOAsyncWriterSinkDelegate.Element, B: NIOCore.NIOAsyncWriterSinkDelegate {
    struct NewWriter {
        let sink: NIOCore.NIOAsyncWriter<A, B>.Sink
        let writer: NIOCore.NIOAsyncWriter<A, B>
    }
    class InternalClass {
        let _storage: NIOCore.NIOAsyncWriter<A, B>.Storage
        let _finishOnDeinit: Swift.Bool
    }
    struct Sink {
        class InternalClass {
            let _storage: NIOCore.NIOAsyncWriter<A, B>.Storage
            let _finishOnDeinit: Swift.Bool
        }
        let _internalClass: NIOCore.NIOAsyncWriter<A, B>.Sink.InternalClass
    }
    struct Storage {
        struct YieldIDGenerator {
            struct YieldID {
                var value: Swift.UInt64
            }
        }
        struct State {
            var stateMachine: NIOCore.NIOAsyncWriter<A, B>.StateMachine
            var didSuspend: 
        }
        let _yieldIDGenerator: NIOCore.NIOAsyncWriter<A, B>.Storage.YieldIDGenerator
        let _state: NIOConcurrencyHelpers.NIOLockedValueBox<NIOCore.NIOAsyncWriter<A, B>.Storage.State>
    }
    struct StateMachine {
        struct SuspendedYield {
            var yieldID: NIOCore.NIOAsyncWriter<A, B>.Storage.YieldIDGenerator.YieldID
            var continuation: Swift.CheckedContinuation<NIOCore.NIOAsyncWriter<A, B>.StateMachine.YieldResult, Swift.Error>
        }
        enum YieldResult {
            case yielded
            case retry
        }
        enum State {
            case initial(isWritable: Swift.Bool, delegate: B)
            case streaming(isWritable: Swift.Bool, inDelegateOutcall: Swift.Bool, cancelledYields: [NIOCore.NIOAsyncWriter<A, B>.Storage.YieldIDGenerator.YieldID], suspendedYields: _NIODataStructures._TinyArray<NIOCore.NIOAsyncWriter<A, B>.StateMachine.SuspendedYield>, delegate: B)
            case writerFinished(isWritable: Swift.Bool, inDelegateOutcall: Swift.Bool, suspendedYields: _NIODataStructures._TinyArray<NIOCore.NIOAsyncWriter<A, B>.StateMachine.SuspendedYield>, cancelledYields: [NIOCore.NIOAsyncWriter<A, B>.Storage.YieldIDGenerator.YieldID], bufferedYieldIDs: _NIODataStructures._TinyArray<NIOCore.NIOAsyncWriter<A, B>.Storage.YieldIDGenerator.YieldID>, delegate: B, error: Swift.Error?)
            case finished(sinkError: Swift.Error?)
            case modifying
        }
        enum SetWritabilityAction {
            case resumeContinuations(_NIODataStructures._TinyArray<NIOCore.NIOAsyncWriter<A, B>.StateMachine.SuspendedYield>)
        }
        enum YieldAction {
            case callDidYield(B)
            case throwError(Swift.Error)
            case suspendTask
        }
        enum CancelAction {
            case resumeContinuationWithCancellationError(Swift.CheckedContinuation<NIOCore.NIOAsyncWriter<A, B>.StateMachine.YieldResult, Swift.Error>)
            case none
        }
        enum WriterFinishAction {
            case callDidTerminate(B)
            case resumeContinuations(_NIODataStructures._TinyArray<NIOCore.NIOAsyncWriter<A, B>.StateMachine.SuspendedYield>)
            case none
        }
        enum SinkFinishAction {
            case resumeContinuationsWithError(_NIODataStructures._TinyArray<NIOCore.NIOAsyncWriter<A, B>.StateMachine.SuspendedYield>, Swift.Error)
            case none
        }
        enum UnbufferQueuedEventsAction {
            case resumeContinuations(_NIODataStructures._TinyArray<NIOCore.NIOAsyncWriter<A, B>.StateMachine.SuspendedYield>)
            case callDidTerminate(B, Swift.Error?)
        }
        var _state: NIOCore.NIOAsyncWriter<A, B>.StateMachine.State
    }
    let _internalClass: NIOCore.NIOAsyncWriter<A, B>.InternalClass
}
struct NIOThrowingAsyncSequenceProducer<A, B, C, D> where B: Swift.Error, C: NIOCore.NIOAsyncSequenceProducerBackPressureStrategy, D: NIOCore.NIOAsyncSequenceProducerDelegate {
    struct NewSequence {
        let source: NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.Source
        let sequence: NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>
    }
    class InternalClass {
        let _storage: NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.Storage
    }
    struct AsyncIterator {
        class InternalClass {
            let _storage: NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.Storage
        }
        let _internalClass: NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.AsyncIterator.InternalClass
    }
    struct Source {
        class InternalClass {
            let _storage: NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.Storage
            let _finishOnDeinit: Swift.Bool
        }
        enum YieldResult {
            case produceMore
            case stopProducing
            case dropped
        }
        let _internalClass: NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.Source.InternalClass
    }
    struct Storage {
        struct State {
            var stateMachine: NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.StateMachine
            var delegate: D?
            var didSuspend: 
        }
        let _state: NIOConcurrencyHelpers.NIOLockedValueBox<NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.Storage.State>
    }
    struct StateMachine {
        enum State {
            case initial(backPressureStrategy: C, iteratorInitialized: Swift.Bool)
            case streaming(backPressureStrategy: C, buffer: DequeModule.Deque<A>, continuation: Swift.CheckedContinuation<A?, Swift.Error>?, hasOutstandingDemand: Swift.Bool, iteratorInitialized: Swift.Bool)
            case sourceFinished(buffer: DequeModule.Deque<A>, iteratorInitialized: Swift.Bool, failure: B?)
            case cancelled(iteratorInitialized: Swift.Bool)
            case finished(iteratorInitialized: Swift.Bool)
            case modifying
        }
        enum SequenceDeinitializedAction {
            case callDidTerminate
            case none
        }
        enum IteratorDeinitializedAction {
            case callDidTerminate
            case none
        }
        enum YieldAction {
            case resumeContinuationAndReturnProduceMore(continuation: Swift.CheckedContinuation<A?, Swift.Error>, element: A)
            case resumeContinuationAndReturnStopProducing(continuation: Swift.CheckedContinuation<A?, Swift.Error>, element: A)
            case returnProduceMore
            case returnStopProducing
            case returnDropped
        }
        enum FinishAction {
            case resumeContinuationWithFailureAndCallDidTerminate(Swift.CheckedContinuation<A?, Swift.Error>, B?)
            case none
        }
        enum CancelledAction {
            case resumeContinuationWithCancellationErrorAndCallDidTerminate(Swift.CheckedContinuation<A?, Swift.Error>)
            case callDidTerminate
            case none
        }
        enum NextAction {
            case returnElement(A)
            case returnElementAndCallProduceMore(A)
            case returnFailureAndCallDidTerminate(B?)
            case returnCancellationError
            case returnNil
            case suspendTask
        }
        enum NextForContinuationAction {
            case callProduceMore
            case none
        }
        var _state: NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.StateMachine.State
    }
    let _internalClass: NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.InternalClass
}
enum NIOBSDSocket {
    struct AddressFamily {
        var rawValue: Swift.Int32
    }
    struct ProtocolFamily {
        var rawValue: Swift.Int32
    }
    struct OptionLevel {
        var rawValue: Swift.Int32
    }
    struct Option {
        var rawValue: Swift.Int32
    }
}
struct _ByteBufferSlice {
    var upperBound: Swift.UInt32
    var _begin: NIOCore._UInt24
}
struct ByteBufferAllocator {
    let malloc: @convention(c) (_: Swift.Int) -> Swift.UnsafeMutableRawPointer?
    let realloc: @convention(c) (Swift.UnsafeMutableRawPointer?, Swift.Int) -> Swift.UnsafeMutableRawPointer?
    let free: @convention(c) (_: Swift.UnsafeMutableRawPointer) -> ()
    let memcpy: @convention(c) (Swift.UnsafeMutableRawPointer, Swift.UnsafeRawPointer, Swift.Int) -> ()
}
struct ByteBuffer {
    struct ReadUTF8ValidationError {
        enum BaseError {
            case invalidUTF8
        }
        var baseError: NIOCore.ByteBuffer.ReadUTF8ValidationError.BaseError
    }
    class _Storage {
        var capacity: Swift.UInt32
        var bytes: Swift.UnsafeMutableRawPointer
        let allocator: NIOCore.ByteBufferAllocator
    }
    struct CopyBytesError {
        enum BaseError {
            case negativeLength
            case unreadableSourceBytes
        }
        var baseError: NIOCore.ByteBuffer.CopyBytesError.BaseError
    }
    struct HexDumpFormat {
        enum Value {
            case plain(maxBytes: Swift.Int?)
            case detailed(maxBytes: Swift.Int?)
            case compact(maxBytes: Swift.Int?)
        }
        let value: NIOCore.ByteBuffer.HexDumpFormat.Value
    }
    struct HexDecodingError {
        enum HexDecodingErrorKind {
            case invalidHexLength
            case invalidCharacter
        }
        let kind: NIOCore.ByteBuffer.HexDecodingError.HexDecodingErrorKind
    }
    struct LengthPrefixError {
        enum BaseError {
            case messageLengthDoesNotFitExactlyIntoRequiredIntegerFormat
            case messageCouldNotBeReadSuccessfully
        }
        var baseError: NIOCore.ByteBuffer.LengthPrefixError.BaseError
    }
    struct QUICBinaryEncodingStrategy {
        enum IntegerLength {
            case one
            case two
            case four
            case eight
        }
        var requiredBytesHint: Swift.Int
    }
    var _storage: NIOCore.ByteBuffer._Storage
    var _readerIndex: Swift.UInt32
    var _writerIndex: Swift.UInt32
    var _slice: NIOCore._ByteBufferSlice
}
enum Endianness {
    case big
    case little
}
struct ByteBufferView {
    var _buffer: NIOCore.ByteBuffer
    var _range: Swift.Range<Swift.Int>
}
enum ChannelError {
    case connectTimeout(NIOCore.TimeAmount)
    case illegalMulticastAddress(NIOCore.SocketAddress)
    case multicastNotSupported(NIOCore.NIONetworkInterface)
    case connectPending
    case operationUnsupported
    case ioOnClosedChannel
    case alreadyClosed
    case outputClosed
    case inputClosed
    case eof
    case writeMessageTooLarge
    case writeHostUnreachable
    case unknownLocalAddress
    case badMulticastGroupAddressFamily
    case badInterfaceAddressFamily
    case inappropriateOperationForState
    case unremovableHandler
}
struct NIOAttemptedToRemoveHandlerMultipleTimesError {}
enum DatagramChannelError {
    struct WriteOnUnconnectedSocketWithoutAddress {}
    struct WriteOnConnectedSocketWithInvalidAddress {
        let envelopeRemoteAddress: NIOCore.SocketAddress
        let connectedRemoteAddress: NIOCore.SocketAddress
    }
}
enum ChannelEvent {
    case inputClosed
    case outputClosed
}
struct ChannelShouldQuiesceEvent {}
class AcceptBackoffHandler {
    var nextReadDeadlineNS: NIOCore.NIODeadline?
    let backoffProvider: (_: NIOCore.IOError) -> NIOCore.TimeAmount?
    let shouldForwardIOErrorCaught: Swift.Bool
    var scheduledRead: NIOCore.Scheduled<()>?
}
class BackPressureHandler {
    var pendingRead: Swift.Bool
    var writable: Swift.Bool
}
class IdleStateHandler {
    enum IdleStateEvent {
        case write
        case read
        case all
    }
    let readTimeout: NIOCore.TimeAmount?
    let writeTimeout: NIOCore.TimeAmount?
    let allTimeout: NIOCore.TimeAmount?
    var reading: Swift.Bool
    var lastReadTime: NIOCore.NIODeadline
    var lastWriteCompleteTime: NIOCore.NIODeadline
    var scheduledReaderTask: NIOCore.Scheduled<()>?
    var scheduledWriterTask: NIOCore.Scheduled<()>?
    var scheduledAllTask: NIOCore.Scheduled<()>?
}
enum CloseMode {
    case output
    case input
    case all
}
struct ChannelOptions {
    enum Types {
        struct SocketOption {
            var optionLevel: NIOCore.NIOBSDSocket.OptionLevel
            var optionName: NIOCore.NIOBSDSocket.Option
        }
        struct AllocatorOption {}
        struct RecvAllocatorOption {}
        struct AutoReadOption {}
        struct WriteSpinOption {}
        struct MaxMessagesPerReadOption {}
        struct BacklogOption {}
        struct DatagramVectorReadMessageCountOption {}
        struct DatagramSegmentSize {}
        struct DatagramReceiveOffload {}
        struct ExplicitCongestionNotificationsOption {}
        struct WriteBufferWaterMark {
            let low: Swift.Int
            let high: Swift.Int
        }
        struct WriteBufferWaterMarkOption {}
        struct ConnectTimeoutOption {}
        struct AllowRemoteHalfClosureOption {}
        struct ReceivePacketInfo {}
        struct BufferedWritableBytesOption {}
        enum ConvenienceOptionValue<A> {
            case set(A)
            case notSet
        }
    }
    struct Storage {
        var _storage: 
    }
    struct TCPConvenienceOption {
        enum ConvenienceOption {
            case allowLocalEndpointReuse
            case disableAutoRead
            case allowRemoteHalfClosure
        }
        var data: NIOCore.ChannelOptions.TCPConvenienceOption.ConvenienceOption
    }
    struct TCPConvenienceOptions {
        var allowLocalEndpointReuse: Swift.Bool
        var disableAutoRead: Swift.Bool
        var allowRemoteHalfClosure: Swift.Bool
    }
}
class ChannelPipeline {
    struct SynchronousOperations {
        enum Position {
            case before(NIOCore.ChannelHandler)
            case after(NIOCore.ChannelHandler)
            case first
            case last
        }
        let _pipeline: NIOCore.ChannelPipeline
    }
    enum Position {
        case before(NIOCore.ChannelHandler)
        case after(NIOCore.ChannelHandler)
        case first
        case last
    }
    struct ChannelHandlerDebugInfo {
        let handler: NIOCore.ChannelHandler
        let name: Swift.String
    }
    var head: NIOCore.ChannelHandlerContext?
    var tail: NIOCore.ChannelHandlerContext?
    var idx: Swift.Int
    var destroyed: Swift.Bool
    let eventLoop: NIOCore.EventLoop
    var _channel: NIOCore.Channel?
}
class HeadChannelHandler {}
class TailChannelHandler {}
enum ChannelPipelineError {
    case alreadyRemoved
    case notFound
}
class ChannelHandlerContext {
    struct RemovalToken {
        let promise: NIOCore.EventLoopPromise<()>?
    }
    var next: NIOCore.ChannelHandlerContext?
    var prev: NIOCore.ChannelHandlerContext?
    let pipeline: NIOCore.ChannelPipeline
    let name: Swift.String
    let inboundHandler: NIOCore._ChannelInboundHandler?
    let outboundHandler: NIOCore._ChannelOutboundHandler?
    var removeHandlerInvoked: Swift.Bool
    var userTriggeredRemovalStarted: Swift.Bool
}
struct CircularBuffer<A> {
    struct Index {
        var _backingIndex: Swift.UInt32
        var _backingCheck: NIOCore._UInt24
        var isIndexGEQHeadIndex: Swift.Bool
    }
    var _buffer: Swift.ContiguousArray<A?>
    var headBackingIndex: Swift.Int
    var tailBackingIndex: Swift.Int
}
enum DecodingState {
    case continue
    case needMoreData
}
enum ByteToMessageDecoderError {
    struct PayloadTooLargeError {}
    case dataReceivedInErrorState(Swift.Error, NIOCore.ByteBuffer)
    case leftoverDataWhenDone(NIOCore.ByteBuffer)
}
class ByteToMessageHandler<A> where A: NIOCore.ByteToMessageDecoder {
    enum RemovalState {
        case notAddedToPipeline
        case notBeingRemoved
        case removalStarted
        case removalCompleted
        case handlerRemovedCalled
    }
    enum State {
        case error(Swift.Error)
        case active
        case leftoversNeedProcessing
        case done
    }
    var decoder: A?
    let maximumBufferSize: Swift.Int?
    var queuedWrites: NIOCore.CircularBuffer<NIOCore.NIOAny>
    var state: NIOCore.ByteToMessageHandler<A>.State
    var removalState: NIOCore.ByteToMessageHandler<A>.RemovalState
    var buffer: NIOCore.B2MDBuffer?
    var seenEOF: Swift.Bool
    var selfAsCanDequeueWrites: NIOCore.CanDequeueWrites?
}
class MessageToByteHandler<A> where A: NIOCore.MessageToByteEncoder {
    enum State {
        case error(Swift.Error)
        case notInChannelYet
        case operational
        case done
    }
    var state: NIOCore.MessageToByteHandler<A>.State
    let encoder: A
    var buffer: NIOCore.ByteBuffer?
    let desiredBufferCapacity: Swift.Int?
}
struct B2MDBuffer {
    enum State {
        case processingInProgress
        case ready
    }
    var state: NIOCore.B2MDBuffer.State
    var buffers: NIOCore.CircularBuffer<NIOCore.ByteBuffer>
    let emptyByteBuffer: NIOCore.ByteBuffer
}
class DeadChannelCore {}
class DeadChannel {
    let eventLoop: NIOCore.EventLoop
    let pipeline: NIOCore.ChannelPipeline
    let parent: NIOCore.Channel?
    let isWritable: Swift.Bool
    let isActive: Swift.Bool
    let _channelCore: NIOCore.ChannelCore
}
class NIODefaultSerialEventLoopExecutor {
    let loop: NIOCore.EventLoop
}
struct Scheduled<A> {
    let _promise: NIOCore.EventLoopPromise<A>
    let _cancellationTask: 
}
class RepeatedTask {
    let delay: NIOCore.TimeAmount
    let eventLoop: NIOCore.EventLoop
    let cancellationPromise: NIOCore.EventLoopPromise<()>?
    var scheduled: NIOCore.Scheduled<NIOCore.EventLoopFuture<()>>?
    var task: 
}
struct EventLoopIterator {
    var eventLoops: Swift.IndexingIterator<[NIOCore.EventLoop]>
}
struct TimeAmount {
    enum ValidationError {
        case unsupportedUnit(Swift.String)
        case invalidNumber(Swift.String)
    }
    let nanoseconds: Swift.Int64
}
struct NIODeadline {
    var _uptimeNanoseconds: Swift.Int64
}
enum NIOEventLoopGroupProvider {
    case shared(NIOCore.EventLoopGroup)
    case createNew
}
enum EventLoopError {
    case unsupportedOperation
    case cancelled
    case shutdown
    case shutdownFailed
}
struct NIOIsolatedEventLoop {
    let _wrapped: NIOCore.EventLoop
}
struct CallbackList {
    struct Wrapper {
        var callback: () -> NIOCore.CallbackList
    }
    var firstCallback: NIOCore.CallbackList.Wrapper?
    var furtherCallbacks: [NIOCore.CallbackList.Wrapper]?
}
struct OperationPlaceholderError {}
struct EventLoopPromise<A> {
    struct Isolated {
        let _wrapped: NIOCore.EventLoopPromise<A>
    }
    let futureResult: NIOCore.EventLoopFuture<A>
}
class EventLoopFuture<A> {
    struct Isolated {
        let _wrapped: NIOCore.EventLoopFuture<A>
    }
    var _value: Swift.Result<A, Swift.Error>?
    let eventLoop: NIOCore.EventLoop
    var _callbacks: NIOCore.CallbackList
}
struct _NIOEventLoopFutureIdentifier {
    var opaqueID: Swift.UInt
}
class NIOFileHandle {
    struct Mode {
        let rawValue: Swift.UInt8
    }
    struct Flags {
        var posixMode: Swift.UInt16
        var posixFlags: Swift.Int32
    }
    let descriptor: Atomics.UnsafeAtomic<Swift.UInt64>
}
struct FileDescriptorState {
    var rawValue: Swift.UInt64
}
struct FileRegion {
    let fileHandle: NIOCore.NIOFileHandle
    let _endIndex: Swift.UInt64
    var _readerIndex: NIOCore._UInt56
}
enum NIOSingletons {}
struct IOError {
    enum FailureDescription {
        case function(Swift.StaticString)
        case reason(Swift.String)
    }
    enum Error {
        case errno(Swift.Int32)
    }
    var failureDescription: Swift.String
    let error: NIOCore.IOError.Error
}
enum IOData {
    case byteBuffer(NIOCore.ByteBuffer)
    case fileRegion(NIOCore.FileRegion)
}
struct NIOIPProtocol {
    var rawValue: Swift.UInt8
}
enum _IntegerBitPacking {}
enum IntegerBitPacking {}
struct _UInt24 {
    var _backing: (Swift.UInt16, Swift.UInt8)
}
struct _UInt56 {
    var _backing: (Swift.UInt32, Swift.UInt16, Swift.UInt8)
}
class NIONetworkInterface {
    let name: Swift.String
    let address: NIOCore.SocketAddress
    let netmask: NIOCore.SocketAddress?
    let broadcastAddress: NIOCore.SocketAddress?
    let pointToPointDestinationAddress: NIOCore.SocketAddress?
    let multicastSupported: Swift.Bool
    let interfaceIndex: Swift.Int
}
struct NIONetworkDevice {
    class Backing {
        var name: Swift.String
        var address: NIOCore.SocketAddress?
        var netmask: NIOCore.SocketAddress?
        var broadcastAddress: NIOCore.SocketAddress?
        var pointToPointDestinationAddress: NIOCore.SocketAddress?
        var multicastSupported: Swift.Bool
        var interfaceIndex: Swift.Int
    }
    var backing: NIOCore.NIONetworkDevice.Backing
}
struct MarkedCircularBuffer<A> {
    var _buffer: NIOCore.CircularBuffer<A>
    var _markedIndexOffset: Swift.Int?
}
struct NIOMulticastNotSupportedError {
    var device: NIOCore.NIONetworkDevice
}
struct NIOMulticastNotImplementedError {}
struct NIOAny {
    enum _NIOAny {
        case ioData(NIOCore.IOData)
        case bufferEnvelope(NIOCore.AddressedEnvelope<NIOCore.ByteBuffer>)
        case other(Any)
    }
    let _storage: NIOCore.NIOAny._NIOAny
}
class NIOCloseOnErrorHandler {}
struct NIOLoopBound<A> {
    let eventLoop: NIOCore.EventLoop
    var _value: A
}
class NIOLoopBoundBox<A> {
    let eventLoop: NIOCore.EventLoop
    var _value: A
}
struct NIOPooledRecvBufferAllocator {
    var _buffer: NIOCore.ByteBuffer?
    var _buffers: [NIOCore.ByteBuffer]
    var _lastUsedIndex: Swift.Int
    var capacity: Swift.Int
    var recvAllocator: NIOCore.RecvByteBufferAllocator
    var _mayGrow: Swift.Bool
}
struct NIOScheduledCallback {
    enum Backing {
        case default(NIOCore.Scheduled<()>)
        case custom(id: Swift.UInt64)
    }
    var eventLoop: NIOCore.EventLoop
    var backing: NIOCore.NIOScheduledCallback.Backing
}
struct LoopBoundScheduledCallbackHandlerWrapper<A> where A: NIOCore.NIOScheduledCallbackHandler {
    let box: NIOCore.NIOLoopBound<A>
}
struct UnsafeTransfer<A> {
    var wrappedValue: A
}
class UnsafeMutableTransferBox<A> {
    var wrappedValue: A
}
struct FixedSizeRecvByteBufferAllocator {
    let capacity: Swift.Int
}
struct AdaptiveRecvByteBufferAllocator {
    let minimum: Swift.Int
    let maximum: Swift.Int
    let initial: Swift.Int
    var nextReceiveBufferSize: Swift.Int
    var decreaseNow: Swift.Bool
}
class NIOSingleStepByteToMessageProcessor<A> where A: NIOCore.NIOSingleStepByteToMessageDecoder {
    enum DecodeMode {
        case normal
        case last
    }
    var decoder: A
    let maximumBufferSize: Swift.Int?
    var _buffer: NIOCore.ByteBuffer?
}
enum SocketAddressError {
    struct FailedToParseIPByteBuffer {
        var address: NIOCore.ByteBuffer
    }
    case unknown(host: Swift.String, port: Swift.Int)
    case failedToParseIPString(Swift.String)
    case unsupported
    case unixDomainSocketPathTooLong
}
enum SocketAddress {
    struct IPv4Address {
        let _storage: NIOCore.Box<(address: __C.sockaddr_in, host: Swift.String)>
    }
    struct IPv6Address {
        let _storage: NIOCore.Box<(address: __C.sockaddr_in6, host: Swift.String)>
    }
    struct UnixSocketAddress {
        let _storage: NIOCore.Box<__C.sockaddr_un>
    }
    case v4(NIOCore.SocketAddress.IPv4Address)
    case v6(NIOCore.SocketAddress.IPv6Address)
    case unixDomainSocket(NIOCore.SocketAddress.UnixSocketAddress)
}
struct NIOClientTCPBootstrap {
    let underlyingBootstrap: NIOCore.NIOClientTCPBootstrapProtocol
    let tlsEnablerTypeErased: (_: NIOCore.NIOClientTCPBootstrapProtocol) -> NIOCore.NIOClientTCPBootstrapProtocol
}
struct NIOInsecureNoTLS<A> where A: NIOCore.NIOClientTCPBootstrapProtocol {}
class Box<A> {
    let value: A
}
enum System {}
class NIOAsyncTestingChannel {
    enum LeftOverState {
        case leftOvers(inbound: NIOCore.CircularBuffer<NIOCore.NIOAny>, outbound: NIOCore.CircularBuffer<NIOCore.NIOAny>, pendingOutbound: [NIOCore.NIOAny])
        case clean
    }
    enum BufferState {
        case full(NIOCore.CircularBuffer<NIOCore.NIOAny>)
        case empty
    }
    struct WrongTypeError {
        let expected: Any.Type
        let actual: Any.Type
    }
    struct State {
        var isWritable: Swift.Bool
        var localAddress: NIOCore.SocketAddress?
        var remoteAddress: NIOCore.SocketAddress?
        var options: [(option: NIOCore.ChannelOption, value: Any)]
    }
    struct SynchronousOptions {
        let channel: NIOEmbedded.NIOAsyncTestingChannel
    }
    let allocator: NIOCore.ByteBufferAllocator
    let testingEventLoop: NIOEmbedded.NIOAsyncTestingEventLoop
    let parent: NIOCore.Channel?
    var channelcore: NIOEmbedded.EmbeddedChannelCore?
    var _pipeline: NIOCore.ChannelPipeline?
    let _stateLock: NIOConcurrencyHelpers.NIOLockedValueBox<NIOEmbedded.NIOAsyncTestingChannel.State>
}
class NIOAsyncTestingEventLoop {
    enum State {
        case open
        case closing
        case closed
    }
    let _now: Atomics.ManagedAtomic<Swift.UInt64>
    let scheduledTaskCounter: Atomics.ManagedAtomic<Swift.UInt64>
    var scheduledTasks: _NIODataStructures.PriorityQueue<NIOEmbedded.EmbeddedScheduledTask>
    let _promiseCreationStore: NIOEmbedded.PromiseCreationStore
    var taskNumber: Swift.UInt64
    let queue: __C.OS_dispatch_queue
    let state: Atomics.ManagedAtomic<NIOEmbedded.NIOAsyncTestingEventLoop.State>
}
class PromiseCreationStore {
    let lock: NIOConcurrencyHelpers.NIOLock
    var promiseCreationStore: [NIOCore._NIOEventLoopFutureIdentifier : (file: Swift.StaticString, line: Swift.UInt)]
}
class EmbeddedEventLoop {
    enum State {
        case open
        case closing
        case closed
    }
    var _now: NIOCore.NIODeadline
    var state: NIOEmbedded.EmbeddedEventLoop.State
    var scheduledTaskCounter: Swift.UInt64
    var scheduledTasks: _NIODataStructures.PriorityQueue<NIOEmbedded.EmbeddedScheduledTask>
    var _promiseCreationStore: [NIOCore._NIOEventLoopFutureIdentifier : (file: Swift.StaticString, line: Swift.UInt)]
    var taskNumber: Swift.UInt64
    let description: Swift.String
    let myThread: Swift.UnsafeMutablePointer<__C._opaque_pthread_t>
}
class EmbeddedChannelCore {
    let _isOpen: Atomics.ManagedAtomic<Swift.Bool>
    let _isActive: Atomics.ManagedAtomic<Swift.Bool>
    let _allowRemoteHalfClosure: Atomics.ManagedAtomic<Swift.Bool>
    let eventLoop: NIOCore.EventLoop
    let closePromise: NIOCore.EventLoopPromise<()>
    var error: Swift.Error?
    let pipeline: NIOCore.ChannelPipeline
    var outboundBuffer: NIOCore.CircularBuffer<NIOCore.NIOAny>
    var outboundBufferConsumer: DequeModule.Deque<(_: NIOCore.NIOAny) -> ()>
    var pendingOutboundBuffer: NIOCore.MarkedCircularBuffer<(NIOCore.NIOAny, NIOCore.EventLoopPromise<()>?)>
    var inboundBuffer: NIOCore.CircularBuffer<NIOCore.NIOAny>
    var inboundBufferConsumer: DequeModule.Deque<(_: NIOCore.NIOAny) -> ()>
    var localAddress: NIOCore.SocketAddress?
    var remoteAddress: NIOCore.SocketAddress?
}
class EmbeddedChannel {
    enum LeftOverState {
        case leftOvers(inbound: [NIOCore.NIOAny], outbound: [NIOCore.NIOAny], pendingOutbound: [NIOCore.NIOAny])
        case clean
    }
    enum BufferState {
        case full([NIOCore.NIOAny])
        case empty
    }
    struct WrongTypeError {
        let expected: Any.Type
        let actual: Any.Type
    }
    struct SynchronousOptions {
        let channel: NIOEmbedded.EmbeddedChannel
    }
    lazy var channelcore: NIOEmbedded.EmbeddedChannelCore?
    var isWritable: Swift.Bool
    var _options: [(option: NIOCore.ChannelOption, value: Any)]
    var _pipeline: NIOCore.ChannelPipeline?
    var allocator: NIOCore.ByteBufferAllocator
    var embeddedEventLoop: NIOEmbedded.EmbeddedEventLoop
    let parent: NIOCore.Channel?
}
struct EmbeddedScheduledTask {
    let id: Swift.UInt64
    let task: () -> ()
    let failFn: (_: Swift.Error) -> ()
    let readyTime: NIOCore.NIODeadline
    let insertOrder: Swift.UInt64
}
class BundleFinder {}
enum Shutdown {
    case RD
    case WR
    case RDWR
}
struct UnixDomainSocketPathWrongType {}
class BaseSocket {
    var descriptor: Swift.Int32
}
class BaseSocketChannel<A> where A: NIOPosix.BaseSocketProtocol {
    struct AddressCache {
        let local: NIOCore.SocketAddress?
        let remote: NIOCore.SocketAddress?
    }
    struct SynchronousOptions {
        let _channel: NIOPosix.BaseSocketChannel<A>
    }
    let parent: NIOCore.Channel?
    let socket: A
    let closePromise: NIOCore.EventLoopPromise<()>
    let selectableEventLoop: NIOPosix.SelectableEventLoop
    let _offEventLoopLock: NIOConcurrencyHelpers.NIOLock
    let isActiveAtomic: Atomics.ManagedAtomic<Swift.Bool>
    let socketDescription: Swift.String
    var readPending: Swift.Bool
    var pendingConnect: NIOCore.EventLoopPromise<()>?
    var recvBufferPool: NIOCore.NIOPooledRecvBufferAllocator
    var maxMessagesPerRead: Swift.UInt
    var inFlushNow: Swift.Bool
    var autoRead: Swift.Bool
    var _pipeline: NIOCore.ChannelPipeline?
    var _addressCache: NIOPosix.BaseSocketChannel<A>.AddressCache
    var _bufferAllocatorCache: NIOCore.ByteBufferAllocator
    var interestedEvent: NIOPosix.SelectorEventSet
    var lifecycleManager: NIOPosix.SocketChannelLifecycleManager
    var bufferAllocator: NIOCore.ByteBufferAllocator
}
struct SocketChannelLifecycleManager {
    enum State {
        case fresh
        case preRegistered
        case fullyRegistered
        case activated
        case closed
    }
    let eventLoop: NIOCore.EventLoop
    let isActiveAtomic: Atomics.ManagedAtomic<Swift.Bool>
    var hasSeenEOFNotification: Swift.Bool
    let supportsReconnect: Swift.Bool
    var currentState: NIOPosix.SocketChannelLifecycleManager.State
}
class BaseStreamSocketChannel<A>: NIOPosix.BaseSocketChannel<A> where A: NIOPosix.SocketProtocol {
    var connectTimeoutScheduled: NIOCore.Scheduled<()>?
    var allowRemoteHalfClosure: Swift.Bool
    var inputShutdown: Swift.Bool
    var outputShutdown: Swift.Bool
    let pendingWrites: NIOPosix.PendingStreamWritesManager
}
class ServerBootstrap {
    class AcceptHandler {
        let childChannelInit: 
        let childChannelOptions: NIOCore.ChannelOptions.Storage
    }
    let group: NIOCore.EventLoopGroup
    let childGroup: NIOCore.EventLoopGroup
    var serverChannelInit: 
    var childChannelInit: 
    var _serverChannelOptions: NIOCore.ChannelOptions.Storage
    var _childChannelOptions: NIOCore.ChannelOptions.Storage
    var enableMPTCP: Swift.Bool
}
class ClientBootstrap {
    let group: NIOCore.EventLoopGroup
    var protocolHandlers: 
    var _channelInitializer: 
    var _channelOptions: NIOCore.ChannelOptions.Storage
    var connectTimeout: NIOCore.TimeAmount
    var resolver: NIOPosix.Resolver?
    var bindTarget: NIOCore.SocketAddress?
    var enableMPTCP: Swift.Bool
}
class DatagramBootstrap {
    let group: NIOCore.EventLoopGroup
    var channelInitializer: 
    var _channelOptions: NIOCore.ChannelOptions.Storage
    var proto: ProtocolSubtype
}
class NIOPipeBootstrap {
    let group: NIOCore.EventLoopGroup
    var channelInitializer: 
    var _channelOptions: NIOCore.ChannelOptions.Storage
    let hooks: NIOPosix.NIOPipeBootstrapHooks
}
struct DefaultNIOPipeBootstrapHooks {}
struct UnsafeControlMessage {
    var level: Swift.Int32
    var type: Swift.Int32
    var data: Swift.UnsafeRawBufferPointer?
}
struct UnsafeControlMessageCollection {
    struct Index {
        var cmsgPointer: Swift.UnsafeMutablePointer<__C.cmsghdr>?
    }
    var messageHeader: __C.msghdr
}
struct UnsafeControlMessageStorage {
    let bytesPerMessage: Swift.Int
    var buffer: Swift.UnsafeMutableRawBufferPointer
    let deallocateBuffer: Swift.Bool
}
struct DatagramVectorReadManager {
    var messageVector: Swift.UnsafeMutableBufferPointer<__C.CNIODarwin_mmsghdr>
    var ioVector: Swift.UnsafeMutableBufferPointer<__C.iovec>
    var sockaddrVector: Swift.UnsafeMutableBufferPointer<__C.sockaddr_storage>
    var controlMessageStorage: NIOPosix.UnsafeControlMessageStorage
}
class GetaddrinfoResolver {
    let loop: NIOCore.EventLoop
    let v4Future: NIOCore.EventLoopPromise<[NIOCore.SocketAddress]>
    let v6Future: NIOCore.EventLoopPromise<[NIOCore.SocketAddress]>
    let aiSocktype: SocketType
    let aiProtocol: NIOCore.NIOBSDSocket.OptionLevel
}
struct SingleConnectionFailure {
    let target: NIOCore.SocketAddress
    let error: Swift.Error
}
struct NIOConnectionError {
    let host: Swift.String
    let port: Swift.Int
    var dnsAError: Swift.Error?
    var dnsAAAAError: Swift.Error?
    var connectionErrors: [NIOPosix.SingleConnectionFailure]
}
class HappyEyeballsConnectorRunner<A> {
    enum ConnectionState {
        case idle
        case resolving
        case aResolvedWaiting
        case aResolvedConnecting
        case aaaaResolved
        case allResolved
        case complete
    }
    enum ConnectorInput {
        case resolve
        case resolverACompleted
        case resolverAAAACompleted
        case resolutionDelayElapsed
        case connectDelayElapsed
        case connectTimeoutElapsed
        case connectSuccess
        case connectFailed
        case noTargetsRemaining
    }
    let connector: NIOPosix.HappyEyeballsConnector<A>
    var resolutionTask: NIOCore.Scheduled<()>?
    var connectionTask: NIOCore.Scheduled<()>?
    var timeoutTask: NIOCore.Scheduled<()>?
    var state: NIOPosix.HappyEyeballsConnectorRunner<A>.ConnectionState
    var targets: NIOPosix.TargetIterator
    var pendingConnections: [NIOCore.EventLoopFuture<(NIOCore.Channel, A)>]
    var dnsResolutions: Swift.Int
    var error: NIOPosix.NIOConnectionError
}
struct TargetIterator {
    enum AddressFamily {
        case v4
        case v6
    }
    var previousAddressFamily: NIOPosix.TargetIterator.AddressFamily
    var aQueryResults: [NIOCore.SocketAddress]
    var aaaaQueryResults: [NIOCore.SocketAddress]
}
struct HappyEyeballsConnector<A> {
    let resolver: NIOPosix.Resolver
    let loop: NIOCore.EventLoop
    let host: Swift.String
    let port: Swift.Int
    let channelBuilderCallback: 
    let resolutionDelay: NIOCore.TimeAmount
    let connectionDelay: NIOCore.TimeAmount
    let connectTimeout: NIOCore.TimeAmount
    let resolutionPromise: NIOCore.EventLoopPromise<(NIOCore.Channel, A)>
}
enum IOResult<A> where A: Swift.Equatable {
    case wouldBlock(A)
    case processed(A)
}
enum _IntegerBitPacking {}
enum IntegerBitPacking {}
struct _UInt24 {
    var _backing: (Swift.UInt16, Swift.UInt8)
}
struct _UInt56 {
    var _backing: (Swift.UInt32, Swift.UInt16, Swift.UInt8)
}
struct NIORegistration {
    enum ChannelType {
        case serverSocketChannel(NIOPosix.ServerSocketChannel)
        case socketChannel(NIOPosix.SocketChannel)
        case datagramChannel(NIOPosix.DatagramChannel)
        case pipeChannel(NIOPosix.PipeChannel, NIOPosix.PipeChannel.Direction)
    }
    var channel: NIOPosix.NIORegistration.ChannelType
    var interested: NIOPosix.SelectorEventSet
    var registrationID: NIOPosix.SelectorRegistrationID
}
class MultiThreadedEventLoopGroup {
    enum _CanBeShutDown {
        case yes
        case no
        case notByUser
    }
    enum RunState {
        case closing()
        case closed(Swift.Error?)
        case running
    }
    let myGroupID: Swift.Int
    let index: Atomics.ManagedAtomic<Swift.Int>
    var eventLoops: [NIOPosix.SelectableEventLoop]
    let shutdownLock: NIOConcurrencyHelpers.NIOLock
    let threadNamePrefix: Swift.String
    var runState: NIOPosix.MultiThreadedEventLoopGroup.RunState
    let canBeShutDown: NIOPosix.MultiThreadedEventLoopGroup._CanBeShutDown
}
struct ErasedUnownedJob {
    let erasedJob: Any
}
struct ScheduledTask {
    enum Kind {
        case task(task: () -> (), failFn: (_: Swift.Error) -> ())
        case callback(NIOCore.NIOScheduledCallbackHandler)
    }
    let kind: NIOPosix.ScheduledTask.Kind
    let id: Swift.UInt64
    let readyTime: NIOCore.NIODeadline
}
enum NIOThreadPoolError {
    struct ThreadPoolInactive {}
    struct UnsupportedOperation {}
}
class NIOThreadPool {
    enum WorkItemState {
        case active
        case cancelled
    }
    struct IdentifiableWorkItem {
        var workItem: 
        var id: Swift.Int?
    }
    enum State {
        case shuttingDown([Swift.Bool])
        case running(DequeModule.Deque<NIOPosix.NIOThreadPool.IdentifiableWorkItem>)
        case stopped
        case modifying
    }
    enum _WorkState {
        case hasWork
        case hasNoWork
    }
    let _conditionLock: NIOConcurrencyHelpers.ConditionLock<NIOPosix.NIOThreadPool._WorkState>
    var threads: [NIOPosix.NIOThread]?
    var _state: NIOPosix.NIOThreadPool.State
    var _cancelledWorkIDs: Swift.Set<Swift.Int>
    let nextWorkID: Atomics.ManagedAtomic<Swift.Int>
    let numberOfThreads: Swift.Int
    let canBeStopped: Swift.Bool
}
struct NonBlockingFileIO {
    enum Error {
        case descriptorSetToNonBlocking
    }
    let threadPool: NIOPosix.NIOThreadPool
}
struct NIODirectoryEntry {
    var ino: Swift.UInt64
    var type: Swift.UInt8
    var name: Swift.String
}
class PendingDatagramWritesManager {
    let bufferPool: NIOPosix.Pool<NIOPosix.PooledBuffer>
    let msgBufferPool: NIOPosix.Pool<NIOPosix.PooledMsgBuffer>
    var state: NIOPosix.PendingDatagramWritesState
    var waterMark: NIOCore.ChannelOptions.Types.WriteBufferWaterMark
    let channelWritabilityFlag: Atomics.ManagedAtomic<Swift.Bool>
    var publishedWritability: Swift.Bool
    var writeSpinCount: Swift.UInt
    var isOpen: Swift.Bool
}
struct PendingDatagramWritesState {
    struct FlushedDatagramWriteSequence {
        let pendingWrites: NIOPosix.PendingDatagramWritesState
        var index: NIOCore.CircularBuffer<NIOPosix.PendingDatagramWrite>.Index
        let markedIndex: NIOCore.CircularBuffer<NIOPosix.PendingDatagramWrite>.Index?
    }
    var pendingWrites: NIOCore.MarkedCircularBuffer<NIOPosix.PendingDatagramWrite>
    var chunks: Swift.Int
    var bytes: Swift.Int64
    var remoteAddress: NIOCore.SocketAddress?
}
struct PendingDatagramWrite {
    var data: NIOCore.ByteBuffer
    var promise: NIOCore.EventLoopPromise<()>?
    let address: NIOCore.SocketAddress?
    var metadata: NIOCore.AddressedEnvelope<NIOCore.ByteBuffer>.Metadata?
}
struct NIOReportedIncompleteWritesWhenNoMoreToPerform {}
struct NIOReportedOpenAfterClose {}
struct NIOReportedPendingWritesInInvalidState {}
class PendingStreamWritesManager {
    var state: NIOPosix.PendingStreamWritesState
    let bufferPool: NIOPosix.Pool<NIOPosix.PooledBuffer>
    var waterMark: NIOCore.ChannelOptions.Types.WriteBufferWaterMark
    let channelWritabilityFlag: Atomics.ManagedAtomic<Swift.Bool>
    var publishedWritability: Swift.Bool
    var writeSpinCount: Swift.UInt
    var isOpen: Swift.Bool
    var outboundCloseState: NIOPosix.CloseState
}
enum CloseState {
    case pending(NIOCore.EventLoopPromise<()>?)
    case readyForClose(NIOCore.EventLoopPromise<()>?)
    case open
    case closed
}
struct PendingStreamWritesState {
    var pendingWrites: NIOCore.MarkedCircularBuffer<NIOPosix.PendingStreamWrite>
    var bytes: Swift.Int64
}
struct PendingStreamWrite {
    var data: NIOCore.IOData
    var promise: NIOCore.EventLoopPromise<()>?
}
class PipeChannel: NIOPosix.BaseStreamSocketChannel<NIOPosix.PipePair> {
    enum Direction {
        case input
        case output
    }
    let pipePair: NIOPosix.PipePair
}
class SelectablePipeHandle {
    var fileDescriptor: Swift.Int32
}
class PipePair {
    let input: NIOPosix.SelectablePipeHandle?
    let output: NIOPosix.SelectablePipeHandle?
}
class Pool<A> where A: NIOPosix.PoolElement {
    let maxSize: Swift.Int
    var elements: [A]
}
struct PooledMsgBuffer {
    class BackingStorage: Swift.ManagedBuffer<NIOPosix.PooledMsgBuffer.PooledMsgBufferHead, Swift.UInt8> {}
    struct PooledMsgBufferHead {
        let count: Swift.Int
        let spaceForMsgHdrs: Swift.Int
        let spaceForAddresses: Swift.Int
        let spaceForControlData: Swift.Int
    }
    var storage: NIOPosix.PooledMsgBuffer.BackingStorage
}
struct PooledBuffer {
    class BackingStorage: Swift.ManagedBuffer<NIOPosix.PooledBuffer.PooledBufferHead, Swift.UInt8> {}
    struct PooledBufferHead {
        let iovectorCount: Swift.Int
        let spaceForIOVectors: Swift.Int
        let spaceForBufferOwners: Swift.Int
    }
    let storage: NIOPosix.PooledBuffer.BackingStorage
}
class NIORawSocketBootstrap {
    let group: NIOCore.EventLoopGroup
    var channelInitializer: 
    var _channelOptions: NIOCore.ChannelOptions.Storage
}
struct NIOEventLoopTickInfo {
    var eventLoopID: Swift.ObjectIdentifier
    var numberOfTasks: Swift.Int
    var sleepTime: NIOCore.TimeAmount
    var startTime: NIOCore.NIODeadline
    var endTime: NIOCore.NIODeadline
}
class SelectableEventLoop {
    enum ExternalState {
        case open
        case closing
        case closed
        case reclaimingResources
        case resourcesReclaimed
    }
    enum InternalState {
        case runningAndAcceptingNewRegistrations
        case runningButNotAcceptingNewRegistrations
        case noLongerRunning
        case exitingThread
    }
    let _selector: NIOPosix.Selector<NIOPosix.NIORegistration>
    let thread: NIOPosix.NIOThread
    var _pendingTaskPop: Swift.Bool
    var scheduledTaskCounter: Atomics.ManagedAtomic<Swift.UInt64>
    var _scheduledTasks: _NIODataStructures.PriorityQueue<NIOPosix.ScheduledTask>
    var _immediateTasks: DequeModule.Deque<NIOPosix.UnderlyingTask>
    let _uniqueID: NIOPosix.SelectableEventLoopUniqueID
    var tasksCopy: Swift.ContiguousArray<NIOPosix.UnderlyingTask>
    var _succeededVoidFuture: NIOCore.EventLoopFuture<()>?
    let canBeShutdownIndividually: Swift.Bool
    let _tasksLock: NIOConcurrencyHelpers.NIOLock
    let _externalStateLock: NIOConcurrencyHelpers.NIOLock
    var internalState: NIOPosix.SelectableEventLoop.InternalState
    var externalState: NIOPosix.SelectableEventLoop.ExternalState
    let bufferPool: NIOPosix.Pool<NIOPosix.PooledBuffer>
    let msgBufferPool: NIOPosix.Pool<NIOPosix.PooledMsgBuffer>
    var _parentGroup: NIOPosix.MultiThreadedEventLoopGroup?
    let promiseCreationStoreLock: NIOConcurrencyHelpers.NIOLock
    var _promiseCreationStore: [NIOCore._NIOEventLoopFutureIdentifier : (file: Swift.StaticString, line: Swift.UInt)]
    let metricsDelegate: NIOPosix.NIOEventLoopMetricsDelegate?
    var lastTickEndTime: NIOCore.NIODeadline
}
enum UnderlyingTask {
    case function(() -> ())
    case unownedJob(NIOPosix.ErasedUnownedJob)
    case callback(NIOCore.NIOScheduledCallbackHandler)
}
enum LoopTask {
    case scheduled(NIOPosix.ScheduledTask)
    case immediate(NIOPosix.UnderlyingTask)
}
struct SelectableEventLoopUniqueID {
    var _loopID: Swift.UInt32
    let _groupID: Swift.UInt32
}
enum SelectorLifecycleState {
    case open
    case closing
    case closed
}
struct SelectorEventSet {
    let rawValue: Swift.UInt8
}
class Selector<A> where A: NIOPosix.Registration {
    var lifecycleState: NIOPosix.SelectorLifecycleState
    var registrations: [Swift.Int : A]
    var registrationID: NIOPosix.SelectorRegistrationID
    let myThread: NIOPosix.NIOThread
    let externalSelectorFDLock: NIOConcurrencyHelpers.NIOLock
    var selectorFD: Swift.Int32
    var events: Swift.UnsafeMutablePointer<__C.kevent>
    var eventsCapacity: Swift.Int
}
struct SelectorEvent<A> {
    let registration: A
    var io: NIOPosix.SelectorEventSet
}
enum SelectorStrategy {
    case blockUntilTimeout(NIOCore.TimeAmount)
    case block
    case now
}
struct SelectorRegistrationID {
    var _rawValue: Swift.UInt32
}
class ServerSocket: NIOPosix.BaseSocket {
    let cleanupOnClose: Swift.Bool
}
class Socket: NIOPosix.BaseSocket {}
class SocketChannel: NIOPosix.BaseStreamSocketChannel<NIOPosix.Socket> {
    var connectTimeout: NIOCore.TimeAmount?
}
class ServerSocketChannel: NIOPosix.BaseSocketChannel<NIOPosix.ServerSocket> {
    var backlog: Swift.Int32
    let group: NIOCore.EventLoopGroup
}
class DatagramChannel: NIOPosix.BaseSocketChannel<NIOPosix.Socket> {
    var reportExplicitCongestionNotifications: Swift.Bool
    var receivePacketInfo: Swift.Bool
    let pendingWrites: NIOPosix.PendingDatagramWritesManager
    var vectorReadManager: NIOPosix.DatagramVectorReadManager?
}
enum Posix {}
struct NIOFcntlFailedError {}
struct NIOFailedToSetSocketNonBlockingError {}
enum KQueue {}
class NIOThread {
    enum Error {
        case threadAlreadyJoinedOrDetached
    }
    let desiredName: Swift.String?
    let handle: NIOConcurrencyHelpers.NIOLockedValueBox<NIOPosix.PthreadWrapper?>
}
class ThreadSpecificVariable<A> where A: AnyObject {
    class Key {
        var underlyingKey: Swift.UInt
    }
    let key: NIOPosix.ThreadSpecificVariable<A>.Key
}
struct PthreadWrapper {
    var handle: Swift.UnsafeMutablePointer<__C._opaque_pthread_t>
}
struct UnsafeTransfer<A> {
    var wrappedValue: A
}
class Box<A> {
    let value: A
}
struct VsockAddress {
    struct ContextID {
        var rawValue: Swift.UInt32
    }
    struct Port {
        var rawValue: Swift.UInt32
    }
    var cid: NIOPosix.VsockAddress.ContextID
    var port: NIOPosix.VsockAddress.Port
}
enum VsockChannelEvents {
    struct BindToAddress {
        var address: NIOPosix.VsockAddress
    }
    struct ConnectToAddress {
        var address: NIOPosix.VsockAddress
    }
}
class BetterHTTPParser {
    var delegate: NIOHTTP1.HTTPDecoderDelegate?
    var parser: __C.c_nio_llhttp__internal_s?
    var settings: Swift.UnsafeMutablePointer<__C.llhttp_settings_s>
    var decodingState: NIOHTTP1.HTTPDecodingState
    var firstNonDiscardableOffset: Swift.Int?
    var currentFieldByteLength: Swift.Int
    var httpParserOffset: Swift.Int
    var rawBytesView: Swift.UnsafeRawBufferPointer
    var httpErrno: __C.llhttp_errno?
    var richerError: Swift.Error?
    let kind: NIOHTTP1.HTTPDecoderKind
    var requestHeads: NIOCore.CircularBuffer<NIOHTTP1.HTTPRequestHead>
}
enum HTTPDecoderKind {
    case request
    case response
}
class HTTPDecoder<A, B> {
    var headers: [(Swift.String, Swift.String)]
    var trailers: [(Swift.String, Swift.String)]?
    var currentHeaderName: Swift.String?
    var url: Swift.String?
    var isUpgrade: Swift.Bool?
    var buffer: NIOCore.ByteBuffer?
    var context: NIOCore.ChannelHandlerContext?
    let parser: NIOHTTP1.BetterHTTPParser
    let leftOverBytesStrategy: NIOHTTP1.RemoveAfterUpgradeStrategy
    let informationalResponseStrategy: NIOHTTP1.NIOInformationalResponseStrategy
    let kind: NIOHTTP1.HTTPDecoderKind
    var stopParsing: Swift.Bool
    var lastResponseHeaderWasInformational: Swift.Bool
}
enum RemoveAfterUpgradeStrategy {
    case forwardBytes
    case fireError
    case dropBytes
}
struct NIOInformationalResponseStrategy {
    enum Base {
        case drop
        case forward
    }
    var base: NIOHTTP1.NIOInformationalResponseStrategy.Base
}
struct NIOHTTPDecoderError {
    enum BaseError {
        case unsolicitedResponse
    }
    let baseError: NIOHTTP1.NIOHTTPDecoderError.BaseError
}
enum HTTPDecodingState {
    case beforeMessageBegin
    case afterMessageBegin
    case url
    case headerName
    case headerValue
    case trailerName
    case trailerValue
    case headersComplete
}
class HTTPRequestEncoder {
    struct Configuration {
        var automaticallySetFramingHeaders: Swift.Bool
    }
    var isChunked: Swift.Bool
    var configuration: NIOHTTP1.HTTPRequestEncoder.Configuration
}
class HTTPResponseEncoder {
    struct Configuration {
        var automaticallySetFramingHeaders: Swift.Bool
    }
    var isChunked: Swift.Bool
    var configuration: NIOHTTP1.HTTPResponseEncoder.Configuration
}
class NIOHTTPRequestHeadersValidator {}
class NIOHTTPResponseHeadersValidator {
    enum State {
        case validating
        case dropping
    }
    var state: NIOHTTP1.NIOHTTPResponseHeadersValidator.State
}
class HTTPServerPipelineHandler {
    struct ConnectionStateError {
        enum Base {
            case preconditionViolated(message: Swift.String)
        }
        var base: NIOHTTP1.HTTPServerPipelineHandler.ConnectionStateError.Base
        var file: Swift.String
        var line: Swift.Int
    }
    enum NextExpectedMessageType {
        case head
        case bodyOrEnd
    }
    enum LifecycleState {
        case acceptingEvents
        case quiescingWaitingForRequestEnd
        case quiescingLastRequestEndReceived
        case quiescingCompleted
    }
    enum ConnectionState {
        case responseEndPending
        case requestAndResponseEndPending
        case idle
        case requestEndPending
        case sentCloseOutputRequestEndPending
        case sentCloseOutput
        case preconditionFailed
    }
    enum BufferedEvent {
        case channelRead(NIOCore.NIOAny)
        case error(NIOHTTP1.HTTPParserError)
        case halfClose
    }
    var failOnPreconditions: Swift.Bool
    var state: NIOHTTP1.HTTPServerPipelineHandler.ConnectionState
    var readPending: Swift.Bool
    var eventBuffer: NIOCore.CircularBuffer<NIOHTTP1.HTTPServerPipelineHandler.BufferedEvent>
    var lifecycleState: NIOHTTP1.HTTPServerPipelineHandler.LifecycleState
    var nextExpectedInboundMessage: NIOHTTP1.HTTPServerPipelineHandler.NextExpectedMessageType?
    var nextExpectedOutboundMessage: NIOHTTP1.HTTPServerPipelineHandler.NextExpectedMessageType?
}
class HTTPServerProtocolErrorHandler {
    var hasUnterminatedResponse: Swift.Bool
}
enum HTTPServerUpgradeErrors {
    case invalidHTTPOrdering
}
enum HTTPServerUpgradeEvents {
    case upgradeComplete(toProtocol: Swift.String, upgradeRequest: NIOHTTP1.HTTPRequestHead)
}
class HTTPServerUpgradeHandler {
    enum UpgradeState {
        case upgraderReady(() -> ())
        case idle
        case awaitingUpgrader
        case upgrading
        case upgradeFailed
        case upgradeComplete
    }
    let upgraders: [Swift.String : NIOHTTP1.HTTPServerProtocolUpgrader]
    let upgradeCompletionHandler: (_: NIOCore.ChannelHandlerContext) -> ()
    let httpEncoder: NIOHTTP1.HTTPResponseEncoder
    let extraHTTPHandlers: [NIOCore.RemovableChannelHandler]
    var seenFirstRequest: Swift.Bool
    var upgradeState: NIOHTTP1.HTTPServerUpgradeHandler.UpgradeState
    var receivedMessages: NIOCore.CircularBuffer<NIOCore.NIOAny>
}
struct NIOUpgradableHTTPServerPipelineConfiguration<A> {
    var enablePipelining: Swift.Bool
    var enableErrorHandling: Swift.Bool
    var enableResponseHeaderValidation: Swift.Bool
    var encoderConfiguration: NIOHTTP1.HTTPResponseEncoder.Configuration
    var upgradeConfiguration: NIOHTTP1.NIOTypedHTTPServerUpgradeConfiguration<A>
}
struct NIOUpgradableHTTPClientPipelineConfiguration<A> {
    var leftOverBytesStrategy: NIOHTTP1.RemoveAfterUpgradeStrategy
    var enableOutboundHeaderValidation: Swift.Bool
    var encoderConfiguration: NIOHTTP1.HTTPRequestEncoder.Configuration
    var upgradeConfiguration: NIOHTTP1.NIOTypedHTTPClientUpgradeConfiguration<A>
}
struct HTTPRequestHead {
    class _Storage {
        var method: NIOHTTP1.HTTPMethod
        var uri: Swift.String
        var version: NIOHTTP1.HTTPVersion
    }
    var _storage: NIOHTTP1.HTTPRequestHead._Storage
    var headers: NIOHTTP1.HTTPHeaders
}
enum HTTPPart<A, B> where A: Swift.Equatable, B: Swift.Equatable {
    case head(A)
    case body(B)
    case end(NIOHTTP1.HTTPHeaders?)
}
struct HTTPResponseHead {
    class _Storage {
        var status: NIOHTTP1.HTTPResponseStatus
        var version: NIOHTTP1.HTTPVersion
    }
    var _storage: NIOHTTP1.HTTPResponseHead._Storage
    var headers: NIOHTTP1.HTTPHeaders
}
struct HTTPHeaders {
    struct Index {
        let base: Swift.Int
    }
    var headers: [(Swift.String, Swift.String)]
    var keepAliveState: NIOHTTP1.KeepAliveState
}
enum HTTPMethod {
    case RAW(value: Swift.String)
    case GET
    case PUT
    case ACL
    case HEAD
    case POST
    case COPY
    case LOCK
    case MOVE
    case BIND
    case LINK
    case PATCH
    case TRACE
    case MKCOL
    case MERGE
    case PURGE
    case NOTIFY
    case SEARCH
    case UNLOCK
    case REBIND
    case UNBIND
    case REPORT
    case DELETE
    case UNLINK
    case CONNECT
    case MSEARCH
    case OPTIONS
    case PROPFIND
    case CHECKOUT
    case PROPPATCH
    case SUBSCRIBE
    case MKCALENDAR
    case MKACTIVITY
    case UNSUBSCRIBE
    case SOURCE
}
struct HTTPVersion {
    var _minor: Swift.UInt16
    var _major: Swift.UInt16
}
enum HTTPParserError {
    case invalidCharactersUsed
    case trailingGarbage
    case invalidEOFState
    case headerOverflow
    case closedConnection
    case invalidVersion
    case invalidStatus
    case invalidMethod
    case invalidURL
    case invalidHost
    case invalidPort
    case invalidPath
    case invalidQueryString
    case invalidFragment
    case lfExpected
    case invalidHeaderToken
    case invalidContentLength
    case unexpectedContentLength
    case invalidChunkSize
    case invalidConstant
    case invalidInternalState
    case strictModeAssertion
    case paused
    case unknown
}
enum HTTPResponseStatus {
    case custom(code: Swift.UInt, reasonPhrase: Swift.String)
    case continue
    case switchingProtocols
    case processing
    case ok
    case created
    case accepted
    case nonAuthoritativeInformation
    case noContent
    case resetContent
    case partialContent
    case multiStatus
    case alreadyReported
    case imUsed
    case multipleChoices
    case movedPermanently
    case found
    case seeOther
    case notModified
    case useProxy
    case temporaryRedirect
    case permanentRedirect
    case badRequest
    case unauthorized
    case paymentRequired
    case forbidden
    case notFound
    case methodNotAllowed
    case notAcceptable
    case proxyAuthenticationRequired
    case requestTimeout
    case conflict
    case gone
    case lengthRequired
    case preconditionFailed
    case payloadTooLarge
    case uriTooLong
    case unsupportedMediaType
    case rangeNotSatisfiable
    case expectationFailed
    case imATeapot
    case misdirectedRequest
    case unprocessableEntity
    case locked
    case failedDependency
    case upgradeRequired
    case preconditionRequired
    case tooManyRequests
    case requestHeaderFieldsTooLarge
    case unavailableForLegalReasons
    case internalServerError
    case notImplemented
    case badGateway
    case serviceUnavailable
    case gatewayTimeout
    case httpVersionNotSupported
    case variantAlsoNegotiates
    case insufficientStorage
    case loopDetected
    case notExtended
    case networkAuthenticationRequired
}
enum KeepAliveState {
    case keepAlive
    case close
    case unknown
}
struct NIOHTTPClientUpgradeError {
    enum Code {
        case responseProtocolNotFound
        case invalidHTTPOrdering
        case upgraderDeniedUpgrade
        case writingToHandlerDuringUpgrade
        case writingToHandlerAfterUpgradeCompleted
        case writingToHandlerAfterUpgradeFailed
        case receivedResponseBeforeRequestSent
        case receivedResponseAfterUpgradeCompleted
    }
    var code: NIOHTTP1.NIOHTTPClientUpgradeError.Code
}
class NIOHTTPClientUpgradeHandler {
    enum UpgradeState {
        case upgraderReady(() -> ())
        case requestRequired
        case awaitingConfirmationResponse
        case upgrading
        case upgradingAddingHandlers
        case upgradeComplete
        case upgradeFailed
    }
    var upgraders: [NIOHTTP1.NIOHTTPClientProtocolUpgrader]
    let httpHandlers: [NIOCore.RemovableChannelHandler]
    let upgradeCompletionHandler: (_: NIOCore.ChannelHandlerContext) -> ()
    var seenFirstResponse: Swift.Bool
    var upgradeState: NIOHTTP1.NIOHTTPClientUpgradeHandler.UpgradeState
    var receivedMessages: NIOCore.CircularBuffer<NIOCore.NIOAny>
}
struct NIOHTTPServerRequestFull {
    var head: NIOHTTP1.HTTPRequestHead
    var body: NIOCore.ByteBuffer?
}
struct NIOHTTPClientResponseFull {
    var head: NIOHTTP1.HTTPResponseHead
    var body: NIOCore.ByteBuffer?
}
struct NIOHTTPObjectAggregatorError {
    enum Base {
        case frameTooLong
        case connectionClosed
        case endingIgnoredMessage
        case unexpectedMessageHead
        case unexpectedMessageBody
        case unexpectedMessageEnd
    }
    var base: NIOHTTP1.NIOHTTPObjectAggregatorError.Base
}
struct NIOHTTPObjectAggregatorEvent {
    enum Base {
        case httpExpectationFailed
        case httpFrameTooLong
    }
    var base: NIOHTTP1.NIOHTTPObjectAggregatorEvent.Base
}
class NIOHTTPServerRequestAggregator {
    var fullMessageHead: NIOHTTP1.HTTPRequestHead?
    var buffer: NIOCore.ByteBuffer?
    var maxContentLength: Swift.Int
    var closeOnExpectationFailed: Swift.Bool
    var state: NIOHTTP1.AggregatorState
}
class NIOHTTPClientResponseAggregator {
    var fullMessageHead: NIOHTTP1.HTTPResponseHead?
    var buffer: NIOCore.ByteBuffer?
    var maxContentLength: Swift.Int
    var state: NIOHTTP1.AggregatorState
}
enum AggregatorState {
    case idle
    case ignoringContent
    case receiving
    case closed
}
struct NIOTypedHTTPClientUpgradeConfiguration<A> {
    var upgradeRequestHead: NIOHTTP1.HTTPRequestHead
    var upgraders: [A]
    var notUpgradingCompletionHandler: 
}
class NIOTypedHTTPClientUpgradeHandler<A> {
    let upgradeRequestHead: NIOHTTP1.HTTPRequestHead
    let httpHandlers: [NIOCore.RemovableChannelHandler]
    let notUpgradingCompletionHandler: 
    var stateMachine: NIOHTTP1.NIOTypedHTTPClientUpgraderStateMachine<A>
    var _upgradeResultPromise: NIOCore.EventLoopPromise<A>?
}
struct NIOTypedHTTPClientUpgraderStateMachine<A> {
    enum State {
        struct Unbuffering {
            var buffer: DequeModule.Deque<NIOCore.NIOAny>
        }
        struct Upgrading {
            var buffer: DequeModule.Deque<NIOCore.NIOAny>
        }
        struct AwaitingUpgradeResponseEnd {
            var upgrader: A
            var responseHead: NIOHTTP1.HTTPResponseHead
        }
        case initial(upgraders: [A])
        case awaitingUpgradeResponseHead(upgraders: [A])
        case awaitingUpgradeResponseEnd(NIOHTTP1.NIOTypedHTTPClientUpgraderStateMachine<A>.State.AwaitingUpgradeResponseEnd)
        case upgrading(NIOHTTP1.NIOTypedHTTPClientUpgraderStateMachine<A>.State.Upgrading)
        case unbuffering(NIOHTTP1.NIOTypedHTTPClientUpgraderStateMachine<A>.State.Unbuffering)
        case finished
        case modifying
    }
    enum UpgradingHandlerCompletedAction {
        case fireErrorCaughtAndStartUnbuffering(Swift.Error)
        case removeHandler(A)
        case fireErrorCaughtAndRemoveHandler(Swift.Error)
        case startUnbuffering(A)
    }
    var state: NIOHTTP1.NIOTypedHTTPClientUpgraderStateMachine<A>.State
}
struct NIOTypedHTTPServerUpgradeConfiguration<A> {
    var upgraders: [A]
    var notUpgradingCompletionHandler: 
}
class NIOTypedHTTPServerUpgradeHandler<A> {
    let upgraders: [Swift.String : A]
    let notUpgradingCompletionHandler: 
    let httpEncoder: NIOHTTP1.HTTPResponseEncoder
    let extraHTTPHandlers: [NIOCore.RemovableChannelHandler]
    var stateMachine: NIOHTTP1.NIOTypedHTTPServerUpgraderStateMachine<A>
    var _upgradeResultPromise: NIOCore.EventLoopPromise<A>?
}
struct NIOTypedHTTPServerUpgraderStateMachine<A> {
    enum State {
        enum BufferedState {
            case data(NIOCore.NIOAny)
            case inputClosed
        }
        struct Unbuffering {
            var buffer: DequeModule.Deque<NIOHTTP1.NIOTypedHTTPServerUpgraderStateMachine<A>.State.BufferedState>
        }
        struct Upgrading {
            var buffer: DequeModule.Deque<NIOHTTP1.NIOTypedHTTPServerUpgraderStateMachine<A>.State.BufferedState>
        }
        struct UpgraderReady {
            var upgrader: A
            var requestHead: NIOHTTP1.HTTPRequestHead
            var responseHeaders: NIOHTTP1.HTTPHeaders
            var proto: Swift.String
            var buffer: DequeModule.Deque<NIOHTTP1.NIOTypedHTTPServerUpgraderStateMachine<A>.State.BufferedState>
        }
        struct AwaitingUpgrader {
            var seenFirstRequest: Swift.Bool
            var buffer: DequeModule.Deque<NIOHTTP1.NIOTypedHTTPServerUpgraderStateMachine<A>.State.BufferedState>
        }
        case awaitingUpgrader(NIOHTTP1.NIOTypedHTTPServerUpgraderStateMachine<A>.State.AwaitingUpgrader)
        case upgraderReady(NIOHTTP1.NIOTypedHTTPServerUpgraderStateMachine<A>.State.UpgraderReady)
        case upgrading(NIOHTTP1.NIOTypedHTTPServerUpgraderStateMachine<A>.State.Upgrading)
        case unbuffering(NIOHTTP1.NIOTypedHTTPServerUpgraderStateMachine<A>.State.Unbuffering)
        case initial
        case finished
        case modifying
    }
    enum UpgradingHandlerCompletedAction {
        case fireErrorCaughtAndStartUnbuffering(Swift.Error)
        case removeHandler(A)
        case fireErrorCaughtAndRemoveHandler(Swift.Error)
        case startUnbuffering(A)
    }
    var state: NIOHTTP1.NIOTypedHTTPServerUpgraderStateMachine<A>.State
}
class BrowserTokenProvider {
    var credentials: OAuth1.Credentials
    var token: OAuth1.Token?
    var sem: __C.OS_dispatch_semaphore?
}
enum AuthError {
    case invalidTokenFile
    case tokenRequestFailed
}
struct Credentials {
    enum CodingKeys {
        case consumerKey
        case consumerSecret
        case requestTokenURL
        case authorizeURL
        case accessTokenURL
        case callback
    }
    let consumerKey: Swift.String
    let consumerSecret: Swift.String
    let requestTokenURL: Swift.String
    let authorizeURL: Swift.String
    let accessTokenURL: Swift.String
    let callback: Swift.String
}
class Connection {
    var provider: OAuth1.TokenProvider
}
struct Token {
    enum CodingKeys {
        case oAuthToken
        case oAuthTokenSecret
        case oAuthVerifier
        case returnAddress
        case screenName
        case userID
        case creationTime
    }
    var oAuthToken: Swift.String?
    var oAuthTokenSecret: Swift.String?
    var oAuthVerifier: Swift.String?
    var returnAddress: Swift.String?
    var screenName: Swift.String?
    var userID: Swift.String?
    var creationTime: Foundation.Date?
}
class AEADChaCha20Poly1305 {}
class AES {
    enum Error {
        case invalidKeySize
        case dataPaddingRequired
        case invalidData
    }
    enum Variant {
        case aes128
        case aes192
        case aes256
    }
    let variantNr: Swift.Int
    let variantNb: Swift.Int
    let variantNk: Swift.Int
    let keySize: Swift.Int
    let variant: CryptoSwift.AES.Variant
    let key: CryptoSwift.SecureBytes
    let blockMode: CryptoSwift.BlockMode
    let padding: CryptoSwift.Padding
    lazy var expandedKey: [[Swift.UInt32]]?
    lazy var expandedKeyInv: [[Swift.UInt32]]?
    lazy var sBoxes: (sBox: [Swift.UInt32], invSBox: [Swift.UInt32])?
    lazy var sBox: [Swift.UInt32]?
    lazy var sBoxInv: [Swift.UInt32]?
}
struct BatchedCollection<A> where A: Swift.Collection {
    let base: A
    let size: Swift.Int
}
struct BatchedCollectionIndex<A> where A: Swift.Collection {
    let range: Swift.Range<A.Collection.Index>
}
enum Bit {
    case zero
    case one
}
class BlockDecryptor {
    let blockSize: Swift.Int
    let padding: CryptoSwift.Padding
    var worker: CryptoSwift.CipherModeWorker
    var accumulated: [Swift.UInt8]
}
class BlockEncryptor {
    let blockSize: Swift.Int
    var worker: CryptoSwift.CipherModeWorker
    let padding: CryptoSwift.Padding
    var accumulated: [Swift.UInt8]
    var lastBlockRemainder: Swift.Int
}
struct BlockModeOption {
    let rawValue: Swift.Int
}
struct CBC {
    enum Error {
        case invalidInitializationVector
    }
    let options: CryptoSwift.BlockModeOption
    let iv: [Swift.UInt8]
}
struct CBCModeWorker {
    let cipherOperation: (_: Swift.ArraySlice<Swift.UInt8>) -> [Swift.UInt8]?
    var blockSize: Swift.Int
    let additionalBufferSize: Swift.Int
    let iv: Swift.ArraySlice<Swift.UInt8>
    var prev: Swift.ArraySlice<Swift.UInt8>?
}
struct CCM {
    enum Error {
        case invalidInitializationVector
        case invalidParameter
        case fail
    }
    let options: CryptoSwift.BlockModeOption
    let nonce: [Swift.UInt8]
    let additionalAuthenticatedData: [Swift.UInt8]?
    let tagLength: Swift.Int
    let messageLength: Swift.Int
    var authenticationTag: [Swift.UInt8]?
}
class CCMModeWorker {
    enum Error {
        case invalidParameter
    }
    var counter: Swift.Int
    let cipherOperation: (_: Swift.ArraySlice<Swift.UInt8>) -> [Swift.UInt8]?
    let blockSize: Swift.Int
    let tagLength: Swift.Int
    let messageLength: Swift.Int
    let q: Swift.UInt8
    let additionalBufferSize: Swift.Int
    var keystreamPosIdx: Swift.Int
    let nonce: [Swift.UInt8]
    var last_y: Swift.ArraySlice<Swift.UInt8>
    var keystream: [Swift.UInt8]
    var expectedTag: [Swift.UInt8]?
    var accumulatedPlaintext: [Swift.UInt8]
}
struct CFB {
    enum Error {
        case invalidInitializationVector
    }
    let options: CryptoSwift.BlockModeOption
    let iv: [Swift.UInt8]
}
struct CFBModeWorker {
    let cipherOperation: (_: Swift.ArraySlice<Swift.UInt8>) -> [Swift.UInt8]?
    let blockSize: Swift.Int
    let additionalBufferSize: Swift.Int
    let iv: Swift.ArraySlice<Swift.UInt8>
    var prev: Swift.ArraySlice<Swift.UInt8>?
}
struct CTR {
    enum Error {
        case invalidInitializationVector
    }
    let options: CryptoSwift.BlockModeOption
    let iv: [Swift.UInt8]
    let counter: Swift.Int
}
struct CTRModeWorker {
    class CTRCounter {
        let constPrefix: [Swift.UInt8]
        var value: Swift.UInt64
    }
    let cipherOperation: (_: Swift.ArraySlice<Swift.UInt8>) -> [Swift.UInt8]?
    let additionalBufferSize: Swift.Int
    let iv: [Swift.UInt8]
    var counter: CryptoSwift.CTRModeWorker.CTRCounter
    let blockSize: Swift.Int
    var keystream: [Swift.UInt8]
    var keystreamPosIdx: Swift.Int
}
struct ECB {
    let options: CryptoSwift.BlockModeOption
}
struct ECBModeWorker {
    let cipherOperation: (_: Swift.ArraySlice<Swift.UInt8>) -> [Swift.UInt8]?
    let blockSize: Swift.Int
    let additionalBufferSize: Swift.Int
}
class GCM {
    enum Mode {
        case combined
        case detached
    }
    enum Error {
        case invalidInitializationVector
        case fail
    }
    let options: CryptoSwift.BlockModeOption
    let iv: [Swift.UInt8]
    let additionalAuthenticatedData: [Swift.UInt8]?
    let mode: CryptoSwift.GCM.Mode
    let tagLength: Swift.Int
    var authenticationTag: [Swift.UInt8]?
}
class GCMModeWorker {
    let cipherOperation: (_: Swift.ArraySlice<Swift.UInt8>) -> [Swift.UInt8]?
    var didCalculateTag: ((_: [Swift.UInt8]) -> ())?
    let tagLength: Swift.Int
    let blockSize: Swift.Int
    let additionalBufferSize: Swift.Int
    let iv: Swift.ArraySlice<Swift.UInt8>
    let mode: CryptoSwift.GCM.Mode
    var counter: CryptoSwift.UInt128
    let eky0: CryptoSwift.UInt128
    let h: CryptoSwift.UInt128
    let aad: Swift.ArraySlice<Swift.UInt8>?
    var expectedTag: [Swift.UInt8]?
    lazy var gf: CryptoSwift.GF?
}
class GF {
    let blockSize: Swift.Int
    let h: CryptoSwift.UInt128
    let aadLength: Swift.Int
    var ciphertextLength: Swift.Int
    var x: CryptoSwift.UInt128
}
struct OFB {
    enum Error {
        case invalidInitializationVector
    }
    let options: CryptoSwift.BlockModeOption
    let iv: [Swift.UInt8]
}
struct OFBModeWorker {
    let cipherOperation: (_: Swift.ArraySlice<Swift.UInt8>) -> [Swift.UInt8]?
    let blockSize: Swift.Int
    let additionalBufferSize: Swift.Int
    let iv: Swift.ArraySlice<Swift.UInt8>
    var prev: Swift.ArraySlice<Swift.UInt8>?
}
struct PCBC {
    enum Error {
        case invalidInitializationVector
    }
    let options: CryptoSwift.BlockModeOption
    let iv: [Swift.UInt8]
}
struct PCBCModeWorker {
    let cipherOperation: (_: Swift.ArraySlice<Swift.UInt8>) -> [Swift.UInt8]?
    var blockSize: Swift.Int
    let additionalBufferSize: Swift.Int
    let iv: Swift.ArraySlice<Swift.UInt8>
    var prev: Swift.ArraySlice<Swift.UInt8>?
}
class Blowfish {
    enum Error {
        case dataPaddingRequired
        case invalidKeyOrInitializationVector
        case invalidInitializationVector
        case invalidBlockMode
    }
    let keySize: Swift.Int
    let blockMode: CryptoSwift.BlockMode
    let padding: CryptoSwift.Padding
    var decryptWorker: CryptoSwift.CipherModeWorker?
    var encryptWorker: CryptoSwift.CipherModeWorker?
    let N: Swift.Int
    var P: [Swift.UInt32]
    var S: [[Swift.UInt32]]
    let origP: [Swift.UInt32]
    let origS: [[Swift.UInt32]]
}
class CBCMAC: CryptoSwift.CMAC {}
class CMAC {
    enum Error {
        case wrongKeyLength
    }
    let key: CryptoSwift.SecureBytes
}
class ChaCha20 {
    enum Error {
        case invalidKeyOrInitializationVector
        case notSupported
    }
    struct ChaChaEncryptor {
        var accumulated: [Swift.UInt8]
        let chacha: CryptoSwift.ChaCha20
    }
    struct ChaChaDecryptor {
        var accumulated: [Swift.UInt8]
        var offset: Swift.Int
        var offsetToRemove: Swift.Int
        let chacha: CryptoSwift.ChaCha20
    }
    let keySize: Swift.Int
    let key: CryptoSwift.SecureBytes
    var counter: [Swift.UInt8]
}
class Checksum {}
enum CipherError {
    case encrypt
    case decrypt
}
struct Digest {}
struct HKDF {
    enum Error {
        case invalidInput
        case derivedKeyTooLong
    }
    let numBlocks: Swift.Int
    let dkLen: Swift.Int
    let info: [Swift.UInt8]
    let prk: [Swift.UInt8]
    let variant: CryptoSwift.HMAC.Variant
}
class HMAC {
    enum Error {
        case authenticateError
        case invalidInput
    }
    enum Variant {
        case sha1
        case sha256
        case sha384
        case sha512
        case md5
    }
    var key: [Swift.UInt8]
    let variant: CryptoSwift.HMAC.Variant
}
class MD5 {
    var accumulated: [Swift.UInt8]
    var processedBytesTotalCount: Swift.Int
    var accumulatedHash: [Swift.UInt32]
    let s: [Swift.UInt32]
    let k: [Swift.UInt32]
}
enum PKCS5 {
    struct PBKDF1 {
        enum Error {
            case invalidInput
            case derivedKeyTooLong
        }
        enum Variant {
            case md5
            case sha1
        }
        let iterations: Swift.Int
        let variant: CryptoSwift.PKCS5.PBKDF1.Variant
        let keyLength: Swift.Int
        let t1: [Swift.UInt8]
    }
    struct PBKDF2 {
        enum Error {
            case invalidInput
            case derivedKeyTooLong
        }
        let salt: [Swift.UInt8]
        let iterations: Swift.Int
        let numBlocks: Swift.Int
        let dkLen: Swift.Int
        let prf: CryptoSwift.HMAC
    }
}
enum PKCS7 {}
enum Padding {
    case noPadding
    case zeroPadding
    case pkcs7
    case pkcs5
    case iso78164
}
class Poly1305 {
    enum Error {
        case authenticateError
    }
    let key: CryptoSwift.SecureBytes
}
class Rabbit {
    enum Error {
        case invalidKeyOrInitializationVector
    }
    let key: CryptoSwift.SecureBytes
    let iv: [Swift.UInt8]?
    var x: [Swift.UInt32]
    var c: [Swift.UInt32]
    var p7: Swift.UInt32
    var a: [Swift.UInt32]
}
class SHA1 {
    var accumulated: [Swift.UInt8]
    var processedBytesTotalCount: Swift.Int
    var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
}
class SHA2 {
    enum Variant {
        case sha224
        case sha256
        case sha384
        case sha512
    }
    let variant: CryptoSwift.SHA2.Variant
    let size: Swift.Int
    let blockSize: Swift.Int
    let digestLength: Swift.Int
    let k: [Swift.UInt64]
    var accumulated: [Swift.UInt8]
    var processedBytesTotalCount: Swift.Int
    var accumulatedHash32: [Swift.UInt32]
    var accumulatedHash64: [Swift.UInt64]
}
class SHA3 {
    enum Variant {
        case sha224
        case sha256
        case sha384
        case sha512
        case keccak224
        case keccak256
        case keccak384
        case keccak512
    }
    let round_constants: [Swift.UInt64]
    let blockSize: Swift.Int
    let digestLength: Swift.Int
    let markByte: Swift.UInt8
    var accumulated: [Swift.UInt8]
    var accumulatedHash: [Swift.UInt64]
}
class Scrypt {
    enum Error {
        case nIsTooLarge
        case rIsTooLarge
        case nMustBeAPowerOf2GreaterThan1
        case invalidInput
    }
    let salt: CryptoSwift.SecureBytes
    let password: CryptoSwift.SecureBytes
    let blocksize: Swift.Int
    let salsaBlock: Swift.UnsafeMutableRawPointer
    let dkLen: Swift.Int
    let N: Swift.Int
    let r: Swift.Int
    let p: Swift.Int
}
class SecureBytes {
    let bytes: [Swift.UInt8]
    let count: Swift.Int
}
class StreamDecryptor {
    let blockSize: Swift.Int
    var worker: CryptoSwift.CipherModeWorker
    let padding: CryptoSwift.Padding
    var accumulated: [Swift.UInt8]
    var lastBlockRemainder: Swift.Int
}
class StreamEncryptor {
    let blockSize: Swift.Int
    var worker: CryptoSwift.CipherModeWorker
    let padding: CryptoSwift.Padding
    var lastBlockRemainder: Swift.Int
}
struct UInt128 {
    let i: (a: Swift.UInt64, b: Swift.UInt64)
}
class BundleFinder {}
struct GoogleSignInButton {
    var _viewModel: SwiftUI.ObservedObject<GoogleSignInSwift.GoogleSignInButtonViewModel>
    let action: () -> ()
    let fontLoaded: Swift.Bool
}
enum GoogleSignInButtonStyle {
    case standard
    case wide
    case icon
}
enum GoogleSignInButtonColorScheme {
    case dark
    case light
}
enum GoogleSignInButtonState {
    case normal
    case disabled
    case pressed
}
struct SwiftUIButtonStyle {
    let style: GoogleSignInSwift.GoogleSignInButtonStyle
    let state: GoogleSignInSwift.GoogleSignInButtonState
    let scheme: GoogleSignInSwift.GoogleSignInButtonColorScheme
}
class GoogleSignInButtonViewModel {
    var _scheme: Combine.Published<GoogleSignInSwift.GoogleSignInButtonColorScheme>
    var _style: Combine.Published<GoogleSignInSwift.GoogleSignInButtonStyle>
    var _state: Combine.Published<GoogleSignInSwift.GoogleSignInButtonState>
}
class BundleFinder {}
class ActionCodeInfo: __C.NSObject {
    let operation: FirebaseAuth.ActionCodeOperation
    let email: Swift.String
    let previousEmail: Swift.String?
}
enum ActionCodeOperation {}
class ActionCodeSettings: __C.NSObject {
    class SendableActionCodeSettings {
        let url: FirebaseCoreInternal.UnfairLock<Foundation.URL?>
        let handleCodeInApp: FirebaseCoreInternal.UnfairLock<Swift.Bool>
        let iOSBundleID: FirebaseCoreInternal.UnfairLock<Swift.String?>
        let androidPackageName: FirebaseCoreInternal.UnfairLock<Swift.String?>
        let androidMinimumVersion: FirebaseCoreInternal.UnfairLock<Swift.String?>
        let androidInstallIfNotAvailable: FirebaseCoreInternal.UnfairLock<Swift.Bool>
        let linkDomain: FirebaseCoreInternal.UnfairLock<Swift.String?>
    }
    let impl: FirebaseAuth.ActionCodeSettings.SendableActionCodeSettings
}
class ActionCodeURL: __C.NSObject {
    let apiKey: Swift.String?
    let operation: FirebaseAuth.ActionCodeOperation
    let code: Swift.String?
    let continueURL: Foundation.URL?
    let languageCode: Swift.String?
}
class Auth: __C.NSObject {
    weak var app: __C.FIRApp?
    var _currentUser: FirebaseAuth.User?
    var settings: FirebaseAuth.AuthSettings?
    var userAccessGroup: Swift.String?
    var shareAuthStateAcrossDevices: Swift.Bool
    var tenantID: Swift.String?
    var customAuthDomain: Swift.String?
    var mainBundleUrlTypes: [[Swift.String : Any]]?
    let requestConfiguration: FirebaseAuth.AuthRequestConfiguration
    let backend: FirebaseAuth.AuthBackend
    let storedUserManager: FirebaseAuth.AuthStoredUserManager
    let firebaseAppName: Swift.String
    let authDispatcher: FirebaseAuth.AuthDispatcher
    let keychainServices: FirebaseAuth.AuthKeychainServices
    var _lastNotifiedUserToken: Swift.String?
    var lastNotifiedUserTokenLock: __C.NSLock
    var autoRefreshTokens: Swift.Bool
    var autoRefreshScheduled: Swift.Bool
    var isAppInBackground: Swift.Bool
    var applicationDidBecomeActiveObserver: __C.NSObject?
    var applicationDidEnterBackgroundObserver: __C.NSObject?
    var protectedDataDidBecomeAvailableObserver: __C.NSObject?
    let kUserKey: Swift.String
    var listenerHandles: __C.NSMutableArray
}
class AuthComponent: __C.NSObject {
    let app: 
    var instances: [Swift.String : FirebaseAuth.Auth]
    var instancesLock: __C.os_unfair_lock_s
}
class AuthDataResult: __C.NSObject {
    let user: FirebaseAuth.User
    let additionalUserInfo: FirebaseAuth.AdditionalUserInfo?
    let credential: FirebaseAuth.OAuthCredential?
    let kAdditionalUserInfoCodingKey: Swift.String
    let kUserCodingKey: Swift.String
    let kCredentialCodingKey: Swift.String
}
struct AuthDispatcher {
    let dispatchAfterImplementation: ((Swift.Double, __C.OS_dispatch_queue, () -> ()) -> ())?
}
enum AuthOperationType {
    case unspecified
    case signUpOrSignIn
    case reauth
    case update
    case link
}
class AuthSettings: __C.NSObject {
    var appVerificationDisabledForTesting: Swift.Bool
}
class AuthTokenResult: __C.NSObject {
    var token: Swift.String
    var expirationDate: Foundation.Date
    var authDate: Foundation.Date
    var issuedAtDate: Foundation.Date
    var signInProvider: Swift.String
    var signInSecondFactor: Swift.String
    var claims: [Swift.String : Any]
}
struct JWT {
    enum CodingKeys {
        case exp
        case authTime
        case iat
        case firebase
    }
    struct FirebasePayload {
        enum CodingKeys {
            case signInProvider
            case signInSecondFactor
        }
        let signInProvider: Swift.String
        let signInSecondFactor: Swift.String?
    }
    let exp: Foundation.Date
    let authTime: Foundation.Date
    let iat: Foundation.Date
    let firebase: FirebaseAuth.JWT.FirebasePayload
}
class AuthCredential: __C.NSObject {
    let provider: Swift.String
}
struct AuthProviderID {
    let rawValue: Swift.String
}
class EmailAuthProvider: __C.NSObject {}
class EmailAuthCredential: FirebaseAuth.AuthCredential {
    enum EmailType {
        case password(Swift.String)
        case link(Swift.String)
    }
    let email: Swift.String
    let emailType: FirebaseAuth.EmailAuthCredential.EmailType
}
class FacebookAuthProvider: __C.NSObject {}
class FacebookAuthCredential: FirebaseAuth.AuthCredential {
    let accessToken: Swift.String?
}
class GameCenterAuthProvider: __C.NSObject {}
class GameCenterAuthCredential: FirebaseAuth.AuthCredential {
    let playerID: Swift.String?
    let teamPlayerID: Swift.String?
    let gamePlayerID: Swift.String?
    let publicKeyURL: Foundation.URL?
    let signature: Foundation.Data?
    let salt: Foundation.Data?
    let timestamp: Swift.UInt64?
    let displayName: Swift.String?
}
class GitHubAuthProvider: __C.NSObject {}
class GitHubAuthCredential: FirebaseAuth.AuthCredential {
    let token: Swift.String?
}
class GoogleAuthProvider: __C.NSObject {}
class GoogleAuthCredential: FirebaseAuth.AuthCredential {
    let idToken: Swift.String?
    let accessToken: Swift.String?
}
class OAuthCredential: FirebaseAuth.AuthCredential {
    let idToken: Swift.String?
    let accessToken: Swift.String?
    let secret: Swift.String?
    let OAuthResponseURLString: Swift.String?
    let sessionID: Swift.String?
    let pendingToken: Swift.String?
    let fullName: Foundation.PersonNameComponents?
    let rawNonce: Swift.String?
}
class OAuthProvider: __C.NSObject {
    var scopes: [Swift.String]?
    var customParameters: [Swift.String : Swift.String]?
    let providerID: Swift.String
    let auth: FirebaseAuth.Auth
    let callbackScheme: Swift.String
    let usingClientIDScheme: Swift.Bool
}
class PhoneAuthCredential: FirebaseAuth.AuthCredential {
    enum CredentialKind {
        case phoneNumber(Swift.String, Swift.String)
        case verification(Swift.String, Swift.String)
    }
    let credentialKind: FirebaseAuth.PhoneAuthCredential.CredentialKind
}
class PhoneAuthProvider: __C.NSObject {}
class TwitterAuthProvider: __C.NSObject {}
class TwitterAuthCredential: FirebaseAuth.AuthCredential {
    let token: Swift.String?
    let secret: Swift.String?
}
class AuthBackend {
    let rpcIssuer: FirebaseAuth.AuthBackendRPCIssuerProtocol
}
class AuthBackendRPCIssuer {
    let fetcherService: __C.GTMSessionFetcherService
}
class AuthRequestConfiguration {
    let apiKey: Swift.String
    var languageCode: Swift.String?
    let appID: Swift.String
    weak var auth: FirebaseAuth.Auth?
    let heartbeatLogger: __C.FIRHeartbeatLoggerProtocol?
    var appCheck: __C.FIRAppCheckInterop?
    let additionalFrameworkMarker: Swift.String
    var emulatorHostAndPort: Swift.String?
}
class IdentityToolkitRequest {
    let endpoint: Swift.String
    var apiKey: Swift.String
    let tenantID: Swift.String?
    let useIdentityPlatform: Swift.Bool
    let useStaging: Swift.Bool
    var clientType: Swift.String
    let _requestConfiguration: FirebaseAuth.AuthRequestConfiguration
}
class CreateAuthURIRequest: FirebaseAuth.IdentityToolkitRequest {
    let identifier: Swift.String
    let continueURI: Swift.String
    let openIDRealm: Swift.String?
    let providerID: Swift.String?
    let clientID: Swift.String?
    let context: Swift.String?
    let appID: Swift.String?
}
struct CreateAuthURIResponse {
    var authURI: Swift.String?
    var registered: Swift.Bool
    var providerID: Swift.String?
    var forExistingProvider: Swift.Bool
    var allProviders: [Swift.String]?
    var signinMethods: [Swift.String]
}
class DeleteAccountRequest: FirebaseAuth.IdentityToolkitRequest {
    let accessToken: Swift.String
    let localID: Swift.String
}
struct DeleteAccountResponse {}
class EmailLinkSignInRequest: FirebaseAuth.IdentityToolkitRequest {
    let email: Swift.String
    let oobCode: Swift.String
    var idToken: Swift.String?
}
struct EmailLinkSignInResponse {
    var idToken: Swift.String?
    var email: Swift.String?
    var refreshToken: Swift.String?
    var approximateExpirationDate: Foundation.Date?
    var isNewUser: Swift.Bool
    var mfaPendingCredential: Swift.String?
    var mfaInfo: [FirebaseAuth.AuthProtoMFAEnrollment]?
}
class GetAccountInfoRequest: FirebaseAuth.IdentityToolkitRequest {
    let accessToken: Swift.String
}
struct GetAccountInfoResponse {
    struct ProviderUserInfo {
        let providerID: Swift.String?
        let displayName: Swift.String?
        let photoURL: Foundation.URL?
        let federatedID: Swift.String?
        let email: Swift.String?
        let phoneNumber: Swift.String?
    }
    struct User {
        let localID: Swift.String?
        let email: Swift.String?
        let emailVerified: Swift.Bool
        let displayName: Swift.String?
        let photoURL: Foundation.URL?
        let creationDate: Foundation.Date?
        let lastLoginDate: Foundation.Date?
        let providerUserInfo: [FirebaseAuth.GetAccountInfoResponse.ProviderUserInfo]?
        let passwordHash: Swift.String?
        let phoneNumber: Swift.String?
        let mfaEnrollments: [FirebaseAuth.AuthProtoMFAEnrollment]?
    }
    var users: [FirebaseAuth.GetAccountInfoResponse.User]?
}
class GetOOBConfirmationCodeRequest: FirebaseAuth.IdentityToolkitRequest {
    let requestType: FirebaseAuth.GetOOBConfirmationCodeRequestType
    let email: Swift.String?
    let updatedEmail: Swift.String?
    let accessToken: Swift.String?
    let continueURL: Swift.String?
    let iOSBundleID: Swift.String?
    let androidPackageName: Swift.String?
    let androidMinimumVersion: Swift.String?
    let androidInstallApp: Swift.Bool
    let handleCodeInApp: Swift.Bool
    var linkDomain: Swift.String?
    var captchaResponse: Swift.String?
    var recaptchaVersion: Swift.String?
}
enum GetOOBConfirmationCodeRequestType {
    case passwordReset
    case verifyEmail
    case emailLink
    case verifyBeforeUpdateEmail
}
struct GetOOBConfirmationCodeResponse {
    var OOBCode: Swift.String?
}
class GetProjectConfigRequest: FirebaseAuth.IdentityToolkitRequest {}
struct GetProjectConfigResponse {
    var projectID: Swift.String?
    var authorizedDomains: [Swift.String]?
}
class GetRecaptchaConfigRequest: FirebaseAuth.IdentityToolkitRequest {}
struct GetRecaptchaConfigResponse {
    var recaptchaKey: Swift.String?
    var enforcementState: [[Swift.String : Swift.String]]?
}
class FinalizeMFAEnrollmentRequest: FirebaseAuth.IdentityToolkitRequest {
    let idToken: Swift.String?
    let displayName: Swift.String?
    let phoneVerificationInfo: FirebaseAuth.AuthProtoFinalizeMFAPhoneRequestInfo?
    let totpVerificationInfo: FirebaseAuth.AuthProtoFinalizeMFATOTPEnrollmentRequestInfo?
}
struct FinalizeMFAEnrollmentResponse {
    var idToken: Swift.String?
    var refreshToken: Swift.String?
    var phoneSessionInfo: FirebaseAuth.AuthProtoFinalizeMFAPhoneResponseInfo?
    var totpSessionInfo: FirebaseAuth.AuthProtoFinalizeMFATOTPEnrollmentResponseInfo?
}
class StartMFAEnrollmentRequest: FirebaseAuth.IdentityToolkitRequest {
    let idToken: Swift.String?
    let phoneEnrollmentInfo: FirebaseAuth.AuthProtoStartMFAPhoneRequestInfo?
    let totpEnrollmentInfo: FirebaseAuth.AuthProtoStartMFATOTPEnrollmentRequestInfo?
}
struct StartMFAEnrollmentResponse {
    var phoneSessionInfo: FirebaseAuth.AuthProtoStartMFAPhoneResponseInfo?
    var totpSessionInfo: FirebaseAuth.AuthProtoStartMFATOTPEnrollmentResponseInfo?
}
class FinalizeMFASignInRequest: FirebaseAuth.IdentityToolkitRequest {
    let mfaPendingCredential: Swift.String?
    let verificationInfo: FirebaseAuth.AuthProto?
}
class StartMFASignInRequest: FirebaseAuth.IdentityToolkitRequest {
    let MFAPendingCredential: Swift.String?
    let MFAEnrollmentID: Swift.String?
    let signInInfo: FirebaseAuth.AuthProtoStartMFAPhoneRequestInfo?
}
struct StartMFASignInResponse {
    let responseInfo: FirebaseAuth.AuthProtoStartMFAPhoneResponseInfo
}
class WithdrawMFARequest: FirebaseAuth.IdentityToolkitRequest {
    let idToken: Swift.String?
    let mfaEnrollmentID: Swift.String?
}
struct WithdrawMFAResponse {
    var idToken: Swift.String?
    var refreshToken: Swift.String?
}
struct AuthProtoMFAEnrollment {
    let phoneInfo: Swift.String?
    let totpInfo: Swift.String?
    let mfaEnrollmentID: Swift.String?
    let displayName: Swift.String?
    let enrolledAt: Foundation.Date?
}
class AuthProtoFinalizeMFAPhoneRequestInfo: __C.NSObject {
    var sessionInfo: Swift.String?
    var code: Swift.String?
}
struct AuthProtoFinalizeMFAPhoneResponseInfo {
    var phoneNumber: Swift.String?
}
class AuthProtoStartMFAPhoneRequestInfo: __C.NSObject {
    var phoneNumber: Swift.String?
    var codeIdentity: FirebaseAuth.CodeIdentity
    var captchaResponse: Swift.String?
    var recaptchaVersion: Swift.String?
    var clientType: Swift.String?
}
struct AuthProtoStartMFAPhoneResponseInfo {
    var sessionInfo: Swift.String?
}
class AuthProtoStartMFATOTPEnrollmentRequestInfo: __C.NSObject {}
struct AuthProtoStartMFATOTPEnrollmentResponseInfo {
    let sharedSecretKey: Swift.String
    let verificationCodeLength: Swift.Int
    let hashingAlgorithm: Swift.String?
    let periodSec: Swift.Int
    let sessionInfo: Swift.String?
    let finalizeEnrollmentTime: Foundation.Date?
}
class AuthProtoFinalizeMFATOTPEnrollmentRequestInfo: __C.NSObject {
    let sessionInfo: Swift.String?
    let verificationCode: Swift.String?
}
class AuthProtoFinalizeMFATOTPSignInRequestInfo: __C.NSObject {
    let mfaEnrollmentID: Swift.String?
    let verificationCode: Swift.String?
}
struct AuthProtoFinalizeMFATOTPEnrollmentResponseInfo {
    var sessionInfo: Swift.String?
}
class ResetPasswordRequest: FirebaseAuth.IdentityToolkitRequest {
    let oobCode: Swift.String
    let updatedPassword: Swift.String?
}
struct ResetPasswordResponse {
    var email: Swift.String?
    var verifiedEmail: Swift.String?
    var requestType: Swift.String?
}
class RevokeTokenRequest: FirebaseAuth.IdentityToolkitRequest {
    enum TokenType {
        case unspecified
        case refreshToken
        case accessToken
        case authorizationCode
    }
    let providerID: Swift.String
    let tokenType: FirebaseAuth.RevokeTokenRequest.TokenType
    let token: Swift.String
    let idToken: Swift.String
}
struct RevokeTokenResponse {}
class SecureTokenRequest {
    let grantType: FirebaseAuth.SecureTokenRequestGrantType
    let scope: Swift.String?
    let refreshToken: Swift.String?
    let code: Swift.String?
    let apiKey: Swift.String
    let _requestConfiguration: FirebaseAuth.AuthRequestConfiguration
}
enum SecureTokenRequestGrantType {
    case authorizationCode
    case refreshToken
}
struct SecureTokenResponse {
    var approximateExpirationDate: Foundation.Date?
    var refreshToken: Swift.String?
    var accessToken: Swift.String?
    var idToken: Swift.String?
}
class SendVerificationCodeRequest: FirebaseAuth.IdentityToolkitRequest {
    let phoneNumber: Swift.String
    let codeIdentity: FirebaseAuth.CodeIdentity
    var captchaResponse: Swift.String?
    var recaptchaVersion: Swift.String?
}
enum CodeIdentity {
    case credential(FirebaseAuth.AuthAppCredential)
    case recaptcha(Swift.String)
    case empty
}
struct SendVerificationCodeResponse {
    let verificationID: Swift.String?
}
class SetAccountInfoRequest: FirebaseAuth.IdentityToolkitRequest {
    var accessToken: Swift.String?
    var displayName: Swift.String?
    var localID: Swift.String?
    var email: Swift.String?
    var photoURL: Foundation.URL?
    var password: Swift.String?
    var providers: [Swift.String]?
    var oobCode: Swift.String?
    var emailVerified: Swift.Bool
    var upgradeToFederatedLogin: Swift.Bool
    var captchaChallenge: Swift.String?
    var captchaResponse: Swift.String?
    var deleteAttributes: [Swift.String]?
    var deleteProviders: [Swift.String]?
    var returnSecureToken: Swift.Bool
}
struct SetAccountInfoResponse {
    struct ProviderUserInfo {
        var providerID: Swift.String?
        var displayName: Swift.String?
        var photoURL: Foundation.URL?
    }
    var email: Swift.String?
    var displayName: Swift.String?
    var providerUserInfo: [FirebaseAuth.SetAccountInfoResponse.ProviderUserInfo]?
    var idToken: Swift.String?
    var approximateExpirationDate: Foundation.Date?
    var refreshToken: Swift.String?
}
class SignInWithGameCenterRequest: FirebaseAuth.IdentityToolkitRequest {
    var playerID: Swift.String?
    var teamPlayerID: Swift.String?
    var gamePlayerID: Swift.String?
    var publicKeyURL: Foundation.URL
    var signature: Foundation.Data
    var salt: Foundation.Data
    var timestamp: Swift.UInt64?
    var accessToken: Swift.String?
    var displayName: Swift.String?
}
struct SignInWithGameCenterResponse {
    var idToken: Swift.String?
    var refreshToken: Swift.String?
    var localID: Swift.String?
    var playerID: Swift.String?
    var teamPlayerID: Swift.String?
    var gamePlayerID: Swift.String?
    var approximateExpirationDate: Foundation.Date?
    var isNewUser: Swift.Bool
    var displayName: Swift.String?
}
class SignUpNewUserRequest: FirebaseAuth.IdentityToolkitRequest {
    var email: Swift.String?
    var password: Swift.String?
    var displayName: Swift.String?
    var idToken: Swift.String?
    var captchaResponse: Swift.String?
    var recaptchaVersion: Swift.String?
    var returnSecureToken: Swift.Bool
}
struct SignUpNewUserResponse {
    var idToken: Swift.String?
    var approximateExpirationDate: Foundation.Date?
    var refreshToken: Swift.String?
}
class VerifyAssertionRequest: FirebaseAuth.IdentityToolkitRequest {
    var requestURI: Swift.String?
    var pendingToken: Swift.String?
    var accessToken: Swift.String?
    var returnSecureToken: Swift.Bool
    let providerID: Swift.String
    var providerAccessToken: Swift.String?
    var providerIDToken: Swift.String?
    var providerRawNonce: Swift.String?
    var returnIDPCredential: Swift.Bool
    var sessionID: Swift.String?
    var providerOAuthTokenSecret: Swift.String?
    var inputEmail: Swift.String?
    var autoCreate: Swift.Bool
    var fullName: Foundation.PersonNameComponents?
}
struct VerifyAssertionResponse {
    var federatedID: Swift.String?
    var providerID: Swift.String?
    var localID: Swift.String?
    var email: Swift.String?
    var inputEmail: Swift.String?
    var originalEmail: Swift.String?
    var oauthRequestToken: Swift.String?
    var oauthScope: Swift.String?
    var firstName: Swift.String?
    var lastName: Swift.String?
    var fullName: Swift.String?
    var nickName: Swift.String?
    var displayName: Swift.String?
    var idToken: Swift.String?
    var approximateExpirationDate: Foundation.Date?
    var refreshToken: Swift.String?
    var action: Swift.String?
    var language: Swift.String?
    var timeZone: Swift.String?
    var photoURL: Foundation.URL?
    var dateOfBirth: Swift.String?
    var context: Swift.String?
    var verifiedProvider: [Swift.String]?
    var needConfirmation: Swift.Bool
    var emailRecycled: Swift.Bool
    var emailVerified: Swift.Bool
    var isNewUser: Swift.Bool
    var profile: [Swift.String : Any]?
    var username: Swift.String?
    var oauthIDToken: Swift.String?
    var oauthExpirationDate: Foundation.Date?
    var oauthAccessToken: Swift.String?
    var oauthSecretToken: Swift.String?
    var pendingToken: Swift.String?
    var mfaPendingCredential: Swift.String?
    var mfaInfo: [FirebaseAuth.AuthProtoMFAEnrollment]?
}
class VerifyCustomTokenRequest: FirebaseAuth.IdentityToolkitRequest {
    let token: Swift.String
    var returnSecureToken: Swift.Bool
}
struct VerifyCustomTokenResponse {
    var idToken: Swift.String?
    var approximateExpirationDate: Foundation.Date?
    var refreshToken: Swift.String?
    var isNewUser: Swift.Bool
}
class VerifyPasswordRequest: FirebaseAuth.IdentityToolkitRequest {
    var email: Swift.String
    var password: Swift.String
    var pendingIDToken: Swift.String?
    var captchaChallenge: Swift.String?
    var captchaResponse: Swift.String?
    var recaptchaVersion: Swift.String?
    var returnSecureToken: Swift.Bool
}
struct VerifyPasswordResponse {
    var localID: Swift.String?
    var email: Swift.String?
    var displayName: Swift.String?
    var idToken: Swift.String?
    var approximateExpirationDate: Foundation.Date?
    var refreshToken: Swift.String?
    var photoURL: Foundation.URL?
    var mfaPendingCredential: Swift.String?
    var mfaInfo: [FirebaseAuth.AuthProtoMFAEnrollment]?
}
class VerifyPhoneNumberRequest: FirebaseAuth.IdentityToolkitRequest {
    let verificationID: Swift.String?
    let verificationCode: Swift.String?
    var accessToken: Swift.String?
    let temporaryProof: Swift.String?
    let phoneNumber: Swift.String?
    let operation: FirebaseAuth.AuthOperationType
}
struct VerifyPhoneNumberResponse {
    var idToken: Swift.String?
    var refreshToken: Swift.String?
    var localID: Swift.String?
    var phoneNumber: Swift.String?
    var temporaryProof: Swift.String?
    var isNewUser: Swift.Bool
    var approximateExpirationDate: Foundation.Date?
}
class VerifyClientRequest: FirebaseAuth.IdentityToolkitRequest {
    let appToken: Swift.String?
    let isSandbox: Swift.Bool
}
struct VerifyClientResponse {
    var receipt: Swift.String?
    var suggestedTimeOutDate: Foundation.Date?
}
class MultiFactor: __C.NSObject {
    var enrolledFactors: [FirebaseAuth.MultiFactorInfo]
    weak var user: FirebaseAuth.User?
    let kEnrolledFactorsCodingKey: Swift.String
}
class MultiFactorAssertion: __C.NSObject {
    var factorID: Swift.String
}
class MultiFactorInfo: __C.NSObject {
    let uid: Swift.String
    let displayName: Swift.String?
    let enrollmentDate: Foundation.Date
    let factorID: Swift.String
    let kUIDCodingKey: Swift.String
    let kDisplayNameCodingKey: Swift.String
    let kEnrollmentDateCodingKey: Swift.String
    let kFactorIDCodingKey: Swift.String
}
class MultiFactorResolver: __C.NSObject {
    let session: FirebaseAuth.MultiFactorSession
    let hints: [FirebaseAuth.MultiFactorInfo]
    let auth: FirebaseAuth.Auth
    let mfaPendingCredential: Swift.String?
}
class MultiFactorSession: __C.NSObject {
    let idToken: Swift.String?
    let mfaPendingCredential: Swift.String?
    let currentUser: FirebaseAuth.User?
    var multiFactorInfo: FirebaseAuth.MultiFactorInfo?
}
class PhoneMultiFactorAssertion: FirebaseAuth.MultiFactorAssertion {
    var authCredential: FirebaseAuth.PhoneAuthCredential?
}
class PhoneMultiFactorGenerator: __C.NSObject {}
class PhoneMultiFactorInfo: FirebaseAuth.MultiFactorInfo {
    var phoneNumber: Swift.String
    let kPhoneNumberCodingKey: Swift.String
}
class TOTPMultiFactorAssertion: FirebaseAuth.MultiFactorAssertion {
    let oneTimePassword: Swift.String
    let secretOrID: FirebaseAuth.SecretOrID
}
enum SecretOrID {
    case secret(FirebaseAuth.TOTPSecret)
    case enrollmentID(Swift.String)
}
class TOTPMultiFactorGenerator: __C.NSObject {}
class TOTPMultiFactorInfo: FirebaseAuth.MultiFactorInfo {}
class TOTPSecret: __C.NSObject {
    let secretKey: Swift.String
    let hashingAlgorithm: Swift.String?
    let codeLength: Swift.Int
    let codeIntervalSeconds: Swift.Int
    let enrollmentCompletionDeadline: Foundation.Date?
    let sessionInfo: Swift.String?
}
class AuthKeychainServices {
    let service: Swift.String
    let keychainStorage: FirebaseAuth.AuthKeychainStorage
    let legacyEntryDeletedForKey: FirebaseCoreInternal.UnfairLock<Swift.Set<Swift.String>>
}
class AuthKeychainStorageReal {}
class AuthUserDefaults {
    let persistentDomainName: Swift.String
    let storage: __C.NSUserDefaults
}
class AuthAppCredential: __C.NSObject {
    let receipt: Swift.String
    let secret: Swift.String?
}
class AuthStoredUserManager {
    let keychainServices: FirebaseAuth.AuthKeychainServices
    let userDefaults: FirebaseAuth.AuthUserDefaults
}
actor SecureTokenServiceInternal {
    var $defaultActor: 
}
class SecureTokenService: __C.NSObject {
    let internalService: FirebaseAuth.SecureTokenServiceInternal
    let _requestConfiguration: FirebaseCoreInternal.UnfairLock<FirebaseAuth.AuthRequestConfiguration?>
    let _accessToken: FirebaseCoreInternal.UnfairLock<Swift.String>
    let _refreshToken: FirebaseCoreInternal.UnfairLock<Swift.String?>
    let _accessTokenExpirationDate: FirebaseCoreInternal.UnfairLock<Foundation.Date?>
    let kAPIKeyCodingKey: Swift.String
}
class AdditionalUserInfo: __C.NSObject {
    let providerID: Swift.String
    let profile: [Swift.String : Any]?
    let username: Swift.String?
    let isNewUser: Swift.Bool
}
class User: __C.NSObject {
    var isAnonymous: Swift.Bool
    var isEmailVerified: Swift.Bool
    var providerDataRaw: [Swift.String : FirebaseAuth.UserInfoImpl]
    var backend: FirebaseAuth.AuthBackend
    var metadata: FirebaseAuth.UserMetadata
    var tenantID: Swift.String?
    var multiFactor: FirebaseAuth.MultiFactor
    var uid: Swift.String
    var displayName: Swift.String?
    var photoURL: Foundation.URL?
    var email: Swift.String?
    var phoneNumber: Swift.String?
    var hasEmailPasswordCredential: Swift.Bool
    let userProfileUpdate: FirebaseAuth.UserProfileUpdate
    var requestConfiguration: FirebaseAuth.AuthRequestConfiguration
    var tokenService: FirebaseAuth.SecureTokenService
    weak var _auth: FirebaseAuth.Auth?
    let kUserIDCodingKey: Swift.String
    let kHasEmailPasswordCredentialCodingKey: Swift.String
    let kAnonymousCodingKey: Swift.String
    let kEmailCodingKey: Swift.String
    let kPhoneNumberCodingKey: Swift.String
    let kEmailVerifiedCodingKey: Swift.String
    let kDisplayNameCodingKey: Swift.String
    let kPhotoURLCodingKey: Swift.String
    let kProviderDataKey: Swift.String
    let kAPIKeyCodingKey: Swift.String
    let kFirebaseAppIDCodingKey: Swift.String
    let kTokenServiceCodingKey: Swift.String
    let kMetadataCodingKey: Swift.String
    let kMultiFactorCodingKey: Swift.String
    let kTenantIDCodingKey: Swift.String
}
class UserInfoImpl: __C.NSObject {
    var providerID: Swift.String
    var uid: Swift.String
    var displayName: Swift.String?
    var photoURL: Foundation.URL?
    var email: Swift.String?
    var phoneNumber: Swift.String?
}
class UserMetadata: __C.NSObject {
    let lastSignInDate: Foundation.Date?
    let creationDate: Foundation.Date?
}
class UserProfileChangeRequest: __C.NSObject {
    var _displayName: Swift.String?
    var _photoURL: Foundation.URL?
    let user: FirebaseAuth.User
    var consumed: Swift.Bool
    var displayNameWasSet: Swift.Bool
    var photoURLWasSet: Swift.Bool
}
actor UserProfileUpdate {
    var $defaultActor: 
}
class AuthErrorUtils {}
class AuthErrors: __C.NSObject {}
enum AuthErrorCode {}
class AuthWebUtils {}
class __CombineFunctionsLibrary: __C.NSObject {}
struct Callable<A, B> where A: Swift.Encodable, B: Swift.Decodable {
    enum CallableError {
        case internalError
    }
    let callable: FirebaseFunctions.HTTPSCallable
    let encoder: FirebaseSharedSwift.FirebaseDataEncoder
    let decoder: FirebaseSharedSwift.FirebaseDataDecoder
}
enum StreamResponse<A, B> where A: Swift.Decodable, B: Swift.Decodable {
    enum CodingKeys {
        case message
        case result
    }
    case message(A)
    case result(B)
}
struct SendableWrapper {
    let value: Any
}
enum JSONStreamResponse {
    case message([Swift.String : Any])
    case result([Swift.String : Any])
}
class Functions: __C.NSObject {
    let fetcherService: __C.GTMSessionFetcherService
    let projectID: Swift.String
    let serializer: FirebaseFunctions.FunctionsSerializer
    let contextProvider: FirebaseFunctions.FunctionsContextProvider
    let customDomain: Swift.String?
    let region: Swift.String
    let _emulatorOrigin: FirebaseCoreInternal.UnfairLock<Swift.String?>
}
enum FunctionsErrorCode {}
struct FunctionsError {
    let code: FirebaseFunctions.FunctionsErrorCode
    let errorUserInfo: [Swift.String : Any]
}
class HTTPSCallableResult: __C.NSObject {
    let data: Any
}
class HTTPSCallable: __C.NSObject {
    let functions: FirebaseFunctions.Functions
    let url: Foundation.URL
    let options: FirebaseFunctions.HTTPSCallableOptions?
    let _timeoutInterval: FirebaseCoreInternal.UnfairLock<Swift.Double>
}
class HTTPSCallableOptions: __C.NSObject {
    let requireLimitedUseAppCheckTokens: Swift.Bool
}
struct FunctionsContextProvider {
    let auth: __C.FIRAuthInterop?
    let messaging: __C.FIRMessagingInterop?
    let appCheck: __C.FIRAppCheckInterop?
}
struct FunctionsContext {
    let authToken: Swift.String?
    let fcmToken: Swift.String?
    let appCheckToken: Swift.String?
    let limitedUseAppCheckToken: Swift.String?
}
class FunctionsSerializer {
    enum Error {
        case unsupportedType(typeName: Swift.String)
        case failedToParseWrappedNumber(value: Swift.String, type: Swift.String)
    }
}
class __CombineStorageLibrary: __C.NSObject {}
actor StorageFetcherService {
    var $defaultActor: 
    var _fetcherService: __C.GTMSessionFetcherService?
    var testBlock: ((__C.GTMSessionFetcher, (__C.NSHTTPURLResponse?, Foundation.Data?, Swift.Error?) -> ()) -> ())?
    var retryWhenOffline: (Swift.Bool, Swift.Error?, (_: Swift.Bool) -> ()) -> ()
    var fetcherServiceMap: [Swift.String : [Swift.String : __C.GTMSessionFetcherService]]
}
class StorageInternalTask: FirebaseStorage.StorageTask {
    var fetcher: __C.GTMSessionFetcher?
}
class StoragePath {
    let bucket: Swift.String
    let object: Swift.String?
}
enum StoragePathError {
    case storagePathError(Swift.String)
}
enum StorageTaskState {
    case unknown
    case queueing
    case resuming
    case running
    case progress
    case pausing
    case completing
    case failing
    case paused
    case cancelled
    case success
    case failed
}
class StorageTokenAuthorizer: __C.NSObject {
    var userEmail: Swift.String?
    let callbackQueue: __C.OS_dispatch_queue
    let googleAppID: Swift.String
    let auth: __C.FIRAuthInterop?
    let appCheck: __C.FIRAppCheckInterop?
    let serialAuthArgsQueue: __C.OS_dispatch_queue
}
class StorageUtils {}
class Storage: __C.NSObject {
    class InstanceCache {
        var instances: [Swift.String : FirebaseStorage.Storage]
        var instancesLock: __C.os_unfair_lock_s
    }
    let app: __C.FIRApp
    var maxUploadRetryTime: Swift.Double
    var maxDownloadRetryTime: Swift.Double
    var maxOperationRetryTime: Swift.Double
    var uploadChunkSizeBytes: Swift.Int64
    var callbackQueue: __C.OS_dispatch_queue
    let dispatchQueue: __C.OS_dispatch_queue
    let auth: __C.FIRAuthInterop?
    let appCheck: __C.FIRAppCheckInterop?
    let storageBucket: Swift.String
    var usesEmulator: Swift.Bool
    var configured: Swift.Bool
    var host: Swift.String
    var scheme: Swift.String
    var port: Swift.Int
    var maxDownloadRetryInterval: Swift.Double
    var maxOperationRetryInterval: Swift.Double
    var maxUploadRetryInterval: Swift.Double
}
enum StorageTaskStatus {}
class StorageDownloadTask: FirebaseStorage.StorageObservableTask {
    var fetcher: __C.GTMSessionFetcher?
    var downloadData: Foundation.Data?
    var completionData: ((Foundation.Data?, Swift.Error?) -> ())?
    var completionURL: ((Foundation.URL?, Swift.Error?) -> ())?
}
enum StorageErrorCode {}
enum StorageError {
    case unknown(message: Swift.String, serverError: [Swift.String : Any])
    case objectNotFound(object: Swift.String, serverError: [Swift.String : Any])
    case bucketNotFound(bucket: Swift.String)
    case projectNotFound(project: Swift.String)
    case quotaExceeded(bucket: Swift.String, serverError: [Swift.String : Any])
    case unauthenticated(serverError: [Swift.String : Any])
    case unauthorized(bucket: Swift.String, object: Swift.String, serverError: [Swift.String : Any])
    case downloadSizeExceeded(total: Swift.Int64, maxSize: Swift.Int64)
    case invalidArgument(message: Swift.String)
    case internalError(message: Swift.String)
    case bucketMismatch(message: Swift.String)
    case pathError(message: Swift.String)
    case retryLimitExceeded
    case nonMatchingChecksum
    case cancelled
}
class StorageListResult: __C.NSObject {
    let prefixes: [FirebaseStorage.StorageReference]
    let items: [FirebaseStorage.StorageReference]
    let pageToken: Swift.String?
}
class StorageMetadata: __C.NSObject {
    enum StorageMetadataType {
        case unknown
        case file
        case folder
    }
    let bucket: Swift.String
    var cacheControl: Swift.String?
    var contentDisposition: Swift.String?
    var contentEncoding: Swift.String?
    var contentLanguage: Swift.String?
    var contentType: Swift.String?
    let md5Hash: Swift.String?
    let generation: Swift.Int64
    var customMetadata: [Swift.String : Swift.String]?
    let metageneration: Swift.Int64
    var name: Swift.String?
    var path: Swift.String?
    let size: Swift.Int64
    let timeCreated: Foundation.Date?
    let updated: Foundation.Date?
    var fileType: FirebaseStorage.StorageMetadata.StorageMetadataType
    var initialMetadata: [Swift.String : Swift.AnyHashable]
}
class StorageObservableTask: FirebaseStorage.StorageTask {
    var handlerDictionaries: [FirebaseStorage.StorageTaskStatus : [Swift.String : (_: FirebaseStorage.StorageTaskSnapshot) -> ()]]
    var handleToStatusMap: [Swift.String : FirebaseStorage.StorageTaskStatus]
    let fileURL: Foundation.URL?
}
class StorageReference: __C.NSObject {
    let storage: FirebaseStorage.Storage
    let path: FirebaseStorage.StoragePath
}
class StorageTask: __C.NSObject {
    var state: FirebaseStorage.StorageTaskState
    var metadata: FirebaseStorage.StorageMetadata?
    var error: __C.NSError?
    var progress: __C.NSProgress
    let reference: FirebaseStorage.StorageReference
    let dispatchQueue: __C.OS_dispatch_queue
    let baseRequest: Foundation.URLRequest
}
class StorageTaskSnapshot: __C.NSObject {
    let task: FirebaseStorage.StorageTask
    let metadata: FirebaseStorage.StorageMetadata?
    let reference: FirebaseStorage.StorageReference
    let progress: __C.NSProgress?
    let error: Swift.Error?
    let status: FirebaseStorage.StorageTaskStatus
}
class StorageUploadTask: FirebaseStorage.StorageObservableTask {
    var uploadFetcher: __C.GTMSessionUploadFetcher?
    var uploadMetadata: FirebaseStorage.StorageMetadata
    var uploadData: Foundation.Data?
    var completionMetadata: ((FirebaseStorage.StorageMetadata?, Swift.Error?) -> ())?
}
enum AuthError {
    case unknownError
}
class BrowserTokenProvider {
    var credentials: OAuth2.Credentials
    var code: OAuth2.Code?
    var token: OAuth2.Token?
    var sem: __C.OS_dispatch_semaphore?
}
struct Credentials {
    enum CodingKeys {
        case clientID
        case clientSecret
        case authorizeURL
        case accessTokenURL
        case callback
    }
    let clientID: Swift.String
    let clientSecret: Swift.String
    let authorizeURL: Swift.String
    let accessTokenURL: Swift.String
    let callback: Swift.String
}
class Code {
    var code: Swift.String?
    var state: Swift.String?
    var error: Swift.String?
}
class Connection {
    var provider: OAuth2.TokenProvider
}
class DefaultTokenProvider {
    var token: OAuth2.Token?
    var tokenProvider: OAuth2.TokenProvider
}
class GoogleCloudMetadataTokenProvider {
    var token: OAuth2.Token?
}
class GoogleRefreshTokenProvider {
    var credentials: OAuth2.OAuth2RefreshCredentials
    var token: OAuth2.Token?
}
struct OAuth2RefreshCredentials {
    enum CodingKeys {
        case clientID
        case clientSecret
        case refreshToken
        case tokenType
    }
    let clientID: Swift.String
    let clientSecret: Swift.String
    let refreshToken: Swift.String
    let tokenType: Swift.String
}
class ASN1Scanner {
    let data: Foundation.Data
    var position: Swift.Int
}
struct ASN1Object {
    let type: OAuth2.ASN1Decoder.DERCode
    let data: Foundation.Data
    var children: [OAuth2.ASN1Object]?
}
struct ASN1Decoder {
    enum DERCode {
        case Boolean
        case Integer
        case OctetString
        case Null
        case ObjectIdentifier
        case IA5String
        case Sequence
    }
}
struct JWTClaimSet {
    enum CodingKeys {
        case Issuer
        case Audience
        case Scope
        case IssuedAt
        case Expiration
    }
    let Issuer: Swift.String
    let Audience: Swift.String
    let Scope: Swift.String
    let IssuedAt: Swift.Int
    let Expiration: Swift.Int
}
struct JWTHeader {
    enum CodingKeys {
        case Algorithm
        case Format
    }
    let Algorithm: Swift.String
    let Format: Swift.String
}
struct RSAKey {
    var N: BigInt.BigUInt
    var E: BigInt.BigUInt
    var D: BigInt.BigUInt
}
class ServiceAccountTokenProvider {
    var token: OAuth2.Token?
    var credentials: OAuth2.ServiceAccountCredentials
    var scopes: [Swift.String]
    var rsaKey: OAuth2.RSAKey
}
struct ServiceAccountCredentials {
    enum CodingKeys {
        case CredentialType
        case ProjectId
        case PrivateKeyId
        case PrivateKey
        case ClientEmail
        case ClientID
        case AuthURI
        case TokenURI
        case AuthProviderX509CertURL
        case ClientX509CertURL
    }
    let CredentialType: Swift.String
    let ProjectId: Swift.String
    let PrivateKeyId: Swift.String
    let PrivateKey: Swift.String
    let ClientEmail: Swift.String
    let ClientID: Swift.String
    let AuthURI: Swift.String
    let TokenURI: Swift.String
    let AuthProviderX509CertURL: Swift.String
    let ClientX509CertURL: Swift.String
}
struct Token {
    enum CodingKeys {
        case AccessToken
        case TokenType
        case ExpiresIn
        case RefreshToken
        case Scope
        case CreationTime
    }
    var AccessToken: Swift.String?
    var TokenType: Swift.String?
    var ExpiresIn: Swift.Int?
    var RefreshToken: Swift.String?
    var Scope: Swift.String?
    var CreationTime: Foundation.Date?
}
struct BigInt {
    enum Sign {
        case plus
        case minus
    }
    struct Words {
        let value: BigInt.BigInt
        let decrementLimit: Swift.Int
    }
    var magnitude: BigInt.BigUInt
    var sign: BigInt.BigInt.Sign
}
struct BigUInt {
    enum Kind {
        case inline(Swift.UInt, Swift.UInt)
        case slice(from: Swift.Int, to: Swift.Int)
        case array
    }
    struct Words {
        let value: BigInt.BigUInt
    }
    var kind: BigInt.BigUInt.Kind
    var storage: [Swift.UInt]
}
struct Units<A, B> where A: Swift.FixedWidthInteger, B: Swift.RandomAccessCollection, B.Sequence.Element: Swift.FixedWidthInteger, B.Collection.Index == Swift.Int {
    let words: B
}
class Context {
    let modelContainer: MLXLMCommon.ModelContainer
    let supportsVision: Swift.Bool
}
struct LLMUserInputProcessor {
    let tokenizer: Tokenizers.Tokenizer
    let configuration: MLXLMCommon.ModelConfiguration
    let messageGenerator: MLXLMCommon.MessageGenerator
}
actor MLXClient {
    struct Parameter {
        var parameters: MLXLMCommon.GenerateParameters
        var options: LocalLLMClientMLX.MLXClient.Options
    }
    struct Options {
        var extraEOSTokens: Swift.Set<Swift.String>
        var disableAutoPause: Swift.Bool
    }
    var $defaultActor: 
    let context: LocalLLMClientMLX.Context
    let parameter: LocalLLMClientMLX.MLXClient.Parameter
    let tools: [LocalLLMClientCore.AnyLLMTool]
    let pauseHandler: LocalLLMClientCore.PauseHandler
}
struct EmptyOutput {
    enum CodingKeys {}
}
struct EmptyInput {
    enum CodingKeys {}
}
class LLMTypeRegistry: MLXLMCommon.ModelTypeRegistry {}
class LLMRegistry: MLXLMCommon.AbstractModelRegistry {}
class LLMModelFactory {
    let typeRegistry: MLXLMCommon.ModelTypeRegistry
    let modelRegistry: MLXLMCommon.AbstractModelRegistry
}
class TrampolineModelFactory: __C.NSObject {}
struct LLMUserInputProcessor {
    let tokenizer: Tokenizers.Tokenizer
    let configuration: MLXLMCommon.ModelConfiguration
    let messageGenerator: MLXLMCommon.MessageGenerator
}
enum LoRADataError {
    case fileNotFound(Foundation.URL, Swift.String)
}
struct Line {
    enum CodingKeys {
        case text
    }
    let text: Swift.String?
}
enum LoRATrain {
    struct Parameters {
        var batchSize: Swift.Int
        var iterations: Swift.Int
        var stepsPerReport: Swift.Int
        var stepsPerEval: Swift.Int
        var validationBatches: Swift.Int
        var saveEvery: Swift.Int
        var adapterURL: Foundation.URL?
    }
    enum Progress {
        case train(iteration: Swift.Int, trainingLoss: Swift.Float, iterationsPerSecond: Swift.Double, tokensPerSecond: Swift.Double)
        case validation(iteration: Swift.Int, validationLoss: Swift.Float, validationTime: Swift.Double)
        case save(iteration: Swift.Int, url: Foundation.URL)
    }
    enum ProgressDisposition {
        case stop
        case more
    }
}
struct LoRABatchIterator {
    let dataset: [Swift.String]
    let batchSize: Swift.Int
    let tokenizer: Tokenizers.Tokenizer
    let train: Swift.Bool
    var indices: [Swift.Int]
    var index: Swift.Int
}
struct BaichuanM1Configuration {
    enum CodingKeys {
        case vocabularySize
        case hiddenSize
        case intermediateSize
        case hiddenLayers
        case attentionHeads
        case kvHeads
        case ropeTheta
        case slidingWindow
        case slidingWindowLayers
        case convWindow
        case rmsNormEps
        case swaAttentionHeads
        case swaKvHeads
        case tieWordEmbeddings
    }
    var vocabularySize: Swift.Int
    var hiddenSize: Swift.Int
    var intermediateSize: Swift.Int
    var hiddenLayers: Swift.Int
    var attentionHeads: Swift.Int
    var kvHeads: Swift.Int
    var ropeTheta: Swift.Float
    var slidingWindow: Swift.Int
    var slidingWindowLayers: [Swift.Int]
    var convWindow: Swift.Int
    var rmsNormEps: Swift.Float
    var swaAttentionHeads: Swift.Int?
    var swaKvHeads: Swift.Int?
    var tieWordEmbeddings: Swift.Bool
}
class Attention: MLXNN.Module {
    enum PositionalEncoding {
        case rope(MLXNN.RoPE)
        case suScaledRotaryEmbedding(MLXLLM.SuScaledRotaryEmbedding)
    }
    let args: MLXLLM.Starcoder2Configuration
    let scale: Swift.Float
    var _wq: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wk: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wv: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wo: MLXNN.ModuleInfo<MLXNN.Linear>
    let rope: MLXNN.RoPE
}
class MLP: MLXNN.Module {
    var _cFc: MLXNN.ModuleInfo<MLXNN.Linear>
    var _cProj: MLXNN.ModuleInfo<MLXNN.Linear>
}
class DecoderLayer: MLXNN.Module {
    let isAttentionLayer: Swift.Bool
    let usesDenseFeedForward: Swift.Bool
    var _attention: MLXNN.ModuleInfo<MLXLLM.Attention?>
    var _conv: MLXNN.ModuleInfo<MLXLLM.ShortConv?>
    var _feedForward: MLXNN.ModuleInfo<MLXNN.Module & MLXNN.UnaryLayer>
    var _operatorNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _ffnNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
}
class BaichuanM1ModelInner: MLXNN.Module {
    let args: MLXLLM.BaichuanM1Configuration
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.DecoderLayer]
    let norm: MLXNN.RMSNorm
}
class BaichuanM1Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.BaichuanM1ModelInner
    let configuration: MLXLLM.BaichuanM1Configuration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct BailingMoeConfiguration {
    enum CodingKeys {
        case modelType
        case hiddenSize
        case intermediateSize
        case maxPositionEmbeddings
        case moeIntermediateSize
        case numExperts
        case numSharedExperts
        case normTopkProb
        case attentionHeads
        case numExpertsPerToken
        case hiddenLayers
        case kvHeads
        case rmsNormEps
        case ropeTheta
        case vocabularySize
        case firstKDenseReplace
        case ropeScaling
        case useBias
        case useQKVBias
        case useQKNorm
        case tieWordEmbeddings
        case partialRotaryFactor
        case moeRouterEnableExpertBias
        case routedScalingFactor
        case scoreFunction
        case nGroup
        case topkGroup
        case moeSharedExpertIntermediateSize
    }
    var modelType: Swift.String
    var hiddenSize: Swift.Int
    var intermediateSize: Swift.Int
    var maxPositionEmbeddings: Swift.Int?
    var moeIntermediateSize: Swift.Int
    var numExperts: Swift.Int
    var numSharedExperts: Swift.Int
    var normTopkProb: Swift.Bool
    var attentionHeads: Swift.Int
    var numExpertsPerToken: Swift.Int
    var hiddenLayers: Swift.Int
    var kvHeads: Swift.Int
    var rmsNormEps: Swift.Float
    var ropeTheta: Swift.Float
    var vocabularySize: Swift.Int
    var firstKDenseReplace: Swift.Int
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var useBias: Swift.Bool
    var useQKVBias: Swift.Bool
    var useQKNorm: Swift.Bool
    var tieWordEmbeddings: Swift.Bool
    var partialRotaryFactor: Swift.Float
    var moeRouterEnableExpertBias: Swift.Bool
    var routedScalingFactor: Swift.Float
    var scoreFunction: Swift.String
    var nGroup: Swift.Int
    var topkGroup: Swift.Int
    var moeSharedExpertIntermediateSize: Swift.Int?
}
class BailingMoeMLP: MLXNN.Module {
    var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
    var _down: MLXNN.ModuleInfo<MLXNN.Linear>
    var _up: MLXNN.ModuleInfo<MLXNN.Linear>
}
class BailingMoeGate: MLXNN.Module {
    let topK: Swift.Int
    let nGroup: Swift.Int
    let topkGroup: Swift.Int
    let numExperts: Swift.Int
    let routedScalingFactor: Swift.Float
    let normTopkProb: Swift.Bool
    let scoreFunction: Swift.String
    var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
    var _expertBias: MLXNN.ModuleInfo<MLX.MLXArray>
}
class BailingMoeSparseMoeBlock: MLXNN.Module {
    let args: MLXLLM.BailingMoeConfiguration
    var _switchMLP: MLXNN.ModuleInfo<MLXLLM.SwitchGLU>
    var _gate: MLXNN.ModuleInfo<MLXLLM.BailingMoeGate>
    var _sharedExperts: MLXNN.ModuleInfo<MLXLLM.BailingMoeMLP?>
}
class TransformerBlock: MLXNN.Module {
    var _attention: MLXNN.ModuleInfo<MLXLLM.Attention>
    let mlp: MLXLLM.MLP
    var _inputLayerNorm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
}
class BailingMoeModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
}
class BailingMoeModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.BailingMoeModelInner
    let configuration: MLXLLM.BailingMoeConfiguration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
class BitLinearKernelManager {
    let bitlinearKernel: MLX.MLXFast.MLXFastKernel
}
class BitLinear: MLXNN.Module {
    let inFeatures: Swift.Int
    let outFeatures: Swift.Int
    let invertWeightScales: Swift.Bool
    let weight: MLX.MLXArray
    let bias: MLX.MLXArray?
    var _weightScale: MLXNN.ModuleInfo<MLX.MLXArray>
}
struct BitnetConfiguration {
    enum CodingKeys {
        case modelType
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case rmsNormEps
        case vocabularySize
        case headDimensions
        case maxPositionEmbeddings
        case kvHeads
        case attentionBias
        case mlpBias
        case ropeTheta
        case ropeTraditional
        case ropeScaling
        case tieWordEmbeddings
    }
    var modelType: Swift.String
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var headDimensions: Swift.Int?
    var maxPositionEmbeddings: Swift.Int?
    var kvHeads: Swift.Int?
    var attentionBias: Swift.Bool
    var mlpBias: Swift.Bool
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
}
class BitnetModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    var norm: MLXNN.RMSNorm
}
class BitnetModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.BitnetModelInner
    let configuration: MLXLLM.BitnetConfiguration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
class CohereModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.LayerNorm
}
class CohereModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.CohereModelInner
    let logitScale: Swift.Float
}
struct CohereConfiguration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case kvHeads
        case ropeTheta
        case vocabularySize
        case layerNormEps
        case logitScale
        case ropeTraditional
        case ropeScaling
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var layerNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var logitScale: Swift.Float
}
struct DeepseekV3Configuration {
    enum CodingKeys {
        case vocabSize
        case hiddenSize
        case intermediateSize
        case moeIntermediateSize
        case numHiddenLayers
        case numAttentionHeads
        case numKeyValueHeads
        case nSharedExperts
        case nRoutedExperts
        case routedScalingFactor
        case kvLoraRank
        case qLoraRank
        case qkRopeHeadDim
        case vHeadDim
        case qkNopeHeadDim
        case normTopkProb
        case nGroup
        case topkGroup
        case numExpertsPerTok
        case moeLayerFreq
        case firstKDenseReplace
        case maxPositionEmbeddings
        case rmsNormEps
        case ropeTheta
        case ropeScaling
        case attentionBias
    }
    var vocabSize: Swift.Int
    var hiddenSize: Swift.Int
    var intermediateSize: Swift.Int
    var moeIntermediateSize: Swift.Int
    var numHiddenLayers: Swift.Int
    var numAttentionHeads: Swift.Int
    var numKeyValueHeads: Swift.Int
    var nSharedExperts: Swift.Int?
    var nRoutedExperts: Swift.Int?
    var routedScalingFactor: Swift.Float
    var kvLoraRank: Swift.Int
    var qLoraRank: Swift.Int
    var qkRopeHeadDim: Swift.Int
    var vHeadDim: Swift.Int
    var qkNopeHeadDim: Swift.Int
    var normTopkProb: Swift.Bool
    var nGroup: Swift.Int?
    var topkGroup: Swift.Int?
    var numExpertsPerTok: Swift.Int?
    var moeLayerFreq: Swift.Int
    var firstKDenseReplace: Swift.Int
    var maxPositionEmbeddings: Swift.Int
    var rmsNormEps: Swift.Float
    var ropeTheta: Swift.Float
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var attentionBias: Swift.Bool
}
class DeepseekV3YarnRotaryEmbedding: MLXNN.Module {
    var mscale: Swift.Float
    let dim: Swift.Int
    let maxPositionEmbeddings: Swift.Int
    let base: Swift.Float
    let scalingFactor: Swift.Float
    let originalMaxPositionEmbeddings: Swift.Int
    let betaFast: Swift.Float
    let betaSlow: Swift.Float
    var _freqs: MLX.MLXArray
}
class DeepseekV3Attention: MLXNN.Module {
    var config: MLXLLM.DeepseekV3Configuration
    var hiddenSize: Swift.Int
    var numHeads: Swift.Int
    var maxPositionEmbeddings: Swift.Int
    var ropeTheta: Swift.Float
    var qLoraRank: Swift.Int?
    var qkRopeHeadDim: Swift.Int
    var kvLoraRank: Swift.Int
    var vHeadDim: Swift.Int
    var qkNopeHeadDim: Swift.Int
    var qHeadDim: Swift.Int
    var scale: Swift.Float
    let rope: MLXLLM.DeepseekV3YarnRotaryEmbedding
    var _qProj: MLXNN.ModuleInfo<MLXNN.Linear?>
    var _qAProj: MLXNN.ModuleInfo<MLXNN.Linear?>
    var _qALayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm?>
    var _qBProj: MLXNN.ModuleInfo<MLXNN.Linear?>
    var _oProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _kvAProjWithMqa: MLXNN.ModuleInfo<MLXNN.Linear>
    var _kvALayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _kvBProj: MLXNN.ModuleInfo<MLXNN.Linear>
}
class DeepseekV3MLP: MLXNN.Module {
    var config: MLXLLM.DeepseekV3Configuration
    var hiddenSize: Swift.Int
    var intermediateSize: Swift.Int
    var _gateProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _upProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _downProj: MLXNN.ModuleInfo<MLXNN.Linear>
}
class MoEGate: MLXNN.Module {
    var config: MLXLLM.DeepseekV3Configuration
    var topK: Swift.Int?
    var normTopkProb: Swift.Bool
    var nRoutedExperts: Swift.Int?
    var routedScalingFactor: Swift.Float
    var nGroup: Swift.Int
    var topkGroup: Swift.Int?
    var weight: MLX.MLXArray
    var e_score_correction_bias: MLX.MLXArray
}
class DeepseekV3MoE: MLXNN.Module {
    var config: MLXLLM.DeepseekV3Configuration
    var numExpertsPerTok: Swift.Int
    var _switchMLP: MLXNN.ModuleInfo<MLXLLM.SwitchGLU>
    var gate: MLXLLM.MoEGate
    var _sharedExperts: MLXNN.ModuleInfo<MLXLLM.DeepseekV3MLP?>
}
class DeepseekV3DecoderLayer: MLXNN.Module {
    var _selfAttn: MLXNN.ModuleInfo<MLXLLM.DeepseekV3Attention>
    var mlp: MLXNN.UnaryLayer
    var _inputLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
}
class DeepseekV3ModelInner: MLXNN.Module {
    var config: MLXLLM.DeepseekV3Configuration
    var vocabSize: Swift.Int
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    var layers: [MLXLLM.DeepseekV3DecoderLayer]
    var startIdx: Swift.Int
    var endIdx: Swift.Int
    var numLayers: Swift.Int
    var _norm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var pipelineRank: Swift.Int
    var pipelineSize: Swift.Int
}
class DeepseekV3Model: MLXNN.Module {
    var kvHeads: [Swift.Int]
    var args: MLXLLM.DeepseekV3Configuration
    var model: MLXLLM.DeepseekV3ModelInner
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear>
}
struct Ernie45Configuration {
    enum CodingKeys {
        case hiddenSize
        case intermediateSize
        case maxPositionEmbeddings
        case numAttentionHeads
        case numKeyValueHeads
        case headDim
        case numHiddenLayers
        case rmsNormEps
        case vocabularySize
        case ropeTheta
        case useBias
        case tieWordEmbeddings
    }
    var hiddenSize: Swift.Int
    var intermediateSize: Swift.Int
    var maxPositionEmbeddings: Swift.Int
    var numAttentionHeads: Swift.Int
    var numKeyValueHeads: Swift.Int
    var headDim: Swift.Int?
    var numHiddenLayers: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var ropeTheta: Swift.Float
    var useBias: Swift.Bool
    var tieWordEmbeddings: Swift.Bool
}
class Ernie45ModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.DecoderLayer]
    let norm: MLXNN.RMSNorm
}
class Ernie45Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.Ernie45ModelInner
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
class ModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXLMCommon.Gemma.RMSNorm
    let hiddenScale: Swift.Float
}
class Exaone4Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.ModelInner
    let configuration: MLXLLM.Exaone4Configuration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct Exaone4Configuration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case maxPositionEmbeddings
        case ropeTheta
        case headDim
        case tieWordEmbeddings
        case ropeScaling
        case slidingWindow
        case slidingWindowPattern
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var maxPositionEmbeddings: Swift.Int
    var ropeTheta: Swift.Float
    var headDim: Swift.Int
    var tieWordEmbeddings: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var slidingWindow: Swift.Int?
    var slidingWindowPattern: Swift.String?
}
struct FalconH1Configuration {
    enum CodingKeys {
        case attentionBias
        case attentionDropout
        case attentionInMultiplier
        case attentionOutMultiplier
        case bosTokenId
        case embeddingMultiplier
        case eosTokenId
        case headDim
        case hiddenAct
        case hiddenSize
        case initializerRange
        case intermediateSize
        case keyMultiplier
        case lmHeadMultiplier
        case mambaChunkSize
        case mambaConvBias
        case mambaDConv
        case mambaDHead
        case mambaDSSM
        case mambaDState
        case mambaExpand
        case mambaNGroups
        case mambaNHeads
        case mambaNormBeforeGate
        case mambaProjBias
        case mambaRMSNorm
        case mambaUseMLP
        case maxPositionEmbeddings
        case mlpBias
        case mlpExpansionFactor
        case mlpMultipliers
        case modelType
        case numAttentionHeads
        case numHiddenLayers
        case numKeyValueHeads
        case numLogitsToKeep
        case padTokenId
        case projectorsBias
        case rmsNormEps
        case ropeTraditional
        case ropeScaling
        case ropeTheta
        case ssmInMultiplier
        case ssmMultipliers
        case ssmOutMultiplier
        case tieWordEmbeddings
        case torchDtype
        case vocabSize
    }
    var attentionBias: Swift.Bool
    var attentionDropout: Swift.Float
    var attentionInMultiplier: Swift.Float
    var attentionOutMultiplier: Swift.Float
    var bosTokenId: Swift.Int
    var embeddingMultiplier: Swift.Float
    var eosTokenId: Swift.Int
    var headDim: Swift.Int
    var hiddenAct: Swift.String
    var hiddenSize: Swift.Int
    var initializerRange: Swift.Float
    var intermediateSize: Swift.Int?
    var keyMultiplier: Swift.Float
    var lmHeadMultiplier: Swift.Float
    var mambaChunkSize: Swift.Int
    var mambaConvBias: Swift.Bool
    var mambaDConv: Swift.Int
    var mambaDHead: Swift.Int
    var mambaDSSM: Swift.Int
    var mambaDState: Swift.Int
    var mambaExpand: Swift.Int
    var mambaNGroups: Swift.Int
    var mambaNHeads: Swift.Int
    var mambaNormBeforeGate: Swift.Bool
    var mambaProjBias: Swift.Bool
    var mambaRMSNorm: Swift.Bool
    var mambaUseMLP: Swift.Bool
    var maxPositionEmbeddings: Swift.Int
    var mlpBias: Swift.Bool
    var mlpExpansionFactor: Swift.Int
    var mlpMultipliers: [Swift.Float]
    var modelType: Swift.String
    var numAttentionHeads: Swift.Int
    var numHiddenLayers: Swift.Int
    var numKeyValueHeads: Swift.Int
    var numLogitsToKeep: Swift.Int
    var padTokenId: Swift.Int
    var projectorsBias: Swift.Bool
    var rmsNormEps: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: Swift.Float?
    var ropeTheta: Swift.Float
    var ssmInMultiplier: Swift.Float
    var ssmMultipliers: [Swift.Float]
    var ssmOutMultiplier: Swift.Float
    var tieWordEmbeddings: Swift.Bool
    var torchDtype: Swift.String
    var vocabSize: Swift.Int
}
class RMSNormGated: MLXNN.Module {
    let weight: MLX.MLXArray
    let varianceEpsilon: Swift.Float
    let nGroups: Swift.Int
    let normBeforeGate: Swift.Bool
}
class Mixer: MLXNN.Module {
    let numHeads: Swift.Int
    let hiddenSize: Swift.Int
    let ssmStateSize: Swift.Int
    let convKernelSize: Swift.Int
    let intermediateSize: Swift.Int
    let useConvBias: Swift.Bool
    let useBias: Swift.Bool
    let layerNormEpsilon: Swift.Float
    let groupsTimeStateSize: Swift.Int
    let nGroups: Swift.Int
    let headDim: Swift.Int
    let chunkSize: Swift.Int
    let timeStepLimit: (Swift.Float, Swift.Float)
    let timeStepMin: Swift.Float
    let timeStepMax: Swift.Float
    let convDim: Swift.Int
    let mambaRMSNorm: Swift.Bool
    var norm: MLXLLM.RMSNormGated?
    let ssmInMultiplier: Swift.Float
    let conv1d: MLXNN.Conv1d
    var _inProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _dtBias: MLXNN.ParameterInfo<MLX.MLXArray>
    var _aLog: MLXNN.ParameterInfo<MLX.MLXArray>
    var _d: MLXNN.ParameterInfo<MLX.MLXArray>
    var _outProj: MLXNN.ModuleInfo<MLXNN.Linear>
}
class FalconH1Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.ModelInner
    let configuration: MLXLLM.FalconH1Configuration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear>
}
class GLM4DecoderLayer: MLXNN.Module {
    var _attention: MLXNN.ModuleInfo<MLXLLM.Attention>
    let mlp: MLXLLM.MLP
    var _inputLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _postSelfAttnLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _postMlpLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
}
class GLM4ModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.GLM4DecoderLayer]
    let norm: MLXNN.RMSNorm
}
class GLM4Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.GLM4ModelInner
    let configuration: MLXLLM.GLM4Configuration
    let modelType: Swift.String
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear>
}
struct GLM4Configuration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case attentionBias
        case headDim
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case partialRotaryFactor
        case ropeTheta
        case ropeTraditional
        case tieWordEmbeddings
        case maxPositionEmbeddings
        case modelType
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var attentionBias: Swift.Bool
    var headDim: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var partialRotaryFactor: Swift.Float
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var tieWordEmbeddings: Swift.Bool
    var maxPositionEmbeddings: Swift.Int
    var modelType: Swift.String
}
struct GPTOSSConfiguration {
    enum CodingKeys {
        case modelType
        case hiddenLayers
        case localExperts
        case expertsPerToken
        case vocabularySize
        case rmsNormEps
        case hiddenSize
        case intermediateSize
        case headDim
        case attentionHeads
        case kvHeads
        case slidingWindow
        case ropeTheta
        case ropeScaling
        case layerTypes
    }
    var modelType: Swift.String
    var hiddenLayers: Swift.Int
    var localExperts: Swift.Int
    var expertsPerToken: Swift.Int
    var vocabularySize: Swift.Int
    var rmsNormEps: Swift.Float
    var hiddenSize: Swift.Int
    var intermediateSize: Swift.Int
    var headDim: Swift.Int
    var attentionHeads: Swift.Int
    var kvHeads: Swift.Int
    var slidingWindow: Swift.Int
    var ropeTheta: Swift.Float
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var layerTypes: [Swift.String]?
}
class SwiGLUSwitchGLU: MLXNN.Module {
    var _gateProj: MLXNN.ModuleInfo<MLXLLM.SwitchLinear>
    var _upProj: MLXNN.ModuleInfo<MLXLLM.SwitchLinear>
    var _downProj: MLXNN.ModuleInfo<MLXLLM.SwitchLinear>
    let inputDims: Swift.Int
    let hiddenDims: Swift.Int
    let numExperts: Swift.Int
}
class AttentionBlock: MLXNN.Module {
    let headDim: Swift.Int
    let numAttentionHeads: Swift.Int
    let numKeyValueHeads: Swift.Int
    let numKeyValueGroups: Swift.Int
    let smScale: Swift.Float
    var _sinks: MLXNN.ParameterInfo<MLX.MLXArray>
    var _qProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _kProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _vProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _oProj: MLXNN.ModuleInfo<MLXNN.Linear>
    let rope: MLXLLM.YarnRoPE
    var _previousMask: MLX.MLXArray?
}
class MLPBlock: MLXNN.Module {
    let hiddenSize: Swift.Int
    let numLocalExperts: Swift.Int
    let numExpertsPerTok: Swift.Int
    var _experts: MLXNN.ModuleInfo<MLXLLM.SwiGLUSwitchGLU>
    var _router: MLXNN.ModuleInfo<MLXNN.Linear>
}
class GPTOSSModel: MLXNN.Module {
    let modelType: Swift.String
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.ModelInner
    let configuration: MLXLLM.GPTOSSConfiguration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear>
}
class RMSNorm: MLXNN.Module {
    let weight: MLX.MLXArray
    let eps: Swift.Float
}
class GemmaModelInner: MLXNN.Module {
    let args: MLXLLM.GemmaConfiguration
    let vocabularySize: Swift.Int
    let numHiddenLayers: Swift.Int
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXLMCommon.Gemma.RMSNorm
}
class GemmaModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let modelType: Swift.String
    let model: MLXLLM.GemmaModelInner
}
struct GemmaConfiguration {
    enum CodingKeys {
        case modelType
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case headDimensions
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case _ropeTheta
        case _ropeTraditional
    }
    var modelType: Swift.String
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var headDimensions: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    let _ropeTheta: Swift.Float?
    let _ropeTraditional: Swift.Bool?
}
class Gemma2Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.ModelInner
    let logitSoftCap: Swift.Float
}
struct Gemma2Configuration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case headDimensions
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case ropeTheta
        case ropeTraditional
        case attnLogitSoftcapping
        case finalLogitSoftcapping
        case queryPreAttnScalar
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var headDimensions: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var attnLogitSoftcapping: Swift.Float
    var finalLogitSoftcapping: Swift.Float
    var queryPreAttnScalar: Swift.Float
}
struct Gemma3TextConfiguration {
    enum CodingKeys {
        case modelType
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case headDim
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case ropeGlobalBaseFreq
        case ropeLocalBaseFreq
        case ropeTraditional
        case queryPreAttnScalar
        case slidingWindow
        case slidingWindowPattern
    }
    enum VLMCodingKeys {
        case textConfig
    }
    let modelType: Swift.String
    let hiddenSize: Swift.Int
    let hiddenLayers: Swift.Int
    let intermediateSize: Swift.Int
    let attentionHeads: Swift.Int
    let headDim: Swift.Int
    let rmsNormEps: Swift.Float
    let vocabularySize: Swift.Int
    let kvHeads: Swift.Int
    let ropeGlobalBaseFreq: Swift.Float
    let ropeLocalBaseFreq: Swift.Float
    let ropeTraditional: Swift.Bool
    let queryPreAttnScalar: Swift.Float
    let slidingWindow: Swift.Int
    let slidingWindowPattern: Swift.Int
}
class Gemma3Model: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    var _layers: MLXNN.ModuleInfo<[MLXLLM.TransformerBlock]>
    var _norm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    let config: MLXLLM.Gemma3TextConfiguration
}
class Gemma3TextModel: MLXNN.Module {
    var _model: MLXNN.ModuleInfo<MLXLLM.Gemma3Model>
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear>
    let config: MLXLLM.Gemma3TextConfiguration
}
struct Gemma3nTextConfiguration {
    enum CodingKeys {
        case modelType
        case hiddenSize
        case numHiddenLayers
        case intermediateSize
        case numAttentionHeads
        case headDim
        case rmsNormEps
        case vocabSize
        case numKeyValueHeads
        case numKvSharedLayers
        case queryPreAttnScalar
        case vocabSizePerLayerInput
        case slidingWindow
        case maxPositionEmbeddings
        case ropeLocalBaseFreq
        case ropeTheta
        case finalLogitSoftcapping
        case layerTypes
        case activationSparsityPattern
        case hiddenSizePerLayerInput
        case altupNumInputs
        case altupCoefClip
        case altupCorrectScale
        case altupActiveIdx
        case laurelRank
        case ropeScaling
        case slidingWindowPattern
    }
    enum VLMCodingKeys {
        case textConfig
    }
    let modelType: Swift.String
    let hiddenSize: Swift.Int
    let numHiddenLayers: Swift.Int
    let intermediateSize: Swift.Int
    let numAttentionHeads: Swift.Int
    let headDim: Swift.Int
    let rmsNormEps: Swift.Float
    let vocabSize: Swift.Int
    let numKeyValueHeads: Swift.Int
    let numKvSharedLayers: Swift.Int
    let queryPreAttnScalar: Swift.Float
    let vocabSizePerLayerInput: Swift.Int
    let slidingWindow: Swift.Int
    let maxPositionEmbeddings: Swift.Int
    let ropeLocalBaseFreq: Swift.Float
    let ropeTheta: Swift.Float
    let finalLogitSoftcapping: Swift.Float
    let layerTypes: [Swift.String]?
    let activationSparsityPattern: [Swift.Float]?
    let hiddenSizePerLayerInput: Swift.Int
    let altupNumInputs: Swift.Int
    let altupCoefClip: Swift.Float?
    let altupCorrectScale: Swift.Bool
    let altupActiveIdx: Swift.Int
    let laurelRank: Swift.Int
    let ropeScaling: [Swift.String : Swift.String]?
    let slidingWindowPattern: Swift.Int?
}
class RMSNoScale: MLXNN.Module {
    let eps: Swift.Float
}
class Gemma3nTextLaurelBlock: MLXNN.Module {
    var _linearLeft: MLXNN.ModuleInfo<MLXNN.Linear>
    var _linearRight: MLXNN.ModuleInfo<MLXNN.Linear>
    var _postLaurelNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
}
class Gemma3nAttention: MLXNN.Module {
    let isSliding: Swift.Bool
    let numHeads: Swift.Int
    let numKVHeads: Swift.Int
    let repeats: Swift.Int
    let headDim: Swift.Int
    let layerIdx: Swift.Int
    let scale: Swift.Float
    let isKvSharedLayer: Swift.Bool
    var _qProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _kProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _vProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _oProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _qNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _kNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _vNorm: MLXNN.ModuleInfo<MLXLLM.RMSNoScale>
    var _rope: MLXNN.ModuleInfo<MLXNN.RoPE>
}
class Gemma3nAltUp: MLXNN.Module {
    var _correctOutputScale: MLXNN.ModuleInfo<MLX.MLXArray>
    var _correctionCoefs: MLXNN.ModuleInfo<MLXNN.Linear>
    var _predictionCoefs: MLXNN.ModuleInfo<MLXNN.Linear>
    var _modalityRouter: MLXNN.ModuleInfo<MLXNN.Linear>
    var _routerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    let _routerInputScale: MLX.MLXArray
    let config: MLXLLM.Gemma3nTextConfiguration
}
class Gemma3nDecoderLayer: MLXNN.Module {
    let config: MLXLLM.Gemma3nTextConfiguration
    let hiddenSize: Swift.Int
    let layerIdx: Swift.Int
    let isSliding: Swift.Bool
    let slidingWindow: Swift.Int
    let hiddenSizePerLayerInput: Swift.Int
    var _selfAttn: MLXNN.ModuleInfo<MLXLLM.Gemma3nAttention>
    var _mlp: MLXNN.ModuleInfo<MLXLLM.MLP>
    var _inputLayernorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _postAttentionLayernorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _preFeedforwardLayernorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _postFeedforwardLayernorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _altup: MLXNN.ModuleInfo<MLXLLM.Gemma3nAltUp>
    var _laurel: MLXNN.ModuleInfo<MLXLLM.Gemma3nTextLaurelBlock>
    var _perLayerInputGate: MLXNN.ModuleInfo<MLXNN.Linear>
    var _perLayerProjection: MLXNN.ModuleInfo<MLXNN.Linear>
    var _postPerLayerInputNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
}
class LanguageModel: MLXNN.Module {
    let config: MLXLLM.Gemma3nTextConfiguration
    let hiddenSize: Swift.Int
    let vocabSize: Swift.Int
    let vocabSizePerLayerInput: Swift.Int
    let numHiddenLayers: Swift.Int
    let firstKvSharedLayerIdx: Swift.Int
    let firstSlidingIdx: Swift.Int
    let firstFullIdx: Swift.Int
    let layerIdxToCacheIdx: [Swift.Int]
    let finalLogitSoftcapping: Swift.Float?
    let _perLayerProjectionScale: MLX.MLXArray
    let _perLayerInputScale: MLX.MLXArray
    let _embedTokensScale: Swift.Float
    let _embedTokensPerLayerScale: Swift.Float
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    var _layers: MLXNN.ModuleInfo<[MLXLLM.Gemma3nDecoderLayer]>
    var _embedTokensPerLayer: MLXNN.ModuleInfo<MLXNN.Embedding>
    var _perLayerModelProjection: MLXNN.ModuleInfo<MLXNN.Linear>
    var _perLayerProjectionNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _altupProjections: MLXNN.ModuleInfo<[MLXNN.Linear]>
    var _altupUnembedProjections: MLXNN.ModuleInfo<[MLXNN.Linear]>
    var _norm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
}
class Gemma3nTextModel: MLXNN.Module {
    var _languageModel: MLXNN.ModuleInfo<MLXLLM.LanguageModel>
    let config: MLXLLM.Gemma3nTextConfiguration
    let modelType: Swift.String
    let textVocabSize: Swift.Int
    var kvHeads: [Swift.Int]
}
class GraniteModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
    let embeddingMultiplier: Swift.Float
}
class GraniteModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let logitsScaling: Swift.Float
    let model: MLXLLM.GraniteModelInner
    let configuration: MLXLLM.GraniteConfiguration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct GraniteConfiguration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case rmsNormEps
        case vocabularySize
        case logitsScaling
        case attentionMultiplier
        case embeddingMultiplier
        case residualMultiplier
        case maxPositionEmbeddings
        case kvHeads
        case attentionBias
        case mlpBias
        case ropeTheta
        case ropeScaling
        case tieWordEmbeddings
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var logitsScaling: Swift.Float
    var attentionMultiplier: Swift.Float
    var embeddingMultiplier: Swift.Float
    var residualMultiplier: Swift.Float
    var maxPositionEmbeddings: Swift.Int
    var kvHeads: Swift.Int
    var attentionBias: Swift.Bool
    var mlpBias: Swift.Bool
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
}
class GraniteMoeHybridRMSNormGated: MLXNN.Module {
    var _weight: MLXNN.ParameterInfo<MLX.MLXArray>
    let eps: Swift.Float
}
class GraniteMoeHybridMamba2Mixer: MLXNN.Module {
    let numHeads: Swift.Int
    let hiddenSize: Swift.Int
    let ssmStateSize: Swift.Int
    let convKernelSize: Swift.Int
    let intermediateSize: Swift.Int
    let numGroups: Swift.Int
    let headDim: Swift.Int
    let timeStepLimit: (Swift.Float, Swift.Float)
    let convDim: Swift.Int
    var _conv1d: MLXNN.ModuleInfo<MLXNN.Conv1d>
    var _inProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _outProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _dtBias: MLXNN.ParameterInfo<MLX.MLXArray>
    var _aLog: MLXNN.ParameterInfo<MLX.MLXArray>
    var _D: MLXNN.ParameterInfo<MLX.MLXArray>
    var _norm: MLXNN.ModuleInfo<MLXLLM.GraniteMoeHybridRMSNormGated>
}
class GraniteMoeHybridAttention: MLXNN.Module {
    let args: MLXLLM.GraniteMoeHybridConfiguration
    let scale: Swift.Float
    var _wq: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wk: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wv: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wo: MLXNN.ModuleInfo<MLXNN.Linear>
    let rope: MLXNN.RoPE?
}
class GraniteMoeHybridTopKGating: MLXNN.Module {
    let numExperts: Swift.Int
    let topK: Swift.Int
    var _layer: MLXNN.ModuleInfo<MLXNN.Linear>
}
class GraniteMoeHybridMoE: MLXNN.Module {
    var _switchMLP: MLXNN.ModuleInfo<MLXLLM.SwitchGLU>
    let router: MLXLLM.GraniteMoeHybridTopKGating
}
class GraniteMoeHybridSharedMLP: MLXNN.Module {
    var _inputLinear: MLXNN.ModuleInfo<MLXNN.Linear>
    var _outputLinear: MLXNN.ModuleInfo<MLXNN.Linear>
}
class GraniteMoeHybridMLP: MLXNN.Module {
    var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
    var _down: MLXNN.ModuleInfo<MLXNN.Linear>
    var _up: MLXNN.ModuleInfo<MLXNN.Linear>
}
class GraniteMoeHybridLayer: MLXNN.Module {
    let layerType: MLXLLM.GraniteMoeHybridLayerType
    let residualMultiplier: Swift.Float
    let useMoE: Swift.Bool
    var _inputLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _selfAttention: MLXNN.ModuleInfo<MLXLLM.GraniteMoeHybridAttention?>
    var _mamba: MLXNN.ModuleInfo<MLXLLM.GraniteMoeHybridMamba2Mixer?>
    var _blockSparseMoE: MLXNN.ModuleInfo<MLXLLM.GraniteMoeHybridMoE?>
    var _sharedMLP: MLXNN.ModuleInfo<MLXLLM.GraniteMoeHybridSharedMLP?>
    var _mlp: MLXNN.ModuleInfo<MLXLLM.GraniteMoeHybridMLP?>
}
class GraniteMoeHybridModelInner: MLXNN.Module {
    let args: MLXLLM.GraniteMoeHybridConfiguration
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.GraniteMoeHybridLayer]
    let norm: MLXNN.RMSNorm
    let embeddingMultiplier: Swift.Float
    let firstAttentionIndex: Swift.Int?
    let firstMambaIndex: Swift.Int?
}
class GraniteMoeHybridModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let logitsScaling: Swift.Float
    let model: MLXLLM.GraniteMoeHybridModelInner
    let configuration: MLXLLM.GraniteMoeHybridConfiguration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct GraniteMoeHybridConfiguration {
    enum CodingKeys {
        case modelType
        case vocabularySize
        case hiddenSize
        case intermediateSize
        case hiddenLayers
        case maxPositionEmbeddings
        case attentionHeads
        case kvHeads
        case attentionBias
        case embeddingMultiplier
        case attentionMultiplier
        case logitsScaling
        case residualMultiplier
        case layerTypes
        case rmsNormEps
        case ropeTheta
        case numLocalExperts
        case numExpertsPerToken
        case sharedIntermediateSize
        case mambaHeads
        case mambaHeadDim
        case mambaProjBias
        case mambaStateDim
        case mambaConvKernel
        case mambaGroups
        case mambaConvBias
        case mlpBias
        case positionEmbeddingType
        case tieWordEmbeddings
        case _timeStepLimit
    }
    var modelType: Swift.String
    var vocabularySize: Swift.Int
    var hiddenSize: Swift.Int
    var intermediateSize: Swift.Int
    var hiddenLayers: Swift.Int
    var maxPositionEmbeddings: Swift.Int
    var attentionHeads: Swift.Int
    var kvHeads: Swift.Int
    var attentionBias: Swift.Bool
    var embeddingMultiplier: Swift.Float
    var attentionMultiplier: Swift.Float
    var logitsScaling: Swift.Float
    var residualMultiplier: Swift.Float
    var layerTypes: [Swift.String]
    var rmsNormEps: Swift.Float
    var ropeTheta: Swift.Float
    var numLocalExperts: Swift.Int?
    var numExpertsPerToken: Swift.Int?
    var sharedIntermediateSize: Swift.Int?
    var mambaHeads: Swift.Int?
    var mambaHeadDim: Swift.Int?
    var mambaProjBias: Swift.Bool?
    var mambaStateDim: Swift.Int?
    var mambaConvKernel: Swift.Int?
    var mambaGroups: Swift.Int?
    var mambaConvBias: Swift.Bool?
    var mlpBias: Swift.Bool
    var positionEmbeddingType: Swift.String
    var tieWordEmbeddings: Swift.Bool
    let _timeStepLimit: [Swift.Float]?
}
enum GraniteMoeHybridLayerType {
    case mamba
    case attention
}
class DynamicNTKScalingRoPE: MLXNN.Module {
    let dims: Swift.Int
    let maxPositionEmbeddings: Swift.Int
    let traditional: Swift.Bool
    var base: Swift.Float?
    let scale: Swift.Float
    let ropeType: Swift.String
    let ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var freqs: MLX.MLXArray?
}
class InternLM2ModelInner: MLXNN.Module {
    var _tokEmbeddings: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
}
class InternLM2Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.InternLM2ModelInner
    var _output: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct InternLM2Configuration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case maxPositionEmbeddings
        case ropeTheta
        case ropeTraditional
        case ropeScaling
        case tieWordEmbeddings
        case bias
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var maxPositionEmbeddings: Swift.Int
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
    var bias: Swift.Bool
}
struct LFM2Configuration {
    enum CodingKeys {
        case modelType
        case vocabularySize
        case hiddenSize
        case hiddenLayers
        case attentionHeads
        case kvHeads
        case maxPositionEmbeddings
        case normEps
        case convBias
        case convLCache
        case _blockDim
        case _blockFFDim
        case blockMultipleOf
        case blockFFNDimMultiplier
        case blockAutoAdjustFFDim
        case _fullAttnIdxs
        case layerTypes
        case ropeTheta
    }
    let modelType: Swift.String
    let vocabularySize: Swift.Int
    let hiddenSize: Swift.Int
    let hiddenLayers: Swift.Int
    let attentionHeads: Swift.Int
    let kvHeads: Swift.Int
    let maxPositionEmbeddings: Swift.Int?
    let normEps: Swift.Float
    let convBias: Swift.Bool
    let convLCache: Swift.Int
    let _blockDim: Swift.Int?
    let _blockFFDim: Swift.Int?
    let blockMultipleOf: Swift.Int
    let blockFFNDimMultiplier: Swift.Float
    let blockAutoAdjustFFDim: Swift.Bool
    let _fullAttnIdxs: [Swift.Int]?
    let layerTypes: [Swift.String]?
    let ropeTheta: Swift.Float
}
class ShortConv: MLXNN.Module {
    let args: MLXLLM.LFM2MoEConfiguration
    let layerIdx: Swift.Int
    let lCache: Swift.Int
    let bias: Swift.Bool
    var _conv: MLXNN.ModuleInfo<MLXNN.Conv1d>
    var _inProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _outProj: MLXNN.ModuleInfo<MLXNN.Linear>
}
class LFM2ModelInner: MLXNN.Module {
    let args: MLXLLM.LFM2Configuration
    let vocabularySize: Swift.Int
    let numHiddenLayers: Swift.Int
    let layers: [MLXLLM.DecoderLayer]
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    var _embeddingNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
}
class LFM2Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.LFM2ModelInner
    let configuration: MLXLLM.LFM2Configuration
}
struct LFM2MoEConfiguration {
    enum CodingKeys {
        case modelType
        case vocabularySize
        case hiddenSize
        case intermediateSize
        case moeIntermediateSize
        case hiddenLayers
        case numExperts
        case numExpertsPerToken
        case normTopkProb
        case attentionHeads
        case kvHeads
        case maxPositionEmbeddings
        case useExpertBias
        case numDenseLayers
        case normEps
        case convBias
        case convLCache
        case ropeTheta
        case _fullAttnIdxs
        case layerTypes
    }
    let modelType: Swift.String
    let vocabularySize: Swift.Int
    let hiddenSize: Swift.Int
    let intermediateSize: Swift.Int
    let moeIntermediateSize: Swift.Int
    let hiddenLayers: Swift.Int
    let numExperts: Swift.Int
    let numExpertsPerToken: Swift.Int
    let normTopkProb: Swift.Bool
    let attentionHeads: Swift.Int
    let kvHeads: Swift.Int
    let maxPositionEmbeddings: Swift.Int
    let useExpertBias: Swift.Bool
    let numDenseLayers: Swift.Int
    let normEps: Swift.Float
    let convBias: Swift.Bool
    let convLCache: Swift.Int
    let ropeTheta: Swift.Float
    let _fullAttnIdxs: [Swift.Int]?
    let layerTypes: [Swift.String]?
}
class Lfm2MoeSparseMoeBlock: MLXNN.Module {
    let args: MLXLLM.LFM2MoEConfiguration
    let numExperts: Swift.Int
    let topK: Swift.Int
    let normTopKProb: Swift.Bool
    let useExpertBias: Swift.Bool
    var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
    var _switchMLP: MLXNN.ModuleInfo<MLXLLM.SwitchGLU>
    var _expertBias: MLXNN.ModuleInfo<MLX.MLXArray?>
}
class LFM2MoEModelInner: MLXNN.Module {
    let args: MLXLLM.LFM2MoEConfiguration
    let layers: [MLXLLM.DecoderLayer]
    let firstAttentionIndex: Swift.Int?
    let firstConvIndex: Swift.Int?
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    var _embeddingNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
}
class LFM2MoEModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let configuration: MLXLLM.LFM2MoEConfiguration
    let model: MLXLLM.LFM2MoEModelInner
}
class Lille130mAttention: MLXNN.Module {
    let args: MLXLLM.Lille130mConfiguration
    let headDim: Swift.Int
    let scale: Swift.Float
    var _qkvProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _outProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _norm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var rope: MLXNN.RoPE
}
class Lille130mMLP: MLXNN.Module {
    var _norm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
    var _up: MLXNN.ModuleInfo<MLXNN.Linear>
    var _down: MLXNN.ModuleInfo<MLXNN.Linear>
}
class Lille130mBlock: MLXNN.Module {
    var _attention: MLXNN.ModuleInfo<MLXLLM.Lille130mAttention>
    var _feedForward: MLXNN.ModuleInfo<MLXLLM.Lille130mMLP>
}
class Lille130mModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.Lille130mBlock]
    let norm: MLXNN.RMSNorm
}
class Lille130mModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    var _transformer: MLXNN.ModuleInfo<MLXLLM.Lille130mModelInner>
    let configuration: MLXLLM.Lille130mConfiguration
}
struct Lille130mConfiguration {
    enum CodingKeys {
        case modelType
        case blockSize
        case layerNormEps
        case hiddenSize
        case attentionHeads
        case kvHeads
        case hiddenLayers
        case ropeTheta
        case vocabularySize
    }
    var modelType: Swift.String
    var blockSize: Swift.Int
    var layerNormEps: Swift.Float
    var hiddenSize: Swift.Int
    var attentionHeads: Swift.Int
    var kvHeads: Swift.Int
    var hiddenLayers: Swift.Int
    var ropeTheta: Swift.Float
    var vocabularySize: Swift.Int
    var tieWordEmbeddings: Swift.Bool
}
class LlamaModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
}
class LlamaModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.LlamaModelInner
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct LlamaConfiguration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case headDimensions
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case maxPositionEmbeddings
        case ropeTheta
        case ropeTraditional
        case ropeScaling
        case tieWordEmbeddings
        case attentionBias
        case mlpBias
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var headDimensions: Swift.Int?
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var maxPositionEmbeddings: Swift.Int?
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
    var attentionBias: Swift.Bool
    var mlpBias: Swift.Bool
}
class MiMoModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
    let numNextnPredictLayers: Swift.Int
}
class MiMoModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.MiMoModelInner
    let configuration: MLXLLM.MiMoConfiguration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct MiMoConfiguration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case maxPositionEmbeddings
        case ropeTheta
        case ropeTraditional
        case ropeScaling
        case tieWordEmbeddings
        case numNextnPredictLayers
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var maxPositionEmbeddings: Swift.Int
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
    var numNextnPredictLayers: Swift.Int
}
class Olmo2ModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
}
class Olmo2Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.Olmo2ModelInner
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct Olmo2Configuration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case headDimensions
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case maxPositionEmbeddings
        case ropeTheta
        case ropeTraditional
        case ropeScaling
        case tieWordEmbeddings
        case attentionBias
        case mlpBias
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var headDimensions: Swift.Int?
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var maxPositionEmbeddings: Swift.Int?
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
    var attentionBias: Swift.Bool
    var mlpBias: Swift.Bool
}
class OlmoeSparseMoeBlock: MLXNN.Module {
    let numExperts: Swift.Int
    let topK: Swift.Int
    let normTopkProb: Swift.Bool
    var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
    var _switchMLP: MLXNN.ModuleInfo<MLXLLM.SwitchGLU>
}
class OlmoEModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
}
class OlmoEModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.OlmoEModelInner
    let configuration: MLXLLM.OlmoEConfiguration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct OlmoEConfiguration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case headDimensions
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case maxPositionEmbeddings
        case ropeTheta
        case ropeTraditional
        case ropeScaling
        case tieWordEmbeddings
        case attentionBias
        case mlpBias
        case numExperts
        case numExpertsPerToken
        case normTopkProb
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var headDimensions: Swift.Int?
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var maxPositionEmbeddings: Swift.Int?
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
    var attentionBias: Swift.Bool
    var mlpBias: Swift.Bool
    var numExperts: Swift.Int
    var numExpertsPerToken: Swift.Int
    var normTopkProb: Swift.Bool
}
class MultiHeadCausalAttention: MLXNN.Module {
    let scale: Swift.Float
    let heads: Swift.Int
    let headDim: Swift.Int
    let kvHeads: Swift.Int
    var _qkvProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _outProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _qNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm?>
    var _kNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm?>
    let rope: MLXNN.RoPE
}
class FeedForwardNetwork: MLXNN.Module {
    var _proj_1: MLXNN.ModuleInfo<MLXNN.Linear>
    var _proj_2: MLXNN.ModuleInfo<MLXNN.Linear>
}
class TransformerDecoderLayer: MLXNN.Module {
    var _attn: MLXNN.ModuleInfo<MLXLLM.MultiHeadCausalAttention>
    let ffn: MLXLLM.FeedForwardNetwork
    var _ffnNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _attnNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
}
class OpenELMModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerDecoderLayer]
    let norm: MLXNN.RMSNorm
}
class OpenELMModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let transformer: MLXLLM.OpenELMModelInner
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct OpenElmConfiguration {
    enum CodingKeys {
        case modelType
        case headDimensions
        case numTransformerLayers
        case modelDim
        case vocabularySize
        case ffnDimDivisor
        case ffnMultipliers
        case ffnWithGlu
        case normalizeQkProjections
        case shareInputOutputLayers
    }
    var modelType: Swift.String
    var headDimensions: Swift.Int
    var numTransformerLayers: Swift.Int
    var modelDim: Swift.Int
    var vocabularySize: Swift.Int
    var ffnDimDivisor: Swift.Int
    var numQueryHeads: [Swift.Int]
    var kvHeads: [Swift.Int]
    var ffnWithGlu: Swift.Bool
    var normalizeQkProjections: Swift.Bool
    var shareInputOutputLayers: Swift.Bool
    var rmsNormEps: Swift.Float
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var numGqaGroups: Swift.Int
    var ffnMultipliers: [Swift.Float]
    var qkvMultiplier: [Swift.Float]
}
class PhiAttention: MLXNN.Module {
    let args: MLXLLM.PhiConfiguration
    let heads: Swift.Int
    let headDim: Swift.Int
    var _wq: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wk: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wv: MLXNN.ModuleInfo<MLXNN.Linear>
    var _dense: MLXNN.ModuleInfo<MLXNN.Linear>
    let rope: MLXNN.RoPE
}
class PhiMLP: MLXNN.Module {
    var _fc1: MLXNN.ModuleInfo<MLXNN.Linear>
    var _fc2: MLXNN.ModuleInfo<MLXNN.Linear>
    var _act: MLXNN.ModuleInfo<MLXNN.GELU>
}
class PhiDecoderLayer: MLXNN.Module {
    var _selfAttention: MLXNN.ModuleInfo<MLXLLM.PhiAttention>
    var _inputLayerNorm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    var mlp: MLXLLM.PhiMLP
}
class PhiModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    var _layers: MLXNN.ModuleInfo<[MLXLLM.PhiDecoderLayer]>
    var _finalLayerNorm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
}
class PhiModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.PhiModelInner
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear>
}
struct PhiConfiguration {
    enum CodingKeys {
        case maxPositionalEmbeddings
        case vocabularySize
        case hiddenSize
        case attentionHeads
        case hiddenLayers
        case kvHeads
        case partialRotaryFactor
        case intermediateSize
        case layerNormEps
        case ropeTheta
    }
    var maxPositionalEmbeddings: Swift.Int
    var vocabularySize: Swift.Int
    var hiddenSize: Swift.Int
    var attentionHeads: Swift.Int
    var hiddenLayers: Swift.Int
    var kvHeads: Swift.Int
    var partialRotaryFactor: Swift.Float
    var intermediateSize: Swift.Int
    var layerNormEps: Swift.Float
    var ropeTheta: Swift.Float
}
class Phi3ModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
    let args: MLXLLM.Phi3Configuration
}
class Phi3Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.Phi3ModelInner
    let args: MLXLLM.Phi3Configuration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct Phi3Configuration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case ropeTheta
        case ropeTraditional
        case ropeScaling
        case partialRotaryFactor
        case maxPositionEmbeddings
        case originalMaxPositionEmbeddings
        case tieWordEmbeddings
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: MLXLLM.RopeScalingWithFactorArrays?
    var partialRotaryFactor: Swift.Float
    var maxPositionEmbeddings: Swift.Int
    var originalMaxPositionEmbeddings: Swift.Int
    var tieWordEmbeddings: Swift.Bool
}
struct RopeScalingWithFactorArrays {
    enum CodingKeys {
        case type
        case factor
        case longFactor
        case shortFactor
        case longMScale
        case shortMScale
    }
    let longFactor: [Swift.Float]?
    let shortFactor: [Swift.Float]?
    let factor: Swift.Float?
    let type: Swift.String?
    let longMScale: Swift.Float?
    let shortMScale: Swift.Float?
}
struct PhiMoEConfiguration {
    enum CodingKeys {
        case modelType
        case vocabularySize
        case hiddenSize
        case intermediateSize
        case hiddenLayers
        case attentionHeads
        case kvHeads
        case maxPositionEmbeddings
        case originalMaxPositionEmbeddings
        case rmsNormEps
        case ropeScaling
        case numLocalExperts
        case numExpertsPerToken
        case ropeTheta
    }
    var modelType: Swift.String
    var vocabularySize: Swift.Int
    var hiddenSize: Swift.Int
    var intermediateSize: Swift.Int
    var hiddenLayers: Swift.Int
    var attentionHeads: Swift.Int
    var kvHeads: Swift.Int
    var maxPositionEmbeddings: Swift.Int
    var originalMaxPositionEmbeddings: Swift.Int
    var rmsNormEps: Swift.Float
    var ropeScaling: MLXLLM.RopeScalingWithFactorArrays?
    var numLocalExperts: Swift.Int
    var numExpertsPerToken: Swift.Int
    var ropeTheta: Swift.Float
}
class PhiMoESparseMoeBlock: MLXNN.Module {
    let hiddenDim: Swift.Int
    let ffnDim: Swift.Int
    let numExperts: Swift.Int
    let topK: Swift.Int
    var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
    var _switchMLP: MLXNN.ModuleInfo<MLXLLM.SwitchGLU>
}
class PhiMoEDecoderLayer: MLXNN.Module {
    let hiddenSize: Swift.Int
    var _selfAttn: MLXNN.ModuleInfo<MLXLLM.Attention>
    var _blockSparseMoe: MLXNN.ModuleInfo<MLXLLM.PhiMoESparseMoeBlock>
    var _inputLayerNorm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
}
class PhiMoEModelInner: MLXNN.Module {
    let args: MLXLLM.PhiMoEConfiguration
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.PhiMoEDecoderLayer]
    var _norm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
}
class PhiMoEModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.PhiMoEModelInner
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear>
}
class Qwen2ModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
}
class Qwen2Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.Qwen2ModelInner
    let configuration: MLXLLM.Qwen2Configuration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct Qwen2Configuration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case ropeTheta
        case ropeTraditional
        case ropeScaling
        case tieWordEmbeddings
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
}
class Qwen3ModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
}
class Qwen3Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.Qwen3ModelInner
    let configuration: MLXLLM.Qwen3Configuration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct Qwen3Configuration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case ropeTheta
        case headDim
        case ropeScaling
        case tieWordEmbeddings
        case maxPositionEmbeddings
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var ropeTheta: Swift.Float
    var headDim: Swift.Int
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
    var maxPositionEmbeddings: Swift.Int
}
class Qwen3MoESparseMoeBlock: MLXNN.Module {
    let numExperts: Swift.Int
    let topK: Swift.Int
    let normTopkProb: Swift.Bool
    var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
    var _switchMLP: MLXNN.ModuleInfo<MLXLLM.SwitchGLU>
}
class Qwen3MoeDecoderLayer: MLXNN.Module {
    let args: MLXLLM.Qwen3MoEConfiguration
    let layerIdx: Swift.Int
    var _selfAttn: MLXNN.ModuleInfo<MLXLLM.Attention>
    var _inputLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    let mlp: MLXNN.UnaryLayer
}
class Qwen3MoEModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.Qwen3MoeDecoderLayer]
    let norm: MLXNN.RMSNorm
    let args: MLXLLM.Qwen3MoEConfiguration
}
class Qwen3MoEModel: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.Qwen3MoEModelInner
    let configuration: MLXLLM.Qwen3MoEConfiguration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct Qwen3MoEConfiguration {
    enum CodingKeys {
        case modelType
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case numExperts
        case numExpertsPerToken
        case decoderSparseStep
        case mlpOnlyLayers
        case moeIntermediateSize
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case headDim
        case ropeTheta
        case tieWordEmbeddings
        case maxPositionEmbeddings
        case normTopkProb
        case ropeScaling
    }
    var modelType: Swift.String
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var numExperts: Swift.Int
    var numExpertsPerToken: Swift.Int
    var decoderSparseStep: Swift.Int
    var mlpOnlyLayers: [Swift.Int]
    var moeIntermediateSize: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var headDim: Swift.Int
    var ropeTheta: Swift.Float
    var tieWordEmbeddings: Swift.Bool
    var maxPositionEmbeddings: Swift.Int
    var normTopkProb: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
}
class YarnRoPE: MLXNN.Module {
    let dimensions: Swift.Int
    let traditional: Swift.Bool
    let maxPositionEmbeddings: Swift.Int
    let base: Swift.Float
    let scalingFactor: Swift.Float
    let originalMaxPositionEmbeddings: Swift.Int
    let betaFast: Swift.Float
    let betaSlow: Swift.Float
    let mscale: Swift.Float
    let mscaleAllDim: Swift.Float
    let _mscale: Swift.Float
    let _freqs: MLX.MLXArray
}
class SSMKernelManager {
    let ssmKernel: MLX.MLXFast.MLXFastKernel?
}
class NoPE: MLXNN.Module {}
class SmolLM3ModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.RMSNorm
}
class SmolLM3Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let model: MLXLLM.SmolLM3ModelInner
    let configuration: MLXLLM.SmolLM3Configuration
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
}
struct SmolLM3Configuration {
    enum CodingKeys {
        case modelType
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case headDimensions
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case maxPositionEmbeddings
        case ropeTheta
        case ropeTraditional
        case ropeScaling
        case tieWordEmbeddings
        case attentionBias
        case mlpBias
        case noRopeLayerInterval
        case noRopeLayers
    }
    var modelType: Swift.String
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var headDimensions: Swift.Int?
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var maxPositionEmbeddings: Swift.Int?
    var ropeTheta: Swift.Float
    var ropeTraditional: Swift.Bool
    var ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
    var attentionBias: Swift.Bool
    var mlpBias: Swift.Bool
    var noRopeLayerInterval: Swift.Int
    var noRopeLayers: [Swift.Int]
}
class Starcoder2ModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXLLM.TransformerBlock]
    let norm: MLXNN.LayerNorm
}
class Starcoder2Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    let tieWordEmbeddings: Swift.Bool
    let model: MLXLLM.Starcoder2ModelInner
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear>
}
struct Starcoder2Configuration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case kvHeads
        case maxPositionEmbeddings
        case normEpsilon
        case normType
        case vocabularySize
        case ropeTheta
        case tieWordEmbeddings
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var kvHeads: Swift.Int
    var maxPositionEmbeddings: Swift.Int
    var normEpsilon: Swift.Float
    var normType: Swift.String
    var vocabularySize: Swift.Int
    var ropeTheta: Swift.Float
    var tieWordEmbeddings: Swift.Bool
}
class SuScaledRotaryEmbedding: MLXNN.Module {
    let dimensions: Swift.Int
    let maxPositionEmbeddings: Swift.Int
    let originalMaxPositionEmbeddings: Swift.Int
    let scale: Swift.Float
    let _freqs: MLX.MLXArray
}
class SwitchGLU: MLXNN.Module {
    var _gateProj: MLXNN.ModuleInfo<MLXLLM.SwitchLinear>
    var _upProj: MLXNN.ModuleInfo<MLXLLM.SwitchLinear>
    var _downProj: MLXNN.ModuleInfo<MLXLLM.SwitchLinear>
    let inputDims: Swift.Int
    let hiddenDims: Swift.Int
    let numExperts: Swift.Int
    let activation: (_: MLX.MLXArray) -> MLX.MLXArray
}
class SwitchLinear: MLXNN.Module {
    var _weight: MLXNN.ModuleInfo<MLX.MLXArray>
    var _bias: MLXNN.ModuleInfo<MLX.MLXArray?>
    let inputDims: Swift.Int
    let outputDims: Swift.Int
    let numExperts: Swift.Int
}
class QuantizedSwitchLinear: MLXLLM.SwitchLinear {
    var _scales: MLXNN.ModuleInfo<MLX.MLXArray>
    var _biases: MLXNN.ModuleInfo<MLX.MLXArray>
    let groupSize: Swift.Int
    let bits: Swift.Int
}
struct ArrayAt {
    let array: MLX.MLXArray
}
struct ArrayAtIndices {
    let array: MLX.MLXArray
    let indexOperations: [MLX.MLXArrayIndexOperation]
    let stream: MLX.StreamOrDevice
}
class ClosureCaptureState {
    let keys: [Swift.String]
    let f: (_: [MLX.MLXArray]) -> [MLX.MLXArray]
}
enum DType {
    struct FInfo {
        let dtype: MLX.DType
    }
    case bool
    case uint8
    case uint16
    case uint32
    case uint64
    case int8
    case int16
    case int32
    case int64
    case float16
    case float32
    case bfloat16
    case complex64
    case float64
}
enum DeviceType {
    case cpu
    case gpu
}
class Device {
    let ctx: __C.mlx_device_
    let defaultStream: MLX.Stream
}
enum MLXError {
    case caught(Swift.String)
}
class ErrorBox {
    let lock: __C.NSLock
    var _firstError: Swift.Error?
}
class ErrorHandler {
    let lock: __C.NSLock
    var globalHandler: (@convention(c) (Swift.UnsafePointer<Swift.Int8>?, Swift.UnsafeMutableRawPointer?) -> ())?
    var globalData: Swift.UnsafeMutableRawPointer?
    var globalDtor: (@convention(c) (_: Swift.UnsafeMutableRawPointer?) -> ())?
}
class FunctionExporterSingle {
    let url: Foundation.URL
    let shapeless: Swift.Bool
    let f: (_: [MLX.MLXArray]) -> [MLX.MLXArray]
}
class FunctionExporterMultiple {
    let exporter: __C.mlx_function_exporter_
}
class ImportedFunction {
    let ctx: __C.mlx_imported_function_
}
enum MLXFFT {}
enum GPU {
    struct Snapshot {
        enum CodingKeys {
            case activeMemory
            case cacheMemory
            case peakMemory
        }
        var activeMemory: Swift.Int
        var cacheMemory: Swift.Int
        var peakMemory: Swift.Int
    }
    struct DeviceInfo {
        let architecture: Swift.String
        let maxBufferSize: Swift.Int
        let maxRecommendedWorkingSetSize: Swift.UInt64
        let memorySize: Swift.Int
    }
}
enum LoadSaveError {
    case unableToOpen(Foundation.URL, Swift.String)
    case unknownExtension(Swift.String)
}
class IOState {
    var offset: Swift.Int
    var data: Foundation.Data
}
enum MLXLinalg {
    enum NormKind {
        case fro
    }
}
enum MLXArrayIndexOperation {
    case index(Swift.Int32)
    case slice(MLX.MLXSlice)
    case array(MLX.MLXArray)
    case ellipsis
    case newAxis
}
struct MLXEllipsisIndex {}
struct MLXNewAxisIndex {}
struct MLXSlice {
    let _start: Swift.Int32?
    let _end: Swift.Int32?
    let _stride: Swift.Int32?
}
class MLXArray {
    enum AccessMethod {
        case copy
        case noCopyIfContiguous
        case noCopy
    }
    struct MLXArrayData {
        let data: Foundation.Data
        let shape: [Swift.Int]
        let strides: [Swift.Int]
        let dType: MLX.DType
    }
    struct MLXArrayIterator {
        var index: Swift.Int
        let count: Swift.Int
        let array: MLX.MLXArray
    }
    var ctx: __C.mlx_array_
}
enum MLXFast {
    enum ScaledDotProductAttentionMaskMode {
        case array(MLX.MLXArray)
        case arrays([MLX.MLXArray])
        case none
        case causal
    }
    class MLXFastKernel {
        let kernel: __C.mlx_fast_metal_kernel_
        let outputNames: [Swift.String]
    }
}
enum NestedItem<A, B> where A: Swift.Hashable {
    indirect case value(B)
    indirect case array([MLX.NestedItem<A, B>])
    indirect case dictionary([A : MLX.NestedItem<A, B>])
    case none
}
struct NestedDictionary<A, B> where A: Swift.Hashable {
    var contents: [A : MLX.NestedItem<A, B>]
}
enum ConvolveMode {
    case full
    case valid
    case same
}
enum MeshGridIndexing {
    case xy
    case ij
}
enum PadMode {
    case constant
    case edge
}
struct IntOrPair {
    let values: (Swift.Int, Swift.Int)
}
struct IntOrTriple {
    let values: (Swift.Int, Swift.Int, Swift.Int)
}
enum IntOrArray {
    case int(Swift.Int)
    case array([Swift.Int])
}
enum FloatOrArray {
    case float(Swift.Float)
    case array([Swift.Float])
}
enum MLXRandom {
    class RandomState {
        var state: MLX.MLXArray
        let lock: __C.NSLock
    }
}
struct StreamOrDevice {
    let stream: MLX.Stream
}
class Stream {
    let ctx: __C.mlx_stream_
}
class CompiledFunction {
    var id: Swift.UInt?
    let lock: __C.NSLock
    let f: (_: [MLX.MLXArray]) -> [MLX.MLXArray]
    let inputs: [MLX.Updatable]
    let outputs: [MLX.Updatable]
    let shapeless: Swift.Bool
}
enum Augmented {}
enum Relaxed {}
struct Complex<A> where A: RealModule.Real {
    var x: A
    var y: A
}
class GLU: MLXNN.Module {
    var axis: Swift.Int
}
class Sigmoid: MLXNN.Module {}
class Mish: MLXNN.Module {}
class ReLU: MLXNN.Module {}
class LeakyReLU: MLXNN.Module {
    var negativeSlope: Swift.Float
}
class ReLU6: MLXNN.Module {}
class ReLUSquared: MLXNN.Module {}
class SoftMax: MLXNN.Module {}
class Softmax: MLXNN.Module {
    var axis: Swift.Int
}
class SoftPlus: MLXNN.Module {}
class Softplus: MLXNN.Module {}
class SoftSign: MLXNN.Module {}
class Softsign: MLXNN.Module {}
class CELU: MLXNN.Module {
    var alpha: Swift.Float
}
class SiLU: MLXNN.Module {}
class LogSoftMax: MLXNN.Module {}
class LogSoftmax: MLXNN.Module {
    var axis: Swift.Int
}
class LogSigmoid: MLXNN.Module {}
class PReLU: MLXNN.Module {
    let weight: MLX.MLXArray
}
class GELU: MLXNN.Module {
    enum Approximation {
        case none
        case precise
        case tanh
        case fast
    }
    let approximation: MLXNN.GELU.Approximation
}
class Tanh: MLXNN.Module {}
class HardSwish: MLXNN.Module {}
class Step: MLXNN.Module {
    var threshold: Swift.Float
}
class SELU: MLXNN.Module {}
class Cache<A, B> where A: Swift.Hashable {
    struct Entry {
        let value: B
        let serial: Swift.Int
    }
    let queue: __C.OS_dispatch_queue
    let maxSize: Swift.Int
    var contents: [A : MLXNN.Cache<A, B>.Entry]
    var serial: Swift.Int
}
class Sequential: MLXNN.Module {
    let layers: [MLXNN.UnaryLayer]
}
struct SequentialBuilder {}
class Conv1d: MLXNN.Module {
    let weight: MLX.MLXArray
    let bias: MLX.MLXArray?
    let padding: Swift.Int
    let dilation: Swift.Int
    let stride: Swift.Int
    let groups: Swift.Int
}
class Conv2d: MLXNN.Module {
    let weight: MLX.MLXArray
    let bias: MLX.MLXArray?
    let padding: (Swift.Int, Swift.Int)
    let dilation: (Swift.Int, Swift.Int)
    let stride: (Swift.Int, Swift.Int)
    let groups: Swift.Int
}
class Conv3d: MLXNN.Module {
    let weight: MLX.MLXArray
    let bias: MLX.MLXArray?
    let padding: (Swift.Int, Swift.Int, Swift.Int)
    let dilation: (Swift.Int, Swift.Int, Swift.Int)
    let stride: (Swift.Int, Swift.Int, Swift.Int)
    let groups: Swift.Int
}
class ConvTransposed1d: MLXNN.Module {
    let weight: MLX.MLXArray
    let bias: MLX.MLXArray?
    let padding: Swift.Int
    let dilation: Swift.Int
    let stride: Swift.Int
    let groups: Swift.Int
}
class ConvTransposed2d: MLXNN.Module {
    let weight: MLX.MLXArray
    let bias: MLX.MLXArray?
    let padding: (Swift.Int, Swift.Int)
    let dilation: (Swift.Int, Swift.Int)
    let stride: (Swift.Int, Swift.Int)
    let groups: Swift.Int
}
class ConvTransposed3d: MLXNN.Module {
    let weight: MLX.MLXArray
    let bias: MLX.MLXArray?
    let padding: (Swift.Int, Swift.Int, Swift.Int)
    let dilation: (Swift.Int, Swift.Int, Swift.Int)
    let stride: (Swift.Int, Swift.Int, Swift.Int)
    let groups: Swift.Int
}
class Dropout: MLXNN.Module {
    let p1: Swift.Float
}
class Dropout2d: MLXNN.Module {
    let p1: Swift.Float
}
class Dropout3d: MLXNN.Module {
    let p1: Swift.Float
}
class Embedding: MLXNN.Module {
    let weight: MLX.MLXArray
}
class Identity: MLXNN.Module {}
class Linear: MLXNN.Module {
    let weight: MLX.MLXArray
    let bias: MLX.MLXArray?
}
class Bilinear: MLXNN.Module {
    let weight: MLX.MLXArray
    let bias: MLX.MLXArray?
}
enum LossReduction {
    case mean
    case sum
    case none
}
class Module {
    struct VerifyUpdate {
        let rawValue: Swift.Int
    }
    var training: Swift.Bool
    var _noGrad: Swift.Set<Swift.String>
    var _items: MLX.NestedDictionary<Swift.String, MLXNN.ModuleValue>?
    var _setters: [Swift.String : MLXNN.TypeErasedSetter]?
}
enum ModuleValue {
    case parameters(MLX.MLXArray)
    case module(MLXNN.Module)
    case other(Any)
    case none
}
class ParameterInfo<A> {
    var value: A?
    let key: Swift.String?
}
class ModuleInfo<A> {
    struct Setter {
        var info: 
    }
    var module: A?
    let key: Swift.String?
}
enum UpdateError {
    case unableToCollectModulesFromContainer(path: [Swift.String], modules: [Swift.String])
    case mismatchedContainers(base: Swift.String, key: Swift.String)
    case mismatchedSize(path: [Swift.String], modules: [Swift.String], expectedShape: [Swift.Int], actualShape: [Swift.Int])
    case keyNotFound(path: [Swift.String], modules: [Swift.String])
    case needModuleInfo(Swift.String)
    case unableToSet(Swift.String)
    case unableToCast(Swift.String)
    case unhandledKeys(path: [Swift.String], modules: [Swift.String], keys: [Swift.String])
}
class InstanceNorm: MLXNN.Module {
    let dimensions: Swift.Int
    let eps: Swift.Float
    let weight: MLX.MLXArray?
    let bias: MLX.MLXArray?
}
class LayerNorm: MLXNN.Module {
    let dimensions: Swift.Int
    let eps: Swift.Float
    let weight: MLX.MLXArray?
    let bias: MLX.MLXArray?
}
class RMSNorm: MLXNN.Module {
    let weight: MLX.MLXArray
    let eps: Swift.Float
}
class GroupNorm: MLXNN.Module {
    let groupCount: Swift.Int
    let dimensions: Swift.Int
    let eps: Swift.Float
    let pytorchCompatible: Swift.Bool
    let weight: MLX.MLXArray?
    let bias: MLX.MLXArray?
}
class BatchNorm: MLXNN.Module {
    let featureCount: Swift.Int
    let eps: Swift.Float
    let momentum: Swift.Float
    let weight: MLX.MLXArray?
    let bias: MLX.MLXArray?
    var _runningMean: MLXNN.ParameterInfo<MLX.MLXArray?>
    var _runningVar: MLXNN.ParameterInfo<MLX.MLXArray?>
}
class Pool: MLXNN.Module {
    let kernelSize: [Swift.Int]
    let stride: [Swift.Int]
    let axes: [Swift.Int]
    let poolingOp: (MLX.MLXArray, [Swift.Int]) -> MLX.MLXArray
}
class MaxPool1d: MLXNN.Pool {}
class MaxPool2d: MLXNN.Pool {}
class AvgPool1d: MLXNN.Pool {}
class AvgPool2d: MLXNN.Pool {}
class RoPE: MLXNN.Module {
    let dimensions: Swift.Int
    let traditional: Swift.Bool
    let base: Swift.Float
    let scale: Swift.Float
}
class SinusoidalPositionalEncoding: MLXNN.Module {
    let _sigmas: MLX.MLXArray
    let scale: Swift.Float
    let cosineFirst: Swift.Bool
}
class ALiBi: MLXNN.Module {
    struct Key {
        let qSequenceLength: Swift.Int
        let kSequenceLength: Swift.Int
        let numHeads: Swift.Int
        let offset: Swift.Int
        let dtype: MLX.DType
    }
}
class QuantizedEmbedding: MLXNN.Embedding {
    let groupSize: Swift.Int
    let bits: Swift.Int
    let scales: MLX.MLXArray
    let biases: MLX.MLXArray
}
class QuantizedLinear: MLXNN.Linear {
    let groupSize: Swift.Int
    let bits: Swift.Int
    let scales: MLX.MLXArray
    let biases: MLX.MLXArray
}
class RNN: MLXNN.Module {
    let nonLinearity: (MLX.MLXArray, MLX.StreamOrDevice) -> MLX.MLXArray
    var _wxh: MLXNN.ParameterInfo<MLX.MLXArray>
    var _whh: MLXNN.ParameterInfo<MLX.MLXArray>
    var bias: MLX.MLXArray?
}
class GRU: MLXNN.Module {
    let hiddenSize: Swift.Int
    var _wx: MLXNN.ParameterInfo<MLX.MLXArray>
    var _wh: MLXNN.ParameterInfo<MLX.MLXArray>
    let b: MLX.MLXArray?
    let bhn: MLX.MLXArray?
}
class LSTM: MLXNN.Module {
    var _wx: MLXNN.ParameterInfo<MLX.MLXArray>
    var _wh: MLXNN.ParameterInfo<MLX.MLXArray>
    let bias: MLX.MLXArray?
}
class MultiHeadAttention: MLXNN.Module {
    let numHeads: Swift.Int
    var _queryProjection: MLXNN.ModuleInfo<MLXNN.UnaryLayer>
    var _keyProjection: MLXNN.ModuleInfo<MLXNN.UnaryLayer>
    var _valueProjection: MLXNN.ModuleInfo<MLXNN.UnaryLayer>
    var _outProjection: MLXNN.ModuleInfo<MLXNN.UnaryLayer>
}
class TransformerEncoderLayer: MLXNN.Module {
    let attention: MLXNN.MultiHeadAttention
    let ln1: MLXNN.LayerNorm
    let ln2: MLXNN.LayerNorm
    var _linear1: MLXNN.ModuleInfo<MLXNN.Linear>
    var _linear2: MLXNN.ModuleInfo<MLXNN.Linear>
    let dropout1: MLXNN.Dropout
    let dropout2: MLXNN.Dropout
    let activation: MLXNN.UnaryLayer
    let normFirst: Swift.Bool
}
class TransformerEncoder: MLXNN.Module {
    let layers: [MLXNN.TransformerEncoderLayer]
    let ln: MLXNN.LayerNorm
}
class TransformerDecoderLayer: MLXNN.Module {
    var _selfAttention: MLXNN.ModuleInfo<MLXNN.MultiHeadAttention>
    var _crossAttention: MLXNN.ModuleInfo<MLXNN.MultiHeadAttention>
    let ln1: MLXNN.LayerNorm
    let ln2: MLXNN.LayerNorm
    let ln3: MLXNN.LayerNorm
    var _linear1: MLXNN.ModuleInfo<MLXNN.Linear>
    var _linear2: MLXNN.ModuleInfo<MLXNN.Linear>
    let dropout1: MLXNN.Dropout
    let dropout2: MLXNN.Dropout
    let dropout3: MLXNN.Dropout
    let activation: MLXNN.UnaryLayer
    let normFirst: Swift.Bool
}
class TransformerDecoder: MLXNN.Module {
    let layers: [MLXNN.TransformerDecoderLayer]
    let ln: MLXNN.LayerNorm
}
class Transformer: MLXNN.Module {
    let encoder: MLXNN.TransformerEncoder
    let decoder: MLXNN.TransformerDecoder
}
class Upsample: MLXNN.Module {
    enum Mode {
        case linear(alignCorners: Swift.Bool)
        case cubic(alignCorners: Swift.Bool)
        case nearest
    }
    let scaleFactor: MLX.FloatOrArray
    let mode: MLXNN.Upsample.Mode
}
class OptimizerBase<A> where A: MLX.Updatable {
    var stateStorage: MLX.NestedDictionary<Swift.String, A>
}
class OptimizerBaseArrayState: MLXOptimizers.OptimizerBase<MLX.MLXArray> {}
struct TupleState {
    let values: (MLX.MLXArray, MLX.MLXArray)
}
class SGD: MLXOptimizers.OptimizerBaseArrayState {
    var learningRate: Swift.Float
    var momentum: Swift.Float
    var weightDecay: Swift.Float
    var dampening: Swift.Float
    var nesterov: Swift.Bool
}
class RMSprop: MLXOptimizers.OptimizerBaseArrayState {
    var learningRate: Swift.Float
    var alpha: Swift.Float
    var eps: Swift.Float
}
class AdaGrad: MLXOptimizers.OptimizerBaseArrayState {
    var learningRate: Swift.Float
    var eps: Swift.Float
}
class AdaDelta: MLXOptimizers.OptimizerBase<MLXOptimizers.TupleState> {
    var learningRate: Swift.Float
    var rho: Swift.Float
    var eps: Swift.Float
}
class Adam: MLXOptimizers.OptimizerBase<MLXOptimizers.TupleState> {
    var learningRate: Swift.Float
    var betas: (Swift.Float, Swift.Float)
    var eps: Swift.Float
}
class AdamW: MLXOptimizers.Adam {
    var weightDecay: Swift.Float
}
class Adamax: MLXOptimizers.OptimizerBase<MLXOptimizers.TupleState> {
    var learningRate: Swift.Float
    var betas: (Swift.Float, Swift.Float)
    var eps: Swift.Float
}
class Lion: MLXOptimizers.OptimizerBaseArrayState {
    var learningRate: Swift.Float
    var betas: (Swift.Float, Swift.Float)
    var weightDecay: Swift.Float
}
class Adafactor: MLXOptimizers.OptimizerBase<MLXOptimizers.Adafactor.State> {
    struct State {
        var step: MLX.MLXArray
        var expAvgSqRow: MLX.MLXArray?
        var expAvgSqCol: MLX.MLXArray?
        var expAvgSq: MLX.MLXArray?
        var expAvg: MLX.MLXArray?
    }
    var learningRate: Swift.Float?
    var eps: (Swift.Float, Swift.Float)
    var clipThreshold: Swift.Float
    var decayRate: Swift.Float
    var beta1: Swift.Float?
    var weightDecay: Swift.Float
    var scaleParameter: Swift.Bool
    var relativeStep: Swift.Bool
    var warmupInit: Swift.Bool
}
class DoRALinear: MLXNN.Linear {
    let scale: Swift.Float
    var _loraA: MLXNN.ParameterInfo<MLX.MLXArray>
    var _loraB: MLXNN.ParameterInfo<MLX.MLXArray>
    var _magnitude: MLXNN.ParameterInfo<MLX.MLXArray>
}
class QDoRALinear: MLXNN.QuantizedLinear {
    let scale: Swift.Float
    var _loraA: MLXNN.ParameterInfo<MLX.MLXArray>
    var _loraB: MLXNN.ParameterInfo<MLX.MLXArray>
    var _magnitude: MLXNN.ParameterInfo<MLX.MLXArray>
}
class LoRALinear: MLXNN.Linear {
    let scale: Swift.Float
    var _loraA: MLXNN.ParameterInfo<MLX.MLXArray>
    var _loraB: MLXNN.ParameterInfo<MLX.MLXArray>
}
class QLoRALinear: MLXNN.QuantizedLinear {
    let scale: Swift.Float
    var _loraA: MLXNN.ParameterInfo<MLX.MLXArray>
    var _loraB: MLXNN.ParameterInfo<MLX.MLXArray>
}
struct LoRAConfiguration {
    enum FineTuneType {
        case lora
        case dora
    }
    struct LoRAParameters {
        enum CodingKeys {
            case rank
            case scale
        }
        let rank: Swift.Int
        let scale: Swift.Float
    }
    enum CodingKeys {
        case numLayers
        case fineTuneType
        case loraParameters
    }
    let numLayers: Swift.Int
    let fineTuneType: MLXLMCommon.LoRAConfiguration.FineTuneType
    let loraParameters: MLXLMCommon.LoRAConfiguration.LoRAParameters
}
struct LoRAContainer {
    let configuration: MLXLMCommon.LoRAConfiguration
    let parameters: MLX.NestedDictionary<Swift.String, MLX.MLXArray>
}
enum ModelAdapterError {
    case unsupportedAdapterType(Swift.String)
    case incompatibleModelType
}
class ModelAdapterFactory {
    let registry: MLXLMCommon.ModelAdapterTypeRegistry
}
struct ModelAdapterBaseConfiguration {
    enum CodingKeys {
        case fineTuneType
    }
    let fineTuneType: Swift.String
}
class ModelAdapterTypeRegistry {
    let lock: __C.NSLock
    var creators: [Swift.String : @Sendable (_: Foundation.URL) throws -> MLXLMCommon.ModelAdapter]
}
struct BaseConfiguration {
    struct Quantization {
        enum CodingKeys {
            case groupSize
            case bits
            case quantMethod
            case linearClass
            case quantizationMode
            case mode
        }
        let groupSize: Swift.Int
        let bits: Swift.Int
        var quantMethod: Swift.String?
        var linearClass: Swift.String?
        var quantizationMode: Swift.String?
        var mode: Swift.String?
    }
    enum QuantizationOption {
        case quantize(MLXLMCommon.BaseConfiguration.Quantization)
        case skip
    }
    struct PerLayerQuantization {
        var quantization: MLXLMCommon.BaseConfiguration.Quantization?
        var perLayerQuantization: [Swift.String : MLXLMCommon.BaseConfiguration.QuantizationOption]
    }
    struct QuantizationContainer {
        struct _DictionaryCodingKey {
            let stringValue: Swift.String
            let intValue: Swift.Int?
        }
        var quantization: MLXLMCommon.BaseConfiguration.Quantization
        var perLayerQuantization: MLXLMCommon.BaseConfiguration.PerLayerQuantization
    }
    enum CodingKeys {
        case modelType
        case quantizationContainer
    }
    let modelType: Swift.String
    var quantizationContainer: MLXLMCommon.BaseConfiguration.QuantizationContainer?
}
enum Chat {
    struct Message {
        enum Role {
            case user
            case assistant
            case system
            case tool
        }
        var role: MLXLMCommon.Chat.Message.Role
        var content: Swift.String
        var images: [MLXLMCommon.UserInput.Image]
        var videos: [MLXLMCommon.UserInput.Video]
    }
}
struct DefaultMessageGenerator {}
struct NoSystemMessageGenerator {}
struct GenerateParameters {
    var prefillStepSize: Swift.Int
    var maxTokens: Swift.Int?
    var maxKVSize: Swift.Int?
    var kvBits: Swift.Int?
    var kvGroupSize: Swift.Int
    var quantizedKVStart: Swift.Int
    var temperature: Swift.Float
    var topP: Swift.Float
    var repetitionPenalty: Swift.Float?
    var repetitionContextSize: Swift.Int
}
struct ArgMaxSampler {}
struct TopPSampler {
    let temp: MLX.MLXArray
    let topP: MLX.MLXArray
    let randomState: MLX.MLXRandom.RandomState
}
struct CategoricalSampler {
    let temp: MLX.MLXArray
    let randomState: MLX.MLXRandom.RandomState
}
struct RepetitionContext {
    var tokens: [Swift.Int]
    var index: Swift.Int
    let repetitionPenalty: Swift.Float
    let repetitionContextSize: Swift.Int
}
struct TokenIterator {
    let model: MLXLMCommon.LanguageModel
    var state: MLXLMCommon.LMOutput.State?
    var y: MLXLMCommon.LMInput.Text
    var cache: [MLXLMCommon.KVCache]
    var processor: MLXLMCommon.LogitProcessor?
    let sampler: MLXLMCommon.LogitSampler
    var tokenCount: Swift.Int
    let maxTokens: Swift.Int?
    let kvBits: Swift.Int?
    let kvGroupSize: Swift.Int
    let quantizedKVStart: Swift.Int
}
struct GenerateResult {
    let inputText: MLXLMCommon.LMInput.Text
    let tokens: [Swift.Int]
    let output: Swift.String
    let promptTime: Swift.Double
    let generateTime: Swift.Double
}
enum GenerateDisposition {
    case more
    case stop
}
struct GenerateCompletionInfo {
    let promptTokenCount: Swift.Int
    let generationTokenCount: Swift.Int
    let promptTime: Swift.Double
    let generateTime: Swift.Double
}
enum Generation {
    case chunk(Swift.String)
    case info(MLXLMCommon.GenerateCompletionInfo)
    case toolCall(MLXLMCommon.ToolCall)
}
class BaseKVCache {
    var offset: Swift.Int
}
class KVCacheSimple: MLXLMCommon.BaseKVCache {
    var keys: MLX.MLXArray?
    var values: MLX.MLXArray?
    var step: Swift.Int
}
class RotatingKVCache: MLXLMCommon.BaseKVCache {
    var keep: Swift.Int
    var keys: MLX.MLXArray?
    var values: MLX.MLXArray?
    var maxCacheSize: Swift.Int
    var step: Swift.Int
    var idx: Swift.Int
}
class QuantizedKVCache: MLXLMCommon.BaseKVCache {
    var keys: (MLX.MLXArray, MLX.MLXArray, MLX.MLXArray)?
    var values: (MLX.MLXArray, MLX.MLXArray, MLX.MLXArray)?
    let step: Swift.Int
    let groupSize: Swift.Int
    let bits: Swift.Int
}
class ChunkedKVCache: MLXLMCommon.KVCacheSimple {
    var chunkSize: Swift.Int?
    var startPosition: Swift.Int
}
class ArraysCache: MLXLMCommon.BaseKVCache {
    var cache: [MLX.MLXArray?]
    var leftPadding: MLX.MLXArray?
}
class MambaCache: MLXLMCommon.ArraysCache {}
class CacheList: MLXLMCommon.BaseKVCache {
    var caches: [MLXLMCommon.KVCache]
}
struct KVCacheError {
    let message: Swift.String
}
struct THW {
    let t: Swift.Int
    let h: Swift.Int
    let w: Swift.Int
}
struct LMInput {
    struct Text {
        let tokens: MLX.MLXArray
        let mask: MLX.MLXArray?
    }
    struct ProcessedImage {
        let pixels: MLX.MLXArray
        let frames: [MLXLMCommon.THW]?
    }
    struct ProcessedVideo {
        let pixels: MLX.MLXArray
        let frames: [MLXLMCommon.THW]?
    }
    let text: MLXLMCommon.LMInput.Text
    let image: MLXLMCommon.LMInput.ProcessedImage?
    let video: MLXLMCommon.LMInput.ProcessedVideo?
}
struct LMOutput {
    struct State {
        let crossAttentionStates: MLX.MLXArray?
    }
    let logits: MLX.MLXArray
    let state: MLXLMCommon.LMOutput.State?
}
enum PrepareResult {
    case tokens(MLXLMCommon.LMInput.Text)
    case logits(MLXLMCommon.LMOutput)
}
struct ModelConfiguration {
    enum Identifier {
        case id(Swift.String, revision: Swift.String)
        case directory(Foundation.URL)
    }
    var id: MLXLMCommon.ModelConfiguration.Identifier
    let tokenizerId: Swift.String?
    let overrideTokenizer: Swift.String?
    var defaultPrompt: Swift.String
    var extraEOSTokens: Swift.Set<Swift.String>
}
actor ModelContainer {
    var $defaultActor: 
    var context: MLXLMCommon.ModelContext
}
enum ModelFactoryError {
    case unsupportedModelType(Swift.String)
    case unsupportedProcessorType(Swift.String)
    case configurationDecodingError(Swift.String, Swift.String, Swift.DecodingError)
    case noModelFactoryAvailable
}
struct ModelContext {
    var configuration: MLXLMCommon.ModelConfiguration
    var model: MLXLMCommon.LanguageModel
    var processor: MLXLMCommon.UserInputProcessor
    var tokenizer: Tokenizers.Tokenizer
}
class ModelFactoryRegistry {
    let lock: __C.NSLock
    var trampolines: [() -> MLXLMCommon.ModelFactory?]
}
enum Gemma {
    class RMSNorm: MLXNN.Module {
        let weight: MLX.MLXArray
        let eps: Swift.Float
    }
}
class AbstractModelRegistry {
    let lock: __C.NSLock
    var registry: [Swift.String : MLXLMCommon.ModelConfiguration]
}
class ModelTypeRegistry {
    let lock: __C.NSLock
    var creators: [Swift.String : @Sendable (_: Foundation.URL) throws -> MLXLMCommon.LanguageModel]
}
class ProcessorTypeRegistry {
    let lock: __C.NSLock
    var creators: [Swift.String : @Sendable (Foundation.URL, Tokenizers.Tokenizer) throws -> MLXLMCommon.UserInputProcessor]
}
class Generator {
    enum Model {
        case container(MLXLMCommon.ModelContainer)
        case context(MLXLMCommon.ModelContext)
    }
    let model: MLXLMCommon.Generator.Model
    var messages: [MLXLMCommon.Chat.Message]
    let processing: MLXLMCommon.UserInput.Processing
    let generateParameters: MLXLMCommon.GenerateParameters
    var cache: [MLXLMCommon.KVCache]
}
class ChatSession {
    let generator: MLXLMCommon.Generator
}
enum StringOrNumber {
    case string(Swift.String)
    case int(Swift.Int)
    case float(Swift.Float)
    case ints([Swift.Int])
    case floats([Swift.Float])
    case bool(Swift.Bool)
}
class TokenizerReplacementRegistry {
    let lock: __C.NSLock
    var replacementTokenizers: [Swift.String : Swift.String]
}
struct NaiveStreamingDetokenizer {
    let tokenizer: Tokenizers.Tokenizer
    var segmentTokens: [Swift.Int]
    var segment: Swift.String
}
struct TokenizerError {
    let message: Swift.String
}
struct Tool<A, B> where A: Swift.Decodable, A: Swift.Encodable, B: Swift.Decodable, B: Swift.Encodable {
    let schema: [Swift.String : Any]
    let handler: (_: A) async throws -> B
}
struct ToolCall {
    struct Function {
        enum CodingKeys {
            case name
            case arguments
        }
        let name: Swift.String
        let arguments: [Swift.String : MLXLMCommon.JSONValue]
    }
    enum CodingKeys {
        case function
    }
    let function: MLXLMCommon.ToolCall.Function
}
enum ToolError {
    case nameMismatch(toolName: Swift.String, functionName: Swift.String)
}
class ToolCallProcessor {
    enum State {
        case normal
        case potentialToolCall
        case collectingToolCall
    }
    var state: MLXLMCommon.ToolCallProcessor.State
    var toolCallBuffer: Swift.String
    var toolCalls: [MLXLMCommon.ToolCall]
}
enum ToolParameterType {
    indirect case array(elementType: MLXLMCommon.ToolParameterType)
    indirect case object(properties: [MLXLMCommon.ToolParameter])
    case string
    case bool
    case int
    case double
    case data
}
struct ToolParameter {
    let name: Swift.String
    let type: MLXLMCommon.ToolParameterType
    let description: Swift.String
    let isRequired: Swift.Bool
    let extraProperties: [Swift.String : Any]
}
enum JSONValue {
    case bool(Swift.Bool)
    case int(Swift.Int)
    case double(Swift.Double)
    case string(Swift.String)
    case array([MLXLMCommon.JSONValue])
    case object([Swift.String : MLXLMCommon.JSONValue])
    case null
}
struct UserInput {
    enum Prompt {
        case text(Swift.String)
        case messages([[Swift.String : Any]])
        case chat([MLXLMCommon.Chat.Message])
    }
    enum Video {
        case avAsset(__C.AVAsset)
        case url(Foundation.URL)
    }
    enum Image {
        case ciImage(__C.CIImage)
        case url(Foundation.URL)
        case array(MLX.MLXArray)
    }
    struct Processing {
        var resize: __C.CGSize?
    }
    var prompt: MLXLMCommon.UserInput.Prompt
    var images: [MLXLMCommon.UserInput.Image]
    var videos: [MLXLMCommon.UserInput.Video]
    var tools: [[Swift.String : Any]]?
    var additionalContext: [Swift.String : Any]?
    var processing: MLXLMCommon.UserInput.Processing
}
struct StandInUserInputProcessor {}
enum UserInputError {
    case unableToLoad(Foundation.URL)
    case arrayError(Swift.String)
    case notImplemented
}
struct VideoFrame {
    let frame: __C.CIImage
    let timeStamp: __C.CMTime
}
struct ProcessedFrames {
    let frames: [MLX.MLXArray]
    let timestamps: [__C.CMTime]
    let totalDuration: __C.CMTime
}
enum MediaProcessing {}
struct Gemma3TextConfiguration {
    enum CodingKeys {
        case modelType
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case slidingWindow
        case ropeScaling
        case finalLogitSoftcapping
        case _attentionHeads
        case _kvHeads
        case _headDim
        case _queryPreAttnScalar
    }
    let modelType: Swift.String
    let hiddenSize: Swift.Int
    let hiddenLayers: Swift.Int
    let intermediateSize: Swift.Int
    let slidingWindow: Swift.Int
    let ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
    let finalLogitSoftcapping: Swift.Float?
    let vocabularySize: Swift.Int
    let rmsNormEps: Swift.Float
    let _attentionHeads: Swift.Int?
    let _kvHeads: Swift.Int?
    let _headDim: Swift.Int?
    let _queryPreAttnScalar: Swift.Float?
    let ropeGlobalBaseFreq: Swift.Float
    let ropeLocalBaseFreq: Swift.Float
    let ropeTraditional: Swift.Bool
    let mmTokensPerImage: Swift.Int
    let slidingWindowPattern: Swift.Int
    let maxPositionEmbeddings: Swift.Int
}
struct Gemma3VisionConfiguration {
    enum CodingKeys {
        case modelType
        case hiddenLayers
        case hiddenSize
        case intermediateSize
        case attentionHeads
        case patchSize
        case imageSize
    }
    let modelType: Swift.String
    let hiddenLayers: Swift.Int
    let hiddenSize: Swift.Int
    let intermediateSize: Swift.Int
    let attentionHeads: Swift.Int
    let patchSize: Swift.Int
    let imageSize: Swift.Int
    let numChannels: Swift.Int
    let layerNormEps: Swift.Float
}
struct QuantizationConfig {
    enum CodingKeys {
        case groupSize
        case bits
    }
    let groupSize: Swift.Int
    let bits: Swift.Int
}
struct Gemma3Configuration {
    enum CodingKeys {
        case textConfiguration
        case visionConfiguration
        case modelType
        case mmTokensPerImage
        case quantization
        case _vocabularySize
        case _padTokenId
    }
    let textConfiguration: MLXVLM.Gemma3TextConfiguration
    let visionConfiguration: MLXVLM.Gemma3VisionConfiguration
    let modelType: Swift.String
    let mmTokensPerImage: Swift.Int
    let quantization: MLXVLM.QuantizationConfig?
    let _vocabularySize: Swift.Int?
    let _padTokenId: Swift.Int?
}
class Attention: MLXNN.Module {
    let numHeads: Swift.Int
    let numKVHeads: Swift.Int
    let repeats: Swift.Int
    let headDim: Swift.Int
    let layerIdx: Swift.Int
    let scale: Swift.Float
    let isSliding: Swift.Bool
    var _queryProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _keyProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _valueProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _outputProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _queryNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    var _keyNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    var _rope: MLXNN.ModuleInfo<MLXNN.RoPE>
}
class MLP: MLXNN.Module {
    var _gateProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _downProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _upProj: MLXNN.ModuleInfo<MLXNN.Linear>
}
class TransformerBlock: MLXNN.Module {
    var _selfAttention: MLXNN.ModuleInfo<MLXVLM.Attention>
    var _mlp: MLXNN.ModuleInfo<MLXVLM.MLP>
    var _inputLayerNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    var _preFeedforwardLayerNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    var _postFeedforwardLayerNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    let numAttentionHeads: Swift.Int
    let hiddenSize: Swift.Int
}
class GemmaModel: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    var _layers: MLXNN.ModuleInfo<[MLXVLM.TransformerBlock]>
    var _norm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    let config: MLXVLM.Gemma3TextConfiguration
}
class LanguageModel: MLXNN.Module {
    var _model: MLXNN.ModuleInfo<MLXVLM.GemmaModel>
    var _lmHead: MLXNN.ModuleInfo<MLXNN.Module>
    let config: MLXVLM.Gemma3TextConfiguration
    var kvHeads: [Swift.Int]
}
class VisionAttention: MLXNN.Module {
    var _queryProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _keyProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _valueProj: MLXNN.ModuleInfo<MLXNN.Linear>
    var _outputProj: MLXNN.ModuleInfo<MLXNN.Linear>
    let numHeads: Swift.Int
    let scale: Swift.Float
}
class VisionMLP: MLXNN.Module {
    var _fc1: MLXNN.ModuleInfo<MLXNN.Linear>
    var _fc2: MLXNN.ModuleInfo<MLXNN.Linear>
    var _activationFn: MLXNN.ModuleInfo<MLXNN.GELU>
}
class EncoderLayer: MLXNN.Module {
    var _selfAttention: MLXNN.ModuleInfo<MLXVLM.VisionAttention>
    var _layerNorm1: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    var _mlp: MLXNN.ModuleInfo<MLXVLM.VisionMLP>
    var _layerNorm2: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    let embedDim: Swift.Int
}
class Encoder: MLXNN.Module {
    var _layers: MLXNN.ModuleInfo<[MLXVLM.EncoderLayer]>
}
class VisionEmbeddings: MLXNN.Module {
    var _patchEmbedding: MLXNN.ModuleInfo<MLXNN.Conv2d>
    var _positionEmbedding: MLXNN.ModuleInfo<MLXNN.Embedding>
    let config: MLXVLM.Gemma3VisionConfiguration
    let embedDim: Swift.Int
    let imageSize: Swift.Int
    let patchSize: Swift.Int
    let numPatches: Swift.Int
    let numPositions: Swift.Int
}
class SigLipVisionModel: MLXNN.Module {
    var _embeddings: MLXNN.ModuleInfo<MLXVLM.VisionEmbeddings>
    var _encoder: MLXNN.ModuleInfo<MLXVLM.Encoder>
    var _postLayerNorm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
}
class VisionModel: MLXNN.Module {
    var _visionModel: MLXNN.ModuleInfo<MLXVLM.SigLipVisionModel>
    let modelType: Swift.String
}
class Gemma3MultiModalProjector: MLXNN.Module {
    var _mmInputProjectionWeight: MLXNN.ModuleInfo<MLX.MLXArray>
    var _mmSoftEmbNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    var _avgPool: MLXNN.ModuleInfo<MLXNN.AvgPool2d>
    let config: MLXVLM.Gemma3Configuration
    let patchesPerImage: Swift.Int
    let tokensPerSide: Swift.Int
    let kernelSize: Swift.Int
}
class Gemma3: MLXNN.Module {
    var _visionTower: MLXNN.ModuleInfo<MLXVLM.VisionModel>
    var _languageModel: MLXNN.ModuleInfo<MLXVLM.LanguageModel>
    var _multiModalProjector: MLXNN.ModuleInfo<MLXVLM.Gemma3MultiModalProjector>
    let config: MLXVLM.Gemma3Configuration
}
class Gemma3Processor {
    let config: MLXVLM.Gemma3ProcessorConfiguration
    let tokenizer: Tokenizers.Tokenizer
}
struct Gemma3ProcessorConfiguration {
    struct ImageSize {
        enum CodingKeys {
            case height
            case width
        }
        let height: Swift.Int
        let width: Swift.Int
    }
    enum CodingKeys {
        case processorClass
        case imageProcessorType
        case doNormalize
        case doRescale
        case doResize
        case doConvertRgb
        case doPanAndScan
        case imageMean
        case imageStd
        case imageSeqLength
        case resample
        case rescaleFactor
        case size
        case panAndScanMaxNumCrops
        case panAndScanMinCropSize
        case panAndScanMinRatioToActivate
    }
    let processorClass: Swift.String
    let imageProcessorType: Swift.String
    let doNormalize: Swift.Bool
    let doRescale: Swift.Bool
    let doResize: Swift.Bool
    let imageMean: [CoreGraphics.CGFloat]
    let imageStd: [CoreGraphics.CGFloat]
    let imageSeqLength: Swift.Int
    let resample: Swift.Int
    let rescaleFactor: Swift.Float
    let size: MLXVLM.Gemma3ProcessorConfiguration.ImageSize
    let doConvertRgb: Swift.Bool?
    let doPanAndScan: Swift.Bool?
    let panAndScanMaxNumCrops: Swift.Int?
    let panAndScanMinCropSize: Swift.Int?
    let panAndScanMinRatioToActivate: Swift.Float?
    let imageTokenId: Swift.Int
}
struct Idefics3Configuration {
    struct TextConfiguration {
        enum CodingKeys {
            case modelType
            case hiddenSize
            case _numHiddenLayers
            case intermediateSize
            case numAttentionHeads
            case rmsNormEps
            case vocabSize
            case numKeyValueHeads
            case ropeTheta
            case _ropeTraditional
            case _tieWordEmbeddings
        }
        let modelType: Swift.String
        let hiddenSize: Swift.Int
        let intermediateSize: Swift.Int
        let numAttentionHeads: Swift.Int
        let rmsNormEps: Swift.Float
        let vocabSize: Swift.Int
        let numKeyValueHeads: Swift.Int
        let ropeTheta: Swift.Float
        let _numHiddenLayers: Swift.Int?
        let _ropeTraditional: Swift.Bool?
        let _tieWordEmbeddings: Swift.Bool?
    }
    struct VisionConfiguration {
        enum CodingKeys {
            case modelType
            case _numHiddenLayers
            case hiddenSize
            case _intermediateSize
            case numAttentionHeads
            case patchSize
            case imageSize
            case _numChannels
            case _layerNormEps
        }
        let modelType: Swift.String
        let hiddenSize: Swift.Int
        let numAttentionHeads: Swift.Int
        let patchSize: Swift.Int
        let imageSize: Swift.Int
        let _numHiddenLayers: Swift.Int?
        let _intermediateSize: Swift.Int?
        let _numChannels: Swift.Int?
        let _layerNormEps: Swift.Float?
    }
    enum CodingKeys {
        case textConfig
        case visionConfig
        case modelType
        case ignoreIndex
        case vocabSize
        case scaleFactor
        case imageTokenId
        case imageTokenIndex
    }
    let textConfig: MLXVLM.Idefics3Configuration.TextConfiguration
    let visionConfig: MLXVLM.Idefics3Configuration.VisionConfiguration
    let modelType: Swift.String
    let ignoreIndex: Swift.Int
    let vocabSize: Swift.Int
    let scaleFactor: Swift.Int
    let imageTokenId: Swift.Int
    let imageTokenIndex: Swift.Int
}
class Idefics3MLP: MLXNN.Module {
    var _proj: MLXNN.ModuleInfo<MLXNN.Linear>
}
class Idefics3Connector: MLXNN.Module {
    let scaleFactor: Swift.Int
    var _modalityProjection: MLXNN.ModuleInfo<MLXVLM.Idefics3MLP>
}
class Idefics3: MLXNN.Module {
    var _visionModel: MLXNN.ModuleInfo<MLXVLM.Vision.VisionModel>
    var _languageModel: MLXNN.ModuleInfo<MLXVLM.Language.LanguageModel>
    var _connector: MLXNN.ModuleInfo<MLXVLM.Idefics3Connector>
    let config: MLXVLM.Idefics3Configuration
}
struct Idefics3ProcessorConfiguration {
    struct Size {
        enum CodingKeys {
            case longestEdge
        }
        let longestEdge: Swift.Int
    }
    enum CodingKeys {
        case imageMean
        case imageStd
        case size
        case imageSequenceLength
    }
    let imageMean: [CoreGraphics.CGFloat]
    let imageStd: [CoreGraphics.CGFloat]
    let size: MLXVLM.Idefics3ProcessorConfiguration.Size
    let imageSequenceLength: Swift.Int?
}
class Idefics3Processor {
    let config: MLXVLM.Idefics3ProcessorConfiguration
    let tokenizer: Tokenizers.Tokenizer
    let fixedImageSize: Swift.Int
    let imageTokenId: Swift.Int
}
enum Language {
    class Attention: MLXNN.Module {
        let heads: Swift.Int
        let kvHeads: Swift.Int
        let headDim: Swift.Int
        let scale: Swift.Float
        let mropeSection: [Swift.Int]
        var _wq: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wk: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wv: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wo: MLXNN.ModuleInfo<MLXNN.Linear>
        var _rotaryEmbedding: MLXNN.ModuleInfo<MLXNN.RoPE>
    }
    class MLP: MLXNN.Module {
        var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
        var _down: MLXNN.ModuleInfo<MLXNN.Linear>
        var _up: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class TransformerBlock: MLXNN.Module {
        var _attention: MLXNN.ModuleInfo<MLXVLM.Language.Attention>
        let mlp: MLXVLM.Language.MLP
        var _inputLayerNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
        var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    }
    class LanguageModel: MLXNN.Module {
        var _model: MLXNN.ModuleInfo<MLXVLM.Language.Qwen2Model>
        var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
        var kvHeads: [Swift.Int]
    }
    class Attention: MLXNN.Module {
        let heads: Swift.Int
        let kvHeads: Swift.Int
        let headDim: Swift.Int
        let scale: Swift.Float
        let mropeSection: [Swift.Int]
        var _wq: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wk: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wv: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wo: MLXNN.ModuleInfo<MLXNN.Linear>
        var _rotaryEmbedding: MLXNN.ModuleInfo<MLXNN.RoPE>
    }
    class MLP: MLXNN.Module {
        var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
        var _down: MLXNN.ModuleInfo<MLXNN.Linear>
        var _up: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class TransformerBlock: MLXNN.Module {
        var _attention: MLXNN.ModuleInfo<MLXVLM.Language.Attention>
        let mlp: MLXVLM.Language.MLP
        var _inputLayerNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
        var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXLMCommon.Gemma.RMSNorm>
    }
    class GemmaModel: MLXNN.Module {
        var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
        let layers: [MLXVLM.Language.TransformerBlock]
        let norm: MLXLMCommon.Gemma.RMSNorm
        let hiddenScale: Swift.Float
    }
    class LanguageModel: MLXNN.Module {
        var _model: MLXNN.ModuleInfo<MLXVLM.Language.Qwen2Model>
        var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
        var kvHeads: [Swift.Int]
    }
    class Attention: MLXNN.Module {
        let heads: Swift.Int
        let kvHeads: Swift.Int
        let headDim: Swift.Int
        let scale: Swift.Float
        let mropeSection: [Swift.Int]
        var _wq: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wk: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wv: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wo: MLXNN.ModuleInfo<MLXNN.Linear>
        var _rotaryEmbedding: MLXNN.ModuleInfo<MLXNN.RoPE>
    }
    class MLP: MLXNN.Module {
        var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
        var _down: MLXNN.ModuleInfo<MLXNN.Linear>
        var _up: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class Qwen25VLDecoderLayer: MLXNN.Module {
        var _attention: MLXNN.ModuleInfo<MLXVLM.Language.Attention>
        let mlp: MLXVLM.Language.MLP
        var _inputLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
        var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    }
    class Qwen25Model: MLXNN.Module {
        var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
        let layers: [MLXVLM.Language.Qwen25VLDecoderLayer]
        let norm: MLXNN.RMSNorm
    }
    class LanguageModel: MLXNN.Module {
        var _model: MLXNN.ModuleInfo<MLXVLM.Language.Qwen2Model>
        var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
        var kvHeads: [Swift.Int]
    }
    class Attention: MLXNN.Module {
        let heads: Swift.Int
        let kvHeads: Swift.Int
        let headDim: Swift.Int
        let scale: Swift.Float
        let mropeSection: [Swift.Int]
        var _wq: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wk: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wv: MLXNN.ModuleInfo<MLXNN.Linear>
        var _wo: MLXNN.ModuleInfo<MLXNN.Linear>
        var _rotaryEmbedding: MLXNN.ModuleInfo<MLXNN.RoPE>
    }
    class MLP: MLXNN.Module {
        var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
        var _down: MLXNN.ModuleInfo<MLXNN.Linear>
        var _up: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class Qwen2VLDecoderLayer: MLXNN.Module {
        var _attention: MLXNN.ModuleInfo<MLXVLM.Language.Attention>
        let mlp: MLXVLM.Language.MLP
        var _inputLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
        var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    }
    class Qwen2Model: MLXNN.Module {
        var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
        let layers: [MLXVLM.Language.Qwen2VLDecoderLayer]
        let norm: MLXNN.RMSNorm
    }
    class LanguageModel: MLXNN.Module {
        var _model: MLXNN.ModuleInfo<MLXVLM.Language.Qwen2Model>
        var _lmHead: MLXNN.ModuleInfo<MLXNN.Linear?>
        var kvHeads: [Swift.Int]
    }
}
enum Vision {
    class Attention: MLXNN.Module {
        let numHeads: Swift.Int
        let scale: Swift.Float
        var _qkv: MLXNN.ModuleInfo<MLXNN.Linear>
        var _proj: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class MLP: MLXNN.Module {
        var _activation: MLXNN.ModuleInfo<MLXNN.GELU>
        var _fc1: MLXNN.ModuleInfo<MLXNN.Linear>
        var _fc2: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class EncoderLayer: MLXNN.Module {
        var _attention: MLXNN.ModuleInfo<MLXVLM.Vision.Attention>
        var _layerNorm1: MLXNN.ModuleInfo<MLXNN.LayerNorm>
        var _mlp: MLXNN.ModuleInfo<MLXVLM.Vision.PhiMLP>
        var _layerNorm2: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    }
    class Encoder: MLXNN.Module {
        var layers: [MLXVLM.Vision.EncoderLayer]
    }
    class VisionEmbeddings: MLXNN.Module {
        var _patchEmbedding: MLXNN.ModuleInfo<MLXNN.Conv2d>
        var _positionEmbedding: MLXNN.ModuleInfo<MLXNN.Embedding>
        let positions: Swift.Int
        let _positionIds: MLX.MLXArray
    }
    class VisionModel: MLXNN.Module {
        var _patchEmbed: MLXNN.ModuleInfo<MLXVLM.QwenVL.PatchEmbed>
        var _rotaryPositionEmbedding: MLXNN.ModuleInfo<MLXVLM.QwenVL.VisionRotaryEmbedding>
        var _blocks: MLXNN.ModuleInfo<[MLXVLM.Vision.Qwen2VLVisionBlock]>
        var _patchMerger: MLXNN.ModuleInfo<MLXVLM.Vision.PatchMerger>
        let spatialMergeSize: Swift.Int
    }
    class Attention: MLXNN.Module {
        let numHeads: Swift.Int
        let scale: Swift.Float
        var _qkv: MLXNN.ModuleInfo<MLXNN.Linear>
        var _proj: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class PhiMLP: MLXNN.Module {
        var _fc1: MLXNN.ModuleInfo<MLXNN.Linear>
        var _fc2: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class EncoderLayer: MLXNN.Module {
        var _attention: MLXNN.ModuleInfo<MLXVLM.Vision.Attention>
        var _layerNorm1: MLXNN.ModuleInfo<MLXNN.LayerNorm>
        var _mlp: MLXNN.ModuleInfo<MLXVLM.Vision.PhiMLP>
        var _layerNorm2: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    }
    class Encoder: MLXNN.Module {
        var layers: [MLXVLM.Vision.EncoderLayer]
    }
    class VisionEmbeddings: MLXNN.Module {
        var _patchEmbedding: MLXNN.ModuleInfo<MLXNN.Conv2d>
        var _positionEmbedding: MLXNN.ModuleInfo<MLXNN.Embedding>
        let positions: Swift.Int
        let _positionIds: MLX.MLXArray
    }
    class SigLipVisionModel: MLXNN.Module {
        var _embeddings: MLXNN.ModuleInfo<MLXVLM.Vision.VisionEmbeddings>
        var _encoder: MLXNN.ModuleInfo<MLXVLM.Vision.Encoder>
        var _postLayerNorm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    }
    class VisionModel: MLXNN.Module {
        var _patchEmbed: MLXNN.ModuleInfo<MLXVLM.QwenVL.PatchEmbed>
        var _rotaryPositionEmbedding: MLXNN.ModuleInfo<MLXVLM.QwenVL.VisionRotaryEmbedding>
        var _blocks: MLXNN.ModuleInfo<[MLXVLM.Vision.Qwen2VLVisionBlock]>
        var _patchMerger: MLXNN.ModuleInfo<MLXVLM.Vision.PatchMerger>
        let spatialMergeSize: Swift.Int
    }
    class PatchMerger: MLXNN.Module {
        let hiddenSize: Swift.Int
        var _layerNormQ: MLXNN.ModuleInfo<MLXNN.LayerNorm>
        var _mlp: MLXNN.ModuleInfo<(MLXNN.Linear, MLXNN.GELU, MLXNN.Linear)>
    }
    class Attention: MLXNN.Module {
        let numHeads: Swift.Int
        let scale: Swift.Float
        var _qkv: MLXNN.ModuleInfo<MLXNN.Linear>
        var _proj: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class MLP: MLXNN.Module {
        var _activation: MLXNN.ModuleInfo<MLXNN.GELU>
        var _fc1: MLXNN.ModuleInfo<MLXNN.Linear>
        var _fc2: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class Qwen25VLVisionBlock: MLXNN.Module {
        var _norm1: MLXNN.ModuleInfo<MLXNN.RMSNorm>
        var _norm2: MLXNN.ModuleInfo<MLXNN.RMSNorm>
        var _attention: MLXNN.ModuleInfo<MLXVLM.Vision.Attention>
        var _mlp: MLXNN.ModuleInfo<MLXVLM.Vision.MLP>
    }
    class VisionModel: MLXNN.Module {
        var _patchEmbed: MLXNN.ModuleInfo<MLXVLM.QwenVL.PatchEmbed>
        var _rotaryPositionEmbedding: MLXNN.ModuleInfo<MLXVLM.QwenVL.VisionRotaryEmbedding>
        var _blocks: MLXNN.ModuleInfo<[MLXVLM.Vision.Qwen2VLVisionBlock]>
        var _patchMerger: MLXNN.ModuleInfo<MLXVLM.Vision.PatchMerger>
        let spatialMergeSize: Swift.Int
    }
    class PatchMerger: MLXNN.Module {
        let hiddenSize: Swift.Int
        var _layerNormQ: MLXNN.ModuleInfo<MLXNN.LayerNorm>
        var _mlp: MLXNN.ModuleInfo<(MLXNN.Linear, MLXNN.GELU, MLXNN.Linear)>
    }
    class Attention: MLXNN.Module {
        let numHeads: Swift.Int
        let scale: Swift.Float
        var _qkv: MLXNN.ModuleInfo<MLXNN.Linear>
        var _proj: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class MLP: MLXNN.Module {
        var _activation: MLXNN.ModuleInfo<MLXNN.GELU>
        var _fc1: MLXNN.ModuleInfo<MLXNN.Linear>
        var _fc2: MLXNN.ModuleInfo<MLXNN.Linear>
    }
    class Qwen2VLVisionBlock: MLXNN.Module {
        var _norm1: MLXNN.ModuleInfo<MLXNN.LayerNorm>
        var _norm2: MLXNN.ModuleInfo<MLXNN.LayerNorm>
        var _attention: MLXNN.ModuleInfo<MLXVLM.Vision.Attention>
        var _mlp: MLXNN.ModuleInfo<MLXVLM.Vision.MLP>
    }
    class VisionModel: MLXNN.Module {
        var _patchEmbed: MLXNN.ModuleInfo<MLXVLM.QwenVL.PatchEmbed>
        var _rotaryPositionEmbedding: MLXNN.ModuleInfo<MLXVLM.QwenVL.VisionRotaryEmbedding>
        var _blocks: MLXNN.ModuleInfo<[MLXVLM.Vision.Qwen2VLVisionBlock]>
        var _patchMerger: MLXNN.ModuleInfo<MLXVLM.Vision.PatchMerger>
        let spatialMergeSize: Swift.Int
    }
}
class PaliGemmaProcessor {
    let config: MLXVLM.PaliGemmaProcessorConfiguration
    let tokenizer: Tokenizers.Tokenizer
}
class PaliGemmaMultiModalProjector: MLXNN.Module {
    var _linear: MLXNN.ModuleInfo<MLXNN.Linear>
}
class PaliGemma: MLXNN.Module {
    var _visionModel: MLXNN.ModuleInfo<MLXVLM.Vision.VisionModel>
    var _languageModel: MLXNN.ModuleInfo<MLXVLM.Language.LanguageModel>
    var _multiModalProjector: MLXNN.ModuleInfo<MLXVLM.PaliGemmaMultiModalProjector>
    let config: MLXVLM.PaliGemmaConfiguration
}
struct PaliGemmaConfiguration {
    struct TextConfiguration {
        enum CodingKeys {
            case modelType
            case hiddenSize
            case hiddenLayers
            case intermediateSize
            case attentionHeads
            case kvHeads
            case vocabularySize
            case _rmsNormEps
            case _ropeTheta
            case _ropeTraditional
        }
        let modelType: Swift.String
        let hiddenSize: Swift.Int
        let hiddenLayers: Swift.Int
        let intermediateSize: Swift.Int
        let attentionHeads: Swift.Int
        let kvHeads: Swift.Int
        let vocabularySize: Swift.Int
        let _rmsNormEps: Swift.Float?
        let _ropeTheta: Swift.Float?
        let _ropeTraditional: Swift.Bool?
    }
    struct VisionConfiguration {
        enum CodingKeys {
            case modelType
            case hiddenSize
            case hiddenLayers
            case intermediateSize
            case attentionHeads
            case patchSize
            case projectionDimensions
            case imageSize
            case _channels
            case _layerNormEps
        }
        let modelType: Swift.String
        let hiddenSize: Swift.Int
        let hiddenLayers: Swift.Int
        let intermediateSize: Swift.Int
        let attentionHeads: Swift.Int
        let patchSize: Swift.Int
        let projectionDimensions: Swift.Int
        let imageSize: Swift.Int
        let _channels: Swift.Int?
        let _layerNormEps: Swift.Float?
    }
    enum CodingKeys {
        case textConfiguration
        case visionConfiguration
        case modelType
        case vocabularySize
        case ignoreIndex
        case imageTokenIndex
        case hiddenSize
        case padTokenId
    }
    let textConfiguration: MLXVLM.PaliGemmaConfiguration.TextConfiguration
    let visionConfiguration: MLXVLM.PaliGemmaConfiguration.VisionConfiguration
    let modelType: Swift.String
    let vocabularySize: Swift.Int
    let ignoreIndex: Swift.Int
    let imageTokenIndex: Swift.Int
    let hiddenSize: Swift.Int
    let padTokenId: Swift.Int
}
struct PaliGemmaProcessorConfiguration {
    struct Size {
        enum CodingKeys {
            case width
            case height
        }
        let width: Swift.Int
        let height: Swift.Int
    }
    enum CodingKeys {
        case imageMean
        case imageStd
        case size
        case imageSequenceLength
    }
    let imageMean: [CoreGraphics.CGFloat]
    let imageStd: [CoreGraphics.CGFloat]
    let size: MLXVLM.PaliGemmaProcessorConfiguration.Size
    let imageSequenceLength: Swift.Int
}
class Qwen25VLProcessor {
    let config: MLXVLM.Qwen25VLProcessorConfiguration
    let tokenizer: Tokenizers.Tokenizer
}
class Qwen25VL: MLXNN.Module {
    var _visionModel: MLXNN.ModuleInfo<MLXVLM.Vision.VisionModel>
    var _languageModel: MLXNN.ModuleInfo<MLXVLM.Language.LanguageModel>
    let config: MLXVLM.Qwen25VLConfiguration
}
struct Qwen25VLConfiguration {
    struct TextConfiguration {
        enum CodingKeys {
            case modelType
            case hiddenSize
            case hiddenLayers
            case intermediateSize
            case attentionHeads
            case _rmsNormEps
            case vocabularySize
            case kvHeads
            case _maxPositionEmbeddings
            case _ropeTheta
            case _ropeTraditional
            case ropeScaling
            case _tieWordEmbeddings
            case _slidingWindow
            case _useSlidingWindow
        }
        let modelType: Swift.String
        let hiddenSize: Swift.Int
        let hiddenLayers: Swift.Int
        let intermediateSize: Swift.Int
        let attentionHeads: Swift.Int
        let _rmsNormEps: Swift.Float?
        let vocabularySize: Swift.Int
        let kvHeads: Swift.Int
        let _maxPositionEmbeddings: Swift.Int?
        let _ropeTheta: Swift.Float?
        let _ropeTraditional: Swift.Bool?
        let ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
        let _tieWordEmbeddings: Swift.Bool?
        let _slidingWindow: Swift.Int?
        let _useSlidingWindow: Swift.Bool?
    }
    struct VisionConfiguration {
        enum CodingKeys {
            case depth
            case hiddenSize
            case intermediateSize
            case outHiddenSize
            case numHeads
            case patchSize
            case _inChans
            case _layerNormEps
            case spatialPatchSize
            case spatialMergeSize
            case temporalPatchSize
            case windowSize
            case fullattBlockIndexes
            case tokensPerSecond
            case _skipVision
            case _hiddenAct
        }
        let depth: Swift.Int
        let hiddenSize: Swift.Int
        let intermediateSize: Swift.Int
        let outHiddenSize: Swift.Int
        let numHeads: Swift.Int
        let patchSize: Swift.Int
        let _inChans: Swift.Int?
        let _layerNormEps: Swift.Float?
        let spatialPatchSize: Swift.Int
        let spatialMergeSize: Swift.Int
        let temporalPatchSize: Swift.Int
        let windowSize: Swift.Int
        let fullattBlockIndexes: [Swift.Int]
        let tokensPerSecond: Swift.Int
        let _skipVision: Swift.Bool?
        let _hiddenAct: Swift.String?
    }
    struct BaseConfiguration {
        enum CodingKeys {
            case modelType
            case vocabularySize
            case imageTokenId
            case videoTokenId
            case visionStartTokenId
            case visionEndTokenId
            case visionTokenId
            case hiddenSize
            case numAttentionHeads
            case numHiddenLayers
            case intermediateSize
            case numKeyValueHeads
            case slidingWindow
            case useSlidingWindow
            case maxWindowLayers
        }
        let modelType: Swift.String
        let vocabularySize: Swift.Int
        let imageTokenId: Swift.Int
        let videoTokenId: Swift.Int
        let visionStartTokenId: Swift.Int
        let visionEndTokenId: Swift.Int
        let visionTokenId: Swift.Int
        let hiddenSize: Swift.Int
        let numAttentionHeads: Swift.Int
        let numHiddenLayers: Swift.Int
        let intermediateSize: Swift.Int
        let numKeyValueHeads: Swift.Int
        let slidingWindow: Swift.Int
        let useSlidingWindow: Swift.Bool
        let maxWindowLayers: Swift.Int
    }
    enum CodingKeys {
        case visionConfiguration
    }
    let textConfiguration: MLXVLM.Qwen25VLConfiguration.TextConfiguration
    let visionConfiguration: MLXVLM.Qwen25VLConfiguration.VisionConfiguration
    let baseConfiguration: MLXVLM.Qwen25VLConfiguration.BaseConfiguration
}
struct Qwen25VLProcessorConfiguration {
    struct Size {
        enum CodingKeys {
            case maxPixels
            case minPixels
        }
        let maxPixels: Swift.Int
        let minPixels: Swift.Int
    }
    enum CodingKeys {
        case imageMean
        case imageStd
        case minPixels
        case maxPixels
        case mergeSize
        case patchSize
        case temporalPatchSize
        case imageProcessorType
    }
    let imageMean: [CoreGraphics.CGFloat]
    let imageStd: [CoreGraphics.CGFloat]
    let minPixels: Swift.Int
    let maxPixels: Swift.Int
    let mergeSize: Swift.Int
    let patchSize: Swift.Int
    let temporalPatchSize: Swift.Int
    let imageProcessorType: Swift.String
}
class Qwen2VLProcessor {
    let config: MLXVLM.Qwen2VLProcessorConfiguration
    let tokenizer: Tokenizers.Tokenizer
}
class Qwen2VL: MLXNN.Module {
    var _visionModel: MLXNN.ModuleInfo<MLXVLM.Vision.VisionModel>
    var _languageModel: MLXNN.ModuleInfo<MLXVLM.Language.LanguageModel>
    let config: MLXVLM.Qwen2VLConfiguration
}
struct Qwen2VLConfiguration {
    struct TextConfiguration {
        enum CodingKeys {
            case modelType
            case hiddenSize
            case hiddenLayers
            case intermediateSize
            case attentionHeads
            case _rmsNormEps
            case vocabularySize
            case kvHeads
            case _maxPositionEmbeddings
            case _ropeTheta
            case _ropeTraditional
            case ropeScaling
            case _tieWordEmbeddings
        }
        let modelType: Swift.String
        let hiddenSize: Swift.Int
        let hiddenLayers: Swift.Int
        let intermediateSize: Swift.Int
        let attentionHeads: Swift.Int
        let _rmsNormEps: Swift.Float?
        let vocabularySize: Swift.Int
        let kvHeads: Swift.Int
        let _maxPositionEmbeddings: Swift.Int?
        let _ropeTheta: Swift.Float?
        let _ropeTraditional: Swift.Bool?
        let ropeScaling: [Swift.String : MLXLMCommon.StringOrNumber]?
        let _tieWordEmbeddings: Swift.Bool?
    }
    struct VisionConfiguration {
        enum CodingKeys {
            case depth
            case embedDimensions
            case hiddenSize
            case numHeads
            case patchSize
            case mlpRatio
            case _inChannels
            case _layerNormEps
            case spatialPatchSize
            case spatialMergeSize
            case temporalPatchSize
        }
        let depth: Swift.Int
        let embedDimensions: Swift.Int
        let hiddenSize: Swift.Int
        let numHeads: Swift.Int
        let patchSize: Swift.Int
        let mlpRatio: Swift.Float
        let _inChannels: Swift.Int?
        let _layerNormEps: Swift.Float?
        let spatialPatchSize: Swift.Int
        let spatialMergeSize: Swift.Int
        let temporalPatchSize: Swift.Int
    }
    struct BaseConfiguration {
        enum CodingKeys {
            case modelType
            case vocabularySize
            case imageTokenId
            case videoTokenId
            case hiddenSize
        }
        let modelType: Swift.String
        let vocabularySize: Swift.Int
        let imageTokenId: Swift.Int
        let videoTokenId: Swift.Int
        let hiddenSize: Swift.Int
    }
    enum CodingKeys {
        case visionConfiguration
    }
    let textConfiguration: MLXVLM.Qwen2VLConfiguration.TextConfiguration
    let visionConfiguration: MLXVLM.Qwen2VLConfiguration.VisionConfiguration
    let baseConfiguration: MLXVLM.Qwen2VLConfiguration.BaseConfiguration
}
struct Qwen2VLProcessorConfiguration {
    struct Size {
        enum CodingKeys {
            case maxPixels
            case minPixels
        }
        let maxPixels: Swift.Int
        let minPixels: Swift.Int
    }
    enum CodingKeys {
        case imageMean
        case imageStd
        case mergeSize
        case patchSize
        case temporalPatchSize
        case _maxPixels
        case _minPixels
        case _size
    }
    let imageMean: [CoreGraphics.CGFloat]
    let imageStd: [CoreGraphics.CGFloat]
    let mergeSize: Swift.Int
    let patchSize: Swift.Int
    let temporalPatchSize: Swift.Int
    let _size: MLXVLM.Qwen2VLProcessorConfiguration.Size?
    let _maxPixels: Swift.Int?
    let _minPixels: Swift.Int?
}
struct Qwen2VLMessageGenerator {}
struct QwenVL {
    class VisionRotaryEmbedding {
        let dimensions: Swift.Int
        let theta: Swift.Float
        let inverseFreq: MLX.MLXArray
    }
    class PatchEmbed: MLXNN.Module {
        var _proj: MLXNN.ModuleInfo<MLXNN.Conv3d>
        let patchSize: Swift.Int
        let temporalPatchSize: Swift.Int
        let inChannels: Swift.Int
        let outputDimensions: Swift.Int
    }
}
struct SmolVLMProcessorConfiguration {
    struct Size {
        enum CodingKeys {
            case longestEdge
        }
        let longestEdge: Swift.Int
    }
    struct VideoSampling {
        enum CodingKeys {
            case fps
            case maxFrames
        }
        let fps: Swift.Int
        let maxFrames: Swift.Int
    }
    enum CodingKeys {
        case imageMean
        case imageStd
        case size
        case maxImageSize
        case videoSampling
        case _imageSequenceLength
    }
    let imageMean: [CoreGraphics.CGFloat]
    let imageStd: [CoreGraphics.CGFloat]
    let size: MLXVLM.SmolVLMProcessorConfiguration.Size
    let maxImageSize: MLXVLM.SmolVLMProcessorConfiguration.Size
    let videoSampling: MLXVLM.SmolVLMProcessorConfiguration.VideoSampling
    let _imageSequenceLength: Swift.Int?
}
class SmolVLMProcessor {
    let config: MLXVLM.SmolVLMProcessorConfiguration
    let tokenizer: Tokenizers.Tokenizer
    let imageTokenId: Swift.Int
    let imageToken: Swift.String
    let fakeImageToken: Swift.String
    let globalImageToken: Swift.String
    let defaultVideoSystemMessage: Swift.String
}
enum VLMError {
    case imageProcessingFailure(Swift.String)
    case processing(Swift.String)
    case imageRequired
    case maskRequired
    case singleImageAllowed
    case singleVideoAllowed
    case singleMediaTypeAllowed
}
struct BaseProcessorConfiguration {
    enum CodingKeys {
        case processorClass
    }
    let processorClass: Swift.String
}
class VLMTypeRegistry: MLXLMCommon.ModelTypeRegistry {}
class VLMProcessorTypeRegistry: MLXLMCommon.ProcessorTypeRegistry {}
class VLMRegistry: MLXLMCommon.AbstractModelRegistry {}
class VLMModelFactory {
    let typeRegistry: MLXLMCommon.ModelTypeRegistry
    let processorRegistry: MLXLMCommon.ProcessorTypeRegistry
    let modelRegistry: MLXLMCommon.AbstractModelRegistry
}
class TrampolineModelFactory: __C.NSObject {}
class BundleFinder {}
class ApplicationLifecyclePublisher: PostHog.BaseApplicationLifecyclePublisher {}
class BaseApplicationLifecyclePublisher {
    let registrationLock: __C.NSLock
    var didBecomeActiveCallbacks: [Foundation.UUID : () -> ()]
    var didEnterBackgroundCallbacks: [Foundation.UUID : () -> ()]
    var didFinishLaunchingCallbacks: [Foundation.UUID : () -> ()]
}
class RegistrationToken {
    let onDealloc: () -> ()
}
class PostHogAppLifeCycleIntegration {
    weak var postHog: PostHog.PostHogSDK?
    var isFreshAppLaunch: Swift.Bool
    var isAppBackgrounded: Swift.Bool
    var didBecomeActiveToken: PostHog.RegistrationToken?
    var didEnterBackgroundToken: PostHog.RegistrationToken?
    var didFinishLaunchingToken: PostHog.RegistrationToken?
}
class PostHogEvent: __C.NSObject {
    var event: Swift.String
    var distinctId: Swift.String
    var properties: [Swift.String : Any]
    var timestamp: Foundation.Date
    var uuid: Foundation.UUID
    var apiKey: Swift.String?
}
class PostHogApi {
    let config: PostHog.PostHogConfig
    let defaultTimeout: Swift.Double
}
class BoxedBeforeSendBlock: __C.NSObject {
    let block: (_: PostHog.PostHogEvent) -> PostHog.PostHogEvent?
}
class PostHogConfig: __C.NSObject {
    enum PostHogDataMode {}
    let host: Foundation.URL
    let apiKey: Swift.String
    var flushAt: Swift.Int
    var maxQueueSize: Swift.Int
    var maxBatchSize: Swift.Int
    var flushIntervalSeconds: Swift.Double
    var dataMode: PostHog.PostHogConfig.PostHogDataMode
    var sendFeatureFlagEvent: Swift.Bool
    var preloadFeatureFlags: Swift.Bool
    var remoteConfig: Swift.Bool
    var captureApplicationLifecycleEvents: Swift.Bool
    var captureScreenViews: Swift.Bool
    var debug: Swift.Bool
    var optOut: Swift.Bool
    var getAnonymousId: (_: Foundation.UUID) -> Foundation.UUID
    var reuseAnonymousId: Swift.Bool
    var propertiesSanitizer: __C.PostHogPropertiesSanitizer?
    var personProfiles: PostHog.PostHogPersonProfiles
    var setDefaultPersonProperties: Swift.Bool
    var evaluationEnvironments: [Swift.String]?
    var appGroupIdentifier: Swift.String?
    var snapshotEndpoint: Swift.String
    var disableReachabilityForTesting: Swift.Bool
    var disableQueueTimerForTesting: Swift.Bool
    var storageManager: PostHog.PostHogStorageManager?
    var _surveys: Swift.Bool
    var _surveysConfig: PostHog.PostHogSurveysConfig
    var beforeSend: (_: PostHog.PostHogEvent) -> PostHog.PostHogEvent?
}
class PostHogContext {
    var _screenSize: PostHog.ReadWriteLock<__C.CGSize?>
    let reachability: PostHog.Reachability?
    lazy var theStaticContext: [Swift.String : Any]?
    lazy var theSdkInfo: [Swift.String : Any]?
}
class PostHogFileBackedQueue {
    let queue: Foundation.URL
    var _items: PostHog.ReadWriteLock<[Swift.String]>
}
enum PostHogPersonProfiles {}
class PostHogQueue {
    enum PostHogApiEndpoint {
        case batch
        case snapshot
    }
    let config: PostHog.PostHogConfig
    let api: PostHog.PostHogApi
    var paused: Swift.Bool
    let pausedLock: __C.NSLock
    var pausedUntil: Foundation.Date?
    var retryCount: Swift.Double
    let reachability: PostHog.Reachability?
    var isFlushing: Swift.Bool
    let isFlushingLock: __C.NSLock
    var timer: __C.NSTimer?
    let timerLock: __C.NSLock
    let endpoint: PostHog.PostHogQueue.PostHogApiEndpoint
    let dispatchQueue: __C.OS_dispatch_queue
    let fileQueue: PostHog.PostHogFileBackedQueue
}
class PostHogRemoteConfig {
    let hasFeatureFlagsKey: Swift.String
    let config: PostHog.PostHogConfig
    let storage: PostHog.PostHogStorage
    let api: PostHog.PostHogApi
    let getDefaultPersonProperties: () -> [Swift.String : Any]
    let loadingFeatureFlagsLock: __C.NSLock
    let featureFlagsLock: __C.NSLock
    var loadingFeatureFlags: Swift.Bool
    var sessionReplayFlagActive: Swift.Bool
    var flags: [Swift.String : Any]?
    var featureFlags: [Swift.String : Any]?
    var remoteConfigLock: __C.NSLock
    let loadingRemoteConfigLock: __C.NSLock
    var loadingRemoteConfig: Swift.Bool
    var remoteConfig: [Swift.String : Any]?
    var remoteConfigDidFetch: Swift.Bool
    var featureFlagPayloads: [Swift.String : Any]?
    var requestId: Swift.String?
    let personPropertiesForFlagsLock: __C.NSLock
    var personPropertiesForFlags: [Swift.String : Any]
    let groupPropertiesForFlagsLock: __C.NSLock
    var groupPropertiesForFlags: [Swift.String : [Swift.String : Any]]
    var canReloadFlagsForTesting: Swift.Bool
    var onRemoteConfigLoaded: ((_: [Swift.String : Any]?) -> ())?
    var onFeatureFlagsLoaded: ((_: [Swift.String : Any]?) -> ())?
    let dispatchQueue: __C.OS_dispatch_queue
}
class PostHogSDK: __C.NSObject {
    var config: PostHog.PostHogConfig
    var enabled: Swift.Bool
    let setupLock: __C.NSLock
    let optOutLock: __C.NSLock
    let groupsLock: __C.NSLock
    let flagCallReportedLock: __C.NSLock
    let personPropsLock: __C.NSLock
    var queue: PostHog.PostHogQueue?
    var replayQueue: PostHog.PostHogQueue?
    var storage: PostHog.PostHogStorage?
    var reachability: PostHog.Reachability?
    var flagCallReported: Swift.Set<Swift.String>
    var remoteConfig: PostHog.PostHogRemoteConfig?
    var context: PostHog.PostHogContext?
    var installedIntegrations: [PostHog.PostHogIntegration]
}
class PostHogSessionManager: __C.NSObject {
    enum SessionIDChangeReason {
        case sessionIdEmpty
        case sessionStart
        case sessionEnd
        case sessionReset
        case sessionTimeout
        case sessionPastMaximumLength
        case customSessionId
    }
    let queue: __C.OS_dispatch_queue
    var sessionId: Swift.String?
    var sessionStartTimestamp: Swift.Double?
    var sessionActivityTimestamp: Swift.Double?
    let sessionLock: __C.NSLock
    var isAppInBackground: Swift.Bool
    let sessionActivityThreshold: Swift.Double
    let sessionMaxLengthThreshold: Swift.Double
    var onSessionIdChanged: () -> ()
    var didBecomeActiveToken: PostHog.RegistrationToken?
    var didEnterBackgroundToken: PostHog.RegistrationToken?
    var applicationEventToken: PostHog.RegistrationToken?
}
class PostHogStorage {
    enum StorageKey {
        case distinctId
        case anonymousId
        case queue
        case oldQeueue
        case replayQeueue
        case enabledFeatureFlags
        case enabledFeatureFlagPayloads
        case flags
        case groups
        case registerProperties
        case optOut
        case sessionReplay
        case isIdentified
        case personProcessingEnabled
        case remoteConfig
        case surveySeen
        case requestId
        case personPropertiesForFlags
        case groupPropertiesForFlags
    }
    let appFolderUrl: Foundation.URL
}
class PostHogStorageManager {
    let storage: PostHog.PostHogStorage?
    let anonLock: __C.NSLock
    let distinctLock: __C.NSLock
    let identifiedLock: __C.NSLock
    let personProcessingLock: __C.NSLock
    let idGen: (_: Foundation.UUID) -> Foundation.UUID
    var distinctId: Swift.String?
    var cachedDistinctId: Swift.Bool
    var anonymousId: Swift.String?
    var isIdentifiedValue: Swift.Bool?
    var personProcessingEnabled: Swift.Bool?
}
class RRStyle {
    var color: Swift.String?
    var backgroundColor: Swift.String?
    var backgroundImage: Swift.String?
    var borderWidth: Swift.Int?
    var borderRadius: Swift.Int?
    var borderColor: Swift.String?
    var fontSize: Swift.Int?
    var fontFamily: Swift.String?
    var horizontalAlign: Swift.String?
    var verticalAlign: Swift.String?
    var paddingTop: Swift.Int?
    var paddingBottom: Swift.Int?
    var paddingLeft: Swift.Int?
    var paddingRight: Swift.Int?
    var bar: Swift.String?
}
class RRWireframe {
    var id: Swift.Int
    var posX: Swift.Int
    var posY: Swift.Int
    var width: Swift.Int
    var height: Swift.Int
    var childWireframes: [PostHog.RRWireframe]?
    var type: Swift.String?
    var inputType: Swift.String?
    var text: Swift.String?
    var label: Swift.String?
    var value: Any?
    var base64: Swift.String?
    var style: PostHog.RRStyle?
    var disabled: Swift.Bool?
    var checked: Swift.Bool?
    var options: [Swift.String]?
    var max: Swift.Int?
    var parentId: Swift.Int?
}
class ViewTreeSnapshotStatus {
    var sentFullSnapshot: Swift.Bool
    var sentMetaEvent: Swift.Bool
    var keyboardVisible: Swift.Bool
    var lastSnapshot: Swift.Bool
}
class ApplicationScreenViewPublisher: PostHog.BaseScreenViewPublisher {
    var hasSwizzled: Swift.Bool
}
class BaseScreenViewPublisher {
    let registrationLock: __C.NSLock
    var onScreenViewCallbacks: [Foundation.UUID : (_: Swift.String) -> ()]
}
class PostHogScreenViewIntegration {
    weak var postHog: PostHog.PostHogSDK?
    var screenViewToken: PostHog.RegistrationToken?
}
class PostHogDisplaySurvey: __C.NSObject {
    let id: Swift.String
    let name: Swift.String
    let questions: [PostHog.PostHogDisplaySurveyQuestion]
    let appearance: PostHog.PostHogDisplaySurveyAppearance?
    let startDate: Foundation.Date?
    let endDate: Foundation.Date?
}
enum PostHogDisplaySurveyRatingType {}
enum PostHogDisplaySurveyTextContentType {}
class PostHogDisplaySurveyAppearance: __C.NSObject {
    let fontFamily: Swift.String?
    let backgroundColor: Swift.String?
    let borderColor: Swift.String?
    let submitButtonColor: Swift.String?
    let submitButtonText: Swift.String?
    let submitButtonTextColor: Swift.String?
    let descriptionTextColor: Swift.String?
    let ratingButtonColor: Swift.String?
    let ratingButtonActiveColor: Swift.String?
    let placeholder: Swift.String?
    let displayThankYouMessage: Swift.Bool
    let thankYouMessageHeader: Swift.String?
    let thankYouMessageDescription: Swift.String?
    let thankYouMessageDescriptionContentType: PostHog.PostHogDisplaySurveyTextContentType?
    let thankYouMessageCloseButtonText: Swift.String?
}
class PostHogDisplaySurveyQuestion: __C.NSObject {
    let id: Swift.String
    let question: Swift.String
    let questionDescription: Swift.String?
    let questionDescriptionContentType: PostHog.PostHogDisplaySurveyTextContentType
    let isOptional: Swift.Bool
    let buttonText: Swift.String?
}
class PostHogDisplayOpenQuestion: PostHog.PostHogDisplaySurveyQuestion {}
class PostHogDisplayLinkQuestion: PostHog.PostHogDisplaySurveyQuestion {
    let link: Swift.String?
}
class PostHogDisplayRatingQuestion: PostHog.PostHogDisplaySurveyQuestion {
    let ratingType: PostHog.PostHogDisplaySurveyRatingType
    let scaleLowerBound: Swift.Int
    let scaleUpperBound: Swift.Int
    let lowerBoundLabel: Swift.String
    let upperBoundLabel: Swift.String
}
class PostHogDisplayChoiceQuestion: PostHog.PostHogDisplaySurveyQuestion {
    let choices: [Swift.String]
    let hasOpenChoice: Swift.Bool
    let shuffleOptions: Swift.Bool
    let isMultipleChoice: Swift.Bool
}
class PostHogNextSurveyQuestion: __C.NSObject {
    let questionIndex: Swift.Int
    let isSurveyCompleted: Swift.Bool
}
class PostHogSurveyResponse: __C.NSObject {
    let type: PostHog.PostHogSurveyResponseType
    let linkClicked: Swift.Bool?
    let ratingValue: Swift.Int?
    let textValue: Swift.String?
    let selectedOptions: [Swift.String]?
}
enum PostHogSurveyResponseType {}
class PostHogSurveysConfig: __C.NSObject {
    var surveysDelegate: PostHog.PostHogSurveysDelegate
}
class PostHogSurveysDefaultDelegate {}
struct PostHogSwiftUIViewModifier {
    let viewEventName: Swift.String
    let screenEvent: Swift.Bool
    let properties: [Swift.String : Any]?
    let postHog: PostHog.PostHogSDK?
}
enum Gzip {}
struct CompressionLevel {
    let rawValue: Swift.Int32
}
struct GzipError {
    enum Kind {
        case unknown(code: Swift.Int)
        case stream
        case data
        case memory
        case buffer
        case version
    }
    let kind: PostHog.GzipError.Kind
    let message: Swift.String
}
class PostHogAPIDateFormatter {
    let dateFormatterWithMilliseconds: __C.NSDateFormatter
    let dateFormatterWithSeconds: __C.NSDateFormatter
}
struct InternalPostHogError {
    let description: Swift.String
}
enum ReachabilityError {
    case failedToCreateWithAddress(__C.sockaddr, Swift.Int32)
    case failedToCreateWithHostname(Swift.String, Swift.Int32)
    case unableToSetCallback(Swift.Int32)
    case unableToSetDispatchQueue(Swift.Int32)
    case unableToGetFlags(Swift.Int32)
}
class Reachability {
    enum NetworkStatus {
        case notReachable
        case reachableViaWiFi
        case reachableViaWWAN
    }
    enum Connection {
        case unavailable
        case wifi
        case cellular
    }
    var whenReachable: ((_: PostHog.Reachability) -> ())?
    var whenUnreachable: ((_: PostHog.Reachability) -> ())?
    let reachableOnWWAN: Swift.Bool
    var allowsCellularConnection: Swift.Bool
    var notificationCenter: __C.NSNotificationCenter
    var notifierRunning: Swift.Bool
    let reachabilityRef: __C.SCNetworkReachability
    let reachabilitySerialQueue: __C.OS_dispatch_queue
    let notificationQueue: __C.OS_dispatch_queue?
    var flags: __C.SCNetworkReachabilityFlags?
}
class ReachabilityWeakifier {
    weak var reachability: PostHog.Reachability?
}
class ReadWriteLock<A> {
    var value: A
    var rwlock: __C._opaque_pthread_rwlock_t
}
class TimeBasedEpochGenerator {
    var lastEntropy: [Swift.UInt8]
    var lastTimestamp: Swift.UInt64
    let lock: __C.NSLock
}
class BundleFinder {}
enum RemoteConfigValueCodableError {
    case unsupportedType(Swift.String)
}
enum RemoteConfigCodableError {
    case invalidSetDefaultsInput(Swift.String)
}
struct CustomSignalValue {
    enum Kind {
        case string(Swift.String)
        case integer(Swift.Int)
        case double(Swift.Double)
    }
    let kind: FirebaseRemoteConfig.CustomSignalValue.Kind
}
struct FirebaseRemoteConfigValueDecoderHelper {
    let value: __C.FIRRemoteConfigValue
}
struct RemoteConfigProperty<A> where A: Swift.Decodable {
    var _configValueObserver: SwiftUI.StateObject<FirebaseRemoteConfig.RemoteConfigValueObservable<A>>
    let key: Swift.String
}
class RemoteConfigValueObservable<A> where A: Swift.Decodable {
    var _configValue: Combine.Published<A>
    let key: Swift.String
    let remoteConfig: __C.FIRRemoteConfig
    let fallbackValue: A
}
class RemoteConfigConstants: __C.NSObject {}
class RolloutAssignment: __C.NSObject {
    var rolloutId: Swift.String
    var variantId: Swift.String
    var templateVersion: Swift.Int64
    var parameterKey: Swift.String
    var parameterValue: Swift.String
}
class RolloutsState: __C.NSObject {
    var assignments: Swift.Set<FirebaseRemoteConfigInterop.RolloutAssignment>
}
class BundleFinder {}
enum Maybe<A> {
    case value(A)
    case error(Swift.Error)
}
class Promise<A> {
    let objCPromise: __C.FBLPromise<Swift.AnyObject>
}
enum PromiseError {
    case timedOut
    case validationFailure
}
class ApplicationInfo {
    let appID: Swift.String
    let networkInformation: FirebaseSessions.NetworkInfoProtocol
    let envParams: [Swift.String : Swift.String]
    let infoDict: [Swift.String : Any]?
}
class DevEventConsoleLogger {
    let commandLineArgument: Swift.String
}
class EventGDTLogger {
    let googleDataTransport: FirebaseSessions.GoogleDataTransportProtocol
    let devEventConsoleLogger: FirebaseSessions.EventGDTLoggerProtocol
}
class Sessions: __C.NSObject {
    let appID: Swift.String
    let coordinator: FirebaseSessions.SessionCoordinatorProtocol
    let initiator: FirebaseSessions.SessionInitiator
    let sessionGenerator: FirebaseSessions.SessionGenerator
    let appInfo: FirebaseSessions.ApplicationInfoProtocol
    let settings: FirebaseSessions.SettingsProtocol
    var subscribers: [__C.FIRSessionsSubscriber]
    var subscriberPromises: [FirebaseSessions.SessionsSubscriberName : Promises.Promise<()>]
    let notificationCenter: __C.NSNotificationCenter
}
enum FirebaseSessionsError {
    case SessionInstallationsError(Swift.Error)
    case DataTransportError(Swift.Error)
    case SessionSamplingError
    case SessionInstallationsTimeOutError
    case DisabledViaSettingsError
    case DataCollectionError
    case NoDependenciesError
}
class GoogleDataTransporter {
    let transporter: __C.GDTCORTransport
}
enum GoogleDataTransportProtocolErrors {
    case writeFailure
}
class NetworkInfo {}
class SessionsDependencies: __C.NSObject {}
class SessionDetails: __C.NSObject {
    let sessionId: Swift.String?
}
enum SessionsSubscriberName {}
class SessionCoordinator {
    let installations: FirebaseSessions.InstallationsProtocol
    let fireLogger: FirebaseSessions.EventGDTLoggerProtocol
}
class SessionGenerator {
    var thisSession: FirebaseSessions.SessionInfo?
    var firstSessionId: Swift.String
    var sessionIndex: Swift.Int32
    var collectEvents: Swift.Bool
}
struct SessionInfo {
    let sessionId: Swift.String
    let firstSessionId: Swift.String
    let shouldDispatchEvents: Swift.Bool
    let sessionIndex: Swift.Int32
}
class SessionInitiator {
    let currentTime: () -> Foundation.Date
    let settings: FirebaseSessions.SettingsProtocol
    var backgroundTime: Foundation.Date
    var initiateSessionStart: () -> ()
}
class SessionStartEvent: __C.NSObject {
    var proto: __C._firebase_appquality_sessions_SessionEvent
}
class LocalOverrideSettings {}
class RemoteSettings {
    let appInfo: FirebaseSessions.ApplicationInfoProtocol
    let downloader: FirebaseSessions.SettingsDownloadClient
    let cache: FirebaseCoreInternal.UnfairLock<FirebaseSessions.SettingsCacheClient>
}
class SDKDefaultSettings {}
class SessionsSettings {
    let appInfo: FirebaseSessions.ApplicationInfoProtocol
    let installations: FirebaseSessions.InstallationsProtocol
    let sdkDefaults: FirebaseSessions.SDKDefaultSettings
    let localOverrides: FirebaseSessions.LocalOverrideSettings
    let remoteSettings: FirebaseSessions.RemoteSettings
}
class SettingsCache {
    let cache: __C.GULUserDefaults
}
struct CacheKey {
    enum CodingKeys {
        case createdAt
        case googleAppID
        case appVersion
    }
    var createdAt: Foundation.Date
    var googleAppID: Swift.String
    var appVersion: Swift.String
}
class SettingsDownloader {
    let appInfo: FirebaseSessions.ApplicationInfoProtocol
    let installations: FirebaseSessions.InstallationsProtocol
}
enum SettingsDownloaderError {
    case URLError(Swift.String)
    case URLSessionError(Swift.String)
    case JSONParseError(Swift.String)
    case InstallationIDError(Swift.String)
}
class Time {}
class BundleFinder {}
class CrashlyticsRemoteConfigManager: __C.NSObject {
    let lock: __C.NSLock
    var _rolloutAssignment: [FirebaseRemoteConfigInterop.RolloutAssignment]
    var remoteConfig: __C.FIRRemoteConfigInterop
    var persistenceDelegate: __C.FIRCLSPersistenceLog
}
class EncodedRolloutsState: __C.NSObject {
    enum CodingKeys {
        case rollouts
    }
    var rollouts: [FirebaseCrashlyticsSwift.EncodedRolloutAssignment]
}
class EncodedRolloutAssignment: __C.NSObject {
    enum CodingKeys {
        case rolloutId
        case variantId
        case templateVersion
        case parameterKey
        case parameterValue
    }
    var rolloutId: Swift.String
    var variantId: Swift.String
    var templateVersion: Swift.Int64
    var parameterKey: Swift.String
    var parameterValue: Swift.String
}
class FileUtility: __C.NSObject {}
struct CustomModel {
    let name: Swift.String
    let size: Swift.Int
    let path: Swift.String
    let hash: Swift.String
}
class ModelFileDownloader: __C.NSObject {
    let conditions: FirebaseMLModelDownloader.ModelDownloadConditions
    let configuration: __C.NSURLSessionConfiguration
    var downloadTask: __C.NSURLSessionDownloadTask?
    lazy var downloadSession: __C.NSURLSession?
    var completion: ((_: Swift.Result<FirebaseMLModelDownloader.FileDownloaderResponse, Swift.Error>) -> ())?
    var progressHandler: ((Swift.Int64, Swift.Int64) -> ())?
}
struct FileDownloaderResponse {
    var urlResponse: __C.NSHTTPURLResponse
    var fileURL: Foundation.URL
}
enum FileDownloaderError {
    case networkError(Swift.Error)
    case unexpectedResponseType
}
class LocalModelInfo {
    let name: Swift.String
    let modelHash: Swift.String
    let size: Swift.Int
}
struct ModelDownloadConditions {
    let allowsCellularAccess: Swift.Bool
}
class ModelDownloadTask {
    let appName: Swift.String
    var remoteModelInfo: FirebaseMLModelDownloader.RemoteModelInfo
    let defaults: __C.GULUserDefaults
    var downloadStatus: FirebaseMLModelDownloader.ModelDownloadStatus
    let downloader: FirebaseMLModelDownloader.FileDownloader
    let telemetryLogger: FirebaseMLModelDownloader.TelemetryLogger?
    var progressHandler: ((_: Swift.Float) -> ())?
    var completion: (_: Swift.Result<FirebaseMLModelDownloader.CustomModel, FirebaseMLModelDownloader.DownloadError>) -> ()
}
enum ModelDownloadStatus {
    case ready
    case downloading
    case complete
}
enum ModelDownloadType {
    case localModel
    case localModelUpdateInBackground
    case latestModel
}
class ModelDownloader {
    let appName: Swift.String
    let options: __C.FIROptions
    let installations: __C.FIRInstallations
    let userDefaults: __C.GULUserDefaults
    let telemetryLogger: FirebaseMLModelDownloader.TelemetryLogger?
    var numberOfRetries: Swift.Int
    var currentDownloadTask: [Swift.String : FirebaseMLModelDownloader.ModelDownloadTask]
    let taskSerialQueue: __C.OS_dispatch_queue
}
enum DownloadError {
    case internalError(description: Swift.String)
    case notFound
    case permissionDenied
    case failedPrecondition
    case resourceExhausted
    case notEnoughSpace
    case invalidArgument
    case emptyModelName
}
enum DownloadedModelError {
    case fileIOError(description: Swift.String)
    case internalError(description: Swift.String)
    case notFound
}
class ModelInfoRetriever {
    let modelName: Swift.String
    let projectID: Swift.String
    let apiKey: Swift.String
    let appName: Swift.String
    let authTokenProvider: (_: (_: Swift.Result<Swift.String, FirebaseMLModelDownloader.DownloadError>) -> ()) -> ()
    let session: FirebaseMLModelDownloader.ModelInfoRetrieverSession
    let localModelInfo: FirebaseMLModelDownloader.LocalModelInfo?
    let telemetryLogger: FirebaseMLModelDownloader.TelemetryLogger?
}
struct ModelInfoResponse {
    enum CodingKeys {
        case downloadURL
        case urlExpiryTime
        case size
    }
    let downloadURL: Swift.String
    let urlExpiryTime: Swift.String
    let size: Swift.String
}
enum DownloadModelInfoResult {
    case modelInfo(FirebaseMLModelDownloader.RemoteModelInfo)
    case notModified
}
struct RemoteModelInfo {
    let name: Swift.String
    let downloadURL: Foundation.URL
    let modelHash: Swift.String
    let size: Swift.Int
    let urlExpiryTime: Foundation.Date
}
class FBMLDataObject: __C.NSObject {
    let event: FirebaseMLModelDownloader.FirebaseMlLogEvent
}
class TelemetryLogger {
    let mappingID: Swift.String
    let app: __C.FIRApp
    let cctTransport: __C.GDTCORTransport
}
struct DeleteModelLogEvent {
    var modelType: FirebaseMLModelDownloader.ModelInfo.ModelType
    var isSuccessful: Swift.Bool
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct ModelDownloadLogEvent {
    enum DownloadStatus {
        case UNRECOGNIZED(Swift.Int)
        case unknownStatus
        case explicitlyRequested
        case implicitlyRequested
        case modelInfoRetrievalSucceeded
        case modelInfoRetrievalFailed
        case scheduled
        case downloading
        case succeeded
        case failed
        case updateAvailable
    }
    var roughDownloadDurationMs: Swift.UInt64
    var errorCode: FirebaseMLModelDownloader.ErrorCode
    var exactDownloadDurationMs: Swift.UInt64
    var downloadStatus: FirebaseMLModelDownloader.ModelDownloadLogEvent.DownloadStatus
    var downloadFailureStatus: Swift.Int64
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _options: FirebaseMLModelDownloader.ModelOptions?
}
struct ModelOptions {
    var isModelUpdateEnabled: Swift.Bool
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _modelInfo: FirebaseMLModelDownloader.ModelInfo?
}
struct ModelInfo {
    enum ModelType {
        case UNRECOGNIZED(Swift.Int)
        case typeUnknown
        case custom
    }
    var name: Swift.String
    var version: Swift.String
    var hash: Swift.String
    var modelType: FirebaseMLModelDownloader.ModelInfo.ModelType
    var unknownFields: SwiftProtobuf.UnknownStorage
}
enum EventName {
    case UNRECOGNIZED(Swift.Int)
    case unknownEvent
    case modelDownload
    case modelUpdate
    case remoteModelDeleteOnDevice
}
struct SystemInfo {
    var appID: Swift.String
    var appVersion: Swift.String
    var firebaseProjectID: Swift.String
    var mlSdkVersion: Swift.String
    var apiKey: Swift.String
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct FirebaseMlLogEvent {
    class _StorageClass {
        var _systemInfo: FirebaseMLModelDownloader.SystemInfo?
        var _eventName: FirebaseMLModelDownloader.EventName
        var _modelDownloadLogEvent: FirebaseMLModelDownloader.ModelDownloadLogEvent?
        var _deleteModelLogEvent: FirebaseMLModelDownloader.DeleteModelLogEvent?
    }
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _storage: FirebaseMLModelDownloader.FirebaseMlLogEvent._StorageClass
}
enum ErrorCode {
    case UNRECOGNIZED(Swift.Int)
    case noError
    case uriExpired
    case noNetworkConnection
    case downloadFailed
    case modelInfoDownloadUnsuccessfulHTTPStatus
    case modelInfoDownloadNoHash
    case modelInfoDownloadConnectionFailed
    case modelHashMismatch
    case unknownError
}
class BundleFinder {}
class AnyMessageStorage {
    enum InternalState {
        case binary(Foundation.Data)
        case message(SwiftProtobuf.Message)
        case contentJSON([Swift.UInt8], SwiftProtobuf.JSONDecodingOptions)
    }
    var _typeURL: Swift.String
    var state: SwiftProtobuf.AnyMessageStorage.InternalState
}
enum AnyUnpackError {
    case typeMismatch
    case malformedWellKnownTypeJSON
    case malformedAnyField
}
struct AsyncMessageSequence<A, B> where A: Swift.AsyncSequence, B: SwiftProtobuf.Message, A.AsyncSequence.Element == Swift.UInt8 {
    struct AsyncIterator {
        var iterator: A.AsyncSequence.AsyncIterator?
        let extensions: SwiftProtobuf.ExtensionMap?
        let partial: Swift.Bool
        let options: SwiftProtobuf.BinaryDecodingOptions
    }
    let base: A
    let extensions: SwiftProtobuf.ExtensionMap?
    let partial: Swift.Bool
    let options: SwiftProtobuf.BinaryDecodingOptions
}
struct BinaryDecoder {
    var p: Swift.UnsafeRawPointer
    var available: Swift.Int
    var fieldStartP: Swift.UnsafeRawPointer
    var fieldEndP: Swift.UnsafeRawPointer?
    var consumed: Swift.Bool
    var fieldWireFormat: SwiftProtobuf.WireFormat
    var fieldNumber: Swift.Int
    var extensions: SwiftProtobuf.ExtensionMap?
    var groupFieldNumber: Swift.Int?
    var options: SwiftProtobuf.BinaryDecodingOptions
    var recursionBudget: Swift.Int
    var unknownData: Foundation.Data?
    var unknownOverride: Foundation.Data?
}
enum BinaryDecodingError {
    case trailingGarbage
    case truncated
    case invalidUTF8
    case malformedProtobuf
    case missingRequiredFields
    case internalExtensionError
    case messageDepthLimit
}
struct BinaryDecodingOptions {
    var messageDepthLimit: Swift.Int
    var discardUnknownFields: Swift.Bool
}
enum BinaryDelimited {
    enum Error {
        case unknownStreamError
        case truncated
    }
}
struct BinaryEncoder {
    var pointer: Swift.UnsafeMutableRawPointer
    var buffer: Swift.UnsafeMutableRawBufferPointer
}
enum BinaryEncodingError {
    case anyTranscodeFailure
    case missingRequiredFields
}
struct BinaryEncodingOptions {
    var useDeterministicOrdering: Swift.Bool
}
struct BinaryEncodingSizeVisitor {
    struct BinaryEncodingMessageSetSizeVisitor {
        var serializedSize: Swift.Int
    }
    var serializedSize: Swift.Int
}
struct BinaryEncodingVisitor {
    struct BinaryEncodingMessageSetVisitor {
        let options: SwiftProtobuf.BinaryEncodingOptions
        var encoder: SwiftProtobuf.BinaryEncoder
    }
    let options: SwiftProtobuf.BinaryEncodingOptions
    var encoder: SwiftProtobuf.BinaryEncoder
}
struct BytecodeInterpreter<A> where A: Swift.RawRepresentable, A.RawRepresentable.RawValue == Swift.UInt64 {
    let program: Swift.StaticString
}
struct BytecodeReader<A> where A: Swift.RawRepresentable, A.RawRepresentable.RawValue == Swift.UInt64 {
    var remainingProgram: Swift.Slice<Swift.UnsafeBufferPointer<Swift.UInt8>>
}
class DoubleParser {
    var work: Swift.UnsafeMutableBufferPointer<Swift.Int8>
}
struct ExtensionFieldValueSet {
    var values: [Swift.Int : SwiftProtobuf.AnyExtensionField]
}
struct OptionalExtensionField<A> where A: SwiftProtobuf.FieldType {
    var value: A.FieldType.BaseType
    var protobufExtension: SwiftProtobuf.AnyMessageExtension
}
struct RepeatedExtensionField<A> where A: SwiftProtobuf.FieldType {
    var value: [A.FieldType.BaseType]
    var protobufExtension: SwiftProtobuf.AnyMessageExtension
}
struct PackedExtensionField<A> where A: SwiftProtobuf.FieldType {
    var value: [A.FieldType.BaseType]
    var protobufExtension: SwiftProtobuf.AnyMessageExtension
}
struct OptionalEnumExtensionField<A> where A: SwiftProtobuf.Enum, A.RawRepresentable.RawValue == Swift.Int {
    var value: A
    var protobufExtension: SwiftProtobuf.AnyMessageExtension
}
struct RepeatedEnumExtensionField<A> where A: SwiftProtobuf.Enum, A.RawRepresentable.RawValue == Swift.Int {
    var value: [A]
    var protobufExtension: SwiftProtobuf.AnyMessageExtension
}
struct PackedEnumExtensionField<A> where A: SwiftProtobuf.Enum, A.RawRepresentable.RawValue == Swift.Int {
    var value: [A]
    var protobufExtension: SwiftProtobuf.AnyMessageExtension
}
struct OptionalMessageExtensionField<A> where A: Swift.Equatable, A: SwiftProtobuf.Message {
    var value: A
    var protobufExtension: SwiftProtobuf.AnyMessageExtension
}
struct RepeatedMessageExtensionField<A> where A: Swift.Equatable, A: SwiftProtobuf.Message {
    var value: [A]
    var protobufExtension: SwiftProtobuf.AnyMessageExtension
}
struct OptionalGroupExtensionField<A> where A: Swift.Hashable, A: SwiftProtobuf.Message {
    var value: A
    var protobufExtension: SwiftProtobuf.AnyMessageExtension
}
struct RepeatedGroupExtensionField<A> where A: Swift.Hashable, A: SwiftProtobuf.Message {
    var value: [A]
    var protobufExtension: SwiftProtobuf.AnyMessageExtension
}
struct FieldTag {
    let rawValue: Swift.UInt32
}
struct ProtobufFloat {}
struct ProtobufDouble {}
struct ProtobufInt32 {}
struct ProtobufInt64 {}
struct ProtobufUInt32 {}
struct ProtobufUInt64 {}
struct ProtobufSInt32 {}
struct ProtobufSInt64 {}
struct ProtobufFixed32 {}
struct ProtobufFixed64 {}
struct ProtobufSFixed32 {}
struct ProtobufSFixed64 {}
struct ProtobufBool {}
struct ProtobufString {}
struct ProtobufBytes {}
class UnsafeMutableTransferBox<A> {
    var wrappedValue: A
}
enum FieldMaskError {
    case invalidPath
    case invalidFieldNumber
}
struct HashVisitor {
    var hasher: Swift.Hasher
}
enum Internal {}
struct JSONDecoder {
    var scanner: SwiftProtobuf.JSONScanner
    var messageType: SwiftProtobuf.Message.Type
    var fieldCount: Swift.Int
    var isMapKey: Swift.Bool
    var fieldNameMap: SwiftProtobuf._NameMap?
}
enum JSONDecodingError {
    case unknownField(Swift.String)
    case failure
    case malformedNumber
    case numberRange
    case malformedMap
    case malformedBool
    case malformedString
    case invalidUTF8
    case missingFieldNames
    case schemaMismatch
    case unrecognizedEnumValue
    case illegalNull
    case unquotedMapKey
    case leadingZero
    case truncated
    case malformedDuration
    case malformedTimestamp
    case malformedFieldMask
    case trailingGarbage
    case conflictingOneOf
    case messageDepthLimit
}
struct JSONDecodingOptions {
    var messageDepthLimit: Swift.Int
    var ignoreUnknownFields: Swift.Bool
}
struct JSONEncoder {
    var data: [Swift.UInt8]
    var separator: Swift.UInt8?
}
enum JSONEncodingError {
    case anyTranscodeFailure
    case timestampRange
    case durationRange
    case fieldMaskConversion
    case missingFieldNames
    case missingValue
    case valueNumberNotFinite
}
struct JSONEncodingOptions {
    var alwaysPrintInt64sAsNumbers: Swift.Bool
    var alwaysPrintEnumsAsInts: Swift.Bool
    var preserveProtoFieldNames: Swift.Bool
    var useDeterministicOrdering: Swift.Bool
}
struct JSONEncodingVisitor {
    var encoder: SwiftProtobuf.JSONEncoder
    var nameMap: SwiftProtobuf._NameMap
    var extensions: SwiftProtobuf.ExtensionFieldValueSet?
    let options: SwiftProtobuf.JSONEncodingOptions
}
struct JSONMapEncodingVisitor {
    var separator: Swift.StaticString?
    var encoder: SwiftProtobuf.JSONEncoder
    let options: SwiftProtobuf.JSONEncodingOptions
}
struct JSONScanner {
    let source: Swift.UnsafeRawBufferPointer
    var index: Swift.Int
    var numberParser: SwiftProtobuf.DoubleParser
    let options: SwiftProtobuf.JSONDecodingOptions
    let extensions: SwiftProtobuf.ExtensionMap
    var recursionBudget: Swift.Int
}
class MessageExtension<A, B> where A: SwiftProtobuf.ExtensionField, B: SwiftProtobuf.Message {
    let fieldNumber: Swift.Int
    let fieldName: Swift.String
    let messageType: SwiftProtobuf.Message.Type
}
class InternPool {
    var interned: [Swift.UnsafeRawBufferPointer]
}
enum ProtoNameInstruction {
    case sameNext
    case sameDelta
    case standardNext
    case standardDelta
    case uniqueNext
    case uniqueDelta
    case groupNext
    case groupDelta
    case aliasNext
    case aliasDelta
    case reservedName
    case reservedNumbers
}
struct _NameMap {
    struct Name {
        let utf8Buffer: Swift.UnsafeRawBufferPointer
    }
    enum NameDescription {
        case same(proto: Swift.StaticString)
        case standard(proto: Swift.StaticString)
        case unique(proto: Swift.StaticString, json: Swift.StaticString)
        case aliased(proto: Swift.StaticString, aliases: [Swift.StaticString])
    }
    struct Names {
        var json: SwiftProtobuf._NameMap.Name?
        var proto: SwiftProtobuf._NameMap.Name
    }
    var internPool: SwiftProtobuf.InternPool
    var numberToNameMap: [Swift.Int : SwiftProtobuf._NameMap.Names]
    var protoToNumberMap: [SwiftProtobuf._NameMap.Name : Swift.Int]
    var jsonToNumberMap: [SwiftProtobuf._NameMap.Name : Swift.Int]
    var reservedNames: [Swift.String]
    var reservedRanges: [Swift.Range<Swift.Int32>]
}
enum PathDecodingError {
    case typeMismatch
    case pathNotFound
}
struct PathDecoder<A> where A: SwiftProtobuf.Message {
    let value: Any?
    var number: Swift.Int?
    let nextPath: [Swift.String]
    let mergeOption: SwiftProtobuf.Google_Protobuf_FieldMask.MergeOptions
}
struct PathVisitor<A> where A: SwiftProtobuf.Message {
    let prevPath: Swift.String?
    var values: [Swift.String : Any]
}
struct _ProtobufMap<A, B> where A: SwiftProtobuf.MapKeyType, B: SwiftProtobuf.FieldType {}
struct _ProtobufMessageMap<A, B> where A: SwiftProtobuf.MapKeyType, B: Swift.Hashable, B: SwiftProtobuf.Message {}
struct _ProtobufEnumMap<A, B> where A: SwiftProtobuf.MapKeyType, B: SwiftProtobuf.Enum {}
struct SimpleExtensionMap {
    var fields: [Swift.Int : [SwiftProtobuf.AnyMessageExtension]]
}
struct SwiftProtobufError {
    class Storage {
        var code: SwiftProtobuf.SwiftProtobufError.Code
        var message: Swift.String
        var location: SwiftProtobuf.SwiftProtobufError.SourceLocation
    }
    struct Code {
        enum Wrapped {
            case binaryDecodingError
            case binaryStreamDecodingError
            case jsonDecodingError
            case jsonEncodingError
        }
        var code: SwiftProtobuf.SwiftProtobufError.Code.Wrapped
    }
    struct SourceLocation {
        var function: Swift.String
        var file: Swift.String
        var line: Swift.Int
    }
    enum BinaryDecoding {}
    enum BinaryStreamDecoding {}
    enum JSONDecoding {}
    enum JSONEncoding {}
    var storage: SwiftProtobuf.SwiftProtobufError.Storage
}
struct TextFormatDecoder {
    var scanner: SwiftProtobuf.TextFormatScanner
    var fieldCount: Swift.Int
    let terminator: Swift.UInt8?
    let fieldNameMap: SwiftProtobuf._NameMap
    let messageType: SwiftProtobuf.Message.Type
}
enum TextFormatDecodingError {
    case malformedText
    case malformedNumber
    case trailingGarbage
    case truncated
    case invalidUTF8
    case schemaMismatch
    case missingFieldNames
    case unknownField
    case unrecognizedEnumValue
    case conflictingOneOf
    case internalExtensionError
    case messageDepthLimit
}
struct TextFormatDecodingOptions {
    var messageDepthLimit: Swift.Int
    var ignoreUnknownFields: Swift.Bool
    var ignoreUnknownExtensionFields: Swift.Bool
}
struct TextFormatEncoder {
    var data: [Swift.UInt8]
    var indentString: [Swift.UInt8]
}
struct TextFormatEncodingOptions {
    var printUnknownFields: Swift.Bool
}
struct TextFormatEncodingVisitor {
    var encoder: SwiftProtobuf.TextFormatEncoder
    var nameMap: SwiftProtobuf._NameMap?
    var nameResolver: [Swift.Int : Swift.StaticString]
    var extensions: SwiftProtobuf.ExtensionFieldValueSet?
    let options: SwiftProtobuf.TextFormatEncodingOptions
}
struct TextFormatScanner {
    let extensions: SwiftProtobuf.ExtensionMap?
    var p: Swift.UnsafeRawPointer
    let end: Swift.UnsafeRawPointer
    let doubleParser: SwiftProtobuf.DoubleParser
    let options: SwiftProtobuf.TextFormatDecodingOptions
    var recursionBudget: Swift.Int
}
struct UnknownStorage {
    var data: Foundation.Data
}
enum Varint {}
struct Version {}
enum WireFormat {
    case varint
    case fixed64
    case lengthDelimited
    case startGroup
    case endGroup
    case fixed32
}
struct Google_Protobuf_Any {
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _storage: SwiftProtobuf.AnyMessageStorage
}
struct Google_Protobuf_Api {
    var name: Swift.String
    var methods: [SwiftProtobuf.Google_Protobuf_Method]
    var options: [SwiftProtobuf.Google_Protobuf_Option]
    var version: Swift.String
    var mixins: [SwiftProtobuf.Google_Protobuf_Mixin]
    var syntax: SwiftProtobuf.Google_Protobuf_Syntax
    var edition: Swift.String
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _sourceContext: SwiftProtobuf.Google_Protobuf_SourceContext?
}
struct Google_Protobuf_Method {
    var name: Swift.String
    var requestTypeURL: Swift.String
    var requestStreaming: Swift.Bool
    var responseTypeURL: Swift.String
    var responseStreaming: Swift.Bool
    var options: [SwiftProtobuf.Google_Protobuf_Option]
    var syntax: SwiftProtobuf.Google_Protobuf_Syntax
    var edition: Swift.String
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_Mixin {
    var name: Swift.String
    var root: Swift.String
    var unknownFields: SwiftProtobuf.UnknownStorage
}
enum Google_Protobuf_Edition {
    case unknown
    case legacy
    case proto2
    case proto3
    case edition2023
    case edition2024
    case edition1TestOnly
    case edition2TestOnly
    case edition99997TestOnly
    case edition99998TestOnly
    case edition99999TestOnly
    case max
}
enum Google_Protobuf_SymbolVisibility {
    case visibilityUnset
    case visibilityLocal
    case visibilityExport
}
struct Google_Protobuf_FileDescriptorSet {
    var file: [SwiftProtobuf.Google_Protobuf_FileDescriptorProto]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
}
struct Google_Protobuf_FileDescriptorProto {
    var dependency: [Swift.String]
    var publicDependency: [Swift.Int32]
    var weakDependency: [Swift.Int32]
    var optionDependency: [Swift.String]
    var messageType: [SwiftProtobuf.Google_Protobuf_DescriptorProto]
    var enumType: [SwiftProtobuf.Google_Protobuf_EnumDescriptorProto]
    var service: [SwiftProtobuf.Google_Protobuf_ServiceDescriptorProto]
    var extension: [SwiftProtobuf.Google_Protobuf_FieldDescriptorProto]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _name: Swift.String?
    var _package: Swift.String?
    var _options: SwiftProtobuf.Google_Protobuf_FileOptions?
    var _sourceCodeInfo: SwiftProtobuf.Google_Protobuf_SourceCodeInfo?
    var _syntax: Swift.String?
    var _edition: SwiftProtobuf.Google_Protobuf_Edition?
}
struct Google_Protobuf_DescriptorProto {
    struct ExtensionRange {
        var unknownFields: SwiftProtobuf.UnknownStorage
        var _start: Swift.Int32?
        var _end: Swift.Int32?
        var _options: SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions?
    }
    struct ReservedRange {
        var unknownFields: SwiftProtobuf.UnknownStorage
        var _start: Swift.Int32?
        var _end: Swift.Int32?
    }
    class _StorageClass {
        var _name: Swift.String?
        var _field: [SwiftProtobuf.Google_Protobuf_FieldDescriptorProto]
        var _extension: [SwiftProtobuf.Google_Protobuf_FieldDescriptorProto]
        var _nestedType: [SwiftProtobuf.Google_Protobuf_DescriptorProto]
        var _enumType: [SwiftProtobuf.Google_Protobuf_EnumDescriptorProto]
        var _extensionRange: [SwiftProtobuf.Google_Protobuf_DescriptorProto.ExtensionRange]
        var _oneofDecl: [SwiftProtobuf.Google_Protobuf_OneofDescriptorProto]
        var _options: SwiftProtobuf.Google_Protobuf_MessageOptions?
        var _reservedRange: [SwiftProtobuf.Google_Protobuf_DescriptorProto.ReservedRange]
        var _reservedName: [Swift.String]
        var _visibility: SwiftProtobuf.Google_Protobuf_SymbolVisibility?
    }
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _storage: SwiftProtobuf.Google_Protobuf_DescriptorProto._StorageClass
}
struct Google_Protobuf_ExtensionRangeOptions {
    enum VerificationState {
        case declaration
        case unverified
    }
    struct Declaration {
        var unknownFields: SwiftProtobuf.UnknownStorage
        var _number: Swift.Int32?
        var _fullName: Swift.String?
        var _type: Swift.String?
        var _reserved: Swift.Bool?
        var _repeated: Swift.Bool?
    }
    var uninterpretedOption: [SwiftProtobuf.Google_Protobuf_UninterpretedOption]
    var declaration: [SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.Declaration]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
    var _features: SwiftProtobuf.Google_Protobuf_FeatureSet?
    var _verification: SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.VerificationState?
}
struct Google_Protobuf_FieldDescriptorProto {
    enum TypeEnum {
        case double
        case float
        case int64
        case uint64
        case int32
        case fixed64
        case fixed32
        case bool
        case string
        case group
        case message
        case bytes
        case uint32
        case enum
        case sfixed32
        case sfixed64
        case sint32
        case sint64
    }
    enum Label {
        case optional
        case repeated
        case required
    }
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _name: Swift.String?
    var _number: Swift.Int32?
    var _label: SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.Label?
    var _type: SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.TypeEnum?
    var _typeName: Swift.String?
    var _extendee: Swift.String?
    var _defaultValue: Swift.String?
    var _oneofIndex: Swift.Int32?
    var _jsonName: Swift.String?
    var _options: SwiftProtobuf.Google_Protobuf_FieldOptions?
    var _proto3Optional: Swift.Bool?
}
struct Google_Protobuf_OneofDescriptorProto {
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _name: Swift.String?
    var _options: SwiftProtobuf.Google_Protobuf_OneofOptions?
}
struct Google_Protobuf_EnumDescriptorProto {
    struct EnumReservedRange {
        var unknownFields: SwiftProtobuf.UnknownStorage
        var _start: Swift.Int32?
        var _end: Swift.Int32?
    }
    class _StorageClass {
        var _name: Swift.String?
        var _value: [SwiftProtobuf.Google_Protobuf_EnumValueDescriptorProto]
        var _options: SwiftProtobuf.Google_Protobuf_EnumOptions?
        var _reservedRange: [SwiftProtobuf.Google_Protobuf_EnumDescriptorProto.EnumReservedRange]
        var _reservedName: [Swift.String]
        var _visibility: SwiftProtobuf.Google_Protobuf_SymbolVisibility?
    }
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _storage: SwiftProtobuf.Google_Protobuf_EnumDescriptorProto._StorageClass
}
struct Google_Protobuf_EnumValueDescriptorProto {
    class _StorageClass {
        var _name: Swift.String?
        var _number: Swift.Int32?
        var _options: SwiftProtobuf.Google_Protobuf_EnumValueOptions?
    }
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _storage: SwiftProtobuf.Google_Protobuf_EnumValueDescriptorProto._StorageClass
}
struct Google_Protobuf_ServiceDescriptorProto {
    var method: [SwiftProtobuf.Google_Protobuf_MethodDescriptorProto]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _name: Swift.String?
    var _options: SwiftProtobuf.Google_Protobuf_ServiceOptions?
}
struct Google_Protobuf_MethodDescriptorProto {
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _name: Swift.String?
    var _inputType: Swift.String?
    var _outputType: Swift.String?
    var _options: SwiftProtobuf.Google_Protobuf_MethodOptions?
    var _clientStreaming: Swift.Bool?
    var _serverStreaming: Swift.Bool?
}
struct Google_Protobuf_FileOptions {
    enum OptimizeMode {
        case speed
        case codeSize
        case liteRuntime
    }
    class _StorageClass {
        var _javaPackage: Swift.String?
        var _javaOuterClassname: Swift.String?
        var _javaMultipleFiles: Swift.Bool?
        var _javaGenerateEqualsAndHash: Swift.Bool?
        var _javaStringCheckUtf8: Swift.Bool?
        var _optimizeFor: SwiftProtobuf.Google_Protobuf_FileOptions.OptimizeMode?
        var _goPackage: Swift.String?
        var _ccGenericServices: Swift.Bool?
        var _javaGenericServices: Swift.Bool?
        var _pyGenericServices: Swift.Bool?
        var _deprecated: Swift.Bool?
        var _ccEnableArenas: Swift.Bool?
        var _objcClassPrefix: Swift.String?
        var _csharpNamespace: Swift.String?
        var _swiftPrefix: Swift.String?
        var _phpClassPrefix: Swift.String?
        var _phpNamespace: Swift.String?
        var _phpMetadataNamespace: Swift.String?
        var _rubyPackage: Swift.String?
        var _features: SwiftProtobuf.Google_Protobuf_FeatureSet?
        var _uninterpretedOption: [SwiftProtobuf.Google_Protobuf_UninterpretedOption]
    }
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
    var _storage: SwiftProtobuf.Google_Protobuf_FileOptions._StorageClass
}
struct Google_Protobuf_MessageOptions {
    var uninterpretedOption: [SwiftProtobuf.Google_Protobuf_UninterpretedOption]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
    var _messageSetWireFormat: Swift.Bool?
    var _noStandardDescriptorAccessor: Swift.Bool?
    var _deprecated: Swift.Bool?
    var _mapEntry: Swift.Bool?
    var _deprecatedLegacyJsonFieldConflicts: Swift.Bool?
    var _features: SwiftProtobuf.Google_Protobuf_FeatureSet?
}
struct Google_Protobuf_FieldOptions {
    enum CType {
        case string
        case cord
        case stringPiece
    }
    enum JSType {
        case jsNormal
        case jsString
        case jsNumber
    }
    enum OptionRetention {
        case retentionUnknown
        case retentionRuntime
        case retentionSource
    }
    enum OptionTargetType {
        case targetTypeUnknown
        case targetTypeFile
        case targetTypeExtensionRange
        case targetTypeMessage
        case targetTypeField
        case targetTypeOneof
        case targetTypeEnum
        case targetTypeEnumEntry
        case targetTypeService
        case targetTypeMethod
    }
    struct EditionDefault {
        var unknownFields: SwiftProtobuf.UnknownStorage
        var _edition: SwiftProtobuf.Google_Protobuf_Edition?
        var _value: Swift.String?
    }
    struct FeatureSupport {
        var unknownFields: SwiftProtobuf.UnknownStorage
        var _editionIntroduced: SwiftProtobuf.Google_Protobuf_Edition?
        var _editionDeprecated: SwiftProtobuf.Google_Protobuf_Edition?
        var _deprecationWarning: Swift.String?
        var _editionRemoved: SwiftProtobuf.Google_Protobuf_Edition?
    }
    class _StorageClass {
        var _ctype: SwiftProtobuf.Google_Protobuf_FieldOptions.CType?
        var _packed: Swift.Bool?
        var _jstype: SwiftProtobuf.Google_Protobuf_FieldOptions.JSType?
        var _lazy: Swift.Bool?
        var _unverifiedLazy: Swift.Bool?
        var _deprecated: Swift.Bool?
        var _weak: Swift.Bool?
        var _debugRedact: Swift.Bool?
        var _retention: SwiftProtobuf.Google_Protobuf_FieldOptions.OptionRetention?
        var _targets: [SwiftProtobuf.Google_Protobuf_FieldOptions.OptionTargetType]
        var _editionDefaults: [SwiftProtobuf.Google_Protobuf_FieldOptions.EditionDefault]
        var _features: SwiftProtobuf.Google_Protobuf_FeatureSet?
        var _featureSupport: SwiftProtobuf.Google_Protobuf_FieldOptions.FeatureSupport?
        var _uninterpretedOption: [SwiftProtobuf.Google_Protobuf_UninterpretedOption]
    }
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
    var _storage: SwiftProtobuf.Google_Protobuf_FieldOptions._StorageClass
}
struct Google_Protobuf_OneofOptions {
    var uninterpretedOption: [SwiftProtobuf.Google_Protobuf_UninterpretedOption]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
    var _features: SwiftProtobuf.Google_Protobuf_FeatureSet?
}
struct Google_Protobuf_EnumOptions {
    var uninterpretedOption: [SwiftProtobuf.Google_Protobuf_UninterpretedOption]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
    var _allowAlias: Swift.Bool?
    var _deprecated: Swift.Bool?
    var _deprecatedLegacyJsonFieldConflicts: Swift.Bool?
    var _features: SwiftProtobuf.Google_Protobuf_FeatureSet?
}
struct Google_Protobuf_EnumValueOptions {
    var uninterpretedOption: [SwiftProtobuf.Google_Protobuf_UninterpretedOption]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
    var _deprecated: Swift.Bool?
    var _features: SwiftProtobuf.Google_Protobuf_FeatureSet?
    var _debugRedact: Swift.Bool?
    var _featureSupport: SwiftProtobuf.Google_Protobuf_FieldOptions.FeatureSupport?
}
struct Google_Protobuf_ServiceOptions {
    var uninterpretedOption: [SwiftProtobuf.Google_Protobuf_UninterpretedOption]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
    var _features: SwiftProtobuf.Google_Protobuf_FeatureSet?
    var _deprecated: Swift.Bool?
}
struct Google_Protobuf_MethodOptions {
    enum IdempotencyLevel {
        case idempotencyUnknown
        case noSideEffects
        case idempotent
    }
    var uninterpretedOption: [SwiftProtobuf.Google_Protobuf_UninterpretedOption]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
    var _deprecated: Swift.Bool?
    var _idempotencyLevel: SwiftProtobuf.Google_Protobuf_MethodOptions.IdempotencyLevel?
    var _features: SwiftProtobuf.Google_Protobuf_FeatureSet?
}
struct Google_Protobuf_UninterpretedOption {
    struct NamePart {
        var unknownFields: SwiftProtobuf.UnknownStorage
        var _namePart: Swift.String?
        var _isExtension: Swift.Bool?
    }
    var name: [SwiftProtobuf.Google_Protobuf_UninterpretedOption.NamePart]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _identifierValue: Swift.String?
    var _positiveIntValue: Swift.UInt64?
    var _negativeIntValue: Swift.Int64?
    var _doubleValue: Swift.Double?
    var _stringValue: Foundation.Data?
    var _aggregateValue: Swift.String?
}
struct Google_Protobuf_FeatureSet {
    enum FieldPresence {
        case unknown
        case explicit
        case implicit
        case legacyRequired
    }
    enum EnumType {
        case unknown
        case open
        case closed
    }
    enum RepeatedFieldEncoding {
        case unknown
        case packed
        case expanded
    }
    enum Utf8Validation {
        case unknown
        case verify
        case none
    }
    enum MessageEncoding {
        case unknown
        case lengthPrefixed
        case delimited
    }
    enum JsonFormat {
        case unknown
        case allow
        case legacyBestEffort
    }
    enum EnforceNamingStyle {
        case unknown
        case style2024
        case styleLegacy
    }
    struct VisibilityFeature {
        enum DefaultSymbolVisibility {
            case unknown
            case exportAll
            case exportTopLevel
            case localAll
            case strict
        }
        var unknownFields: SwiftProtobuf.UnknownStorage
    }
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
    var _fieldPresence: SwiftProtobuf.Google_Protobuf_FeatureSet.FieldPresence?
    var _enumType: SwiftProtobuf.Google_Protobuf_FeatureSet.EnumType?
    var _repeatedFieldEncoding: SwiftProtobuf.Google_Protobuf_FeatureSet.RepeatedFieldEncoding?
    var _utf8Validation: SwiftProtobuf.Google_Protobuf_FeatureSet.Utf8Validation?
    var _messageEncoding: SwiftProtobuf.Google_Protobuf_FeatureSet.MessageEncoding?
    var _jsonFormat: SwiftProtobuf.Google_Protobuf_FeatureSet.JsonFormat?
    var _enforceNamingStyle: SwiftProtobuf.Google_Protobuf_FeatureSet.EnforceNamingStyle?
    var _defaultSymbolVisibility: SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature.DefaultSymbolVisibility?
}
struct Google_Protobuf_FeatureSetDefaults {
    struct FeatureSetEditionDefault {
        class _StorageClass {
            var _edition: SwiftProtobuf.Google_Protobuf_Edition?
            var _overridableFeatures: SwiftProtobuf.Google_Protobuf_FeatureSet?
            var _fixedFeatures: SwiftProtobuf.Google_Protobuf_FeatureSet?
        }
        var unknownFields: SwiftProtobuf.UnknownStorage
        var _storage: SwiftProtobuf.Google_Protobuf_FeatureSetDefaults.FeatureSetEditionDefault._StorageClass
    }
    var defaults: [SwiftProtobuf.Google_Protobuf_FeatureSetDefaults.FeatureSetEditionDefault]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _minimumEdition: SwiftProtobuf.Google_Protobuf_Edition?
    var _maximumEdition: SwiftProtobuf.Google_Protobuf_Edition?
}
struct Google_Protobuf_SourceCodeInfo {
    struct Location {
        var path: [Swift.Int32]
        var span: [Swift.Int32]
        var leadingDetachedComments: [Swift.String]
        var unknownFields: SwiftProtobuf.UnknownStorage
        var _leadingComments: Swift.String?
        var _trailingComments: Swift.String?
    }
    var location: [SwiftProtobuf.Google_Protobuf_SourceCodeInfo.Location]
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _protobuf_extensionFieldValues: SwiftProtobuf.ExtensionFieldValueSet
}
struct Google_Protobuf_GeneratedCodeInfo {
    struct Annotation {
        enum Semantic {
            case none
            case set
            case alias
        }
        var path: [Swift.Int32]
        var unknownFields: SwiftProtobuf.UnknownStorage
        var _sourceFile: Swift.String?
        var _begin: Swift.Int32?
        var _end: Swift.Int32?
        var _semantic: SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation.Semantic?
    }
    var annotation: [SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation]
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_Duration {
    var seconds: Swift.Int64
    var nanos: Swift.Int32
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_Empty {
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_FieldMask {
    struct MergeOptions {
        var replaceRepeatedFields: Swift.Bool
    }
    var paths: [Swift.String]
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_SourceContext {
    var fileName: Swift.String
    var unknownFields: SwiftProtobuf.UnknownStorage
}
enum Google_Protobuf_NullValue {
    case UNRECOGNIZED(Swift.Int)
    case nullValue
}
struct Google_Protobuf_Struct {
    var fields: [Swift.String : SwiftProtobuf.Google_Protobuf_Value]
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_Value {
    enum OneOf_Kind {
        case nullValue(SwiftProtobuf.Google_Protobuf_NullValue)
        case numberValue(Swift.Double)
        case stringValue(Swift.String)
        case boolValue(Swift.Bool)
        case structValue(SwiftProtobuf.Google_Protobuf_Struct)
        case listValue(SwiftProtobuf.Google_Protobuf_ListValue)
    }
    var kind: SwiftProtobuf.Google_Protobuf_Value.OneOf_Kind?
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_ListValue {
    var values: [SwiftProtobuf.Google_Protobuf_Value]
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_Timestamp {
    var seconds: Swift.Int64
    var nanos: Swift.Int32
    var unknownFields: SwiftProtobuf.UnknownStorage
}
enum Google_Protobuf_Syntax {
    case UNRECOGNIZED(Swift.Int)
    case proto2
    case proto3
    case editions
}
struct Google_Protobuf_Type {
    var name: Swift.String
    var fields: [SwiftProtobuf.Google_Protobuf_Field]
    var oneofs: [Swift.String]
    var options: [SwiftProtobuf.Google_Protobuf_Option]
    var syntax: SwiftProtobuf.Google_Protobuf_Syntax
    var edition: Swift.String
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _sourceContext: SwiftProtobuf.Google_Protobuf_SourceContext?
}
struct Google_Protobuf_Field {
    enum Kind {
        case UNRECOGNIZED(Swift.Int)
        case typeUnknown
        case typeDouble
        case typeFloat
        case typeInt64
        case typeUint64
        case typeInt32
        case typeFixed64
        case typeFixed32
        case typeBool
        case typeString
        case typeGroup
        case typeMessage
        case typeBytes
        case typeUint32
        case typeEnum
        case typeSfixed32
        case typeSfixed64
        case typeSint32
        case typeSint64
    }
    enum Cardinality {
        case UNRECOGNIZED(Swift.Int)
        case unknown
        case optional
        case required
        case repeated
    }
    var kind: SwiftProtobuf.Google_Protobuf_Field.Kind
    var cardinality: SwiftProtobuf.Google_Protobuf_Field.Cardinality
    var number: Swift.Int32
    var name: Swift.String
    var typeURL: Swift.String
    var oneofIndex: Swift.Int32
    var packed: Swift.Bool
    var options: [SwiftProtobuf.Google_Protobuf_Option]
    var jsonName: Swift.String
    var defaultValue: Swift.String
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_Enum {
    var name: Swift.String
    var enumvalue: [SwiftProtobuf.Google_Protobuf_EnumValue]
    var options: [SwiftProtobuf.Google_Protobuf_Option]
    var syntax: SwiftProtobuf.Google_Protobuf_Syntax
    var edition: Swift.String
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _sourceContext: SwiftProtobuf.Google_Protobuf_SourceContext?
}
struct Google_Protobuf_EnumValue {
    var name: Swift.String
    var number: Swift.Int32
    var options: [SwiftProtobuf.Google_Protobuf_Option]
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_Option {
    var name: Swift.String
    var unknownFields: SwiftProtobuf.UnknownStorage
    var _value: SwiftProtobuf.Google_Protobuf_Any?
}
struct Google_Protobuf_DoubleValue {
    var value: Swift.Double
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_FloatValue {
    var value: Swift.Float
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_Int64Value {
    var value: Swift.Int64
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_UInt64Value {
    var value: Swift.UInt64
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_Int32Value {
    var value: Swift.Int32
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_UInt32Value {
    var value: Swift.UInt32
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_BoolValue {
    var value: Swift.Bool
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_StringValue {
    var value: Swift.String
    var unknownFields: SwiftProtobuf.UnknownStorage
}
struct Google_Protobuf_BytesValue {
    var value: Foundation.Data
    var unknownFields: SwiftProtobuf.UnknownStorage
}
class BundleFinder {}
struct Configuration {
    enum JournalModeConfiguration {
        case default
        case wal
    }
    var foreignKeysEnabled: Swift.Bool
    var readonly: Swift.Bool
    var label: Swift.String?
    var acceptsDoubleQuotedStringLiterals: Swift.Bool
    var observesSuspensionNotifications: Swift.Bool
    var publicStatementArguments: Swift.Bool
    var transactionClock: GRDB.TransactionClock
    var setups: 
    var allowsUnsafeTransactions: Swift.Bool
    var journalMode: GRDB.Configuration.JournalModeConfiguration
    var busyMode: GRDB.Database.BusyMode
    var readonlyBusyMode: GRDB.Database.BusyMode?
    var maximumReaderCount: Swift.Int
    var qos: Dispatch.DispatchQoS
    var targetQueue: __C.OS_dispatch_queue?
    var writeTargetQueue: __C.OS_dispatch_queue?
    var persistentReadOnlyConnections: Swift.Bool
    var threadingMode: GRDB.Database.ThreadingMode
    var SQLiteConnectionDidOpen: 
    var SQLiteConnectionWillClose: 
    var SQLiteConnectionDidClose: 
}
class AnyCursor<A> {
    let _next: () throws -> A?
    let _forEach: (_: (_: A) throws -> ()) throws -> ()
}
class DropFirstCursor<A> where A: GRDB.Cursor {
    let base: A
    let limit: Swift.Int
    var dropped: Swift.Int
}
class DropWhileCursor<A> where A: GRDB.Cursor {
    let base: A
    let predicate: (_: A.Cursor.Element) throws -> Swift.Bool
    var predicateHasFailed: Swift.Bool
}
class EnumeratedCursor<A> where A: GRDB.Cursor {
    let base: A
    var index: Swift.Int
}
class FilterCursor<A> where A: GRDB.Cursor {
    let base: A
    let isIncluded: (_: A.Cursor.Element) throws -> Swift.Bool
}
class FlattenCursor<A> where A: GRDB.Cursor, A.Cursor.Element: GRDB.Cursor {
    let base: A
    var inner: A.Cursor.Element?
}
class MapCursor<A, B> where A: GRDB.Cursor {
    let base: A
    let transform: (_: A.Cursor.Element) throws -> B
}
class PrefixCursor<A> where A: GRDB.Cursor {
    let base: A
    let maxLength: Swift.Int
    var taken: Swift.Int
}
class PrefixWhileCursor<A> where A: GRDB.Cursor {
    let base: A
    let predicate: (_: A.Cursor.Element) throws -> Swift.Bool
    var predicateHasFailed: Swift.Bool
}
struct ColumnInfo {
    let cid: Swift.Int
    let hidden: Swift.Int?
    let name: Swift.String
    let type: Swift.String
    let isNotNull: Swift.Bool
    let defaultValueSQL: Swift.String?
    let primaryKeyIndex: Swift.Int
}
struct IndexInfo {
    struct Origin {
        var rawValue: Swift.String
    }
    let name: Swift.String
    let columns: [Swift.String]
    let isUnique: Swift.Bool
    let origin: GRDB.IndexInfo.Origin
}
struct ForeignKeyViolation {
    var originTable: Swift.String
    var originRowID: Swift.Int64?
    var destinationTable: Swift.String
    var foreignKeyId: Swift.Int
}
struct PrimaryKeyInfo {
    enum Impl {
        case rowID(GRDB.ColumnInfo)
        case regular(columnInfos: [GRDB.ColumnInfo], tableHasRowID: Swift.Bool)
        case hiddenRowID
    }
    let impl: GRDB.PrimaryKeyInfo.Impl
}
struct ForeignKeyInfo {
    var id: Swift.Int
    let destinationTable: Swift.String
    let mapping: [(origin: Swift.String, destination: Swift.String)]
}
struct SchemaInfo {
    let objects: Swift.Set<GRDB.SchemaObject>
}
struct TableInfo {
    struct Kind {
        var rawValue: Swift.String
    }
    var schemaID: GRDB.Database.SchemaIdentifier
    var name: Swift.String
    var kind: GRDB.TableInfo.Kind
    var columnCount: Swift.Int
    var hasRowID: Swift.Bool
    var strict: Swift.Bool
}
struct SchemaObjectType {
    var rawValue: Swift.String
}
struct SchemaObject {
    var type: GRDB.SchemaObjectType
    var name: Swift.String
    var tbl_name: Swift.String?
    var sql: Swift.String?
}
class SQLStatementCursor {
    let database: GRDB.Database
    let cString: Swift.ContiguousArray<Swift.Int8>
    let prepFlags: Swift.UInt32
    let initialArgumentCount: Swift.Int?
    var offset: Swift.Int
    var arguments: GRDB.StatementArguments?
}
struct StatementCache {
    let db: 
    var statements: [Swift.String : GRDB.Statement]
}
class Database {
    struct SchemaCache {
        var schemaIdentifiers: [GRDB.Database.SchemaIdentifier]?
        var schemas: [GRDB.Database.SchemaIdentifier : GRDB.DatabaseSchemaCache]
    }
    enum SchemaIdentifier {
        case attached(Swift.String)
        case main
        case temp
    }
    enum BusyMode {
        case timeout(Swift.Double)
        case callback()
        case immediateError
    }
    enum CheckpointMode {
        case passive
        case full
        case restart
        case truncate
    }
    struct CollationName {
        let rawValue: Swift.String
    }
    struct ColumnType {
        let rawValue: Swift.String
    }
    enum ConflictResolution {
        case rollback
        case abort
        case fail
        case ignore
        case replace
    }
    enum ForeignKeyAction {
        case cascade
        case restrict
        case setNull
        case setDefault
    }
    struct StorageClass {
        let rawValue: Swift.String
    }
    struct TracingOptions {
        let rawValue: Swift.Int32
    }
    enum TraceEvent {
        struct Statement {
            var sqliteStatement: Swift.OpaquePointer
            var unexpandedSQL: Swift.UnsafePointer<Swift.Int8>?
            var sqlite3_expanded_sql: @convention(c) (_: Swift.OpaquePointer?) -> Swift.UnsafeMutablePointer<Swift.Int8>?
            var publicStatementArguments: Swift.Bool
        }
        case statement(GRDB.Database.TraceEvent.Statement)
        case profile(statement: GRDB.Database.TraceEvent.Statement, duration: Swift.Double)
    }
    enum TransactionCompletion {
        case commit
        case rollback
    }
    enum TransactionKind {
        case deferred
        case immediate
        case exclusive
    }
    enum AutocommitState {
        case off
        case on
    }
    enum ThreadingMode {
        case default
        case multiThread
        case serialized
    }
    struct Suspension {
        var isSuspended: Swift.Bool
        var isCancelled: Swift.Bool
        var interruptsWhenCancelled: Swift.Bool
    }
    enum TransactionObservationExtent {
        case observerLifetime
        case nextTransaction
        case databaseLifetime
    }
    class TransactionHandler {
        let onCommit: 
        let onRollback: 
    }
    class FTS5TokenizerConstructor {
        let db: GRDB.Database
        let constructor: (GRDB.Database, [Swift.String], Swift.UnsafeMutablePointer<Swift.OpaquePointer?>?) -> Swift.Int32
    }
    class FTS5RegisteredTokenizer {
        let xTokenizer: __C.fts5_tokenizer
        let tokenizerPointer: Swift.OpaquePointer
    }
    var sqliteConnection: Swift.OpaquePointer?
    let configuration: GRDB.Configuration
    let description: Swift.String
    let path: Swift.String
    var lastSchemaVersion: Swift.Int32?
    var schemaCache: GRDB.Database.SchemaCache
    lazy var internalStatementCache: GRDB.StatementCache?
    lazy var publicStatementCache: GRDB.StatementCache?
    lazy var authorizer: GRDB.StatementAuthorizer?
    var observationBroker: GRDB.DatabaseObservationBroker?
    var isRecordingSelectedRegion: Swift.Bool
    var selectedRegion: GRDB.DatabaseRegion
    var journalModeCache: Swift.String?
    let suspensionMutex: GRDB.Mutex<GRDB.Database.Suspension>
    var isInsideTransactionBlock: Swift.Bool
    var autocommitState: GRDB.Database.AutocommitState
    var transactionDateResult: Swift.Result<Foundation.Date, Swift.Error>?
    var busyCallback: 
    var trace: ((_: GRDB.Database.TraceEvent) -> ())?
    var functions: [GRDB.DatabaseFunction.ID : GRDB.DatabaseFunction]
    var collations: [GRDB.DatabaseCollation.ID : GRDB.DatabaseCollation]
    var readOnlyDepth: Swift.Int
}
struct DatabaseBackupProgress {
    let remainingPageCount: Swift.Int
    let totalPageCount: Swift.Int
    let isCompleted: Swift.Bool
}
class DatabaseCollation {
    struct ID {
        var name: Swift.String
    }
    let name: Swift.String
    let function: 
}
struct ResultCode {
    let rawValue: Swift.Int32
}
struct DatabaseError {
    let extendedResultCode: GRDB.ResultCode
    let message: Swift.String?
    let sql: Swift.String?
    let arguments: GRDB.StatementArguments?
    var publicStatementArguments: Swift.Bool
}
class DatabaseFunction {
    struct ID {
        let name: Swift.String
        let nArg: Swift.Int32
    }
    class FunctionDefinition {
        let compute: (Swift.Int32, Swift.UnsafeMutablePointer<Swift.OpaquePointer?>?) throws -> GRDB.DatabaseValueConvertible?
    }
    class AggregateDefinition {
        let makeAggregate: () -> GRDB.DatabaseAggregate
    }
    class AggregateContext {
        var aggregate: GRDB.DatabaseAggregate
        var hasErrored: Swift.Bool
    }
    enum Kind {
        case function()
        case aggregate()
    }
    let id: GRDB.DatabaseFunction.ID
    let isPure: Swift.Bool
    let kind: GRDB.DatabaseFunction.Kind
}
class DatabasePool {
    let writer: GRDB.SerializedDatabase
    var readerPool: GRDB.Pool<GRDB.SerializedDatabase>?
    let databaseSnapshotCountMutex: GRDB.Mutex<Swift.Int>
    var suspensionObservers: [__C.NSObject]
}
enum DatabasePublishers {
    struct Read<A> {
        let upstream: Combine.AnyPublisher<A, Swift.Error>
    }
    struct DatabaseRegion {
        let writer: GRDB.DatabaseWriter
        let observation: GRDB.DatabaseRegionObservation
    }
    class DatabaseRegionSubscription<A> where A: Combine.Subscriber, A.Subscriber.Failure == Swift.Error, A.Subscriber.Input == GRDB.Database {
        enum State {
            case waitingForDemand(GRDB.DatabasePublishers.DatabaseRegionSubscription<A>.WaitingForDemand)
            case observing(GRDB.DatabasePublishers.DatabaseRegionSubscription<A>.Observing)
            case finished
        }
        struct Observing {
            let downstream: A
            let writer: GRDB.DatabaseWriter
            var remainingDemand: Combine.Subscribers.Demand
        }
        struct WaitingForDemand {
            let downstream: A
            let writer: GRDB.DatabaseWriter
            let observation: GRDB.DatabaseRegionObservation
        }
        var cancellable: GRDB.AnyDatabaseCancellable?
        var state: GRDB.DatabasePublishers.DatabaseRegionSubscription<A>.State
        var lock: __C.NSRecursiveLock
    }
    struct Write<A> {
        let upstream: Combine.AnyPublisher<A, Swift.Error>
    }
    struct Migrate {
        let upstream: Combine.AnyPublisher<(), Swift.Error>
    }
    struct Value<A> {
        let start: 
    }
    class ValueSubscription<A> where A: Combine.Subscriber, A.Subscriber.Failure == Swift.Error {
        enum State {
            case waitingForDemand(GRDB.DatabasePublishers.ValueSubscription<A>.WaitingForDemand)
            case observing(GRDB.DatabasePublishers.ValueSubscription<A>.Observing)
            case finished
        }
        struct Observing {
            let downstream: A
            var remainingDemand: Combine.Subscribers.Demand
        }
        struct WaitingForDemand {
            let downstream: A
            let start: 
        }
        var cancellable: GRDB.AnyDatabaseCancellable?
        var state: GRDB.DatabasePublishers.ValueSubscription<A>.State
        var lock: __C.NSRecursiveLock
    }
}
class DatabaseQueue {
    let writer: GRDB.SerializedDatabase
    var suspensionObservers: [__C.NSObject]
}
class AnyDatabaseReader {
    let base: GRDB.DatabaseReader
}
struct DatabaseRegion {
    let tableRegions: [GRDB.CaseInsensitiveIdentifier : GRDB.TableRegion]?
}
struct AnyDatabaseRegionConvertible {
    let _region: 
}
struct TableRegion {
    var columns: Swift.Set<GRDB.CaseInsensitiveIdentifier>?
    var rowIds: Swift.Set<Swift.Int64>?
}
struct DatabaseRegionObservation {
    enum ObservationState {
        case started(GRDB.StrongReference<GRDB.DatabaseRegionObserver>)
        case cancelled
        case pending
    }
    var observedRegion: 
}
class DatabaseRegionObserver {
    let region: GRDB.DatabaseRegion
    let onChange: 
    var isChanged: Swift.Bool
}
struct DatabaseSchemaCache {
    enum Presence<A> {
        case value(A)
        case missing
    }
    var schemaInfo: GRDB.SchemaInfo?
    var tables: [Swift.String : GRDB.DatabaseSchemaCache.Presence<GRDB.TableInfo>]
    var primaryKeys: [Swift.String : GRDB.DatabaseSchemaCache.Presence<GRDB.PrimaryKeyInfo>]
    var columns: [Swift.String : GRDB.DatabaseSchemaCache.Presence<[GRDB.ColumnInfo]>]
    var indexes: [Swift.String : GRDB.DatabaseSchemaCache.Presence<[GRDB.IndexInfo]>]
    var foreignKeys: [Swift.String : GRDB.DatabaseSchemaCache.Presence<[GRDB.ForeignKeyInfo]>]
}
class DatabaseSnapshot {
    let reader: GRDB.SerializedDatabase
}
class DatabaseSnapshotPool {
    let configuration: GRDB.Configuration
    let path: Swift.String
    var readerPool: GRDB.Pool<GRDB.SerializedDatabase>?
    let walSnapshot: GRDB.WALSnapshot
    let snapshotHolder: GRDB.DatabaseQueue
}
struct DatabaseValue {
    enum Storage {
        case int64(Swift.Int64)
        case double(Swift.Double)
        case string(Swift.String)
        case blob(Foundation.Data)
        case null
    }
    let storage: GRDB.DatabaseValue.Storage
}
class DatabaseValueCursor<A> where A: GRDB.DatabaseValueConvertible {
    let _statement: GRDB.Statement
    var _isDone: Swift.Bool
    let columnIndex: Swift.Int32
}
class AnyDatabaseWriter {
    let base: GRDB.DatabaseWriter
}
struct PreparedRequest {
    var statement: GRDB.Statement
    var adapter: GRDB.RowAdapter?
    var supplementaryFetch: ((GRDB.Database, [GRDB.Row], ((GRDB.AnyFetchRequest<GRDB.Row>, [Swift.String]) throws -> ())?) throws -> ())?
}
struct AdaptedFetchRequest<A> where A: GRDB.FetchRequest {
    let base: A
    let adapter: 
}
struct AnyFetchRequest<A> {
    let request: GRDB.FetchRequestEraser
}
class FetchRequestEraser {}
class ConcreteFetchRequestEraser<A>: GRDB.FetchRequestEraser where A: GRDB.FetchRequest {
    let request: A
}
class Row {
    struct Index {
        let index: Swift.Int
    }
    struct ScopesView {
        let row: GRDB.Row
        let scopes: [Swift.String : GRDB._LayoutedRowAdapter]
        let prefetchedRows: GRDB.Row.PrefetchedRowsView
    }
    struct ScopesTreeView {
        let scopes: GRDB.Row.ScopesView
    }
    struct PrefetchedRowsView {
        var prefetches: GRDB.OrderedDictionary<Swift.String, GRDB.Row.Prefetch>
    }
    struct Prefetch {
        var rows: [GRDB.Row]?
        var prefetches: GRDB.OrderedDictionary<Swift.String, GRDB.Row.Prefetch>
    }
    let impl: GRDB.RowImpl
    let statement: GRDB.Statement?
    let sqliteStatement: Swift.OpaquePointer?
    let count: Swift.Int
    var prefetchedRows: GRDB.Row.PrefetchedRowsView
}
class RowCursor {
    let _statement: GRDB.Statement
    var _isDone: Swift.Bool
    let _row: GRDB.Row
}
struct ArrayRowImpl {
    let columns: [(Swift.String, GRDB.DatabaseValue)]
}
struct EmptyRowImpl {}
struct StatementCopyRowImpl {
    let dbValues: Swift.ContiguousArray<GRDB.DatabaseValue>
    let columnNames: [Swift.String]
}
struct StatementRowImpl {
    let statement: GRDB.Statement
    let sqliteStatement: Swift.OpaquePointer
    let lowercaseColumnIndexes: [Swift.String : Swift.Int]
}
struct _LayoutedColumnMapping {
    let _layoutColumns: [(Swift.Int, Swift.String)]
    let lowercaseColumnIndexes: [Swift.String : Swift.Int]
}
struct EmptyRowAdapter {}
struct ColumnMapping {
    let mapping: [Swift.String : Swift.String]
}
struct SuffixRowAdapter {
    let index: Swift.Int
}
struct RangeRowAdapter {
    let range: Swift.Range<Swift.Int>
}
struct ScopeAdapter {
    let base: GRDB.RowAdapter
    let scopes: [Swift.String : GRDB.RowAdapter]
}
struct RenameColumnAdapter {
    let transform: 
}
struct LayoutedScopeAdapter {
    let _mapping: GRDB._LayoutedColumnMapping
    let _scopes: [Swift.String : GRDB._LayoutedRowAdapter]
}
struct ChainedAdapter {
    let first: GRDB.RowAdapter
    let second: GRDB.RowAdapter
}
struct AdaptedRowImpl {
    let base: GRDB.Row
    let adapter: GRDB._LayoutedRowAdapter
    let mapping: GRDB._LayoutedColumnMapping
}
enum RowKey {
    case columnName(Swift.String)
    case columnIndex(Swift.Int)
    case scope(Swift.String)
    case prefetchKey(Swift.String)
}
enum RowDecodingError {
    struct Context {
        let debugDescription: Swift.String
        let rowImpl: GRDB.ArrayRowImpl
        let key: GRDB.RowKey?
        let sql: Swift.String?
        let statementArguments: GRDB.StatementArguments?
    }
    case keyNotFound(GRDB.RowKey, GRDB.RowDecodingError.Context)
    case valueMismatch(Any.Type, GRDB.RowDecodingError.Context)
}
struct RowDecodingContext {
    let row: GRDB.Row
    let key: GRDB.RowKey?
    let sql: Swift.String?
    let statementArguments: GRDB.StatementArguments?
}
struct SQL {
    enum Element {
        case sql(Swift.String, GRDB.StatementArguments)
        case subquery(GRDB.SQLSubquery)
        case expression(GRDB.SQLExpression)
        case selection(GRDB.SQLSelection)
        case ordering(GRDB.SQLOrdering)
    }
    var elements: [GRDB.SQL.Element]
}
struct SQLInterpolation {
    var elements: [GRDB.SQL.Element]
}
struct SQLRequest<A> {
    enum Cache {
        case public
        case internal
    }
    var adapter: GRDB.RowAdapter?
    var sqlLiteral: GRDB.SQL
    let cache: GRDB.SQLRequest<A>.Cache?
}
class SchedulingWatchdog {
    var allowedDatabases: [GRDB.Database]
    var databaseObservationBroker: GRDB.DatabaseObservationBroker?
}
class SerializedDatabase {
    let db: GRDB.Database
    let path: Swift.String
    let queue: __C.OS_dispatch_queue
    var allowsUnsafeTransactions: Swift.Bool
}
enum DatabaseAccessCancellationState {
    case connected(GRDB.Database)
    case notConnected
    case cancelled
    case expired
}
class Statement {
    enum TransactionEffect {
        case beginSavepoint(Swift.String)
        case releaseSavepoint(Swift.String)
        case rollbackSavepoint(Swift.String)
        case beginTransaction
        case commitTransaction
        case rollbackTransaction
    }
    let sqliteStatement: Swift.OpaquePointer
    lazy var columnNames: [Swift.String]?
    var databaseRegion: GRDB.DatabaseRegion
    var invalidatesDatabaseSchemaCache: Swift.Bool
    var transactionEffect: GRDB.Statement.TransactionEffect?
    var authorizerEventKinds: [GRDB.DatabaseEventKind]
    var isQueryOnlyPragma: Swift.Bool
    let database: 
    lazy var columnIndexes: [Swift.String : Swift.Int]?
    var argumentsAreValidAndBound: Swift.Bool
    var _arguments: GRDB.StatementArguments
    lazy var sqliteArgumentCount: Swift.Int?
    lazy var sqliteArgumentNames: [Swift.String?]?
}
class StatementCursor {
    let _statement: GRDB.Statement
    var _isDone: Swift.Bool
}
struct StatementArguments {
    var values: [GRDB.DatabaseValue]
    var namedValues: [Swift.String : GRDB.DatabaseValue]
}
class StatementAuthorizer {
    var database: 
    var selectedRegion: GRDB.DatabaseRegion
    var databaseEventKinds: [GRDB.DatabaseEventKind]
    var invalidatesDatabaseSchemaCache: Swift.Bool
    var transactionEffect: GRDB.Statement.TransactionEffect?
    var isQueryOnlyPragma: Swift.Bool
    var isDropStatement: Swift.Bool
}
class FastDatabaseValueCursor<A> where A: GRDB.DatabaseValueConvertible, A: GRDB.StatementColumnConvertible {
    let _statement: GRDB.Statement
    var _isDone: Swift.Bool
    let columnIndex: Swift.Int32
}
struct DatabaseDateComponents {
    enum Format {
        case YMD
        case YMD_HM
        case YMD_HMS
        case YMD_HMSS
        case HM
        case HMS
        case HMSS
    }
    let dateComponents: Foundation.DateComponents
    let format: GRDB.DatabaseDateComponents.Format
}
struct SQLiteDateParser {}
struct DatabaseValueDecoder {
    let dbValue: GRDB.DatabaseValue
    let codingPath: [Swift.CodingKey]
}
struct DatabaseValueDecodingContainer {
    let dbValue: GRDB.DatabaseValue
    let codingPath: [Swift.CodingKey]
}
class DatabaseValueEncoder {
    let encode: (_: GRDB.DatabaseValue) -> ()
    let jsonEncoder: Foundation.JSONEncoder
    var requiresJSON: Swift.Bool
    var userInfo: [Swift.CodingUserInfoKey : Any]
}
struct DatabaseValueEncodingContainer {
    let encode: (_: GRDB.DatabaseValue) -> ()
    let jsonEncoder: Foundation.JSONEncoder
}
struct JSONRequiredError {}
struct JSONRequiredEncoder {
    struct KeyedContainer<A> where A: Swift.CodingKey {
        var codingPath: [Swift.CodingKey]
    }
    var codingPath: [Swift.CodingKey]
}
struct DefaultTransactionClock {}
struct CustomTransactionClock {
    let _now: 
}
class DatabaseObservationBroker {
    enum TransactionCompletion {
        case cancelledCommit(Swift.Error)
        case none
        case commit
        case rollback
    }
    let database: 
    let savepointStack: GRDB.SavepointStack
    var transactionCompletion: GRDB.DatabaseObservationBroker.TransactionCompletion
    var transactionObservations: [GRDB.TransactionObservation]
    var statementObservations: [GRDB.StatementObservation]
}
class TransactionObservation {
    let extent: GRDB.Database.TransactionObservationExtent
    var isEnabled: Swift.Bool
    weak var weakObserver: GRDB.TransactionObserver?
    var strongObserver: GRDB.TransactionObserver?
}
enum DatabaseEventKind {
    case insert(tableName: Swift.String)
    case delete(tableName: Swift.String)
    case update(tableName: Swift.String, columnNames: Swift.Set<Swift.String>)
}
struct DatabaseEvent {
    enum Kind {
        case insert
        case delete
        case update
    }
    let impl: GRDB.DatabaseEventImpl
    let kind: GRDB.DatabaseEvent.Kind
    let rowID: Swift.Int64
}
class SavepointStack {
    var eventsBuffer: [(event: GRDB.DatabaseEventProtocol, statementObservations: [GRDB.StatementObservation])]
    var savepoints: [(name: Swift.String, index: Swift.Int)]
}
struct StatementObservation {
    var transactionObservation: GRDB.TransactionObservation
    var tracksEvent: GRDB.DatabaseEventPredicate
}
struct MetalDatabaseEventImpl {
    let databaseNameCString: Swift.UnsafePointer<Swift.Int8>?
    let tableNameCString: Swift.UnsafePointer<Swift.Int8>?
}
enum DatabaseEventPredicate {
    case matching(observedEventKinds: [GRDB.DatabaseEventKind], authorizerEventKinds: [GRDB.DatabaseEventKind])
    case all
}
struct CopiedDatabaseEventImpl {
    let databaseName: Swift.String
    let tableName: Swift.String
}
class WALSnapshot {
    let sqliteSnapshot: Swift.UnsafeMutablePointer<__C.sqlite3_snapshot>
}
class WALSnapshotTransaction {
    struct DatabaseAccess {
        let reader: GRDB.SerializedDatabase
        let release: 
    }
    let databaseAccessMutex: GRDB.Mutex<GRDB.WALSnapshotTransaction.DatabaseAccess?>
    let walSnapshot: GRDB.WALSnapshot
}
enum DumpTableHeaderOptions {
    case automatic
    case always
}
struct DumpStream {
    var base: Swift.TextOutputStream
    var needsMarginLine: Swift.Bool
}
struct StandardOutputStream {}
struct DebugDumpFormat {
    var header: Swift.Bool
    var separator: Swift.String
    var nullValue: Swift.String
    var firstRow: Swift.Bool
}
struct JSONDumpFormat {
    var encoder: Foundation.JSONEncoder
    var firstRow: Swift.Bool
}
struct LineDumpFormat {
    var nullValue: Swift.String
    var firstRow: Swift.Bool
}
struct ListDumpFormat {
    var header: Swift.Bool
    var separator: Swift.String
    var nullValue: Swift.String
    var firstRow: Swift.Bool
}
struct QuoteDumpFormat {
    var header: Swift.Bool
    var separator: Swift.String
    var firstRow: Swift.Bool
}
struct FTS3 {
    enum Diacritics {
        case keep
        case removeLegacy
        case remove
    }
}
class FTS3TableDefinition {
    var columns: [Swift.String]
    var tokenizer: GRDB.FTS3TokenizerDescriptor?
}
struct FTS3Pattern {
    let rawPattern: Swift.String
}
struct FTS3TokenizerDescriptor {
    let name: Swift.String
    let arguments: [Swift.String]
}
struct FTS4 {}
class FTS4TableDefinition {
    enum ContentMode {
        case raw(content: Swift.String?)
        case synchronized(contentTable: Swift.String)
    }
    let configuration: GRDB.VirtualTableConfiguration
    var columns: [GRDB.FTS4ColumnDefinition]
    var contentMode: GRDB.FTS4TableDefinition.ContentMode
    var tokenizer: GRDB.FTS3TokenizerDescriptor?
    var compress: Swift.String?
    var uncompress: Swift.String?
    var matchinfo: Swift.String?
    var prefixes: Swift.Set<Swift.Int>?
}
class FTS4ColumnDefinition {
    let name: Swift.String
    var isIndexed: Swift.Bool
    var isLanguageId: Swift.Bool
}
struct FTS5 {
    enum Diacritics {
        case keep
        case removeLegacy
        case remove
    }
}
class FTS5TableDefinition {
    enum ContentMode {
        case raw(content: Swift.String?, contentRowID: Swift.String?)
        case synchronized(contentTable: Swift.String)
    }
    let configuration: GRDB.VirtualTableConfiguration
    var columns: [GRDB.FTS5ColumnDefinition]
    var contentMode: GRDB.FTS5TableDefinition.ContentMode
    var tokenizer: GRDB.FTS5TokenizerDescriptor?
    var prefixes: Swift.Set<Swift.Int>?
    var columnSize: Swift.Int?
    var detail: Swift.String?
}
class FTS5ColumnDefinition {
    let name: Swift.String
    var isIndexed: Swift.Bool
}
struct FTS5Pattern {
    let rawPattern: Swift.String
}
struct FTS5Tokenization {
    let rawValue: Swift.Int32
}
class TokenizeContext {
    var tokens: [(Swift.String, GRDB.FTS5TokenFlags)]
}
struct FTS5TokenizerDescriptor {
    let components: [Swift.String]
}
struct FTS5TokenFlags {
    let rawValue: Swift.Int32
}
class DatabaseFuture<A> {}
struct JSONColumn {
    var name: Swift.String
}
struct AnySQLJSONExpressible {
    let sqlExpression: GRDB.SQLExpression
}
struct DatabaseMigrator {
    enum ForeignKeyChecks {
        case deferred
        case immediate
    }
    var eraseDatabaseOnSchemaChange: Swift.Bool
    var defersForeignKeyChecks: Swift.Bool
    var _migrations: [GRDB.Migration]
}
struct Migration {
    enum ForeignKeyChecks {
        case deferred
        case immediate
        case disabled
    }
    let identifier: Swift.String
    var foreignKeyChecks: GRDB.Migration.ForeignKeyChecks
    let migrate: 
}
struct ForeignKey {
    var originColumns: [Swift.String]
    var destinationColumns: [Swift.String]?
}
struct AssociationAggregate<A> {
    let preparation: GRDB.AssociationAggregatePreparation<A>
    var key: Swift.String?
}
class AssociationAggregatePreparation<A> {}
class BasePreparation<A>: GRDB.AssociationAggregatePreparation<A.Association.OriginRowDecoder> where A: GRDB.AssociationToMany {
    let association: A
    let expression: GRDB.SQLExpression
}
class MapPreparation<A>: GRDB.AssociationAggregatePreparation<A> {
    let base: GRDB.AssociationAggregatePreparation<A>
    let transform: (_: GRDB.SQLExpression) -> GRDB.SQLExpression
}
class CombinePreparation<A>: GRDB.AssociationAggregatePreparation<A> {
    let lhs: GRDB.AssociationAggregatePreparation<A>
    let rhs: GRDB.AssociationAggregatePreparation<A>
    let combine: (GRDB.SQLExpression, GRDB.SQLExpression) -> GRDB.SQLExpression
}
struct BelongsToAssociation<A, B> {
    var _sqlAssociation: GRDB._SQLAssociation
}
struct HasManyAssociation<A, B> {
    var _sqlAssociation: GRDB._SQLAssociation
}
struct HasManyThroughAssociation<A, B> {
    var _sqlAssociation: GRDB._SQLAssociation
}
struct HasOneAssociation<A, B> {
    var _sqlAssociation: GRDB._SQLAssociation
}
struct HasOneThroughAssociation<A, B> {
    var _sqlAssociation: GRDB._SQLAssociation
}
struct JoinAssociation<A, B> {
    var _sqlAssociation: GRDB._SQLAssociation
}
struct CommonTableExpression<A> {
    var cte: GRDB.SQLCTE
}
struct SQLCTE {
    var tableName: Swift.String
    var columns: [Swift.String]?
    var sqlSubquery: GRDB.SQLSubquery
    var isRecursive: Swift.Bool
}
struct QueryInterfaceRequest<A> {
    var relation: GRDB.SQLRelation
}
struct ColumnAssignment {
    var columnName: Swift.String
    var value: GRDB.SQLExpression?
}
struct Column {
    var name: Swift.String
}
struct DatabasePromise<A> {
    let resolve: 
}
struct _SQLAssociation {
    var steps: [GRDB.SQLAssociationStep]
}
struct SQLAssociationStep {
    var key: GRDB.SQLAssociationKey
    var condition: GRDB.SQLAssociationCondition
    var relation: GRDB.SQLRelation
    var cardinality: GRDB.SQLAssociationCardinality
}
enum SQLAssociationCardinality {
    case toOne
    case toMany
}
enum SQLAssociationKey {
    case inflected(Swift.String)
    case fixedSingular(Swift.String)
    case fixedPlural(Swift.String)
    case fixed(Swift.String)
}
struct SQLCollection {
    enum Impl {
        case array([GRDB.SQLExpression])
        case subquery(GRDB.SQLSubquery)
        case table(Swift.String)
    }
    var impl: GRDB.SQLCollection.Impl
}
struct SQLExpression {
    struct AssociativeBinaryOperator {
        let sql: Swift.String
        let neutralValue: GRDB.DatabaseValue
        let isStrictlyAssociative: Swift.Bool
        let isBijective: Swift.Bool
    }
    enum JSONInterpretation {
        case deferredToSQLite
        case jsonValue
    }
    enum Impl {
        case column(Swift.String)
        case qualifiedColumn(Swift.String, GRDB.TableAliasBase)
        case databaseValue(GRDB.DatabaseValue)
        case rowValue([GRDB.SQLExpression])
        case subquery(GRDB.SQLSubquery)
        case literal(GRDB.SQL)
        indirect case cast(GRDB.SQLExpression, GRDB.Database.StorageClass)
        indirect case between(expression: GRDB.SQLExpression, lowerBound: GRDB.SQLExpression, upperBound: GRDB.SQLExpression, isNegated: Swift.Bool)
        indirect case binary(GRDB.SQLExpression.BinaryOperator, GRDB.SQLExpression, GRDB.SQLExpression)
        indirect case escapableBinary(GRDB.SQLExpression.EscapableBinaryOperator, GRDB.SQLExpression, GRDB.SQLExpression, escape: GRDB.SQLExpression?)
        case associativeBinary(GRDB.SQLExpression.AssociativeBinaryOperator, [GRDB.SQLExpression])
        case exists(GRDB.SQLSubquery, isNegated: Swift.Bool)
        indirect case in(GRDB.SQLExpression, GRDB.SQLCollection, isNegated: Swift.Bool)
        indirect case unary(GRDB.SQLExpression.UnaryOperator, GRDB.SQLExpression)
        indirect case compare(GRDB.SQLExpression.EqualityOperator, GRDB.SQLExpression, GRDB.SQLExpression)
        indirect case tableMatch(GRDB.TableAliasBase, GRDB.SQLExpression)
        indirect case not(GRDB.SQLExpression)
        indirect case collated(GRDB.SQLExpression, GRDB.Database.CollationName)
        indirect case simpleFunction(GRDB.SQLSimpleFunctionInvocation)
        indirect case aggregateFunction(GRDB.SQLAggregateFunctionInvocation)
        indirect case isEmpty(GRDB.SQLExpression, isNegated: Swift.Bool)
        case qualifiedFastPrimaryKey(GRDB.TableAliasBase)
        case qualifiedExists(GRDB.TableAliasBase, isNegated: Swift.Bool)
        case countAll
        case fastPrimaryKey
    }
    enum EqualityOperator {
        case equal
        case notEqual
        case is
        case isNot
    }
    struct UnaryOperator {
        let sql: Swift.String
    }
    struct EscapableBinaryOperator {
        let sql: Swift.String
        let negatedSQL: Swift.String
    }
    struct BinaryOperator {
        let sql: Swift.String
        let isJSONValue: Swift.Bool
    }
    var impl: GRDB.SQLExpression.Impl
    var preferredJSONInterpretation: GRDB.SQLExpression.JSONInterpretation
}
struct SQLAggregateFunctionInvocation {
    var name: Swift.String
    var arguments: [GRDB.SQLExpression]
    var isDistinct: Swift.Bool
    var ordering: GRDB.SQLOrdering?
    var filter: GRDB.SQLExpression?
    var isJSONValue: Swift.Bool
}
struct SQLSimpleFunctionInvocation {
    var name: Swift.String
    var arguments: [GRDB.SQLExpression]
    var isPure: Swift.Bool
    var isJSONValue: Swift.Bool
}
enum SQLDateModifier {
    case second(Swift.Double)
    case minute(Swift.Int)
    case hour(Swift.Int)
    case day(Swift.Int)
    case month(Swift.Int)
    case year(Swift.Int)
    case weekday(Swift.Int)
    case startOfDay
    case startOfMonth
    case startOfYear
    case unixEpoch
    case localTime
    case utc
}
struct SQLOrdering {
    enum Impl {
        case expression(GRDB.SQLExpression)
        case asc(GRDB.SQLExpression)
        case desc(GRDB.SQLExpression)
        case ascNullsLast(GRDB.SQLExpression)
        case descNullsFirst(GRDB.SQLExpression)
        case literal(GRDB.SQL)
    }
    var impl: GRDB.SQLOrdering.Impl
}
struct SQLRelation {
    struct Child {
        enum Kind {
            case oneOptional
            case oneRequired
            case all
            case bridge
        }
        var kind: GRDB.SQLRelation.Child.Kind
        var condition: GRDB.SQLAssociationCondition
        var relation: GRDB.SQLRelation
    }
    struct Ordering {
        enum Element {
            case terms(GRDB.DatabasePromise<[GRDB.SQLOrdering]>)
            case ordering(GRDB.SQLRelation.Ordering)
        }
        var elements: [GRDB.SQLRelation.Ordering.Element]
        var isReversed: Swift.Bool
    }
    var source: GRDB.SQLSource
    var selectionPromise: GRDB.DatabasePromise<[GRDB.SQLSelection]>
    var filterPromise: GRDB.DatabasePromise<GRDB.SQLExpression>?
    var ordering: GRDB.SQLRelation.Ordering
    var ctes: GRDB.OrderedDictionary<Swift.String, GRDB.SQLCTE>
    var children: GRDB.OrderedDictionary<Swift.String, GRDB.SQLRelation.Child>
    var isDistinct: Swift.Bool
    var groupPromise: GRDB.DatabasePromise<[GRDB.SQLExpression]>?
    var havingExpressionPromise: GRDB.DatabasePromise<GRDB.SQLExpression>?
    var limit: GRDB.SQLLimit?
}
struct DummyRow {
    struct DummyIndex {}
}
struct SQLLimit {
    let limit: Swift.Int
    let offset: Swift.Int?
}
struct SQLSource {
    var tableName: Swift.String
    var alias: GRDB.TableAliasBase?
}
enum SQLAssociationCondition {
    case foreignKey(GRDB.SQLForeignKeyCondition)
    case expression()
}
struct SQLForeignKeyCondition {
    var destinationTable: Swift.String
    var foreignKey: GRDB.ForeignKey?
    var originIsLeft: Swift.Bool
}
struct SQLSelection {
    enum Impl {
        case qualifiedAllColumns(GRDB.TableAliasBase)
        case allColumnsExcluding(Swift.Set<GRDB.CaseInsensitiveIdentifier>)
        case qualifiedAllColumnsExcluding(GRDB.TableAliasBase, Swift.Set<GRDB.CaseInsensitiveIdentifier>)
        case expression(GRDB.SQLExpression)
        case aliasedExpression(GRDB.SQLExpression, Swift.String)
        case literal(GRDB.SQL)
        case allColumns
    }
    var impl: GRDB.SQLSelection.Impl
}
struct AllColumns {}
struct AllColumnsExcluding {
    var excludedColumns: Swift.Set<GRDB.CaseInsensitiveIdentifier>
}
enum SQLCount {
    case distinct(GRDB.SQLExpression)
    case all
}
struct SQLSubquery {
    enum Impl {
        case literal(GRDB.SQL)
        case relation(GRDB.SQLRelation)
    }
    var impl: GRDB.SQLSubquery.Impl
}
struct Table<A> {
    var tableName: Swift.String
}
enum SQLColumnGenerator {
    case columnDefinition(GRDB.ColumnDefinition)
    case columnLiteral(GRDB.SQL)
}
class SQLGenerationContext {
    enum Parent {
        case none(db: GRDB.Database, argumentsSink: GRDB.StatementArgumentsSink)
        case context(GRDB.SQLGenerationContext)
    }
    let parent: GRDB.SQLGenerationContext.Parent
    let resolvedNames: [GRDB.TableAliasBase : Swift.String]
    let ownAliases: Swift.Set<GRDB.TableAliasBase>
    let ownCTEs: [Swift.String : GRDB.SQLCTE]
}
class StatementArgumentsSink {
    var arguments: GRDB.StatementArguments
    let rawSQL: Swift.Bool
}
struct SQLIndexGenerator {
    let name: Swift.String
    let table: Swift.String
    let expressions: [GRDB.SQLExpression]
    let options: GRDB.IndexOptions
    let condition: GRDB.SQLExpression?
}
struct SQLQueryGenerator {
    var relation: GRDB.SQLQualifiedRelation
    let singleResult: Swift.Bool
    let prefetchedAssociations: [GRDB._SQLAssociation]
}
struct SQLQualifiedJoin {
    enum Kind {
        case leftJoin
        case innerJoin
    }
    var kind: GRDB.SQLQualifiedJoin.Kind
    var condition: GRDB.SQLAssociationCondition
    var relation: GRDB.SQLQualifiedRelation
}
struct SQLQualifiedRelation {
    let source: GRDB.SQLQualifiedSource
    var sourceSelectionPromise: GRDB.DatabasePromise<[GRDB.SQLSelection]>
    var isDistinct: Swift.Bool
    let filterPromise: GRDB.DatabasePromise<GRDB.SQLExpression>?
    let sourceOrdering: GRDB.SQLRelation.Ordering
    var joins: GRDB.OrderedDictionary<Swift.String, GRDB.SQLQualifiedJoin>
    let groupPromise: GRDB.DatabasePromise<[GRDB.SQLExpression]>?
    let havingExpressionPromise: GRDB.DatabasePromise<GRDB.SQLExpression>?
    let limit: GRDB.SQLLimit?
    let ctes: GRDB.OrderedDictionary<Swift.String, GRDB.SQLCTE>
}
struct SQLQualifiedSource {
    var tableName: Swift.String
    var alias: GRDB.TableAliasBase
}
struct SQLTableAlterationGenerator {
    enum TableAlterationKind {
        case addColumn(GRDB.SQLColumnGenerator)
        case addIndex(GRDB.SQLIndexGenerator)
        case renameColumn(old: Swift.String, new: Swift.String)
        case dropColumn(Swift.String)
    }
    var name: Swift.String
    var alterations: [GRDB.SQLTableAlterationGenerator.TableAlterationKind]
}
struct SQLTableGenerator {
    struct ForeignKeyGenerator {
        var columnNames: [Swift.String]
        var columnGenerators: [GRDB.SQLColumnGenerator]
        var foreignKeyConstraint: GRDB.SQLForeignKeyConstraint?
        var indexGenerator: GRDB.SQLIndexGenerator?
    }
    struct KeyConstraint {
        var columns: [Swift.String]
        var conflictResolution: GRDB.Database.ConflictResolution?
    }
    var name: Swift.String
    var options: GRDB.TableOptions
    var columnGenerators: [GRDB.SQLColumnGenerator]
    var forwardPrimaryKeyColumns: [GRDB.SQLColumnDescriptor]?
    var primaryKeyConstraint: GRDB.SQLTableGenerator.KeyConstraint?
    var uniqueKeyConstraints: [GRDB.SQLTableGenerator.KeyConstraint]
    var foreignKeyConstraints: [GRDB.SQLForeignKeyConstraint]
    var checkConstraints: [GRDB.SQLExpression]
    var literalConstraints: [GRDB.SQL]
    var indexGenerators: [GRDB.SQLIndexGenerator]
}
struct SQLForeignKeyConstraint {
    var columns: [Swift.String]
    var destinationTable: Swift.String
    var destinationColumns: [Swift.String]?
    var deleteAction: GRDB.Database.ForeignKeyAction?
    var updateAction: GRDB.Database.ForeignKeyAction?
    var isDeferred: Swift.Bool
}
struct SQLColumnDescriptor {
    var name: Swift.String
    var type: GRDB.Database.ColumnType?
}
class TableAliasBase {
    enum Impl {
        case undefined(userName: Swift.String?)
        case table(tableName: Swift.String, userName: Swift.String?)
        case proxy(GRDB.TableAliasBase)
    }
    var impl: GRDB.TableAliasBase.Impl
}
class TableAlias<A>: GRDB.TableAliasBase {}
class ColumnDefinition {
    enum GeneratedColumnQualification {
        case virtual
        case stored
    }
    struct ForeignKeyConstraint {
        var destinationTable: Swift.String
        var destinationColumn: Swift.String?
        var deleteAction: GRDB.Database.ForeignKeyAction?
        var updateAction: GRDB.Database.ForeignKeyAction?
        var isDeferred: Swift.Bool
    }
    enum Indexing {
        case unique(GRDB.Database.ConflictResolution)
        case index
    }
    struct GeneratedColumnConstraint {
        var expression: GRDB.SQLExpression
        var qualification: GRDB.ColumnDefinition.GeneratedColumnQualification
    }
    let name: Swift.String
    let type: GRDB.Database.ColumnType?
    var primaryKey: (conflictResolution: GRDB.Database.ConflictResolution?, autoincrement: Swift.Bool)?
    var indexing: GRDB.ColumnDefinition.Indexing?
    var notNullConflictResolution: GRDB.Database.ConflictResolution?
    var checkConstraints: [GRDB.SQLExpression]
    var foreignKeyConstraints: [GRDB.ColumnDefinition.ForeignKeyConstraint]
    var defaultExpression: GRDB.SQLExpression?
    var collationName: Swift.String?
    var generatedColumnConstraint: GRDB.ColumnDefinition.GeneratedColumnConstraint?
}
struct ViewOptions {
    let rawValue: Swift.Int
}
class ForeignKeyDefinition {
    enum Indexing {
        case index
        case unique
    }
    var name: Swift.String
    var table: Swift.String?
    var deleteAction: GRDB.Database.ForeignKeyAction?
    var updateAction: GRDB.Database.ForeignKeyAction?
    var indexing: GRDB.ForeignKeyDefinition.Indexing?
    var isDeferred: Swift.Bool
    var notNullConflictResolution: GRDB.Database.ConflictResolution?
}
struct IndexOptions {
    let rawValue: Swift.Int
}
struct IndexDefinition {
    let name: Swift.String
    let table: Swift.String
    let expressions: [GRDB.SQLExpression]
    let options: GRDB.IndexOptions
    let condition: GRDB.SQLExpression?
}
class TableAlteration {
    enum TableAlterationKind {
        case add(GRDB.ColumnDefinition)
        case addColumnLiteral(GRDB.SQL)
        case rename(old: Swift.String, new: Swift.String)
        case drop(Swift.String)
    }
    let name: Swift.String
    var alterations: [GRDB.TableAlteration.TableAlterationKind]
}
struct TableOptions {
    let rawValue: Swift.Int
}
class TableDefinition {
    struct KeyConstraint {
        enum Component {
            case columnName(Swift.String)
            case columnDefinition(GRDB.ColumnDefinition)
            case foreignKeyDefinition(GRDB.ForeignKeyDefinition)
        }
        var components: [GRDB.TableDefinition.KeyConstraint.Component]
        var conflictResolution: GRDB.Database.ConflictResolution?
    }
    enum ColumnComponent {
        case columnDefinition(GRDB.ColumnDefinition)
        case columnLiteral(GRDB.SQL)
        case foreignKeyDefinition(GRDB.ForeignKeyDefinition)
        case foreignKeyConstraint(GRDB.SQLForeignKeyConstraint)
    }
    let name: Swift.String
    let options: GRDB.TableOptions
    var columnComponents: [GRDB.TableDefinition.ColumnComponent]
    var inPrimaryKeyBody: Swift.Bool
    var primaryKeyConstraint: GRDB.TableDefinition.KeyConstraint?
    var uniqueKeyConstraints: [GRDB.TableDefinition.KeyConstraint]
    var checkConstraints: [GRDB.SQLExpression]
    var literalConstraints: [GRDB.SQL]
}
struct VirtualTableConfiguration {
    var ifNotExists: Swift.Bool
    var temporary: Swift.Bool
}
struct VirtualTableOptions {
    let rawValue: Swift.Int
}
class RecordEncoder<A> where A: GRDB.EncodableRecord {
    struct KeyedContainer<A1> where A1: Swift.CodingKey {
        var recordEncoder: GRDB.RecordEncoder<A>
    }
    var _persistenceContainer: GRDB.PersistenceContainer
}
class ColumnEncoder<A> where A: GRDB.EncodableRecord {
    var recordEncoder: GRDB.RecordEncoder<A>
    var key: Swift.CodingKey
    var requiresJSON: Swift.Bool
}
struct PersistenceContainer {
    var storage: GRDB.OrderedDictionary<GRDB.CaseInsensitiveIdentifier, GRDB.DatabaseValue>
}
enum DatabaseDataEncodingStrategy {
    case custom()
    case deferredToData
    case text
}
enum DatabaseDateEncodingStrategy {
    case formatted(__C.NSDateFormatter)
    case custom()
    case deferredToDate
    case timeIntervalSinceReferenceDate
    case timeIntervalSince1970
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
}
enum DatabaseUUIDEncodingStrategy {
    case deferredToUUID
    case uppercaseString
    case lowercaseString
}
enum DatabaseColumnEncodingStrategy {
    case custom()
    case useDefaultKeys
    case convertToSnakeCase
}
class FetchableRecordDecoder {}
struct _RowDecoder<A> where A: GRDB.FetchableRecord {
    class KeyedContainer<A1> where A1: Swift.CodingKey {
        let decoder: GRDB._RowDecoder<A>
        var decodedRootKey: Swift.CodingKey?
        let _columnForKey: [Swift.String : Swift.String]?
        lazy var allKeys: [A1]?
    }
    var row: GRDB.Row
    var codingPath: [Swift.CodingKey]
    var columnDecodingStrategy: GRDB.DatabaseColumnDecodingStrategy
}
struct SingleValueRowDecoder<A> where A: GRDB.FetchableRecord {
    var columnDecoder: GRDB.ColumnDecoder<A>
    var columnDecodingStrategy: GRDB.DatabaseColumnDecodingStrategy
    let codingPath: [Swift.CodingKey]
}
struct PrefetchedRowsDecoder<A> where A: GRDB.FetchableRecord {
    var rows: [GRDB.Row]
    var codingPath: [Swift.CodingKey]
    var currentIndex: Swift.Int
}
struct ColumnDecoder<A> where A: GRDB.FetchableRecord {
    var row: GRDB.Row
    var columnIndex: Swift.Int
    var codingPath: [Swift.CodingKey]
}
class RecordCursor<A> where A: GRDB.FetchableRecord {
    let _statement: GRDB.Statement
    var _isDone: Swift.Bool
    let _row: GRDB.Row
}
enum DatabaseDataDecodingStrategy {
    case custom()
    case deferredToData
}
enum DatabaseDateDecodingStrategy {
    case formatted(__C.NSDateFormatter)
    case custom()
    case deferredToDate
    case timeIntervalSinceReferenceDate
    case timeIntervalSince1970
    case millisecondsSince1970
    case iso8601
}
enum DatabaseColumnDecodingStrategy {
    case custom()
    case useDefaultKeys
    case convertFromSnakeCase
}
class DAO<A> where A: GRDB.MutablePersistableRecord {
    let db: GRDB.Database
    let persistenceContainer: GRDB.PersistenceContainer
    let databaseTableName: Swift.String
    let primaryKey: GRDB.PrimaryKeyInfo
}
struct InsertQuery {
    let onConflict: GRDB.Database.ConflictResolution
    let tableName: Swift.String
    let insertedColumns: [Swift.String]
}
struct UpdateQuery {
    let onConflict: GRDB.Database.ConflictResolution
    let tableName: Swift.String
    let updatedColumns: [Swift.String]
    let conditionColumns: [Swift.String]
}
struct PersistenceConflictPolicy {
    let conflictResolutionForInsert: GRDB.Database.ConflictResolution
    let conflictResolutionForUpdate: GRDB.Database.ConflictResolution
}
struct InsertionSuccess {
    var rowID: Swift.Int64
    var rowIDColumn: Swift.String?
    var persistenceContainer: GRDB.PersistenceContainer
}
struct PersistenceSuccess {
    var persistenceContainer: GRDB.PersistenceContainer
}
class Record {
    var referenceRow: GRDB.Row?
}
enum RecordError {
    case recordNotFound(databaseTableName: Swift.String, key: [Swift.String : GRDB.DatabaseValue])
}
struct CaseInsensitiveIdentifier {
    let lowercased: Swift.String
    let rawValue: Swift.String
}
struct Inflections {
    var pluralizeRules: [(__C.NSRegularExpression, Swift.String)]
    var singularizeRules: [(__C.NSRegularExpression, Swift.String)]
    var uncountablesRegularExpressions: [Swift.String : __C.NSRegularExpression]
}
class Mutex<A> {
    var _value: A
    var lock: __C.NSLock
}
class UnsafeSendableMutex<A> {
    var _value: A
    var lock: __C.NSLock
}
class OnDemandFutureSubscription<A> where A: Combine.Subscriber {
    enum State {
        case waitingForDemand()
        case waitingForFulfillment(downstream: A)
        case finished
    }
    var state: GRDB.OnDemandFutureSubscription<A>.State
    let lock: __C.NSRecursiveLock
}
struct OnDemandFuture<A, B> where B: Swift.Error {
    let attemptToFulfill: 
}
struct OrderedDictionary<A, B> where A: Swift.Hashable {
    var keys: [A]
    var dictionary: [A : B]
}
class Pool<A> {
    class Item {
        let element: A
        var isAvailable: Swift.Bool
    }
    struct Content {
        var items: [GRDB.Pool<A>.Item]
        var createdCount: Swift.Int
    }
    let makeElement: 
    let contentLock: GRDB.ReadWriteLock<GRDB.Pool<A>.Content>
    let itemsSemaphore: __C.OS_dispatch_semaphore
    let itemsGroup: __C.OS_dispatch_group
    let barrierQueue: __C.OS_dispatch_queue
    let semaphoreWaitingQueue: __C.OS_dispatch_queue
}
enum PoolCompletion {
    case reuse
    case discard
}
class ReadWriteLock<A> {
    var _value: A
    var queue: __C.OS_dispatch_queue
}
class ReceiveValuesOnSubscription<A, B, C> where A: Combine.Publisher, B: Combine.Scheduler, C: Combine.Subscriber, A.Publisher.Failure == C.Subscriber.Failure, A.Publisher.Output == C.Subscriber.Input {
    enum State {
        case waitingForRequest(A, GRDB.ReceiveValuesOnSubscription<A, B, C>.Target)
        case waitingForSubscription(GRDB.ReceiveValuesOnSubscription<A, B, C>.Target, Combine.Subscribers.Demand)
        case subscribed(GRDB.ReceiveValuesOnSubscription<A, B, C>.Target, Combine.Subscription)
        case finished
    }
    struct Target {
        let context: B
        let options: B.Scheduler.SchedulerOptions?
        let downstream: C
    }
    var state: GRDB.ReceiveValuesOnSubscription<A, B, C>.State
    let lock: __C.NSRecursiveLock
}
struct ReceiveValuesOn<A, B> where A: Combine.Publisher, B: Combine.Scheduler {
    let upstream: A
    let context: B
    let options: B.Scheduler.SchedulerOptions?
}
class StrongReference<A> where A: AnyObject {
    let value: A
}
struct PrintOutputStream {}
class AnyDatabaseCancellable {
    let cancelMutex: 
}
class ValueConcurrentObserver<A, B> where A: GRDB.ValueReducer, B: GRDB.ValueObservationScheduler {
    struct ObservationState {
        var region: GRDB.DatabaseRegion?
        var isModified: Swift.Bool
    }
    enum FetchingState {
        case idle
        case fetching
        case fetchingAndNeedsFetch
    }
    struct NotificationCallbacks {
        let events: GRDB.ValueObservationEvents
        let onChange: (_: A._ValueReducer.Value) -> ()
    }
    struct DatabaseAccess {
        let dbPool: GRDB.DatabasePool
        let fetcher: A._ValueReducer.Fetcher
    }
    let scheduler: B
    let trackingMode: GRDB.ValueObservationTrackingMode
    let lock: __C.NSLock
    let reduceQueue: __C.OS_dispatch_queue
    var databaseAccess: GRDB.ValueConcurrentObserver<A, B>.DatabaseAccess?
    var notificationCallbacks: GRDB.ValueConcurrentObserver<A, B>.NotificationCallbacks?
    let fetchingStateMutex: GRDB.Mutex<GRDB.ValueConcurrentObserver<A, B>.FetchingState>
    var observationState: GRDB.ValueConcurrentObserver<A, B>.ObservationState
    var reducer: A
}
class ValueWriteOnlyObserver<A, B, C> where A: GRDB.DatabaseWriter, B: GRDB.ValueReducer, C: GRDB.ValueObservationScheduler {
    struct ObservationState {
        var region: GRDB.DatabaseRegion?
        var isModified: Swift.Bool
    }
    struct NotificationCallbacks {
        let events: GRDB.ValueObservationEvents
        let onChange: (_: B._ValueReducer.Value) -> ()
    }
    struct DatabaseAccess {
        let writer: A
        let readOnly: Swift.Bool
        let fetcher: B._ValueReducer.Fetcher
    }
    let scheduler: C
    let trackingMode: GRDB.ValueObservationTrackingMode
    let lock: __C.NSLock
    let reduceQueue: __C.OS_dispatch_queue
    var databaseAccess: GRDB.ValueWriteOnlyObserver<A, B, C>.DatabaseAccess?
    var notificationCallbacks: GRDB.ValueWriteOnlyObserver<A, B, C>.NotificationCallbacks?
    var observationState: GRDB.ValueWriteOnlyObserver<A, B, C>.ObservationState
    var reducer: B
}
enum ValueReducers {
    struct Fetch<A> {
        struct _Fetcher {
            let _fetch: 
        }
        let _fetch: 
    }
    struct Map<A, B> where A: GRDB._ValueReducer {
        var base: A
        let transform: (_: A._ValueReducer.Value) throws -> B
    }
    struct RemoveDuplicates<A> where A: GRDB.ValueReducer {
        var base: A
        var previousValue: A._ValueReducer.Value?
        var predicate: (A._ValueReducer.Value, A._ValueReducer.Value) -> Swift.Bool
    }
    struct Trace<A> where A: GRDB.ValueReducer {
        struct _Fetcher {
            let base: A._ValueReducer.Fetcher
            let willFetch: 
        }
        var base: A
        let willFetch: 
        let didReceiveValue: (_: A._ValueReducer.Value) -> ()
    }
}
enum SharedValueObservationExtent {
    case observationLifetime
    case whileObserved
}
class SharedValueObservation<A> {
    class Client {
        let onError: 
        let onChange: 
    }
    let scheduler: GRDB.ValueObservationScheduler
    let extent: GRDB.SharedValueObservationExtent
    let startObservation: 
    let lock: __C.NSRecursiveLock
    var clients: [GRDB.SharedValueObservation<A>.Client]
    var isObserving: Swift.Bool
    var cancellable: GRDB.AnyDatabaseCancellable?
    var lastResult: Swift.Result<A, Swift.Error>?
}
struct ValueObservation<A> where A: GRDB.ValueReducer {
    var events: GRDB.ValueObservationEvents
    var requiresWriteAccess: Swift.Bool
    var trackingMode: GRDB.ValueObservationTrackingMode
    var makeReducer: 
}
struct AsyncValueObservation<A> {
    struct Iterator {
        var iterator: Swift.AsyncThrowingStream<A, Swift.Error>.Iterator
        let cancellable: GRDB.AnyDatabaseCancellable
    }
    var bufferingPolicy: Swift.AsyncThrowingStream<A, Swift.Error>.Continuation.BufferingPolicy
    var start: 
}
struct ValueObservationEvents {
    var willStart: 
    var willTrackRegion: 
    var databaseDidChange: 
    var didFail: 
    var didCancel: 
}
enum ValueObservationTrackingMode {
    case constantRegion([GRDB.DatabaseRegionConvertible])
    case constantRegionRecordedFromSelection
    case nonConstantRegionRecordedFromSelection
}
struct AsyncValueObservationScheduler {
    var queue: __C.OS_dispatch_queue
}
struct ImmediateValueObservationScheduler {}
class TaskValueObservationScheduler {
    let continuation: 
    let task: Swift.Task<(), Swift.Never>
}
class DelayedMainActorValueObservationScheduler {}
struct AnyGraphContent<A> where A: Swift.Hashable {
    let storage: A
}
struct GraphContentBuilder<A> where A: Swift.Hashable {}
struct LinkMark<A> where A: Swift.Hashable {
    var id: ForceSimulation.EdgeID<A>
}
struct ModifiedGraphContent<A, B> where A: Grape.GraphContent, B: Grape.GraphContentModifier {
    let content: A
    let modifier: B
}
struct NodeMark<A> where A: Swift.Hashable {
    var id: A
}
struct AnnotationNodeMark<A> where A: Swift.Hashable {
    var id: A
    var radius: CoreGraphics.CGFloat
    var annotation: SwiftUI.AnyView
}
struct Series<A, B, C> where A == C.GraphContent.NodeID, B: Swift.RandomAccessCollection, C: Grape.GraphContent {
    let data: B
    let content: (_: B.Sequence.Element) -> C
}
struct _ArrayGraphContent<A> where A: Grape.GraphContent {
    let storage: [A]
}
struct _ConditionalGraphContent<A, B> where A: Grape.GraphContent, B: Grape.GraphContent, A.GraphContent.NodeID == B.GraphContent.NodeID {
    enum Storage {
        case trueContent(A)
        case falseContent(B)
    }
    let storage: Grape._ConditionalGraphContent<A, B>.Storage
}
struct _EmptyGraphContent<A> where A: Swift.Hashable {}
enum _IdentifiableNever<A> where A: Swift.Hashable {}
struct _OptionalGraphContent<A> where A: Grape.GraphContent {
    let storage: A?
}
struct _PairedGraphContent<A, B, C> where A: Grape.GraphContent, B: Grape.GraphContent, C == A.GraphContent.NodeID, A.GraphContent.NodeID == B.GraphContent.NodeID {
    let first: A
    let second: B
}
enum NodeAttribute<A, B> where A: Swift.Hashable {
    case varied((_: A) -> B)
    case constant(B)
}
struct SealedForceDescriptor<A> where A: Swift.Hashable {
    enum Entry {
        case center(Grape.CenterForce<A>)
        case link(Grape.LinkForce<A>)
        case manyBody(Grape.ManyBodyForce<A>)
        case position(Grape.PositionForce<A>)
        case collide(Grape.CollideForce<A>)
        case radial(Grape.RadialForce<A>)
    }
    var storage: [Grape.SealedForceDescriptor<A>.Entry]
}
struct SealedForceDescriptorBuilder<A> where A: Swift.Hashable {}
struct CenterForce<A> where A: Swift.Hashable {
    var x: Swift.Double
    var y: Swift.Double
    var strength: Swift.Double
}
struct ManyBodyForce<A> where A: Swift.Hashable {
    var strength: Swift.Double
    var mass: Grape.NodeAttribute<A, Swift.Double>
    var theta: Swift.Double
}
struct LinkForce<A> where A: Swift.Hashable {
    enum Stiffness {
        case constant(Swift.Double)
        case weightedByDegree((ForceSimulation.EdgeID<A>, ForceSimulation.LinkLookup<A>) -> Swift.Double)
    }
    enum LinkLength {
        case constant(Swift.Double)
        case varied((ForceSimulation.EdgeID<A>, ForceSimulation.LinkLookup<A>) -> Swift.Double)
    }
    var stiffness: Grape.LinkForce<A>.Stiffness
    var originalLength: Grape.LinkForce<A>.LinkLength
    var iterationsPerTick: Swift.UInt
    var links: [ForceSimulation.EdgeID<A>]
}
struct CollideForce<A> where A: Swift.Hashable {
    var strength: Swift.Double
    var radius: Grape.NodeAttribute<A, Swift.Double>
    var iterationsPerTick: Swift.UInt
}
struct PositionForce<A> where A: Swift.Hashable {
    var strength: Grape.NodeAttribute<A, Swift.Double>
    var targetOnDirection: Grape.NodeAttribute<A, Swift.Double>
    var direction: ForceSimulation.Kinetics<Swift.SIMD2<Swift.Double>>.DirectionOfPositionForce
}
struct RadialForce<A> where A: Swift.Hashable {
    var strength: Grape.NodeAttribute<A, Swift.Double>
    var radius: Grape.NodeAttribute<A, Swift.Double>
    var center: Swift.SIMD2<Swift.Double>
    var iterationsPerTick: Swift.UInt
}
enum GraphDragState<A> where A: Swift.Hashable {
    case node(A)
    case background(Swift.SIMD2<Swift.Double>)
}
struct GraphDragModifier<A> where A: Swift.Hashable {
    var _dragState: SwiftUI.State<Grape.GraphDragState<A>?>
    let graphProxy: Grape.GraphProxy
    let action: ((_: Grape.GraphDragState<A>?) -> ())?
}
struct GraphMagnifyModifier {
    let proxy: Grape.GraphProxy
    let action: (() -> ())?
}
struct AnyGraphContentModifier {
    let storage: Grape.GraphContentModifier
}
enum StrokeColor {
    case color(SwiftUI.Color)
    case clip
}
enum GraphContentEffect {
    struct ForegroundStyle<A> where A: SwiftUI.ShapeStyle {
        let style: A
    }
    struct Shading {
        let shading: SwiftUI.GraphicsContext.Shading
    }
    struct ShadingBy {
        let value: Swift.AnyHashable
    }
    struct TextAnnotation {
        let text: SwiftUI.Text?
        let alignment: SwiftUI.Alignment
        let offset: __C.CGVector
    }
    struct ViewAnnotation {
        let view: SwiftUI.AnyView
        let tag: Swift.String
        let alignment: SwiftUI.Alignment
        let offset: __C.CGVector
    }
    struct Opacity {
        let value: Swift.Double
    }
    struct Stroke {
        let color: Grape.StrokeColor
        let style: SwiftUI.StrokeStyle?
    }
    struct Symbol {
        let shape: SwiftUI.AnyShape
    }
    struct SymbolSize {
        let size: __C.CGSize
    }
    struct _LinkShape {
        let storage: Grape.LinkShape
    }
}
struct GraphEnvironmentViewModifier {
    let colorScale: [Swift.AnyHashable : SwiftUI.GraphicsContext.Shading]
}
struct GraphProxy {
    var storage: Grape._AnyGraphProxyProtocol?
}
struct GraphProxyKey {}
struct KeyFrame {
    var elapsed: Swift.UInt
}
struct PlainLineLink {}
struct ArrowLineLink {
    let arrowSize: CoreGraphics.CGFloat
    let arrowAngle: SwiftUI.Angle
    let arrowCornerRadius: CoreGraphics.CGFloat
}
struct ViewRasteriazationStore<A, B> where A: Swift.Hashable, B: SwiftUI.View {
    enum RasteriazationEntry {
        case pending(B)
        case resolved(B, __C.CGImage?)
    }
    var resolvedViews: [A : Grape.ViewRasteriazationStore<A, B>.RasteriazationEntry]
}
struct ViewportTransform {
    var translate: Swift.SIMD2<Swift.Double>
    var scale: Swift.Double
}
struct VolumeTransform {
    var translate: Swift.SIMD3<Swift.Double>
    var scale: Swift.Double
}
struct ForceDirectedGraph<A, B> where A == B.GraphContent.NodeID, B: Grape.GraphContent {
    var _environment: SwiftUI.Environment<SwiftUI.EnvironmentValues>
    var _graphForegroundScale: SwiftUI.Environment<[Swift.AnyHashable : SwiftUI.GraphicsContext.Shading]>
    var _colorScheme: SwiftUI.Environment<SwiftUI.ColorScheme>
    var _colorSchemeContrast: SwiftUI.Environment<SwiftUI.ColorSchemeContrast>
    let _graphRenderingContextShadow: Grape._GraphRenderingContext<A>
    let _forceDescriptors: Grape.SealedForceDescriptor<A>
    var _model: SwiftUI.State<Grape.ForceDirectedGraphModel<A>>
}
struct ObsoleteState {
    var cgSize: __C.CGSize
}
class ForceDirectedGraphModel<A> where A: Swift.Hashable {
    var graphRenderingContext: Grape._GraphRenderingContext<A>
    var simulationContext: Grape.SimulationContext<A>
    var finalTransform: Grape.ViewportTransform
    var viewportPositions: ForceSimulation.UnsafeArray<Swift.SIMD2<Swift.Double>>
    var draggingNodeID: A?
    var backgroundDragStart: Swift.SIMD2<Swift.Double>?
    var lastTransformRecord: Grape.ViewportTransform?
    var rasterizedSymbols: [(Grape.GraphRenderingStates<A>.StateID, __C.CGRect)]
    let velocityDecay: Swift.Double
    var lastRasterizedScaleFactor: Swift.Double
    var _$changeMessage: Swift.String
    var _$currentFrame: Swift.UInt
    let ticksPerSecond: Swift.Double
    var scheduledTimer: __C.NSTimer?
    var _onTicked: ((_: Swift.UInt) -> ())?
    var _onViewportTransformChanged: ((Grape.ViewportTransform, Swift.Bool) -> ())?
    var _onSimulationStabilized: (() -> ())?
    var _emittingNewNodesWith: (_: A) -> Grape.KineticState
    var obsoleteState: Grape.ObsoleteState
    var stateMixinRef: Grape.ForceDirectedGraphState
    let _$observationRegistrar: Observation.ObservationRegistrar
}
enum Ticks {
    case untilReachingAlpha(Swift.Double?)
    case iteration(Swift.Int)
}
class ForceDirectedGraphState {
    var ticksOnAppear: Grape.Ticks
    var _$modelTransform: Grape.ViewportTransform
    var _$isRunning: Swift.Bool
    let _reg: Observation.ObservationRegistrar
}
struct _GraphRenderingContext<A> where A: Swift.Hashable {
    enum ViewResolvingState<A1> where A1: SwiftUI.View {
        case pending(A1)
        case resolved(A1, __C.CGImage?)
    }
    var resolvedTexts: [Grape.GraphRenderingStates<A>.StateID : Swift.String]
    var resolvedViews: [Grape.GraphRenderingStates<A>.StateID : Grape._GraphRenderingContext<A>.ViewResolvingState<SwiftUI.AnyView>]
    var textOffsets: [Grape.GraphRenderingStates<A>.StateID : (alignment: SwiftUI.Alignment, offset: Swift.SIMD2<Swift.Double>)]
    var symbols: [Swift.String : Grape._GraphRenderingContext<A>.ViewResolvingState<SwiftUI.Text>]
    var nodeOperations: [Grape.RenderOperation<A>.Node]
    var nodeHitSizeAreaLookup: [A : Swift.Double]
    var linkOperations: [Grape.RenderOperation<A>.Link]
    var states: Grape.GraphRenderingStates<A>
}
struct GraphRenderingStates<A> where A: Swift.Hashable {
    enum StateID {
        case node(A)
        case link(A, A)
    }
    var currentID: Grape.GraphRenderingStates<A>.StateID?
    var shading: [SwiftUI.GraphicsContext.Shading]
    var stroke: [Grape.GraphContentEffect.Stroke]
    var opacity: [Swift.Double]
    var symbolShape: [SwiftUI.Path]
    var symbolSize: [__C.CGSize]
    let defaultShading: SwiftUI.GraphicsContext.Shading
    let defaultSymbolSize: __C.CGSize
    var linkShape: [Grape.LinkShape]
    let defaultLinkShape: Grape.PlainLineLink
}
enum PathOrSymbolSize {
    case path(SwiftUI.Path)
    case symbolSize(__C.CGSize)
}
enum RenderOperation<A> where A: Swift.Hashable {
    struct Node {
        let mark: Grape.NodeMark<A>
        let fill: SwiftUI.GraphicsContext.Shading?
        let stroke: Grape.GraphContentEffect.Stroke?
        let pathOrSymbolSize: Grape.PathOrSymbolSize
    }
    struct Link {
        let mark: Grape.LinkMark<A>
        let stroke: Grape.GraphContentEffect.Stroke?
        let path: ((Swift.SIMD2<Swift.Double>, Swift.SIMD2<Swift.Double>) -> SwiftUI.Path)?
    }
}
struct KineticState {
    let position: Swift.SIMD2<Swift.Double>
    let velocity: Swift.SIMD2<Swift.Double>
    let fixation: Swift.SIMD2<Swift.Double>?
}
struct SimulationContext<A> where A: Swift.Hashable {
    var storage: ForceSimulation.Simulation<Swift.SIMD2<Swift.Double>, ForceSimulation.SealedForce2D>
    var nodeIndexLookup: [A : Swift.Int]
    var nodeIndices: [A]
}
struct ServerTimestamp {
    var value: Foundation.Date?
}
enum StarGraph<A> where A: Swift.Decodable, A: Swift.Encodable, A: Swift.Equatable {}
enum CompleteGraph<A> where A: Swift.Decodable, A: Swift.Encodable, A: Swift.Equatable {}
class Queue<A> {
    var container: [A]
    var head: Swift.Int
}
struct DijkstraNode<A> where A: Swift.Comparable {
    let vertex: Swift.Int
    let distance: A
}
class TSNode {
    let index: Swift.Int
    var color: SwiftGraph.TSColor
}
enum TSColor {
    case black
    case gray
    case white
}
class Stack<A> {
    var container: [A]
}
struct PriorityQueue<A> where A: Swift.Comparable {
    var heap: [A]
    let ordered: (A, A) -> Swift.Bool
}
class UniqueElementsGraph<A, B> where A: Swift.Decodable, A: Swift.Encodable, A: Swift.Equatable, B: Swift.Equatable, B: SwiftGraph.Edge {
    enum CodingKeys {
        case vertices
        case edges
    }
    var vertices: [A]
    var edges: [[B]]
}
struct UnweightedEdge {
    enum CodingKeys {
        case u
        case v
        case directed
    }
    var u: Swift.Int
    var v: Swift.Int
    var directed: Swift.Bool
}
class UnweightedGraph<A> where A: Swift.Decodable, A: Swift.Encodable, A: Swift.Equatable {
    enum CodingKeys {
        case vertices
        case edges
    }
    var vertices: [A]
    var edges: [[SwiftGraph.UnweightedEdge]]
}
struct WeightedEdge<A> where A: Swift.Decodable, A: Swift.Encodable, A: Swift.Equatable {
    enum CodingKeys {
        case u
        case v
        case directed
        case weight
    }
    var u: Swift.Int
    var v: Swift.Int
    var directed: Swift.Bool
    var weight: A
}
class WeightedGraph<A, B> where A: Swift.Decodable, A: Swift.Encodable, A: Swift.Equatable, B: Swift.Decodable, B: Swift.Encodable, B: Swift.Equatable {
    enum CodingKeys {
        case vertices
        case edges
    }
    var vertices: [A]
    var edges: [[SwiftGraph.WeightedEdge<B>]]
}
class MLXEmbedder {
    let modelContainer: MLXEmbedders.ModelContainer
    let configuration: MLXEmbedders.ModelConfiguration
}
class VecturaMLXKit {
    let config: VecturaKit.VecturaConfig
    let embedder: VecturaMLXKit.MLXEmbedder
    var documents: [Foundation.UUID : VecturaKit.VecturaDocument]
    var normalizedEmbeddings: [Foundation.UUID : [Swift.Float]]
    let storageDirectory: Foundation.URL
}
struct BaseConfiguration {
    struct Quantization {
        enum CodingKeys {
            case groupSize
            case bits
        }
        let groupSize: Swift.Int
        let bits: Swift.Int
    }
    enum QuantizationOption {
        case quantize(MLXEmbedders.BaseConfiguration.Quantization)
        case skip
    }
    struct PerLayerQuantization {
        var quantization: MLXEmbedders.BaseConfiguration.Quantization?
        var perLayerQuantization: [Swift.String : MLXEmbedders.BaseConfiguration.QuantizationOption]
    }
    enum CodingKeys {
        case modelType
        case quantizationContainer
    }
    struct QuantizationContainer {
        struct _DictionaryCodingKey {
            let stringValue: Swift.String
            let intValue: Swift.Int?
        }
        var quantization: MLXEmbedders.BaseConfiguration.Quantization
        var perLayerQuantization: MLXEmbedders.BaseConfiguration.PerLayerQuantization
    }
    let modelType: Swift.String
    var quantizationContainer: MLXEmbedders.BaseConfiguration.QuantizationContainer?
}
class BertEmbedding: MLXNN.Module {
    let typeVocabularySize: Swift.Int
    var _wordEmbeddings: MLXNN.ModuleInfo<MLXNN.Embedding>
    var _norm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    var _tokenTypeEmbeddings: MLXNN.ModuleInfo<MLXNN.Embedding?>
    var _positionEmbeddings: MLXNN.ModuleInfo<MLXNN.Embedding>
}
class TransformerBlock: MLXNN.Module {
    var _attention: MLXNN.ModuleInfo<MLXEmbedders.Attention>
    let mlp: MLXEmbedders.MLP
    var _inputLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _postAttentionLayerNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
}
class Encoder: MLXNN.Module {
    let layers: [MLXEmbedders.TransformerBlock]
}
class LMHead: MLXNN.Module {
    var _dense: MLXNN.ModuleInfo<MLXNN.Linear>
    var _layerNorm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    var _decoder: MLXNN.ModuleInfo<MLXNN.Linear>
}
class BertModel: MLXNN.Module {
    var _lmHead: MLXNN.ModuleInfo<MLXEmbedders.LMHead?>
    var _embedder: MLXNN.ModuleInfo<MLXEmbedders.BertEmbedding>
    let pooler: MLXNN.Linear?
    let encoder: MLXEmbedders.Encoder
    var vocabularySize: Swift.Int
}
class DistilBertModel: MLXEmbedders.BertModel {}
struct BertConfiguration {
    enum CodingKeys {
        case layerNormEps
        case maxTrainedPositions
        case vocabularySize
        case maxPositionEmbeddings
        case modelType
    }
    enum DistilBertCodingKeys {
        case embedDim
        case numLayers
        case numHeads
        case interDim
    }
    enum BertCodingKeys {
        case embedDim
        case numHeads
        case interDim
        case numLayers
        case typeVocabularySize
    }
    var layerNormEps: Swift.Float
    var maxTrainedPositions: Swift.Int
    var embedDim: Swift.Int
    var numHeads: Swift.Int
    var interDim: Swift.Int
    var numLayers: Swift.Int
    var typeVocabularySize: Swift.Int
    var vocabularySize: Swift.Int
    var maxPositionEmbeddings: Swift.Int
    var modelType: Swift.String
}
enum StringOrNumber {
    case string(Swift.String)
    case float(Swift.Float)
}
class ModelTypeRegistry {
    let lock: __C.NSLock
    var creators: [Swift.String : @Sendable (_: Foundation.URL) throws -> MLXEmbedders.EmbeddingModel]
}
struct ModelType {
    let rawValue: Swift.String
}
actor ModelContainer {
    var $defaultActor: 
    let model: MLXEmbedders.EmbeddingModel
    let tokenizer: Tokenizers.Tokenizer
    let pooler: MLXEmbedders.Pooling
}
struct EmbeddingModelOutput {
    let hiddenStates: MLX.MLXArray?
    let pooledOutput: MLX.MLXArray?
}
struct EmbedderError {
    let message: Swift.String
}
struct ModelConfiguration {
    enum Identifier {
        case id(Swift.String)
        case directory(Foundation.URL)
    }
    var id: MLXEmbedders.ModelConfiguration.Identifier
    let tokenizerId: Swift.String?
    let overrideTokenizer: Swift.String?
}
class NomicEmbedding: MLXNN.Module {
    let typeVocabularySize: Swift.Int
    var _wordEmbeddings: MLXNN.ModuleInfo<MLXNN.Embedding>
    var _norm: MLXNN.ModuleInfo<MLXNN.LayerNorm>
    var _tokenTypeEmbeddings: MLXNN.ModuleInfo<MLXNN.Embedding?>
    var _positionEmbeddings: MLXNN.ModuleInfo<MLXNN.Embedding?>
}
class MLP: MLXNN.Module {
    var _gate: MLXNN.ModuleInfo<MLXNN.Linear>
    var _down: MLXNN.ModuleInfo<MLXNN.Linear>
    var _up: MLXNN.ModuleInfo<MLXNN.Linear>
}
class DynamicNTKScalingRoPE: MLXNN.Module {
    let dims: Swift.Int
    let maxPositionEmbeddings: Swift.Int?
    let traditional: Swift.Bool
    let base: Swift.Float
    var scale: Swift.Float
    let ropeType: Swift.String
    let ropeScaling: [Swift.String : MLXEmbedders.StringOrNumber]?
}
class Attention: MLXNN.Module {
    enum PositionalEncoding {
        case rope(MLXNN.RoPE)
        case dynamicNTKScalingRoPE(MLXEmbedders.DynamicNTKScalingRoPE)
    }
    let args: MLXEmbedders.Qwen3Configuration
    let scale: Swift.Float
    var _wq: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wk: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wv: MLXNN.ModuleInfo<MLXNN.Linear>
    var _wo: MLXNN.ModuleInfo<MLXNN.Linear>
    var _qNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    var _kNorm: MLXNN.ModuleInfo<MLXNN.RMSNorm>
    let rope: MLXNN.RoPE
}
class NomicBertModel: MLXNN.Module {
    var _lmHead: MLXNN.ModuleInfo<MLXEmbedders.LMHead?>
    var _embedder: MLXNN.ModuleInfo<MLXEmbedders.NomicEmbedding>
    let pooler: MLXNN.Linear?
    let encoder: MLXEmbedders.Encoder
    var vocabularySize: Swift.Int
}
struct NomicBertConfiguration {
    enum CodingKeys {
        case layerNormEps
        case maxTrainedPositions
        case mlpFc1Bias
        case mlpFc2Bias
        case embedDim
        case numHeads
        case MLPDim
        case numLayers
        case qkvProjBias
        case rotaryEmbBase
        case rotaryEmbFraction
        case rotaryEmbInterleaved
        case rotaryEmbScaleBase
        case rotaryScalingFactor
        case typeVocabularySize
        case useCache
        case vocabularySize
        case maxPositionEmbeddings
    }
    var layerNormEps: Swift.Float
    var maxTrainedPositions: Swift.Int
    var mlpFc1Bias: Swift.Bool
    var mlpFc2Bias: Swift.Bool
    var embedDim: Swift.Int
    var numHeads: Swift.Int
    var MLPDim: Swift.Int
    var numLayers: Swift.Int
    var qkvProjBias: Swift.Bool
    var rotaryEmbBase: Swift.Float
    var rotaryEmbFraction: Swift.Float
    var rotaryEmbInterleaved: Swift.Bool
    var rotaryEmbScaleBase: Swift.Float?
    var rotaryScalingFactor: Swift.Float?
    var typeVocabularySize: Swift.Int
    var vocabularySize: Swift.Int
    var maxPositionEmbeddings: Swift.Int
}
struct PoolingConfiguration {
    enum CodingKeys {
        case dimension
        case poolingModeClsToken
        case poolingModeMeanTokens
        case poolingModeMaxTokens
        case poolingModeLastToken
    }
    let dimension: Swift.Int
    let poolingModeClsToken: Swift.Bool
    let poolingModeMeanTokens: Swift.Bool
    let poolingModeMaxTokens: Swift.Bool
    let poolingModeLastToken: Swift.Bool
}
class Pooling: MLXNN.Module {
    enum Strategy {
        case mean
        case cls
        case first
        case last
        case max
        case none
    }
    let strategy: MLXEmbedders.Pooling.Strategy
    let dimension: Swift.Int?
}
class Qwen3ModelInner: MLXNN.Module {
    var _embedTokens: MLXNN.ModuleInfo<MLXNN.Embedding>
    let layers: [MLXEmbedders.TransformerBlock]
    let norm: MLXNN.RMSNorm
}
class Qwen3Model: MLXNN.Module {
    let vocabularySize: Swift.Int
    let kvHeads: [Swift.Int]
    var _model: MLXNN.ModuleInfo<MLXEmbedders.Qwen3ModelInner>
    let configuration: MLXEmbedders.Qwen3Configuration
}
struct Qwen3Configuration {
    enum CodingKeys {
        case hiddenSize
        case hiddenLayers
        case intermediateSize
        case attentionHeads
        case rmsNormEps
        case vocabularySize
        case kvHeads
        case ropeTheta
        case headDim
        case ropeScaling
        case tieWordEmbeddings
        case maxPositionEmbeddings
    }
    var hiddenSize: Swift.Int
    var hiddenLayers: Swift.Int
    var intermediateSize: Swift.Int
    var attentionHeads: Swift.Int
    var rmsNormEps: Swift.Float
    var vocabularySize: Swift.Int
    var kvHeads: Swift.Int
    var ropeTheta: Swift.Float
    var headDim: Swift.Int
    var ropeScaling: [Swift.String : MLXEmbedders.StringOrNumber]?
    var tieWordEmbeddings: Swift.Bool
    var maxPositionEmbeddings: Swift.Int
}
class __CombineAuthLibrary: __C.NSObject {}
class __CombineFirestoreLibrary: __C.NSObject {}

protocol Endpoint {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol AnthropicService {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol LLMClientProtocol {
    // Kind: Method, isAsync: true, isInstance: true
}
protocol MeetingNotesProvider {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol KGNode: Swift.Decodable, Swift.Encodable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol ChatServiceProtocol: AnyObject {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol AnthropicService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol BraveService {
    // Kind: Method, isAsync: true, isInstance: true
}
protocol DeepLService {
    // Kind: Method, isAsync: true, isInstance: true
}
protocol DeepSeekService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol DirectService: AIProxy.ServiceMixin {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol ElevenLabsService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol FalService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol FireworksAIService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol GeminiService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol GroqService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol MicrophonePCMSampleVendor: AnyObject {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol MistralService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol MultipartFormEncodable {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol OpenAIRequestBuilder {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol OpenRouterService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol PerplexityService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol ProxiedService: AIProxy.ServiceMixin {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol ReplicateService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol ServiceMixin {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol SingleOrPartsEncodable {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol StabilityAIService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol TogetherAIService {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol HeartbeatStorageProtocol {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol HeartbeatsPayloadConvertible {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol HTTPHeaderRepresentable {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Storage {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol StorageFactory {
    // Kind: Method, isAsync: false, isInstance: false
}
protocol FirebaseRemoteConfigValueDecoding {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol StructureCodingPassthroughTypeResolver {
    // Kind: Method, isAsync: false, isInstance: false
}
protocol StructureCodingUncodedUnkeyed {}
protocol _JSONStringDictionaryEncodableMarker {}
protocol _JSONStringDictionaryDecodableMarker {
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol DocumentIDWrappable {
    // Kind: Method, isAsync: false, isInstance: false
}
protocol DocumentIDProtocol {
    // Kind: Init, isAsync: false, isInstance: false
}
protocol CodableDocumentReference: Swift.Decodable, Swift.Encodable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol CodableGeoPoint: Swift.Decodable, Swift.Encodable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
}
protocol ServerTimestampWrappable {
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol CodableTimestamp: Swift.Decodable, Swift.Encodable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
}
protocol CodableVectorValue: Swift.Decodable, Swift.Encodable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
}
protocol Endpoint {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol MultipartFormDataParameters {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Delta: Swift.Decodable {
    associatedtype T

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol OpenAIService {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol FileDownloadable {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _SortedCollection {}
protocol _UniqueCollection {}
protocol LLMClient where Self.ResponseGenerator: Swift.AsyncSequence, Self.ResumeGenerator: Swift.AsyncSequence, Self.TextGenerator: Swift.AsyncSequence, Self.ResponseGenerator.Element == LocalLLMClientCore.StreamingChunk, Self.ResumeGenerator.Element == LocalLLMClientCore.StreamingChunk, Self.TextGenerator.Element == Swift.String {
    associatedtype TextGenerator
    associatedtype ResponseGenerator
    associatedtype ResumeGenerator

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Getter, isAsync: true, isInstance: true
}
protocol LLMTool where Self.Arguments: LocalLLMClientCore.ToolSchemaGeneratable, Self.Arguments: Swift.Decodable {
    associatedtype Arguments

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol DefaultFormattedType {
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol ToolArgumentConvertible {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol ToolArgumentType {
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol ToolSchemaGeneratable {
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol ToolArgumentObject: LocalLLMClientCore.ToolArgumentType, LocalLLMClientCore.ToolSchemaGeneratable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol ForceProtocol where Self.Vector: ForceSimulation.L2NormCalculatable, Self.Vector: ForceSimulation.SimulatableVector {
    associatedtype Vector

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Force2D: ForceSimulation.ForceProtocol where Self.Vector == Swift.SIMD2<Swift.Double> {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol Force3D: ForceSimulation.ForceProtocol where Self.Vector == Swift.SIMD3<Swift.Float> {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol ForceDescriptor: Swift.Equatable where Self.ConcreteForce: ForceSimulation.ForceProtocol {
    associatedtype ConcreteForce

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ForceField: ForceSimulation.ForceProtocol where Self.F: ForceSimulation.ForceProtocol, Self.Vector == Self.F.Vector {
    associatedtype F

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
}
protocol ForceField2D: ForceSimulation.Force2D, ForceSimulation.ForceField {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol ForceField3D: ForceSimulation.Force3D, ForceSimulation.ForceField {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol KDTreeDelegate where Self.NodeID: Swift.Hashable, Self.Vector: Swift.SIMD, Self.Vector.Scalar: Swift.ExpressibleByFloatLiteral, Self.Vector.Scalar: Swift.FloatingPoint {
    associatedtype NodeID
    associatedtype Vector

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Disposable {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol DeterministicRandomGenerator where Self.OverflowingInteger: Swift.FixedWidthInteger, Self.OverflowingInteger: Swift.UnsignedInteger, Self.Scalar: Swift.ExpressibleByFloatLiteral, Self.Scalar: Swift.FloatingPoint {
    associatedtype Scalar
    associatedtype OverflowingInteger

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
}
protocol HasDeterministicRandomGenerator: Swift.ExpressibleByFloatLiteral, Swift.FloatingPoint where Self == Self.Generator.Scalar, Self.Generator: ForceSimulation.DeterministicRandomGenerator {
    associatedtype Generator

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
}
protocol SimulatableVector: Swift.SIMD where Self.Scalar: ForceSimulation.HasDeterministicRandomGenerator {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol L2NormCalculatable: Swift.SIMD where Self.Scalar: Swift.FloatingPoint {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol VecturaProtocol {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol VecturaStorage {
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol TextTokenizer {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SafetensorsEncodable {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Decoder {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
}
protocol Normalizer {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
}
protocol PostProcessor {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
}
protocol PreTokenizer {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
}
protocol TokenizingModel {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol PreTrainedTokenizerModel: Tokenizers.TokenizingModel {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
}
protocol Tokenizer {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Generation {
    // Kind: Method, isAsync: true, isInstance: true
}
protocol LanguageModelProtocol {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: true, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Method, isAsync: true, isInstance: true
}
protocol TextGenerationModel: Generation.Generation, Models.LanguageModelProtocol {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol StringConvertible: Swift.ExpressibleByStringLiteral {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol NIOAtomicPrimitive {
    associatedtype AtomicWrapper

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol AtomicPrimitive {
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol AtomicInteger: Atomics.AtomicValue, Swift.FixedWidthInteger where Self == Self.AtomicRepresentation.Value, Self.AtomicRepresentation: Atomics.AtomicIntegerStorage {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
}
protocol AtomicIntegerStorage: Atomics.AtomicStorage {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol AtomicOptionalWrappable: Atomics.AtomicValue where Self.AtomicOptionalRepresentation: Atomics.AtomicStorage, Self.AtomicOptionalRepresentation.Value == Self.AtomicRepresentation.Value {
    associatedtype AtomicOptionalRepresentation

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
}
protocol AtomicReference: AnyObject, Atomics.AtomicOptionalWrappable where Self.AtomicOptionalRepresentation == Self._AtomicBase, Self.AtomicRepresentation == Self._AtomicBase, Self._AtomicBase: AnyObject {
    associatedtype _AtomicBase

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
}
protocol AtomicStorage {
    associatedtype Value

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol AtomicValue where Self.AtomicRepresentation: Atomics.AtomicStorage {
    associatedtype AtomicRepresentation

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
}
protocol NIOAsyncSequenceProducerBackPressureStrategy {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOAsyncSequenceProducerDelegate {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOAsyncWriterSinkDelegate {
    associatedtype Element

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOBinaryIntegerEncodingStrategy {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ChannelCore: AnyObject {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Channel: AnyObject, NIOCore.ChannelOutboundInvoker, NIOCore._NIOPreconcurrencySendable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOSynchronousChannelOptions {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ChannelHandler: AnyObject {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _ChannelOutboundHandler: NIOCore.ChannelHandler {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _ChannelInboundHandler: NIOCore.ChannelHandler {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol RemovableChannelHandler: NIOCore.ChannelHandler {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOOutboundByteBufferingChannelHandler {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol NIOInboundByteBufferingChannelHandler {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol ChannelOutboundInvoker {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol ChannelInboundInvoker {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ChannelInvoker: NIOCore.ChannelInboundInvoker, NIOCore.ChannelOutboundInvoker {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol ChannelOption: NIOCore._NIOPreconcurrencySendable, Swift.Equatable {
    associatedtype Value

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
}
protocol ByteToMessageDecoder {
    associatedtype InboundOut

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol WriteObservingByteToMessageDecoder: NIOCore.ByteToMessageDecoder {
    associatedtype OutboundIn

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol CanDequeueWrites {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol MessageToByteEncoder {
    associatedtype OutboundIn

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOSerialEventLoopExecutor: NIOCore.EventLoop, Swift.SerialExecutor {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol EventLoop: NIOCore.EventLoopGroup {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol EventLoopGroup: AnyObject, NIOCore._NIOPreconcurrencySendable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol FileDescriptor {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol MulticastChannel: NIOCore.Channel {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOScheduledCallbackHandler {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _NIOPreconcurrencySendable {}
protocol RecvByteBufferAllocator: NIOCore._NIOPreconcurrencySendable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOSingleStepByteToMessageDecoder: NIOCore.ByteToMessageDecoder {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SockAddrProtocol {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SocketOptionProvider: NIOCore._NIOPreconcurrencySendable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _EmittingChannelHandler {
    associatedtype OutboundOut

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ChannelInboundHandler: NIOCore._ChannelInboundHandler, NIOCore._EmittingChannelHandler {
    associatedtype InboundIn
    associatedtype InboundOut

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ChannelOutboundHandler: NIOCore._ChannelOutboundHandler, NIOCore._EmittingChannelHandler {
    associatedtype OutboundIn

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOClientTCPBootstrapProtocol {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOClientTLSProvider {
    associatedtype Bootstrap

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _SocketShutdownProtocol {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol _BSDSocketProtocol {
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol _BSDSocketControlMessageProtocol {
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol Registration {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
}
protocol NIOPipeBootstrapHooks {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol PendingWritesManager: AnyObject {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
}
protocol PoolElement {
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SilenceWarning {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Resolver {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Selectable {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SelectableChannel: NIOCore.Channel where Self.SelectableType: NIOPosix.Selectable {
    associatedtype SelectableType

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOEventLoopMetricsDelegate {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _SelectorBackendProtocol where Self.R: NIOPosix.Registration {
    associatedtype R

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol BaseSocketProtocol: Swift.CustomStringConvertible where Self.SelectableType: NIOPosix.Selectable {
    associatedtype SelectableType

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ServerSocketProtocol: NIOPosix.BaseSocketProtocol {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SocketProtocol: NIOPosix.BaseSocketProtocol {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ThreadOps {
    associatedtype ThreadHandle
    associatedtype ThreadSpecificKey
    associatedtype ThreadSpecificKeyDestructor

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol HTTPDecoderDelegate {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol HTTPServerProtocolUpgrader {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOHTTPClientProtocolUpgrader {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOTypedHTTPClientProtocolUpgrader {
    associatedtype UpgradeResult

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NIOTypedHTTPServerProtocolUpgrader {
    associatedtype UpgradeResult

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol TokenProvider {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol AEAD {
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol Authenticator {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol BatchedCollectionType: Swift.Collection where Self.Base: Swift.Collection {
    associatedtype Base

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
}
protocol BlockCipher: CryptoSwift.Cipher {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol BlockMode {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol CipherModeWorker {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol BlockModeWorker: CryptoSwift.CipherModeWorker {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol CounterModeWorker: CryptoSwift.CipherModeWorker {
    associatedtype Counter

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
}
protocol SeekableModeWorker: CryptoSwift.CipherModeWorker {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol StreamModeWorker: CryptoSwift.CipherModeWorker {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol FinalizingEncryptModeWorker: CryptoSwift.CipherModeWorker {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol FinalizingDecryptModeWorker: CryptoSwift.CipherModeWorker {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Cipher: AnyObject {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Cryptor {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Cryptors: AnyObject {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: false
}
protocol DigestType {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol PaddingProtocol {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _UInt32Type {}
protocol _UInt8Type {}
protocol Updatable {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol WarningWorkaround {
    // Kind: Method, isAsync: false, isInstance: false
}
protocol AuthBackendProtocol {
    // Kind: Method, isAsync: true, isInstance: true
}
protocol AuthBackendRPCIssuerProtocol {
    // Kind: Method, isAsync: true, isInstance: true
}
protocol AuthRPCRequest where Self.Response: FirebaseAuth.AuthRPCResponse {
    associatedtype Response

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol AuthRPCResponse {
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol AuthMFAResponse {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol AuthProto {
    // Kind: Init, isAsync: false, isInstance: false
}
protocol AuthKeychainStorage {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol StreamResponseProtocol {}
protocol TokenProvider {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol LLMModel: MLXLMCommon.LanguageModel, MLXLMCommon.LoRAModel {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol PositionEmbedding {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol HasDType: MLX.ScalarOrArray {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol ScalarOrArray {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol MLXArrayIndex {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol KernelTemplateArg {}
protocol IndentedDescription: Swift.CustomStringConvertible {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Updatable {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Evaluatable {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol RandomStateOrKey {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol AlgebraicField: Swift.SignedNumeric where Self.Magnitude: RealModule.AlgebraicField {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol ElementaryFunctions: Swift.AdditiveArithmetic {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol Real: RealModule.AlgebraicField, RealModule.RealFunctions, Swift.FloatingPoint {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol RealFunctions: RealModule.ElementaryFunctions {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol UnaryLayer: MLXNN.Module {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol TypeErasedSetter {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol TypeErasedSetterProvider {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Quantizable {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Quantized: MLXNN.Module {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol Optimizer: MLX.Evaluatable, MLX.Updatable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol LoRAModel {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol LoRALayer: MLXNN.Module {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ModelAdapter {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol MessageGenerator {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol LogitSampler {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol LogitProcessor {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol KVCache: MLX.Evaluatable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol QuantizedKVCacheProtocol: MLXLMCommon.KVCache {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol LanguageModel: MLXNN.Module {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol KVCacheDimensionProvider {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol ModelFactory {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
}
protocol ModelFactoryTrampoline {
    // Kind: Method, isAsync: false, isInstance: false
}
protocol StreamingDetokenizer: Swift.IteratorProtocol where Self.Element == Swift.String {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ToolProtocol {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol UserInputProcessor {
    // Kind: Method, isAsync: true, isInstance: true
}
protocol VLMModel: MLXLMCommon.LanguageModel, MLXLMCommon.LoRAModel {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol AppLifecyclePublishing: AnyObject {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol PostHogSurveyQuestionProperties {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol PostHogIntegration {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ScreenViewPublishing: AnyObject {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ApplicationInfoProtocol {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol EventGDTLoggerProtocol {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol GoogleDataTransportProtocol {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol InstallationsProtocol {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol NetworkInfoProtocol {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol SessionCoordinatorProtocol {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SettingsCacheClient {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SettingsDownloadClient {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SettingsProtocol {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol SettingsProvider {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol TimeProvider {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol DownloaderUserDefaultsWriteable {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol FileDownloader {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ModelInfoRetrieverSession {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _CustomJSONCodable {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: false
}
protocol Decoder {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Enum: Swift.Hashable, Swift.RawRepresentable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol ExtensibleMessage: SwiftProtobuf.Message {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
}
protocol AnyExtensionField: Swift.CustomDebugStringConvertible {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol ExtensionField: Swift.Hashable, SwiftProtobuf.AnyExtensionField {
    associatedtype ValueType

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
}
protocol ExtensionMap {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol FieldType where Self.BaseType: Swift.Hashable {
    associatedtype BaseType

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol MapKeyType: SwiftProtobuf.FieldType {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol MapValueType: SwiftProtobuf.FieldType {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol ProtobufWrapper where Self.WrappedType: SwiftProtobuf.FieldType {
    associatedtype WrappedType

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
}
protocol Message: Swift.CustomDebugStringConvertible {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _MessageImplementationBase: Swift.Hashable, SwiftProtobuf.Message {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol AnyMessageExtension {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _ProtoNameProviding {
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol ProtobufAPIVersion_2 {}
protocol ProtobufAPIVersionCheck where Self.Version: SwiftProtobuf.ProtobufAPIVersion_2 {
    associatedtype Version

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
}
protocol SelectiveVisitor: SwiftProtobuf.Visitor {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol SwiftProtobufContiguousBytes {
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Visitor {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Cursor: AnyObject {
    associatedtype Element

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol DatabaseAggregate {
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol DatabaseReader: AnyObject {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol DatabaseSnapshotReader: GRDB.DatabaseReader {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol DatabaseRegionConvertible {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol DatabaseValueConvertible: GRDB.SQLExpressible, GRDB.StatementBinding {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
}
protocol DatabaseWriter: GRDB.DatabaseReader {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: true, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol FetchRequest: GRDB.DatabaseRegionConvertible, GRDB.SQLSubqueryable {
    associatedtype RowDecoder

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol RowImpl {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _LayoutedRowAdapter {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol _RowLayout {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol RowAdapter {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol DatabaseCursor: GRDB.Cursor {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol StatementBinding {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol StatementColumnConvertible {
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
}
protocol TransactionClock {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol TransactionObserver: AnyObject {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol DatabaseEventProtocol {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol DatabaseEventImpl {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol DumpFormat {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol FTS5CustomTokenizer: GRDB.FTS5Tokenizer {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
}
protocol FTS5Tokenizer: AnyObject {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol FTS5WrapperTokenizer: GRDB.FTS5CustomTokenizer {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SQLJSONExpressible: GRDB.SQLSpecificExpressible {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol Association: GRDB.DerivableRequest {
    associatedtype OriginRowDecoder

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol AssociationToOne: GRDB.Association {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol AssociationToMany: GRDB.Association {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol TypedRequest {
    associatedtype RowDecoder

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
}
protocol SelectionRequest {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol FilteredRequest {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol TableRequest {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol AggregatingRequest {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol OrderedRequest {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol JoinableRequest: GRDB.TypedRequest {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol DerivableRequest: GRDB.AggregatingRequest, GRDB.FilteredRequest, GRDB.JoinableRequest, GRDB.OrderedRequest, GRDB.SelectionRequest, GRDB.TableRequest {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ColumnExpression: GRDB.SQLSpecificExpressible {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol SQLExpressible {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol SQLSpecificExpressible: GRDB.SQLExpressible, GRDB.SQLOrderingTerm, GRDB.SQLSelectable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol SQLOrderingTerm {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol ColumnAddressable {
    associatedtype ColumnIndex

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol SQLSelectable {
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol SQLSubqueryable: GRDB.SQLSpecificExpressible {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol VirtualTableModule {
    associatedtype TableDefinition

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol EncodableRecord {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol FetchableRecord {
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol MutablePersistableRecord: GRDB.EncodableRecord, GRDB.TableRecord {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol PersistableRecord: GRDB.MutablePersistableRecord {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol TableRecord {
    associatedtype Columns
    associatedtype DatabaseComponents

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: false
}
protocol Refinable {}
protocol DatabaseCancellable {
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _ValueReducer where Self.Fetcher: GRDB._ValueReducerFetcher {
    associatedtype Fetcher
    associatedtype Value

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol _ValueReducerFetcher {
    associatedtype Value

    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ValueReducer: GRDB._ValueReducer {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol ValueObservationScheduler {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol ValueObservationMainActorScheduler: GRDB.ValueObservationScheduler {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol GraphContent where Self.Body: Grape.GraphContent, Self.NodeID: Swift.Hashable, Self.NodeID == Self.Body.NodeID {
    associatedtype NodeID
    associatedtype Body

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol _ForceDescriptor where Self.NodeID: Swift.Hashable {
    associatedtype NodeID

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol GraphContentModifier {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol GraphProtocol where Self.Edge: Swift.Identifiable, Self.Node: Swift.Identifiable, Self.Edge.ID == Self.Node.ID {
    associatedtype Node
    associatedtype Edge

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
}
protocol LinkShape {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol StraightLineLinkShape: Grape.LinkShape {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
}
protocol TransformProtocol where Self.Scalar: Swift.ExpressibleByFloatLiteral, Self.Scalar: Swift.FloatingPoint, Self.Scalar == Self.Vector.Scalar, Self.Vector: Swift.SIMD {
    associatedtype Scalar
    associatedtype Vector

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
}
protocol _AnyGraphProxyProtocol {
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
}
protocol Edge: Swift.CustomStringConvertible, Swift.Decodable, Swift.Encodable {
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}
protocol Graph: Swift.Collection, Swift.CustomStringConvertible, Swift.Decodable, Swift.Encodable where Self.E: Swift.Equatable, Self.E: SwiftGraph.Edge, Self.V: Swift.Decodable, Self.V: Swift.Encodable, Self.V: Swift.Equatable {
    associatedtype V
    associatedtype E

    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: BaseProtocol, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Setter, isAsync: false, isInstance: true
    // Kind: ModifyCoroutine, isAsync: false, isInstance: true
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Method, isAsync: false, isInstance: true
}
protocol WeightedEdgeProtocol where Self.Weight: Swift.Equatable {
    associatedtype Weight

    // Kind: AssociatedConformanceAccessFunction, isAsync: false, isInstance: false
    // Kind: AssociatedTypeAccessFunction, isAsync: false, isInstance: false
    // Kind: Init, isAsync: false, isInstance: false
    // Kind: Getter, isAsync: false, isInstance: true
}
protocol EmbeddingModel: MLXNN.Module {
    // Kind: Getter, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
    // Kind: Method, isAsync: false, isInstance: true
}

extension __C.FIRFirestore {
    class Encoder {
        var dateEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.DateEncodingStrategy
        var dataEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.DataEncodingStrategy
        var nonConformingFloatEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.NonConformingFloatEncodingStrategy
        var keyEncodingStrategy: FirebaseSharedSwift.FirebaseDataEncoder.KeyEncodingStrategy
        var userInfo: [Swift.CodingUserInfoKey : Any]
    }
}
extension __C.FIRFirestore {
    class Decoder {
        var dateDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.DateDecodingStrategy
        var dataDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.DataDecodingStrategy
        var nonConformingFloatDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.NonConformingFloatDecodingStrategy
        var keyDecodingStrategy: FirebaseSharedSwift.FirebaseDataDecoder.KeyDecodingStrategy
        var userInfo: [Swift.CodingUserInfoKey : Any]
    }
}
extension Swift.Bool {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt8Storage
    }
}
extension Swift.Int8 {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt8Storage
    }
}
extension Swift.Int16 {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt16Storage
    }
}
extension Swift.Int32 {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt32Storage
    }
}
extension Swift.Int64 {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.UInt8 {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt8Storage
    }
}
extension Swift.UInt16 {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt16Storage
    }
}
extension Swift.UInt32 {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt32Storage
    }
}
extension Swift.UInt64 {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.Int {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.UInt {
    struct AtomicRepresentation {
        var _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.UnsafeRawPointer {
    struct AtomicRepresentation {
        let _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.UnsafeRawPointer {
    struct AtomicOptionalRepresentation {
        let _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.UnsafeMutableRawPointer {
    struct AtomicRepresentation {
        let _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.UnsafeMutableRawPointer {
    struct AtomicOptionalRepresentation {
        let _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.UnsafePointer {
    struct AtomicRepresentation {
        let _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.UnsafePointer {
    struct AtomicOptionalRepresentation {
        let _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.UnsafeMutablePointer {
    struct AtomicRepresentation {
        let _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.UnsafeMutablePointer {
    struct AtomicOptionalRepresentation {
        let _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.Unmanaged where A: AnyObject {
    struct AtomicRepresentation {
        let _storage: Atomics._AtomicInt64Storage
    }
}
extension Swift.Unmanaged where A: AnyObject {
    struct AtomicOptionalRepresentation {
        let _storage: Atomics._AtomicInt64Storage
    }
}
extension NIOCore.NIOBSDSocket {
    struct SocketType {
        var rawValue: Swift.Int32
    }
}
extension NIOCore.NIOBSDSocket {
    struct ProtocolSubtype {
        var rawValue: Swift.Int32
    }
}
extension NIOCore.ChannelOptions.Types {
    struct LocalVsockContextID {}
}
extension SwiftUI.Image {
    enum Error {
        case unableToLoadGoogleIcon(name: Swift.String)
    }
}
extension FirebaseFunctions.Callable where A: Swift.Encodable, B: Swift.Decodable {
    struct StreamResponseMessage {
        enum CodingKeys {
            case message
        }
        let message: B
    }
}
extension __C.CIImage {
    enum ResamplingMethod {
        case bicubic
        case lanczos
    }
}
extension PostHog.DI {
    class Container {
        lazy var sessionManager: PostHog.PostHogSessionManager?
        lazy var appLifecyclePublisher: PostHog.AppLifecyclePublishing?
        lazy var screenViewPublisher: PostHog.ScreenViewPublishing?
    }
}
extension SwiftUI.EnvironmentValues {
    struct __Key_graphForegroundScaleEnvironment {}
}
extension SwiftGraph.UniqueElementsGraph where A: Swift.Decodable, A: Swift.Encodable, A: Swift.Equatable, B == SwiftGraph.UnweightedEdge {
    struct QueueElement<A1> {
        let v: A1
        let previousIndex: Swift.Int
    }
}
extension Spec.ContactsEnrichmentDebugView.SortOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactsEnrichmentDebugView.SortOption: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ContactsEnrichmentDebugView.SortOption: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ContactsEnrichmentDebugView.SortOption: Swift.CaseIterable {
    typealias AllCases = [Spec.ContactsEnrichmentDebugView.SortOption]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.ContactsEnrichmentDebugView.FilterOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactsEnrichmentDebugView.FilterOption: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ContactsEnrichmentDebugView.FilterOption: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ContactsEnrichmentDebugView.FilterOption: Swift.CaseIterable {
    typealias AllCases = [Spec.ContactsEnrichmentDebugView.FilterOption]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.ContactsEnrichmentDebugView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HSplitView<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Image>SwiftUI.BorderlessButtonStyle)>>, SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Spec.ContactsEnrichmentDebugView.FilterOption, SwiftUI.ForEach<[Spec.ContactsEnrichmentDebugView.FilterOption], Spec.ContactsEnrichmentDebugView.FilterOption, SwiftUI.TextSpec.ContactsEnrichmentDebugView.FilterOption>>SwiftUI.MenuPickerStyle, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Spec.ContactsEnrichmentDebugView.SortOption, SwiftUI.ForEach<[Spec.ContactsEnrichmentDebugView.SortOption], Spec.ContactsEnrichmentDebugView.SortOption, SwiftUI.TextSpec.ContactsEnrichmentDebugView.SortOption>>SwiftUI.MenuPickerStyle, SwiftUI._FrameLayout>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>, SwiftUI.List<Spec.ContactSummary, SwiftUI.ForEach<[Spec.ContactSummary], Swift.String, Spec.ContactListRow>>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<Spec.ContactEnrichmentDetailView, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ContactSummary: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.ContactSummary: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ContactSummary: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactListRow: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>, SwiftUI.Text?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ContactEnrichmentDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>, SwiftUI.TextSwiftUI.EnabledTextSelectability)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.GroupBox<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text?)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._PaddingLayout>, SwiftUI.Text, SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.Text?, SwiftUI.Spacer, SwiftUI.Text?)>>>)>?)>>, SwiftUI._PaddingLayout>>?, SwiftUI.GroupBox<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Spec.ContactOverview.ChannelMetrics], Swift.String, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.VStack<SwiftUI.Text>)>>, SwiftUI._PaddingLayout>>>, SwiftUI._PaddingLayout>>?, SwiftUI.GroupBox<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.ContactOverview.Employment)], Swift.Int, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.Text?)>>, SwiftUI.Text?)>>>>, SwiftUI._PaddingLayout>>?, SwiftUI.GroupBox<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.ContactOverview.Education)], Swift.Int, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.Text?)>>>>, SwiftUI._PaddingLayout>>?, SwiftUI.GroupBox<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.ModifiedContent<SwiftUI._VariadicView.Tree<SwiftUI._LayoutRoot<Spec.FlowLayout>, SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.ContactOverview.Topic)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._PaddingLayout>>?, SwiftUI.GroupBox<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.ModifiedContent<SwiftUI._VariadicView.Tree<SwiftUI._LayoutRoot<Spec.FlowLayout>, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._PaddingLayout>>?, SwiftUI.GroupBox<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>>?, SwiftUI.GroupBox<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.ContactOverview.Address)], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>?, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>)>>>>, SwiftUI._PaddingLayout>>?, SwiftUI.GroupBox<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.ContactOverview.SocialLink)], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>?, SwiftUI.Spacer, SwiftUI.Text?)>>>>, SwiftUI._PaddingLayout>>?, SwiftUI.ModifiedContent<SwiftUI.DisclosureGroup<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[Spec.ContactOverview.AppIdentity], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.Text)>>>, SwiftUI.TupleView<(SwiftUI.Divider, SwiftUI.Text, SwiftUI.Text)>?)>>, SwiftUI._PaddingLayout>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>>?>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension __C.FileAttributeKey: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.FileAttributeKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.FileAttributeKey: Swift._SwiftNewtypeWrapper {}
extension __C.FileAttributeKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.FileAttributeKey: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.FileAttributeKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.CNAuthorizationStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.CNAuthorizationStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.DirectoryEnumerationOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.DirectoryEnumerationOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.DirectoryEnumerationOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.DirectoryEnumerationOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.DirectoryEnumerationOptions: Swift.OptionSet {
    typealias Element = __C.DirectoryEnumerationOptions

    init(rawValue: Self.RawValue)
}
extension __C.DirectoryEnumerationOptions: Swift.SetAlgebra {
    typealias Element = __C.DirectoryEnumerationOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.DangerousPathError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.DangerousPathError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DraftContextDisplayView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._PaddingLayout>?

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GmailDraftDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<Spec.EnhancedEmailDraftCard, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GmailDraftDetailView: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessagesDraftDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.IDView<Spec.DraftMessagesReplyPreviewView, Swift.String>, SwiftUI._AppearanceActionModifier>Swift.String

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessagesDraftDetailView: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DraftListItem: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DraftListItem: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SlackDraftDetailView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(Spec.DraftContextDisplayView, SwiftUI.ModifiedContent<Spec.DraftSlackReplyPreviewView, SwiftUI._PaddingLayout>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SlackDraftDetailView: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XDMDraftDetailView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(Spec.DraftContextDisplayView, SwiftUI.ModifiedContent<Spec.DraftXDMReplyPreviewView, SwiftUI._PaddingLayout>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.XDMDraftDetailView: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PinMenuView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<Spec.PinMenuOption, SwiftUI.TupleView<(Spec.PinMenuOption, SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._PaddingLayout>, Spec.PinMenuOption)>>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Material>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PinMenuOption: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._HoverRegionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0022PinMenuViewswift_tiAIefMX122_0_024_342666391A9BD0154DB0DA2E6F9529DLl7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.ScreenObservation.AppInfo: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ScreenObservation.AppInfo: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ScreenObservation.AppInfo: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ScreenObservation.AppInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ScreenObservation.Element: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ScreenObservation.Element: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ScreenObservation.Element: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ScreenObservation.Element: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ScreenObservation.Affordance: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ScreenObservation.Affordance: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ScreenObservation.Affordance: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ScreenObservation.Affordance: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ScreenObservation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ScreenObservation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ScreenObservation: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ScreenObservation: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ScreenObservation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ScreenObservation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ScreenObservation.Affordance.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.Affordance.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.Affordance.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ScreenObservation.Affordance.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.Affordance.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ScreenObservation.Element.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.Element.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.Element.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ScreenObservation.Element.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.Element.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ScreenObservation.AppInfo.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.AppInfo.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.AppInfo.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ScreenObservation.AppInfo.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ScreenObservation.AppInfo.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AIProxyService: Spec.AnthropicService {}
extension __C.ReadingOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.ReadingOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.ReadingOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.ReadingOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.ReadingOptions: Swift.OptionSet {
    typealias Element = __C.ReadingOptions

    init(rawValue: Self.RawValue)
}
extension __C.ReadingOptions: Swift.SetAlgebra {
    typealias Element = __C.ReadingOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.PinnedChatCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle, SwiftUI._HoverRegionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0025PinnedChatCardswift_jqFBgfMX80_0_33_D6F941A65CB44825A89CFBF45A58F5D0Ll7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.AnthropicAPI.APIPath: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.AnthropicAPI.APIPath: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AnthropicAPI: Spec.Endpoint {}
extension Spec.XAPIServiceError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.XAPIServiceError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CodingKeys in SendDMResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in SendDMResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in SendDMResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in SendDMResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in SendDMResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SendDMResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SendDMResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in SendDMRequest #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in SendDMRequest #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in SendDMRequest #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in SendDMRequest #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in SendDMRequest #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SendDMRequest #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SendDMRequest #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension CodingKeys in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Message.CodingKeys in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Message.CodingKeys in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Message.CodingKeys in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Message.CodingKeys in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Message.CodingKeys in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Message in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Message in CreateDMConversationRequest #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CreateDMConversationRequest #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CreateDMConversationRequest #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension CodingKeys in UnmuteResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in UnmuteResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in UnmuteResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in UnmuteResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in UnmuteResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension UnmuteData.CodingKeys in UnmuteResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension UnmuteData.CodingKeys in UnmuteResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension UnmuteData.CodingKeys in UnmuteResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension UnmuteData.CodingKeys in UnmuteResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension UnmuteData.CodingKeys in UnmuteResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension UnmuteData in UnmuteResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension UnmuteData in UnmuteResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension UnmuteResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension UnmuteResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in MuteResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in MuteResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in MuteResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in MuteResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in MuteResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MuteData.CodingKeys in MuteResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MuteData.CodingKeys in MuteResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MuteData.CodingKeys in MuteResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MuteData.CodingKeys in MuteResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MuteData.CodingKeys in MuteResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MuteData in MuteResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MuteData in MuteResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MuteResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MuteResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in MuteRequest #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in MuteRequest #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in MuteRequest #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in MuteRequest #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in MuteRequest #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MuteRequest #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MuteRequest #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension CodingKeys in UnblockResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in UnblockResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in UnblockResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in UnblockResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in UnblockResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension UnblockData.CodingKeys in UnblockResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension UnblockData.CodingKeys in UnblockResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension UnblockData.CodingKeys in UnblockResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension UnblockData.CodingKeys in UnblockResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension UnblockData.CodingKeys in UnblockResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension UnblockData in UnblockResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension UnblockData in UnblockResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension UnblockResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension UnblockResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in BlockResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in BlockResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in BlockResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in BlockResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in BlockResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension BlockData.CodingKeys in BlockResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension BlockData.CodingKeys in BlockResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension BlockData.CodingKeys in BlockResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension BlockData.CodingKeys in BlockResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension BlockData.CodingKeys in BlockResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension BlockData in BlockResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension BlockData in BlockResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension BlockResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension BlockResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in BlockRequest #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in BlockRequest #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in BlockRequest #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in BlockRequest #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in BlockRequest #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension BlockRequest #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension BlockRequest #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension CodingKeys in UnfollowResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in UnfollowResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in UnfollowResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in UnfollowResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in UnfollowResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension UnfollowData.CodingKeys in UnfollowResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension UnfollowData.CodingKeys in UnfollowResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension UnfollowData.CodingKeys in UnfollowResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension UnfollowData.CodingKeys in UnfollowResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension UnfollowData.CodingKeys in UnfollowResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension UnfollowData in UnfollowResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension UnfollowData in UnfollowResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension UnfollowResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension UnfollowResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in FollowResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in FollowResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in FollowResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in FollowResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in FollowResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FollowData.CodingKeys in FollowResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FollowData.CodingKeys in FollowResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FollowData.CodingKeys in FollowResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FollowData.CodingKeys in FollowResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension FollowData.CodingKeys in FollowResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FollowData in FollowResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FollowData in FollowResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FollowResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FollowResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in FollowRequest #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in FollowRequest #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in FollowRequest #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in FollowRequest #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in FollowRequest #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FollowRequest #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FollowRequest #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension CodingKeys in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension RemoveBookmarkData.CodingKeys in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension RemoveBookmarkData.CodingKeys in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension RemoveBookmarkData.CodingKeys in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension RemoveBookmarkData.CodingKeys in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension RemoveBookmarkData.CodingKeys in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension RemoveBookmarkData in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension RemoveBookmarkData in RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension RemoveBookmarkResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in BookmarkResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in BookmarkResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in BookmarkResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in BookmarkResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in BookmarkResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension BookmarkData.CodingKeys in BookmarkResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension BookmarkData.CodingKeys in BookmarkResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension BookmarkData.CodingKeys in BookmarkResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension BookmarkData.CodingKeys in BookmarkResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension BookmarkData.CodingKeys in BookmarkResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension BookmarkData in BookmarkResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension BookmarkData in BookmarkResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension BookmarkResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension BookmarkResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in BookmarkRequest #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in BookmarkRequest #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in BookmarkRequest #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in BookmarkRequest #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in BookmarkRequest #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension BookmarkRequest #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension BookmarkRequest #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension CodingKeys in UndoRetweetResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in UndoRetweetResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in UndoRetweetResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in UndoRetweetResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in UndoRetweetResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension UndoRetweetData.CodingKeys in UndoRetweetResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension UndoRetweetData.CodingKeys in UndoRetweetResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension UndoRetweetData.CodingKeys in UndoRetweetResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension UndoRetweetData.CodingKeys in UndoRetweetResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension UndoRetweetData.CodingKeys in UndoRetweetResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension UndoRetweetData in UndoRetweetResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension UndoRetweetData in UndoRetweetResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension UndoRetweetResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension UndoRetweetResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in RetweetResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in RetweetResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in RetweetResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in RetweetResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in RetweetResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension RetweetData.CodingKeys in RetweetResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension RetweetData.CodingKeys in RetweetResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension RetweetData.CodingKeys in RetweetResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension RetweetData.CodingKeys in RetweetResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension RetweetData.CodingKeys in RetweetResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension RetweetData in RetweetResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension RetweetData in RetweetResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension RetweetResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension RetweetResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in RetweetRequest #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in RetweetRequest #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in RetweetRequest #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in RetweetRequest #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in RetweetRequest #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension RetweetRequest #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension RetweetRequest #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension CodingKeys in UnlikeResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in UnlikeResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in UnlikeResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in UnlikeResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in UnlikeResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension UnlikeData.CodingKeys in UnlikeResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension UnlikeData.CodingKeys in UnlikeResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension UnlikeData.CodingKeys in UnlikeResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension UnlikeData.CodingKeys in UnlikeResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension UnlikeData.CodingKeys in UnlikeResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension UnlikeData in UnlikeResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension UnlikeData in UnlikeResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension UnlikeResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension UnlikeResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in LikeResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in LikeResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in LikeResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in LikeResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in LikeResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LikeData.CodingKeys in LikeResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension LikeData.CodingKeys in LikeResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension LikeData.CodingKeys in LikeResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LikeData.CodingKeys in LikeResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension LikeData.CodingKeys in LikeResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LikeData in LikeResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension LikeData in LikeResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension LikeResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension LikeResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in LikeRequest #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in LikeRequest #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in LikeRequest #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in LikeRequest #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in LikeRequest #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LikeRequest #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension LikeRequest #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension CodingKeys in DeleteResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in DeleteResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in DeleteResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in DeleteResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension CodingKeys in DeleteResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension DeleteData.CodingKeys in DeleteResponse #1 in Spec.XAPIService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension DeleteData.CodingKeys in DeleteResponse #1 in Spec.XAPIService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension DeleteData.CodingKeys in DeleteResponse #1 in Spec.XAPIService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension DeleteData.CodingKeys in DeleteResponse #1 in Spec.XAPIService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension DeleteData.CodingKeys in DeleteResponse #1 in Spec.XAPIService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension DeleteData in DeleteResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension DeleteData in DeleteResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension DeleteResponse #1 in Spec.XAPIService: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension DeleteResponse #1 in Spec.XAPIService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension __C.Options: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.Options

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.Options: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.Options: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.Options: Swift.OptionSet {
    typealias Element = __C.Options

    init(rawValue: Self.RawValue)
}
extension __C.Options: Swift.SetAlgebra {
    typealias Element = __C.Options

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.HTTPMethod: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.HTTPMethod: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.HTTPMethod: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.JSONSchema.Property: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.JSONSchema.Property: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.JSONSchema.Property: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.JSONSchema.JSONType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.JSONSchema.JSONType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.JSONSchema.JSONType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.JSONSchema.JSONType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.JSONSchema.JSONType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.JSONSchema.Items: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.JSONSchema.Items: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.JSONSchema.Items: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.JSONSchema: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.JSONSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.JSONSchema: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.JSONSchema.Items.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.JSONSchema.Items.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.JSONSchema.Items.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.JSONSchema.Items.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.JSONSchema.Items.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.JSONSchema.Items.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.JSONSchema.Property.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.JSONSchema.Property.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.JSONSchema.Property.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.JSONSchema.Property.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.JSONSchema.Property.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.JSONSchema.Property.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.JSONSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.JSONSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.JSONSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.JSONSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.JSONSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.JSONSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.System: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Role: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Role: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Role: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ContentObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Content.ContentObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.ContentObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ContentObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ContentObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ContentObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ContentObject: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Content.ContentObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.Message.Content.ImageSource.MediaType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Content.ImageSource.MediaType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.ImageSource.MediaType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ImageSource.MediaType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Content.ImageSource.ImageSourceType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Content.ImageSource.ImageSourceType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.ImageSource.ImageSourceType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ImageSource.ImageSourceType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Content.ImageSource: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Content.ImageSource: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Source: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Source: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.Message.Content.DocumentSource.DocumentError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Content.DocumentSource.DocumentError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.DocumentSource.DocumentError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.MessageParameter.Message.Content.DocumentSource.MediaType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Content.DocumentSource.MediaType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.DocumentSource.MediaType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.MediaType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Content.DocumentSource.DocumentSourceType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Content.DocumentSource.DocumentSourceType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.DocumentSource.DocumentSourceType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.DocumentSourceType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Citations: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Citations: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.Message.Content.DocumentSource: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Content.DocumentSource: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.Message.Content: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message.Content: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.Message: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Message: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.MetaData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.ToolChoice.ToolType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.ToolChoice.ToolType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.ToolChoice.ToolType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.ToolChoice.ToolType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.ToolChoice.ToolType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.ToolChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.ToolChoice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Tool: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.Tool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Tool: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Cache.CacheType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Cache.CacheType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Cache.CacheType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.Cache.CacheType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Cache.CacheType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.Cache: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Cache: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.CacheControl.CacheControlType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.CacheControl.CacheControlType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.CacheControl.CacheControlType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.CacheControl.CacheControlType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.CacheControl.CacheControlType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.CacheControl: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageParameter.CacheControl: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.CacheControl: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Thinking.ThinkingType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Thinking.ThinkingType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Thinking.ThinkingType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.Thinking.ThinkingType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.Thinking: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Thinking.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Thinking.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Thinking.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Thinking.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Thinking.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Thinking.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.CacheControl.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.CacheControl.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.CacheControl.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.CacheControl.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.CacheControl.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Cache.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Cache.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Cache.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Cache.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Cache.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Tool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Tool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Tool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Tool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Tool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Tool.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.ToolChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.ToolChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.ToolChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.ToolChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.ToolChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.ToolChoice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.MetaData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.MetaData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.MetaData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.MetaData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.MetaData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.DocumentSource.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Content.DocumentSource.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Citations.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Citations.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Citations.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Citations.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Citations.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Source.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Source.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Source.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Source.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Source.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.DocumentSource.Source.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ImageSource.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ImageSource.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ImageSource.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageParameter.Message.Content.ImageSource.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageParameter.Message.Content.ImageSource.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageParameter.Message.Content.ImageSource.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageTokenCountParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageTokenCountParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageTokenCountParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageTokenCountParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageTokenCountParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageTokenCountParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.TextCompletionParameter.MetaData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.TextCompletionParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.TextCompletionParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.TextCompletionParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.TextCompletionParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.TextCompletionParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.TextCompletionParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.TextCompletionParameter.MetaData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.TextCompletionParameter.MetaData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.TextCompletionParameter.MetaData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.TextCompletionParameter.MetaData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.TextCompletionParameter.MetaData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageInputTokens: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageInputTokens.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageInputTokens.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageInputTokens.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageInputTokens.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageInputTokens.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageInputTokens.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Content.ToolUse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageResponse.Content.ToolUse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageResponse.Content.Thinking: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageResponse.Content.Thinking: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageResponse.Content.DynamicContent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageResponse.Content.DynamicContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageResponse.Content: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageResponse.Content: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageResponse.Citation.CharLocation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageResponse.Citation.CharLocation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageResponse.Citation.PageLocation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageResponse.Citation.PageLocation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageResponse.Citation.ContentBlockLocation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageResponse.Citation.ContentBlockLocation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageResponse.Citation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageResponse.Citation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageResponse.Usage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageResponse.Usage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MessageResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageResponse.Content.TextEditorCommand: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageResponse.Content.TextEditorCommand: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageResponse.Content.TextEditorCommand: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageResponse.Usage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Usage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Usage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageResponse.Usage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Usage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageResponse.Citation.ContentBlockLocation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.ContentBlockLocation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.ContentBlockLocation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageResponse.Citation.ContentBlockLocation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.ContentBlockLocation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageResponse.Citation.PageLocation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.PageLocation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.PageLocation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageResponse.Citation.PageLocation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.PageLocation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageResponse.Citation.CharLocation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.CharLocation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.CharLocation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageResponse.Citation.CharLocation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.CharLocation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageResponse.Citation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageResponse.Citation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageResponse.Citation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Citation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageResponse.Content.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Content.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Content.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageResponse.Content.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageResponse.Content.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Content.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageResponse.Content.Thinking.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Content.Thinking.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Content.Thinking.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageResponse.Content.Thinking.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Content.Thinking.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageResponse.Content.ToolUse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Content.ToolUse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Content.ToolUse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageResponse.Content.ToolUse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageResponse.Content.ToolUse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageStreamResponse.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageStreamResponse.ContentBlock: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageStreamResponse.Error: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageStreamResponse.StreamEvent: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageStreamResponse.StreamEvent: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageStreamResponse.StreamEvent: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MessageStreamResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageStreamResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageStreamResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageStreamResponse.Error.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.Error.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.Error.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageStreamResponse.Error.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.Error.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageStreamResponse.ContentBlock.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.ContentBlock.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.ContentBlock.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageStreamResponse.ContentBlock.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.ContentBlock.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageStreamResponse.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageStreamResponse.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageStreamResponse.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.TextCompletionResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.TextCompletionResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.TextCompletionResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.TextCompletionResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.TextCompletionResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.TextCompletionResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.TextCompletionStreamResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.TextCompletionStreamResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.TextCompletionStreamResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.TextCompletionStreamResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.TextCompletionStreamResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.TextCompletionStreamResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ErrorResponse.Error: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ErrorResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ErrorResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ErrorResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ErrorResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ErrorResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ErrorResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ErrorResponse.Error.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ErrorResponse.Error.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ErrorResponse.Error.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ErrorResponse.Error.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ErrorResponse.Error.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Model: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.APIError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.APIError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension __C.WritingOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.WritingOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.WritingOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.WritingOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.WritingOptions: Swift.OptionSet {
    typealias Element = __C.WritingOptions

    init(rawValue: Self.RawValue)
}
extension __C.WritingOptions: Swift.SetAlgebra {
    typealias Element = __C.WritingOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.XDMReplyPreviewView: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Text, SwiftUI.Spacer)>>>, SwiftUI.VStack<SwiftUI.ForEach<Swift.ArraySlice<Spec.XDirectMessage>, Swift.String, SwiftUI.HStack<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.Text?)>>, SwiftUI.Spacer)>, SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.Text?)>>)>>>>>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._PaddingLayout>)>>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Text, SwiftUI.Spacer)>>>, SwiftUI.VStack<SwiftUI.ForEach<Swift.ArraySlice<Spec.XDirectMessage>, Swift.String, SwiftUI.HStack<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.Text?)>>, SwiftUI.Spacer)>, SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.Text?)>>)>>>>>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._AppearanceActionModifier>Swift.String>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0030XDMReplyPreviewViewswift_eDAEifMX343_0_33_A8F11E40B349CFC31149B42DCE1340FDLl7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.CerebrasService: Spec.AnthropicService {}
extension Spec.DefaultAnthropicService: Spec.AnthropicService {}
extension Spec.GeminiService: Spec.AnthropicService {}
extension Spec.GeminiTokenCountResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GeminiTokenCountResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GeminiTokenCountResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GeminiTokenCountResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GeminiTokenCountResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GeminiTokenCountResponse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GeminiTokenCountResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GeminiUsageMetadata.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GeminiUsageMetadata.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GeminiUsageMetadata.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GeminiUsageMetadata.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GeminiUsageMetadata.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GeminiUsageMetadata: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GeminiUsageMetadata: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GeminiFunctionResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GeminiFunctionResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GeminiFunctionResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GeminiFunctionResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GeminiFunctionResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GeminiFunctionResponse.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GeminiFunctionResponse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GeminiFunctionResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GeminiFunctionCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GeminiFunctionCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GeminiFunctionCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GeminiFunctionCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GeminiFunctionCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GeminiFunctionCall.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GeminiFunctionCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GeminiFunctionCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GeminiPart.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GeminiPart.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GeminiPart.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GeminiPart.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GeminiPart.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GeminiPart: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GeminiPart: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GeminiContent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GeminiContent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GeminiContent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GeminiContent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GeminiContent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GeminiContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GeminiContent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GeminiCandidate.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GeminiCandidate.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GeminiCandidate.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GeminiCandidate.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GeminiCandidate.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GeminiCandidate: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GeminiCandidate: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GeminiResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GeminiResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GeminiResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GeminiResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GeminiResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GeminiResponse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GeminiResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GoogleVertexService: Spec.AnthropicService {}
extension Spec.GoogleVertexService.VertexModel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GoogleVertexService.VertexModel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GoogleVertexService.VertexModel: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GrokService: Spec.AnthropicService {}
extension Spec.GrokService.JSONValue: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.JSONValue: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GrokService.GrokChatCompletionRequest.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokChatCompletionRequest.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokChatCompletionRequest.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GrokService.GrokChatCompletionRequest.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokChatCompletionRequest.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokChatCompletionRequest.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokChatCompletionRequest: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GrokService.StreamOptions.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.StreamOptions.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.StreamOptions.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GrokService.StreamOptions.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.StreamOptions.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.StreamOptions.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.StreamOptions: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GrokService.GrokMessage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GrokService.GrokResponse.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokResponse.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokResponse.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GrokService.GrokResponse.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokResponse.ResponseMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokResponse.ResponseMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokResponse.ResponseMessage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GrokService.GrokResponse.ResponseMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.ResponseMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.ResponseMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.FunctionCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokResponse.ResponseMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokResponse.Usage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokResponse.Usage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokResponse.Usage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GrokService.GrokResponse.Usage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.Usage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.Usage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.Usage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokStreamingChunk.StreamChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokStreamingChunk.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.FunctionCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokStreamingChunk: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GrokService.GrokStreamingChunk.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokStreamingChunk.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.FunctionCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.FunctionCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.FunctionCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.FunctionCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.ToolCall.FunctionCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokStreamingChunk.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokStreamingChunk.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokStreamingChunk.StreamChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.StreamChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.StreamChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokStreamingChunk.StreamChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokStreamingChunk.StreamChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.FunctionCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.FunctionCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.FunctionCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.FunctionCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokResponse.ResponseMessage.ToolCall.FunctionCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GrokService.GrokMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GrokService.GrokMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GrokService.GrokMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientMLX.MLXClient: Spec.LLMClientProtocol {}
extension LocalLLMClientMLX.MLXClient: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension LocalLLMClientMLX.MLXClient: LocalLLMClientCore.LLMClient {
    typealias TextGenerator = Swift.AsyncStream<Swift.String>
    typealias ResponseGenerator = Swift.AsyncThrowingStream<LocalLLMClientCore.StreamingChunk, Swift.Error>
    typealias ResumeGenerator = Swift.AsyncThrowingStream<LocalLLMClientCore.StreamingChunk, Swift.Error>
}
extension Spec.LocalLLMService: Spec.AnthropicService {}
extension Spec.LocalLLMError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.LocalLLMError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.NovitaService: Spec.AnthropicService {}
extension Spec.OpenAIResponsesService: Spec.AnthropicService {}
extension Spec._ResumeBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec._ResumeBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec._ResumeBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec._ResumeBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec._ResumeBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec._FnOut.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec._FnOut.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec._FnOut.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec._FnOut.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec._FnOut.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec._FnOut: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec._ResumeBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIService: Spec.AnthropicService {}
extension Spec.OpenAIFunctionDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIFunctionDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIFunctionDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIFunctionDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIFunctionDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIFunctionDelta: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIFunctionDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIToolCallDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIToolCallDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIToolCallDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIToolCallDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIToolCallDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIToolCallDelta: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIToolCallDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIDelta: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIStreamChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIStreamChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIStreamChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIStreamChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIStreamChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIStreamChoice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIStreamChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIStreamChunk.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIStreamChunk.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIStreamChunk.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIStreamChunk.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIStreamChunk.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIStreamChunk: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIStreamChunk: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIUsage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIUsage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIUsage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIUsage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIUsage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIUsage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIUsage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIFunction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIFunction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIFunction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIFunction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIFunction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIFunction: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIFunction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIToolCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIMessage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIChoice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.OpenAIResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIResponse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.TogetherService: Spec.AnthropicService {}
extension __C.CompareOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.CompareOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.CompareOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.CompareOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.CompareOptions: Swift.OptionSet {
    typealias Element = __C.CompareOptions

    init(rawValue: Self.RawValue)
}
extension __C.CompareOptions: Swift.SetAlgebra {
    typealias Element = __C.CompareOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.AuthError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.AuthError: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.AuthError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.AuthViewModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.ContinueWithGoogleButton: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._FrameLayout>, SwiftUI.Text)>>>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI._FlexFrameLayout>>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>Spec.GooglePillStyleSpec.AuthError, SwiftUI.AccessibilityAttachmentModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GooglePillStyle: SwiftUI.ButtonStyle {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ButtonStyleConfiguration.Label, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.HierarchicalShapeStyle>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._OpacityEffect>

    func makeBody(configuration: SwiftUI.ButtonStyleConfiguration) -> Self.Body
}
extension Spec.GoogleMultiAccountManager.GoogleAccount: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GoogleMultiAccountManager.GoogleAccount: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GoogleMultiAccountManager.GoogleAccount: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.GoogleMultiAccountManager: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.GoogleMultiAccountManager.GoogleAccount.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GoogleMultiAccountManager.GoogleAccount.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GoogleMultiAccountManager.GoogleAccount.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GoogleMultiAccountManager.GoogleAccount.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.GoogleMultiAccountManager.GoogleAccount.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XAPISettingsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderlessButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>>>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>?)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderlessButtonStyle)>>)>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>?)>>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0027XAPISettingsViewswift_ovFAhfMX308_0_33_CBD234D87587863EFB66F4D04456F3CBLl7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension __C.StyleMask: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.StyleMask

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.StyleMask: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.StyleMask: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.StyleMask: Swift.OptionSet {
    typealias Element = __C.StyleMask

    init(rawValue: Self.RawValue)
}
extension __C.StyleMask: Swift.SetAlgebra {
    typealias Element = __C.StyleMask

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.InstagramCredentialsStore.Envelope: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.InstagramCredentialsStore.Envelope: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.InstagramCredentialsStore.Envelope.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.InstagramCredentialsStore.Envelope.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.InstagramCredentialsStore.Envelope.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.InstagramCredentialsStore.Envelope.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.InstagramCredentialsStore.Envelope.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.SignInWithGoogleButtonView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<GoogleSignInSwift.GoogleSignInButton, SwiftUI._FrameLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._ClipEffect<SwiftUI.Capsule>>Spec.AuthError

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GmailError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.GmailError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension __C.ComparisonResult: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.ComparisonResult: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageEventTestViewModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.EventValidationResult: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.ThreadListResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ThreadID: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ThreadDetail: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GmailMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Payload: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Header: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessagePart: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.EmailDetail: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CodingKeys in AttachmentResponse #1 in Spec.GmailService: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in AttachmentResponse #1 in Spec.GmailService: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in AttachmentResponse #1 in Spec.GmailService: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in AttachmentResponse #1 in Spec.GmailService: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension CodingKeys in AttachmentResponse #1 in Spec.GmailService: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.EmailDetail.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.EmailDetail.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.EmailDetail.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.EmailDetail.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.EmailDetail.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessagePart.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessagePart.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessagePart.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessagePart.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.MessagePart.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.MessageBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Header.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.Header.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.Header.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Header.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.Header.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Payload.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.Payload.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.Payload.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Payload.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.Payload.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GmailMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GmailMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GmailMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GmailMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GmailMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ThreadDetail.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ThreadDetail.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ThreadDetail.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ThreadDetail.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.ThreadDetail.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ThreadID.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ThreadID.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ThreadID.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ThreadID.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.ThreadID.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ThreadListResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ThreadListResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ThreadListResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ThreadListResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.ThreadListResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AttachmentResponse #1 in Spec.GmailService: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Phase2Participant.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Phase2Participant.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Phase2Participant.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.Phase2Participant.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.Phase2Participant.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.Phase2Participant.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.Phase2Participant: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Phase2Participant: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.AttachmentDoc: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.AttachmentDoc: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Phase2DraftedAction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Phase2DraftedAction: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Phase2Event.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Phase2Event.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Phase2Event.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.Phase2Event.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.Phase2Event.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.Phase2Event.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.Phase2Event: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Phase2Event: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.SourceDocs: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.SourceDocs: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Phase2Data.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Phase2Data.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Phase2Data.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.Phase2Data.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.Phase2Data.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.Phase2Data.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.Phase2Data: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension __C.MatchingOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.MatchingOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.MatchingOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.MatchingOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.MatchingOptions: Swift.OptionSet {
    typealias Element = __C.MatchingOptions

    init(rawValue: Self.RawValue)
}
extension __C.MatchingOptions: Swift.SetAlgebra {
    typealias Element = __C.MatchingOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.Phase2EventParser.CanonicalEventStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Phase2EventParser.CanonicalEventStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Phase2EventParser.CanonicalEventStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.Phase2DraftedAction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.Phase2DraftedAction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.Phase2DraftedAction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Phase2DraftedAction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.Phase2DraftedAction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AttachmentDoc.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.AttachmentDoc.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.AttachmentDoc.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.AttachmentDoc.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AttachmentDoc.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.AnyViewModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI._ViewModifier_Content<Spec.AnyViewModifier>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.AspectRatioModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.AspectRatioModifier>, SwiftUI._AspectRatioLayout>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.EquatableViewModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI._ViewModifier_Content<Spec.EquatableViewModifier>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.EquatableViewModifier: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SpecLeadingWatermarkModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.SpecLeadingWatermarkModifier>, SwiftUI._PaddingLayout>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._OffsetEffect>, SwiftUI._AllowsHitTestingModifier>>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.PinnedChatManager: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.FirestoreStoredMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.FirestoreStoredMessage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.FirestoreStoredMessage: Swift.Identifiable {
    typealias ID = Swift.String?

    var id: Self.ID {
        get
    }
}
extension Spec.FirestoreStoredMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.FirestoreStoredMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.FirestoreStoredMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.FirestoreStoredMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.FirestoreStoredMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.RelayChatMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.RelayChatMessage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.RelayChatMessage: Swift.Identifiable {
    typealias ID = Swift.String?

    var id: Self.ID {
        get
    }
}
extension Spec.RelayChatMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.RelayChatMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.RelayChatMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.RelayChatMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.RelayChatMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.SpecVirtualMachine: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.SpecVirtualMachine: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.SpecVirtualMachine: Swift.Identifiable {
    typealias ID = Swift.String?

    var id: Self.ID {
        get
    }
}
extension Spec.SpecVirtualMachine.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.SpecVirtualMachine.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.SpecVirtualMachine.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SpecVirtualMachine.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.SpecVirtualMachine.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DraftXDMReplyPreviewView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Text, SwiftUI.Spacer)>>>, SwiftUI.VStack<SwiftUI.ForEach<Swift.ArraySlice<Spec.XDirectMessage>, Swift.String, SwiftUI.HStack<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.Text?)>>, SwiftUI.Spacer)>, SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.Text?)>>)>>>>>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._PaddingLayout>)>>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0035DraftXDMReplyPreviewViewswift_IgGGkfMX343_0_33_EC73086B80D134D99E46CA09658DD3B5Ll7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.VirtualMachineService: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.DKEventStream: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DKEventStream: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DKEventStream: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DKEventStream: Swift.CaseIterable {
    typealias AllCases = [Spec.DKEventStream]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.ComprehensiveDKEventExtractor: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.DKEventInsightsDemo.InsightCategory: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.DKEventInsightsDemo: SwiftUI.View {
    typealias Body = SwiftUI.NavigationView<SwiftUI.List<Swift.Never, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>, SwiftUI._PaddingLayout>, SwiftUI.Spacer)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI.ForEach<[Spec.DKEventInsightsDemo.InsightCategory], Foundation.UUID, SwiftUI.Section<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>>, SwiftUI.EmptyView>>>>(SwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Text>>)?>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.DKEventInsightsDemoApp: SwiftUI.App {
    typealias Body = SwiftUI.WindowGroup<SwiftUI.ModifiedContent<Spec.DKEventInsightsDemo, SwiftUI._FrameLayout>>

    init()

    var body: Self.Body {
        get
    }
}
extension Spec.FunctionCallDefinition: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.FunctionCallDefinition: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.FunctionCallDefinition: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.FunctionCallDefinition: Swift.CaseIterable {
    typealias AllCases = [Spec.FunctionCallDefinition]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.MeetingNotesError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.MeetingNotesError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.GranolaMeetingNotesProvider: Spec.MeetingNotesProvider {}
extension Spec.QuillMeetingNotesProvider: Spec.MeetingNotesProvider {}
extension Spec.GranolaMeetingNotesProvider.ConferencingData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.ConferencingData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.ConferencingData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.ConferencingData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.ConferencingData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.ConferencingData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.ConferencingData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.NameDetailsData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.NameDetailsData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.NameDetailsData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.NameDetailsData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.NameDetailsData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.NameDetailsData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.NameDetailsData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.PersonDetailsData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.PersonDetailsData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.PersonDetailsData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.PersonDetailsData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.PersonDetailsData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.PersonDetailsData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.PersonDetailsData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDetailsData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDetailsData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDetailsData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDetailsData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDetailsData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDetailsData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDetailsData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDataCodable.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDataCodable.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDataCodable.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDataCodable.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDataCodable.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDataCodable: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.AttendeeDataCodable: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.CreatorData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.CreatorData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.CreatorData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.CreatorData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.CreatorData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.CreatorData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.CreatorData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.MeetingMetadataData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.MeetingMetadataData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.MeetingMetadataData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.MeetingMetadataData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.MeetingMetadataData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.MeetingMetadataData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.MeetingMetadataData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.DocumentData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.DocumentData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.DocumentData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.DocumentData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.DocumentData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.DocumentData.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.DocumentData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.DocumentData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.GranolaStateData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.GranolaStateData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.GranolaStateData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.GranolaStateData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.GranolaStateData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.GranolaStateData.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.GranolaStateData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.CacheData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.CacheData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.CacheData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.CacheData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.CacheData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.CacheData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.CacheWrapper.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.CacheWrapper.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.CacheWrapper.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.CacheWrapper.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.CacheWrapper.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.CacheWrapper: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.CacheWrapper: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorNode.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorNode.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorNode.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorNode.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorNode.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorNode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorNode: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorContent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorContent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorContent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorContent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorContent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.ProseMirrorContent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.Panel.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.Panel.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.Panel.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.Panel.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.Panel.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.Panel: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.Panel: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GranolaMeetingNotesProvider.TranscriptData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.TranscriptData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.TranscriptData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaMeetingNotesProvider.TranscriptData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GranolaMeetingNotesProvider.TranscriptData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GranolaMeetingNotesProvider.TranscriptData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GranolaMeetingNotesProvider.TranscriptData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageFunctionCallingObservable: Observation.Observable {}
extension __C.DocumentReadingOptionKey: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.DocumentReadingOptionKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.DocumentReadingOptionKey: Swift._SwiftNewtypeWrapper {}
extension __C.DocumentReadingOptionKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.DocumentReadingOptionKey: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.DocumentReadingOptionKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.DocumentType: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.DocumentType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.DocumentType: Swift._SwiftNewtypeWrapper {}
extension __C.DocumentType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.DocumentType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.DocumentType: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension CodingKeys in SummaryResponse #1 in Spec.MessageFunctionCallingObservable: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in SummaryResponse #1 in Spec.MessageFunctionCallingObservable: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in SummaryResponse #1 in Spec.MessageFunctionCallingObservable: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in SummaryResponse #1 in Spec.MessageFunctionCallingObservable: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension CodingKeys in SummaryResponse #1 in Spec.MessageFunctionCallingObservable: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SummaryResponse #1 in Spec.MessageFunctionCallingObservable: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SummaryResponse #1 in Spec.MessageFunctionCallingObservable: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension CacheLocation #1 in Spec.MessageFunctionCallingObservable: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CacheLocation #1 in Spec.MessageFunctionCallingObservable: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CachePoint #1 in Spec.MessageFunctionCallingObservable: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CachePoint #1 in Spec.MessageFunctionCallingObservable: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ProfileBuildCheckpoint.Checkpoint: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ProfileBuildCheckpoint.Checkpoint: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ProfileBuildCheckpoint.SourceCheckpoint: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ProfileBuildCheckpoint.SourceCheckpoint: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ProfileBuildCheckpoint.SourceCheckpoint.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ProfileBuildCheckpoint.SourceCheckpoint.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ProfileBuildCheckpoint.SourceCheckpoint.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ProfileBuildCheckpoint.SourceCheckpoint.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.ProfileBuildCheckpoint.SourceCheckpoint.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ProfileBuildCheckpoint.Checkpoint.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ProfileBuildCheckpoint.Checkpoint.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ProfileBuildCheckpoint.Checkpoint.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ProfileBuildCheckpoint.Checkpoint.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.ProfileBuildCheckpoint.Checkpoint.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.EnrichedContactsListView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>)>>, SwiftUI._FlexFrameLayout>>, SwiftUI.List<Swift.String, SwiftUI.ForEach<[Spec.SimpleContactItem], Swift.String, SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.Text>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.Text?)>>)>>, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>)>>>SwiftUI.PlainButtonStyle>>>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SimpleContactItem: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.DraftSlackReplyPreviewView: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>>, SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>, SwiftUI.Spacer?)>>>>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._FlexFrameLayout>SwiftUI.EnabledTextSelectability, SwiftUI.Text)>)>>, SwiftUI._PaddingLayout>)>>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._AppearanceActionModifier>Swift.String>, SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>>, SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>, SwiftUI.Spacer?)>>>>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._AppearanceActionModifier>Swift.String>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension __C.MutabilityOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.MutabilityOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.MutabilityOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.MutabilityOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.MutabilityOptions: Swift.OptionSet {
    typealias Element = __C.MutabilityOptions

    init(rawValue: Self.RawValue)
}
extension __C.MutabilityOptions: Swift.SetAlgebra {
    typealias Element = __C.MutabilityOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.ScreenTimeError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.ScreenTimeError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.ScreenTimeDevice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ScreenTimeDevice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.AppUsageData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.AppUsageData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DailyScreenTime: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DailyScreenTime: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ScreenTimeReport: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ScreenTimeReport: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ScreenTimeExtractor: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension __C.URLResourceKey: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.URLResourceKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.URLResourceKey: Swift._SwiftNewtypeWrapper {}
extension __C.URLResourceKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.URLResourceKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.URLResourceKey: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension Spec.ScreenTimeReport.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ScreenTimeReport.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ScreenTimeReport.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ScreenTimeReport.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.ScreenTimeReport.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DailyScreenTime.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DailyScreenTime.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DailyScreenTime.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DailyScreenTime.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.DailyScreenTime.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AppUsageData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.AppUsageData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.AppUsageData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.AppUsageData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.AppUsageData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ScreenTimeDevice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ScreenTimeDevice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ScreenTimeDevice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ScreenTimeDevice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.ScreenTimeDevice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.ActivationPolicy: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.ActivationPolicy: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.TestComprehensiveDKEventView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>, SwiftUI.Text, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.LinearProgressViewStyle, SwiftUI._FrameLayout>)>?, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>SwiftUI.EnabledTextSelectability>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.IncrementalProfileBuilderFunction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.IncrementalProfileBuilderFunction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.IncrementalProfileBuilderFunction: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.IncrementalProfileBuilderFunction: Swift.CaseIterable {
    typealias AllCases = [Spec.IncrementalProfileBuilderFunction]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.UserProfileBuilderFunction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.UserProfileBuilderFunction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.UserProfileBuilderFunction: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.UserProfileBuilderFunction: Swift.CaseIterable {
    typealias AllCases = [Spec.UserProfileBuilderFunction]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.ProfileDataRow: SwiftUI.View {
    typealias Body = SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AnyAppProgress: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.AnyAppProgress: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AnyAppProgress: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ProfileBuilderProgressView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.LinearProgressViewStyle, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Spec.AnyAppProgress], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._FrameLayout>)>>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>?)>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ProfileBuilderCompletionView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ProfileBuilderOnboardingView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.SymbolRenderingMode?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(Spec.ProfileDataRow, Spec.ProfileDataRow, Spec.ProfileDataRow, Spec.ProfileDataRow, Spec.ProfileDataRow)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, (SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)?, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ProfileBuilderError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.ProfileBuilderError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.ExtractionPhase: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExtractionPhase: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AppScanProgress: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.AppScanProgress: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AppScanProgress: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.UserProfileBuilderService: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.DatabaseError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.DatabaseError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.AppleNotesError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.AppleNotesError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.AttendeeStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.AttendeeStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.CalendarError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.CalendarError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.CalendarError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.GranolaError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.GranolaError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.HandleType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.HandleType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessagesDBAccessError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessagesDBAccessError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessagesDBAccessError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.AttachmentType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.AttachmentType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.NotionError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.NotionError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.QuillError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.QuillError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.QuillError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.QuillError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.KGNodeType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGNodeType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KGNodeType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.KGNodeType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KGNodeType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.KGEdgeType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGEdgeType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KGEdgeType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.KGEdgeType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KGEdgeType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.PersonUserNode.TripLocation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.PersonUserNode.TripLocation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.PersonUserNode: Spec.KGNode {}
extension Spec.PersonUserNode: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.PersonUserNode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.PersonContactNode: Spec.KGNode {}
extension Spec.PersonContactNode: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.PersonContactNode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ContactMethodNode.ContactType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactMethodNode.ContactType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ContactMethodNode.ContactType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ContactMethodNode.ContactType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ContactMethodNode.ContactType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ContactMethodNode: Spec.KGNode {}
extension Spec.ContactMethodNode: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ContactMethodNode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.EmploymentEduNode: Spec.KGNode {}
extension Spec.EmploymentEduNode: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.EmploymentEduNode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.EventNode.EventType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.EventNode.EventType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.EventNode.EventType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.EventNode.EventType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.EventNode.EventType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.EventNode: Spec.KGNode {}
extension Spec.EventNode: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.EventNode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentNode.DocumentType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentNode.DocumentType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentNode.DocumentType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DocumentNode.DocumentType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentNode.DocumentType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentNode: Spec.KGNode {}
extension Spec.DocumentNode: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentNode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.PlaceNode.PlaceType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PlaceNode.PlaceType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PlaceNode.PlaceType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.PlaceNode.PlaceType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.PlaceNode.PlaceType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.PlaceNode: Spec.KGNode {}
extension Spec.PlaceNode: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.PlaceNode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ProjectTopicNode: Spec.KGNode {}
extension Spec.ProjectTopicNode: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ProjectTopicNode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.KGEdge: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KGEdge: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.WorkThread: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.WorkThread: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.KGProcessingStatus.ProcessingPhase: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGProcessingStatus.ProcessingPhase: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KGProcessingStatus.ProcessingPhase: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.KGProcessingStatus.ProcessingPhase: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KGProcessingStatus.ProcessingPhase: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.KGProcessingStatus.ProcessingStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGProcessingStatus.ProcessingStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KGProcessingStatus.ProcessingStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.KGProcessingStatus.ProcessingStatus: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KGProcessingStatus.ProcessingStatus: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.KGProcessingStatus: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KGProcessingStatus: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.KGHighlights.ContactHighlight: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KGHighlights.ContactHighlight: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.KGHighlights.TripHighlight: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KGHighlights.TripHighlight: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.KGHighlights: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KGHighlights: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DataSourceStatus.DataSource: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DataSourceStatus.DataSource: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DataSourceStatus.DataSource: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DataSourceStatus.DataSource: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DataSourceStatus.DataSource: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DataSourceStatus.DataSource: Swift.CaseIterable {
    typealias AllCases = [Spec.DataSourceStatus.DataSource]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.DataSourceStatus.SyncStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DataSourceStatus.SyncStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DataSourceStatus.SyncStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DataSourceStatus.SyncStatus: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DataSourceStatus.SyncStatus: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DataSourceStatus: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DataSourceStatus: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DataSourceStatus.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DataSourceStatus.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DataSourceStatus.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DataSourceStatus.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DataSourceStatus.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KGHighlights.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.KGHighlights.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.KGHighlights.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGHighlights.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.KGHighlights.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KGHighlights.TripHighlight.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.KGHighlights.TripHighlight.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.KGHighlights.TripHighlight.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGHighlights.TripHighlight.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.KGHighlights.TripHighlight.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KGHighlights.ContactHighlight.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.KGHighlights.ContactHighlight.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.KGHighlights.ContactHighlight.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGHighlights.ContactHighlight.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.KGHighlights.ContactHighlight.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KGProcessingStatus.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.KGProcessingStatus.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.KGProcessingStatus.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGProcessingStatus.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.KGProcessingStatus.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.WorkThread.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.WorkThread.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.WorkThread.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.WorkThread.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.WorkThread.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KGEdge.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.KGEdge.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.KGEdge.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGEdge.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.KGEdge.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ProjectTopicNode.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ProjectTopicNode.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ProjectTopicNode.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ProjectTopicNode.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ProjectTopicNode.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PlaceNode.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.PlaceNode.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.PlaceNode.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PlaceNode.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.PlaceNode.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentNode.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentNode.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentNode.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentNode.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentNode.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.EventNode.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.EventNode.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.EventNode.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.EventNode.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.EventNode.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.EmploymentEduNode.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.EmploymentEduNode.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.EmploymentEduNode.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.EmploymentEduNode.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.EmploymentEduNode.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ContactMethodNode.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ContactMethodNode.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ContactMethodNode.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactMethodNode.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ContactMethodNode.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PersonContactNode.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.PersonContactNode.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.PersonContactNode.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PersonContactNode.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.PersonContactNode.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PersonUserNode.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.PersonUserNode.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.PersonUserNode.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PersonUserNode.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.PersonUserNode.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PersonUserNode.TripLocation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.PersonUserNode.TripLocation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.PersonUserNode.TripLocation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PersonUserNode.TripLocation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.PersonUserNode.TripLocation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KnowledgeGraphBuilder: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.KnowledgeGraphLLMAgent.LogEntry: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.KnowledgeGraphLLMAgent.SystemPromptPhase: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KnowledgeGraphLLMAgent.SystemPromptPhase: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KnowledgeGraphLLMAgent.KGAgentError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.KnowledgeGraphLLMAgent.KGAgentError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.KnowledgeGraphLLMAgent: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.ThreadDiscoveryService.LLMModel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ThreadDiscoveryService.LLMModel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ThreadDiscoveryService.ThreadDiscoveryError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.ThreadDiscoveryService.ThreadDiscoveryError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.ThreadDiscoveryService: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.ThreadDiscoveryService.LLMThreadResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ThreadDiscoveryService.LLMThreadResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ThreadDiscoveryService.LLMThreadResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ThreadDiscoveryService.LLMThreadResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.ThreadDiscoveryService.LLMThreadResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ThreadDiscoveryService.LLMThreadResponse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ThreadDiscoveryService.LLMThreadResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KnowledgeGraphExtractionTestView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text>>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text?)>>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.TupleView<(SwiftUI.ForEach<Swift.ArraySlice<Spec.Message>, Swift.String?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>?)>>>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.Node)], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>>, SwiftUI.Text?)>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>, SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.KnowledgeGraphLLMSimpleTestView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle)>>, SwiftUI.Text, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI.Text)>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)>>, SwiftUI.Text, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Text)>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._FlexFrameLayout>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>Spec.EntityResultsView, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.KnowledgeGraphLLMSimpleTestViewModel.ExtractedEntity: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.KnowledgeGraphLLMSimpleTestViewModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.EntityResultsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.NavigationView<SwiftUI.List<Swift.Never, SwiftUI.ForEach<[Spec.KnowledgeGraphLLMSimpleTestViewModel.ExtractedEntity], Foundation.UUID, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>>>SwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Text>>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.KnowledgeGraphLLMTest.TimeRange: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KnowledgeGraphLLMTest.TimeRange: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KnowledgeGraphLLMTest.TimeRange: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.KnowledgeGraphLLMTest.TimeRange: Swift.CaseIterable {
    typealias AllCases = [Spec.KnowledgeGraphLLMTest.TimeRange]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.KnowledgeGraphLLMTest.TestError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KnowledgeGraphLLMTest.TestError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KnowledgeGraphLLMTest.TestError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.KnowledgeGraphLLMTest.TestError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.KnowledgeGraphLLMTest: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.KnowledgeGraphLLMTestView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Picker<SwiftUI.Text, Spec.KnowledgeGraphLLMTest.TimeRange, SwiftUI.ForEach<[Spec.KnowledgeGraphLLMTest.TimeRange], Spec.KnowledgeGraphLLMTest.TimeRange, SwiftUI.TextSpec.KnowledgeGraphLLMTest.TimeRange>>SwiftUI.SegmentedPickerStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, (SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>SwiftUI.LinearProgressViewStyle)?, SwiftUI.Text?)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Button<SwiftUI.Text>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>, SwiftUI.Text>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>Spec.EntityListView

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EntityListView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.NavigationView<SwiftUI.List<Swift.Never, SwiftUI.ForEach<[Spec.KnowledgeGraphLLMTest.ExtractedEntity], Swift.String, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>>>SwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Text>>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.KnowledgeGraphLLMTestView_Previews: SwiftUI.PreviewProvider {
    typealias Previews = Spec.KnowledgeGraphLLMTestView

    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var previews: Self.Previews {
        get
    }
}
extension Spec.KnowledgeGraphLLMTestView_Previews: SwiftUI._PreviewProvider {
    static var _previews: Any {
        get
    }
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
}
extension Spec.TestKnowledgeGraphView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text, SwiftUI.Text?, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[Spec.DataSourceStatus], Spec.DataSourceStatus.DataSource, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text, SwiftUI.Text?)>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Swift.String)], Swift.Int, SwiftUI.Text>>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[Spec.WorkThread], Swift.String, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessageCollector: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.MessageCollectorError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageCollectorError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageCollectorError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.BasicSemanticSearch: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.CipherEnvelope: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.CipherEnvelope: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.CipherEnvelope: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.EncryptedSync: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.EncryptedSyncError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.EncryptedSyncError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.EncryptedSyncError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.CipherEnvelope.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.CipherEnvelope.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.CipherEnvelope.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.CipherEnvelope.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.CipherEnvelope.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ContactResolver: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.DeviceKey: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.CryptoError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.EncryptedMessage: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.EncryptedMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.EncryptedMessage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.EncryptedMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.EncryptedMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.EncryptedMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.EncryptedMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.EncryptedMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KeychainError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KeychainError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KeychainError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.MessageRecord: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageRecord: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.HandleRecord: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.HandleRecord: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ChatRecord: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ChatRecord: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.AttachmentRecord: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.AttachmentRecord: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.AttachmentRecord.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.AttachmentRecord.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.AttachmentRecord.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.AttachmentRecord.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.AttachmentRecord.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ChatRecord.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ChatRecord.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ChatRecord.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ChatRecord.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ChatRecord.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.HandleRecord.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.HandleRecord.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.HandleRecord.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.HandleRecord.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.HandleRecord.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageRecord.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageRecord.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageRecord.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageRecord.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageRecord.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DraftConversationDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.AnyView>, SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.AnyView>>?>, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.XAuthError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.XAuthError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.MLXSemanticSearch: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.PeerDirectory: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.PeerDirectoryError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PeerDirectoryError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PeerDirectoryError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.SearchResult: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.SemanticSearchManager: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.VecturaKitSemanticSearch: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.VecturaError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.VecturaError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.VecturaError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.VecturaError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.VecturaKitSemanticSearch.IndexMetadata.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.VecturaKitSemanticSearch.IndexMetadata.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.VecturaKitSemanticSearch.IndexMetadata.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.VecturaKitSemanticSearch.IndexMetadata.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.VecturaKitSemanticSearch.IndexMetadata.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.VecturaKitSemanticSearch.IndexMetadata: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.VecturaKitSemanticSearch.IndexMetadata: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MailRAGInboxView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.NavigationStack<SwiftUI.NavigationPath, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>?, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._ValueActionModifier<Swift.String>>, (SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle)?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>SwiftUI.BorderlessButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ContentUnavailableView<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Text?, SwiftUI.EmptyView>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>, SwiftUI._ConditionalContent<SwiftUI.ContentUnavailableView<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Text?, SwiftUI.EmptyView>, SwiftUI.List<Swift.Never, SwiftUI.ForEach<[Spec.EncryptedMessage], Swift.String, Spec.MessageRowView>>SwiftUI.PlainListStyle>>, SwiftUI.Spacer)>>SwiftUI.TupleToolbarContent<(SwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Text>>, SwiftUI.ToolbarItem<(), SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>, SwiftUI.Image>>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>>, SwiftUI.ToolbarItem<(), SwiftUI.Menu<SwiftUI.Image, SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Divider, SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>, SwiftUI.Divider, SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>>>)>Spec.EncryptedMessageSpec.MessageDetailViewSwiftUI.Button<SwiftUI.Text>SwiftUI.Text>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessageRowView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>>, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>??)>>, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessageDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.NavigationStack<SwiftUI.NavigationPath, SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?, SwiftUI.Text?, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>SwiftUI.EnabledTextSelectability, SwiftUI.Spacer)>>>SwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Text>>>, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FirstRunInstaller: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.DraftEmailReplyPreviewView: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI.Spacer)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>?, SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer)>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OpacityEffect>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<Spec.VisualEffectView>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>)>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>)>>, SwiftUI._PaddingLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OpacityEffect>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.NodeData: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.EdgeData: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.GraphViewModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.GraphView: SwiftUI.View {
    typealias Body = Grape.ForceDirectedGraph<Swift.String, Grape._PairedGraphContent<Grape.Series<Swift.String, [Spec.NodeData], Grape.ModifiedGraphContent<Grape.NodeMark<Swift.String>, Grape.GraphContentEffect.Shading>>, Grape.Series<Swift.String, [Spec.EdgeData], Grape.LinkMark<Swift.String>>, Swift.String>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.NodeType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.NodeType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.NodeType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.NodeType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.NodeType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Node: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Node: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Node: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Node: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Edge: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Edge: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Edge: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Edge: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.CodableValue: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.CodableValue: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.CodableValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.CodableValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.KGDelta: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.KGDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.KGDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.KGDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.KGDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.KGDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.CodableValue.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.CodableValue.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.CodableValue.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.CodableValue.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.CodableValue.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Edge.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.Edge.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.Edge.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Edge.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.Edge.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Node.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.Node.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.Node.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Node.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.Node.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.LocalChatService: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.LocalChatService: Spec.ChatServiceProtocol {}
extension Spec.LocalThreadService: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.FirestoreToLocalChatMigrator.MigrationError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.FirestoreToLocalChatMigrator.MigrationError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.FirestoreToLocalChatMigrator.MigrationError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.FirestoreToLocalChatMigrator: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.LocalChatThread: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.LocalChatThread: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.LocalStoredMessage: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.LocalStoredMessage: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.LocalPaginationCursor: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ModelManager: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.DBNode: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DBNode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DBNode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DBNode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DBEdge: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DBEdge: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GraphDatabaseError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.DBEdge.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DBEdge.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DBEdge.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DBEdge.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DBEdge.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DBNode.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DBNode.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DBNode.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DBNode.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DBNode.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ExtractionError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExtractionError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ExtractionError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.ExtractionError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.MessageCommitmentTestView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Toggle<SwiftUI.Text>SwiftUI.SwitchToggleStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text?)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI.Text)>>?, SwiftUI._ConditionalContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.Contact)], Swift.Int, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>SwiftUI.PlainButtonStyle>>, SwiftUI._PaddingLayout>>, SwiftUI.Text>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._PaddingLayout>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>)>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, (SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)?)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>SwiftUI.EnabledTextSelectability>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.ForEach<[Spec.CommitmentValidationResult], Foundation.UUID, Spec.CommitmentValidationResultRow>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI._PaddingLayout>>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0036MessageCommitmentTestViewswift_tjBBlfMX406_0_33_51422BF8EC5C729106D29ABBC979E2A9Ll7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.CommitmentValidationResultRow: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>?, SwiftUI.Text?)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI.ModifiedContent<SwiftUI.DisclosureGroup<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Spacer)>>>>, SwiftUI._PaddingLayout>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PersonalStyleDatasetExporter.Record: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.PersonalStyleDatasetExporter.ChatMessage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.PersonalStyleDatasetExporter.ChatSample: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.PersonalStyleDatasetExporter.ChatSample.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.PersonalStyleDatasetExporter.ChatSample.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.PersonalStyleDatasetExporter.ChatSample.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PersonalStyleDatasetExporter.ChatSample.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.PersonalStyleDatasetExporter.ChatSample.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PersonalStyleDatasetExporter.ChatMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.PersonalStyleDatasetExporter.ChatMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.PersonalStyleDatasetExporter.ChatMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PersonalStyleDatasetExporter.ChatMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.PersonalStyleDatasetExporter.ChatMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PersonalStyleDatasetExporter.Record.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.PersonalStyleDatasetExporter.Record.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.PersonalStyleDatasetExporter.Record.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PersonalStyleDatasetExporter.Record.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.PersonalStyleDatasetExporter.Record.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ChatTitleModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.ContactOverview.AppIdentity: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview.Container: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview.Container: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.ContactOverview.WeeklyStats: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview.ResponseStats: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview.SocialLink: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview.Address: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview.Employment: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview.Education: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview.Topic: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview.RelatedContact: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview.ChannelMetrics: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactOverview: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Phase2Task.TaskSource: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Phase2Task.TaskSource: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Phase2Task.TaskPriority: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Phase2Task.TaskPriority: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Phase2Task: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.ThinkingState: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.Todo.TodoType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Todo.TodoType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Todo.TodoType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.Todo.TodoType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Todo.TodoType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Todo.TodoType: Swift.CaseIterable {
    typealias AllCases = [Spec.Todo.TodoType]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.Todo.Priority: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Todo.Priority: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Todo.Priority: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.Todo.Priority: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Todo.Priority: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Todo.Priority: Swift.CaseIterable {
    typealias AllCases = [Spec.Todo.Priority]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.Todo.Category: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Todo.Category: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Todo.Category: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.Todo.Category: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Todo.Category: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Todo.Category: Swift.CaseIterable {
    typealias AllCases = [Spec.Todo.Category]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.Todo: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.Todo: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Todo: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Todo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Todo.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.Todo.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.Todo.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.Todo.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Todo.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.Todo.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.BrowserManager: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.BrowserManager.BrowserKind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.BrowserManager.BrowserKind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.BrowserManager.BrowserKind: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.EmbeddedBrowserController.Mode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.EmbeddedBrowserController.Mode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.EmbeddedBrowserController: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.EmbeddedBrowserRepresentable: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.WKWebView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.EmbeddedBrowserRepresentable: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EmbeddedBrowserOverlayView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Group<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._BackgroundStyleModifier<SwiftUI.Material>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.EmbeddedBrowserRepresentable, SwiftUI._AllowsHitTestingModifier>, SwiftUI._FrameLayout>, SwiftUI._ScaleEffect>, SwiftUI._ClipEffect<SwiftUI.Rectangle>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.Circle>>>SwiftUI.PlainButtonStyle, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>>?>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._AnimationModifier<Spec.EmbeddedBrowserController.Mode>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AppleIntelligenceService.AvailableModel: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.AppleIntelligenceService.AvailableModel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.AppleIntelligenceError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.AppleIntelligenceError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension __C.SFSpeechRecognizerAuthorizationStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.AuthHealthService: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.BackgroundServiceTracker: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.SingleFlight: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.BrowserSearchService.BrowserType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.BrowserSearchService.BrowserType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.BrowserSearchService.BrowserType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ConnectivityService: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.ContactMessagingInfo: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ContactMessagingInfo: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ChannelOption: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ChannelOption: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ContactMessagingError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.ContactMessagingError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.ChannelOption.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ChannelOption.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ChannelOption.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ChannelOption.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ChannelOption.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ContactMessagingInfo.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ContactMessagingInfo.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ContactMessagingInfo.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactMessagingInfo.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ContactMessagingInfo.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DraftConversationListView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.ForEach<[Spec.DraftListItem], Swift.String, SwiftUI.ModifiedContent<Spec.DraftConversationRowView, SwiftUI._PaddingLayout>>>>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>>>, SwiftUI._ClipEffect<SwiftUI.Rectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.DevicePresenceService: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension __C.DocumentChangeType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DigitalWellbeingService: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.DigitalWellbeingNudgeView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.VisualEffectBlurView, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.LumaKeyVideoView, SwiftUI._FrameLayout>, SwiftUI._OpacityEffect>, SwiftUI._ScaleEffect>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._TraitWritingModifier<SwiftUI.ZIndexTraitKey>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>>Spec.OverlayPillButtonStyle, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>>Spec.OverlayPillButtonStyle)>>, SwiftUI._PaddingLayout>)>>)>>, SwiftUI._OpacityEffect>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.VisualEffectBlurView: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSVisualEffectView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.VisualEffectBlurView: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.OverlayPillButtonStyle: SwiftUI.ButtonStyle {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ButtonStyleConfiguration.Label, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI._ScaleEffect>, SwiftUI._AnimationModifier<Swift.Bool>>

    func makeBody(configuration: SwiftUI.ButtonStyleConfiguration) -> Self.Body
}
extension __C.CollectionBehavior: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.CollectionBehavior

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.CollectionBehavior: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.CollectionBehavior: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.CollectionBehavior: Swift.OptionSet {
    typealias Element = __C.CollectionBehavior

    init(rawValue: Self.RawValue)
}
extension __C.CollectionBehavior: Swift.SetAlgebra {
    typealias Element = __C.CollectionBehavior

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.CGWindowListOption: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.CGWindowListOption

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.CGWindowListOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.CGWindowListOption: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.CGWindowListOption: Swift.OptionSet {
    typealias Element = __C.CGWindowListOption

    init(rawValue: Self.RawValue)
}
extension __C.CGWindowListOption: Swift.SetAlgebra {
    typealias Element = __C.CGWindowListOption

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.NSDeviceDescriptionKey: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.NSDeviceDescriptionKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.NSDeviceDescriptionKey: Swift._SwiftNewtypeWrapper {}
extension __C.NSDeviceDescriptionKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.NSDeviceDescriptionKey: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.NSDeviceDescriptionKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.ActivationOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.ActivationOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.ActivationOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.ActivationOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.ActivationOptions: Swift.OptionSet {
    typealias Element = __C.ActivationOptions

    init(rawValue: Self.RawValue)
}
extension __C.ActivationOptions: Swift.SetAlgebra {
    typealias Element = __C.ActivationOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.AXValueType: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.AXError: Swift.RawRepresentable {
    typealias RawValue = Swift.Int32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.AXError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DraftsPageIndicatorView: SwiftUI.View {
    typealias Body = SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.IconWithBadge, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>, SwiftUI.Color>>>>>SwiftUI.PlainButtonStyle>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>>>, SwiftUI._AppearanceActionModifier>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.IconWithBadge: SwiftUI.View {
    typealias Body = SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>, SwiftUI._OffsetEffect>?)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.DocumentWriter.FormatDef.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentWriter.FormatDef.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentWriter.FormatDef.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DocumentWriter.FormatDef.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.FormatDef.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.FormatDef.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.FormatDef: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.FormatDef: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.RunSpec: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.RunSpec: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.ParagraphSpec.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentWriter.ParagraphSpec.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentWriter.ParagraphSpec.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DocumentWriter.ParagraphSpec.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.ParagraphSpec.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.ParagraphSpec.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.ParagraphSpec: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.ParagraphSpec: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.HeadingSpec: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.HeadingSpec: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.TableCellSpec: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.TableCellSpec: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.TableRowSpec: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.TableRowSpec: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.TableSpec: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.TableSpec: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.ImageSpec.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentWriter.ImageSpec.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentWriter.ImageSpec.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DocumentWriter.ImageSpec.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.ImageSpec.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.ImageSpec.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.ImageSpec: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.ImageSpec: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.PageBreakSpec: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.PageBreakSpec: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.DocumentSpec.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentWriter.DocumentSpec.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentWriter.DocumentSpec.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DocumentWriter.DocumentSpec.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.DocumentSpec.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.DocumentSpec.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.DocumentSpec: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.DocumentSpec: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.ContentBlock: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.ContentBlock: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.AnyCodable: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DocumentWriter.AnyCodable: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DocumentWriter.PageBreakSpec.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.PageBreakSpec.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.PageBreakSpec.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentWriter.PageBreakSpec.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.PageBreakSpec.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentWriter.TableSpec.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.TableSpec.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.TableSpec.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentWriter.TableSpec.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.TableSpec.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentWriter.TableRowSpec.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.TableRowSpec.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.TableRowSpec.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentWriter.TableRowSpec.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.TableRowSpec.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentWriter.TableCellSpec.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.TableCellSpec.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.TableCellSpec.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentWriter.TableCellSpec.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.TableCellSpec.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentWriter.HeadingSpec.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.HeadingSpec.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.HeadingSpec.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentWriter.HeadingSpec.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.HeadingSpec.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DocumentWriter.RunSpec.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.RunSpec.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.RunSpec.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DocumentWriter.RunSpec.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DocumentWriter.RunSpec.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ExcelWriter.FormatDef: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ExcelWriter.FormatDef: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExcelWriter.ChartType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExcelWriter.ChartType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ExcelWriter.ChartType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.TitleServiceError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.TitleServiceError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.OpenAIChoiceMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIChoiceMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIChoiceMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIChoiceMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.OpenAIChoiceMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIChoiceMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.OpenAIChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIChatCompletionsResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIChatCompletionsResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIChatCompletionsResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIChatCompletionsResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.OpenAIChatCompletionsResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.OpenAIMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIMessage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.OpenAIChatCompletionsRequest.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.OpenAIChatCompletionsRequest.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.OpenAIChatCompletionsRequest.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIChatCompletionsRequest.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIChatCompletionsRequest.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.OpenAIChatCompletionsRequest.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.OpenAIChatCompletionsResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.OpenAIChatCompletionsRequest: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GlobalChatRegistry: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.GodLogger.Category: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GodLogger.Category: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GodLogger.Category: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GodLogger.Category: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GodLogger.Category: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GodLogger.Level: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GodLogger.Level: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GodLogger.Level: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.GodLogger.Level: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GodLogger.Level: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GodLogger.Entry: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.GodLogger.Entry: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.GodLogger.Entry: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.GodLogger: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.GodLogger.Entry.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.GodLogger.Entry.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.GodLogger.Entry.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GodLogger.Entry.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.GodLogger.Entry.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AuthViewModelAccessor: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.GoogleAccountsAccessor: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.GranolaWatcherError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.GranolaWatcherError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.IntraDayPrepService.TimeSlot: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.IntraDayPrepService.TimeSlot: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.IntraDayPrepService.TimeSlot: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.InviteService.InviteCode: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.LLMBannedError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.LLMBannedError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.AsyncSemaphore: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.LLMWorkScheduler.Category: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.LLMWorkScheduler.Category: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.LLMWorkScheduler: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.MCAGeminiRequest: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MCAGeminiRequest: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MCAGeminiContent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MCAGeminiContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MCAGeminiPart: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MCAGeminiPart: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MCAGeminiGenerationConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MCAGeminiGenerationConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MCAGeminiResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MCAGeminiResponse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MCAGeminiCandidate: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MCAGeminiCandidate: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MCAGeminiCandidate.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MCAGeminiCandidate.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MCAGeminiCandidate.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MCAGeminiCandidate.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.MCAGeminiCandidate.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MCAGeminiResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MCAGeminiResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MCAGeminiResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MCAGeminiResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.MCAGeminiResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MCAGeminiGenerationConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MCAGeminiGenerationConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MCAGeminiGenerationConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MCAGeminiGenerationConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.MCAGeminiGenerationConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MCAGeminiPart.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MCAGeminiPart.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MCAGeminiPart.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MCAGeminiPart.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.MCAGeminiPart.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MCAGeminiContent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MCAGeminiContent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MCAGeminiContent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MCAGeminiContent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.MCAGeminiContent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MCAGeminiRequest.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MCAGeminiRequest.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MCAGeminiRequest.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MCAGeminiRequest.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.MCAGeminiRequest.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageWatcherError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.MessageWatcherError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.OpenAIResponsesProvider.Message.Role: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIResponsesProvider.Message.Role: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.OpenAIResponsesProvider.Message.Role: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.OpenAIResponsesProvider.Message: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.OpenAIResponsesProvider.Message: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIResponsesProvider.ToolCall: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.OpenAIResponsesProvider.ToolCall: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.OpenAIResponsesProvider: Observation.Observable {}
extension Spec.OpenAIResponsesStreamHandler: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.OpenAIServiceWrapper: Spec.AnthropicService {}
extension Spec.OpenAIToolCallHandler: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.ToolError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.ToolError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.PairingSyncService: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.Phase2TaskManager: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.QuillWatcherError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.QuillWatcherError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.RemoteAccessControlService: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.ReplyDraftingService.DraftParseError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.ResponseStreamProvider.ResponseMessage.MessageRole: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ResponseStreamProvider.ResponseMessage.MessageRole: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ResponseStreamProvider.ResponseMessage: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.ResponseStreamProvider: Observation.Observable {}
extension Spec.SlackUserMeta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.SlackUserMeta: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.SlackConversationMeta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.SlackConversationMeta: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.AnyCodable: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.AnyCodable: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.SlackAccountSummary: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.SlackAccountSummary: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.SlackAccountSummary: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.SlackAccountSummary.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.SlackAccountSummary.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.SlackAccountSummary.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SlackAccountSummary.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.SlackAccountSummary.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.SlackConversationMeta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.SlackConversationMeta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.SlackConversationMeta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SlackConversationMeta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.SlackConversationMeta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.SlackUserMeta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.SlackUserMeta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.SlackUserMeta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SlackUserMeta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.SlackUserMeta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.TodoManager: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.BackupError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.BackupError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension __C.UNAuthorizationOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.UNAuthorizationOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.UNAuthorizationOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.UNAuthorizationOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.UNAuthorizationOptions: Swift.OptionSet {
    typealias Element = __C.UNAuthorizationOptions

    init(rawValue: Self.RawValue)
}
extension __C.UNAuthorizationOptions: Swift.SetAlgebra {
    typealias Element = __C.UNAuthorizationOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.Base64EncodingOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.Base64EncodingOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.Base64EncodingOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.Base64EncodingOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.Base64EncodingOptions: Swift.OptionSet {
    typealias Element = __C.Base64EncodingOptions

    init(rawValue: Self.RawValue)
}
extension __C.Base64EncodingOptions: Swift.SetAlgebra {
    typealias Element = __C.Base64EncodingOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.ModalResponse: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.ModalResponse: Swift._SwiftNewtypeWrapper {}
extension __C.ModalResponse: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.ModalResponse: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.ModalResponse: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSNumber

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.ModalResponse: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DraftMessagesReplyPreviewView: SwiftUI.View {
    typealias Body = SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ScrollViewReader<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.IDView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI._PaddingLayout>, Swift.String>?, SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>, SwiftUI.ForEach<[(offset: Swift.Int, element: (message: Spec.Message, reactions: [Swift.String]))], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._FlexFrameLayout>, SwiftUI._OverlayModifier<SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Swift.String)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._ShadowEffect>>>>>, SwiftUI._OffsetEffect>?>>>, SwiftUI.Spacer?)>>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>>, SwiftUI._PaddingLayout>, SwiftUI.IDView<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._PaddingLayout>, Swift.String>, SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>)>>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>Swift.Int>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>)>>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>, SwiftUI._BlendModeEffect>>>, SwiftUI._CompositingGroupEffect>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>?)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>>, SwiftUI._PaddingLayout>)>>, SwiftUI._FlexFrameLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<Spec.DraftContextDisplayView, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>, SwiftUI._FlexFrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer)>>)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>Swift.String>Swift.String?Swift.String?

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ActionExecutor: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionExecutor: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ActionExecutor: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ActionExecutor: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ActionExecutor: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ActionStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ActionStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ActionStatus: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ActionStatus: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.RetryPolicy.Backoff: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.RetryPolicy.Backoff: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.RetryPolicy.Backoff: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.RetryPolicy.Backoff: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.RetryPolicy.Backoff: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.RetryPolicy: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.RetryPolicy: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.RetryPolicy: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionResult: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ActionResult: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ActionResult: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Action: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.Action: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.Action: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Action: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.Action.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.Action.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.Action.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Action.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.Action.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ActionResult.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ActionResult.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ActionResult.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionResult.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ActionResult.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.RetryPolicy.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.RetryPolicy.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.RetryPolicy.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.RetryPolicy.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.RetryPolicy.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ActionSet: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ActionSet: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ActionSet: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionSet: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.ActionSet.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ActionSet.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ActionSet.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionSet.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ActionSet.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ActionType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ActionType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ActionType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionType.Kind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ActionType.Kind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionType.Kind: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ActionType.Kind: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ActionType.Kind: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ActionType.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ActionType.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ActionType.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ActionType.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionType.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ActionType.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ExecutionStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExecutionStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ExecutionStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ExecutionStatus: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ExecutionStatus: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ExecutionLog: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ExecutionLog: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ExecutionLog: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExecutionLog: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.ActionSetLog: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ActionSetLog: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ActionSetLog: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionSetLog: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.ActionLog: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ActionLog: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ActionLog: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionLog: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.ActionLog.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ActionLog.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ActionLog.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionLog.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ActionLog.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ActionSetLog.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ActionSetLog.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ActionSetLog.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionSetLog.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ActionSetLog.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ExecutionLog.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ExecutionLog.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ExecutionLog.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExecutionLog.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ExecutionLog.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.JSONValue: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.JSONValue: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.JSONValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SpecTask: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.SpecTask: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.SpecTask: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SpecTask: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.TaskSchedule: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.TaskSchedule: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.TaskSchedule: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.RecurrenceRule.Frequency: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.RecurrenceRule.Frequency: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.RecurrenceRule.Frequency: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.RecurrenceRule.Frequency: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.RecurrenceRule.Frequency: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.RecurrenceRule: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.RecurrenceRule: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.RecurrenceRule: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.RecurrenceEnd: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.RecurrenceEnd: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.RecurrenceEnd: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionSetStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActionSetStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ActionSetStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ActionSetStatus: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ActionSetStatus: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DependencyCondition.OnStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DependencyCondition.OnStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DependencyCondition.OnStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DependencyCondition.OnStatus: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DependencyCondition.OnStatus: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DependencyCondition: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DependencyCondition: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DependencyCondition: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExecutionTiming: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ExecutionTiming: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ExecutionTiming: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExecutionTiming.Kind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ExecutionTiming.Kind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExecutionTiming.Kind: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ExecutionTiming.Kind: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ExecutionTiming.Kind: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ExecutionTiming.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ExecutionTiming.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ExecutionTiming.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ExecutionTiming.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ExecutionTiming.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.ExecutionTiming.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.DependencyCondition.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DependencyCondition.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DependencyCondition.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DependencyCondition.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DependencyCondition.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.RecurrenceEnd.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.RecurrenceEnd.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.RecurrenceEnd.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.RecurrenceEnd.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.RecurrenceEnd.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.RecurrenceRule.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.RecurrenceRule.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.RecurrenceRule.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.RecurrenceRule.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.RecurrenceRule.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.TaskSchedule.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.TaskSchedule.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.TaskSchedule.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.TaskSchedule.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.TaskSchedule.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.SpecTask.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.SpecTask.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.SpecTask.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SpecTask.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.SpecTask.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessagesError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.MessagesAdapterError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.MessagesAdapterError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.ProfileBuildLogger.LogLevel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ProfileBuildLogger.LogLevel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DraftsPlatformPageView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(Spec.DraftsPageIndicatorView, Spec.DraftConversationListView)>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.IDView<Spec.DraftConversationDetailView, Swift.String>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.Int>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.WhatsAppAdapterError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.WhatsAppAdapterError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.WhatsAppError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.WhatsAppError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.WhatsAppError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.WrappingFlowLayout: SwiftUI.Layout {
    typealias Cache = ()

    func makeCache(subviews: SwiftUI.LayoutSubviews) -> Self.Cache
    func updateCache(_: inout Self.Cache, subviews: SwiftUI.LayoutSubviews)
    func spacing(subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> SwiftUI.ViewSpacing
    func sizeThatFits(proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> __C.CGSize
    func placeSubviews(in: __C.CGRect, proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache)
    func explicitAlignment(of: SwiftUI.HorizontalAlignment, in: __C.CGRect, proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> CoreGraphics.CGFloat?
    func explicitAlignment(of: SwiftUI.VerticalAlignment, in: __C.CGRect, proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> CoreGraphics.CGFloat?

    static var layoutProperties: SwiftUI.LayoutProperties {
        get
    }

    static func _makeLayoutView(root: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewOutputs
}
extension Spec.WrappingFlowLayout: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.IncrementalProfileBuilderView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>SwiftUI.LinearProgressViewStyle, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<Spec.ProcessingVisualization, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._FlexFrameLayout>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>)>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(Spec.FeatureRow, Spec.FeatureRow, Spec.FeatureRow, Spec.FeatureRow)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._FlexFrameLayout>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[[Swift.String : Swift.String]], [Swift.String : Swift.String], SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>?>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>)>>?, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ProcessingVisualization: SwiftUI.View {
    typealias Body = SwiftUI.HStack<SwiftUI.TupleView<(Spec.PhaseIndicator, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, Spec.PhaseIndicator, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, Spec.PhaseIndicator, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, Spec.PhaseIndicator)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PhaseIndicator: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI.Text)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FeatureRow: SwiftUI.View {
    typealias Body = SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AIAction: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.AIAction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.AIAction.ToolUse: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.Attachment: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.Attachment: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.Key: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.Key: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.Key: Swift._SwiftNewtypeWrapper {}
extension __C.Key: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.Key: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.Key: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AnthropicOverloadedToastView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.AccessibilityAttachmentModifier>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.AccessibilityAttachmentModifier>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Material>, SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>)>>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Capsule, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>, SwiftUI.AccessibilityAttachmentModifier>, SwiftUI._FixedSizeLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AppleIntelligenceTestView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text)>>, SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.String?, SwiftUI.ForEach<[Spec.AppleIntelligenceService.AvailableModel], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>?)>>Swift.String?>>SwiftUI.MenuPickerStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI.Text?)>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Toggle<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Toggle<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._ValueActionModifier<Swift.Bool>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._FlexFrameLayout>>SwiftUI.BorderedButtonStyle, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._FlexFrameLayout>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.Text, SwiftUI.TupleView<(SwiftUI.Divider, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>)>?)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.BorderlessButtonStyle)>?)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>SwiftUI.EnabledTextSelectability>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI._PaddingLayout>>>, SwiftUI._FrameLayout>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0036AppleIntelligenceTestViewswift_tjBBlfMX342_0_33_2C5BFA3853141A4DEA4FE53924BBF36BLl7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.AppleIntelligenceTestViewModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.InFlightBatchRegistry: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.ProfileBuildCoordinator: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Spec.ProfileBuildingStage: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ProfileBuildingStage: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ProfileBuildingStage: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ProfileBuildingStage: Swift.CaseIterable {
    typealias AllCases = [Spec.ProfileBuildingStage]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.AutomaticProfileBuilder: SwiftUI.View {
    typealias Body = SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.LinearProgressViewStyle, SwiftUI._FrameLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Spec.ProfileBuildingStage], Spec.ProfileBuildingStage, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>?)>>>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.LazyVGrid<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._DiscreteSymbolEffectModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ContentTransition>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._DiscreteSymbolEffectModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ContentTransition>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._DiscreteSymbolEffectModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ContentTransition>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._DiscreteSymbolEffectModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ContentTransition>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._DiscreteSymbolEffectModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ContentTransition>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>)>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>?)>>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>?)>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._AppearanceActionModifier>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AutomaticProfileBuilder_Previews: SwiftUI.PreviewProvider {
    typealias Previews = Spec.AutomaticProfileBuilder

    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var previews: Self.Previews {
        get
    }
}
extension Spec.AutomaticProfileBuilder_Previews: SwiftUI._PreviewProvider {
    static var _previews: Any {
        get
    }
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
}
extension Spec.BirthdayMessagePopupModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.BirthdayMessagePopupView: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.EmptyView>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension __C.EventTypeMask: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.EventTypeMask

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.EventTypeMask: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.EventTypeMask: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt64

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.EventTypeMask: Swift.OptionSet {
    typealias Element = __C.EventTypeMask

    init(rawValue: Self.RawValue)
}
extension __C.EventTypeMask: Swift.SetAlgebra {
    typealias Element = __C.EventTypeMask

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.GlassOrFallback: SwiftUI.ViewModifier {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.GlassOrFallback>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>>>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.TaperedTabShape: SwiftUI.Shape {
    var layoutDirectionBehavior: SwiftUI.LayoutDirectionBehavior {
        get
    }

    func path(in: __C.CGRect) -> SwiftUI.Path
    func sizeThatFits(_: SwiftUI.ProposedViewSize) -> __C.CGSize

    static var role: SwiftUI.ShapeRole {
        get
    }
}
extension Spec.TaperedTabShape: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.TaperedTabShape: SwiftUI.View {
    typealias Body = SwiftUI._ShapeView<Spec.TaperedTabShape, SwiftUI.ForegroundStyle>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.BlackTabDropdownView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.GeometryReader<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Rectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Rectangle, SwiftUI.LinearGradient>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._AnimationModifier<Swift.Double>>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._ShadowEffect>)>>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>)>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<Spec.TaperedTabShape, SwiftUI.Color>>>, SwiftUI._ClipEffect<Spec.TaperedTabShape>>, SwiftUI._OffsetEffect>, SwiftUI._HoverRegionModifier>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AnalysisConfidence: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.AnalysisConfidence: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AnalysisConfidence: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ContentSuggestion.SuggestionType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContentSuggestion.SuggestionType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XProactiveError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XProactiveError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XProactiveError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.XProactiveError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.CentralizedContactDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.LinearGradient, SwiftUI.Text)>>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?, SwiftUI.HStack<SwiftUI.ForEach<[(platform: Swift.String, image: __C.NSImage)], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>)>>, SwiftUI.Spacer)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Swift.Int], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?, SwiftUI.Text?)>>, SwiftUI.Spacer)>>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>?, SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.Text?)>?)>>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<Spec.ContainersListView>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Swift.Int], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text?, SwiftUI.ModifiedContent<SwiftUI.Link<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>?)>>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.GroupBox<SwiftUI.Text, SwiftUI.ForEach<[Swift.Int], Swift.Int, SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.Text?)>>>?, SwiftUI.GroupBox<SwiftUI.Text, SwiftUI.ForEach<[Swift.Int], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>>>?, SwiftUI.GroupBox<SwiftUI.Text, SwiftUI.ForEach<[Swift.Int], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<Spec.FlowLayoutView<[Swift.String], SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Swift.Int], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text, SwiftUI.Text?)>>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>?)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FlowLayoutView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.GeometryReader<SwiftUI.ZStack<SwiftUI.ForEach<[A.Sequence.Element], A.Sequence.Element, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<B, SwiftUI._PaddingLayout>, SwiftUI._AlignmentWritingModifier>, SwiftUI._AlignmentWritingModifier>>>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ContainersListView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ChatInputField: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._AllowsHitTestingModifier>?, SwiftUI.ModifiedContent<Spec.MacTextEditor, SwiftUI._FrameLayout>)>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._FlexFrameLayout>, SwiftUI._ValueActionModifier<Swift.Bool>>, SwiftUI._ValueActionModifier<Swift.String>>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Menu<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>, SwiftUI.TupleView<(SwiftUI.Menu<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ForEach<[(id: Swift.String, title: Swift.String, icon: Swift.String)], Swift.String, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>>>>, SwiftUI.Divider, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>)>>SwiftUI.PlainButtonStyleSwiftUI.DefaultMenuStyle, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI._FixedSizeLayout>, SwiftUI._FlexFrameLayout>, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._FixedSizeLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.String?>>?, (SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>SwiftUI.PlainButtonStyle)?, (SwiftUI.Menu<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Divider, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.TupleView<(SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>)>?)>>SwiftUI.PlainButtonStyleSwiftUI.DefaultMenuStyle)?, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>>>Spec.ScaleButtonStyle, SwiftUI._HoverRegionModifier>)>>, SwiftUI._OverlayModifier<SwiftUI.EmptyView>>, SwiftUI._PaddingLayout>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.AngularGradient, SwiftUI.EmptyView>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>)>>, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._AnimationModifier<CoreGraphics.CGFloat>>, SwiftUI._HoverRegionModifier>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MacTextEditor: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSScrollView
    typealias Coordinator = Spec.MacTextEditor.Coordinator

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.MacTextEditor: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ChatInputExample: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.ChatInputField, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension __C.DrawingOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.DrawingOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.DrawingOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.DrawingOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.DrawingOptions: Swift.OptionSet {
    typealias Element = __C.DrawingOptions

    init(rawValue: Self.RawValue)
}
extension __C.DrawingOptions: Swift.SetAlgebra {
    typealias Element = __C.DrawingOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.Name: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.Name: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.Name: Swift._SwiftNewtypeWrapper {}
extension __C.Name: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.Name: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.Name: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.AutoresizingMask: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.AutoresizingMask

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.AutoresizingMask: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.AutoresizingMask: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.AutoresizingMask: Swift.OptionSet {
    typealias Element = __C.AutoresizingMask

    init(rawValue: Self.RawValue)
}
extension __C.AutoresizingMask: Swift.SetAlgebra {
    typealias Element = __C.AutoresizingMask

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.NSKeyValueObservingOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.NSKeyValueObservingOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.NSKeyValueObservingOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.NSKeyValueObservingOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.NSKeyValueObservingOptions: Swift.OptionSet {
    typealias Element = __C.NSKeyValueObservingOptions

    init(rawValue: Self.RawValue)
}
extension __C.NSKeyValueObservingOptions: Swift.SetAlgebra {
    typealias Element = __C.NSKeyValueObservingOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.ModifierFlags: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.ModifierFlags

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.ModifierFlags: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.ModifierFlags: Swift.SetAlgebra {
    typealias Element = __C.ModifierFlags

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.ModifierFlags: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.ModifierFlags: Swift.OptionSet {
    typealias Element = __C.ModifierFlags

    init(rawValue: Self.RawValue)
}
extension Spec.MacPairingRequestService: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.ChatHistoryItem: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.ChatHistoryItem: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ChatHistoryItem: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ChatSidebarView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>>SwiftUI.PlainButtonStyle, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI._OpacityShapeStyle<SwiftUI.HierarchicalShapeStyle>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._ForegroundStyleModifier<SwiftUI.HierarchicalShapeStyle>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ForEach<[Spec.ChatHistoryItem], Swift.String, SwiftUI.ModifiedContent<Spec.SidebarRow, SwiftUI._AppearanceActionModifier>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>?, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, Spec.KeepAwakeToggle)>>, Spec.UserProfileView, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>)>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI._ConditionalContent<SwiftUI.Color, SwiftUI.Color>)>>, SwiftUI._SafeAreaRegionsIgnoringLayout>>>, SwiftUI._OffsetEffect>>, SwiftUI._FrameLayout>, SwiftUI._TaskModifier>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>Swift.Bool

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.UserProfileView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Image, SwiftUI.Image)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._ForegroundStyleModifier<SwiftUI.HierarchicalShapeStyle>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ShareRow: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._ForegroundStyleModifier<SwiftUI.Color>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._ForegroundStyleModifier<SwiftUI.HierarchicalShapeStyle>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SidebarRow: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI._OpacityShapeStyle<SwiftUI.HierarchicalShapeStyle>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>?)>>)>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SpecChatHistoryItem: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.ChatsListView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>SwiftUI.CircularProgressViewStyle, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI.LazyVStack<SwiftUI.TupleView<(SwiftUI.ForEach<[Spec.SpecChatHistoryItem], Foundation.UUID, SwiftUI.ModifiedContent<Spec.ChatRowView, SwiftUI._AppearanceActionModifier>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>SwiftUI.CircularProgressViewStyle, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>?)>>>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ChatRowView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._HoverRegionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0024ChatsListViewswift_ynAHffMX395_0_33_3351E9E840B2833270E61F9394A6F554Ll7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.CheckboxField: SwiftUI.View {
    typealias Body = SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, A)>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.CheckboxField_Previews: SwiftUI.PreviewProvider {
    typealias Previews = Spec.CheckboxField<SwiftUI.Text>

    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var previews: Self.Previews {
        get
    }
}
extension Spec.CheckboxField_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension Spec.SimpleCheckboxField: SwiftUI.View {
    typealias Body = SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>>SwiftUI.PlainButtonStyle

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SimpleCheckboxField_Previews: SwiftUI.PreviewProvider {
    typealias Previews = Spec.SimpleCheckboxField

    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var previews: Self.Previews {
        get
    }
}
extension Spec.SimpleCheckboxField_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension Spec.DraftConversationRowView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.IDView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>, SwiftUI.AsyncImage<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>)>>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>, SwiftUI._BlendModeEffect>>>, SwiftUI._CompositingGroupEffect>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ScaleEffect>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>?>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>?, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>?>>?, SwiftUI._FrameLayout>)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.String>>, Swift.String>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer, SwiftUI.Text?)>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>, SwiftUI._AllowsHitTestingModifier>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>, SwiftUI.Color>>>>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.RingShape: SwiftUI.Shape {
    var layoutDirectionBehavior: SwiftUI.LayoutDirectionBehavior {
        get
    }

    func path(in: __C.CGRect) -> SwiftUI.Path
    func sizeThatFits(_: SwiftUI.ProposedViewSize) -> __C.CGSize

    static var role: SwiftUI.ShapeRole {
        get
    }
}
extension Spec.RingShape: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.RingShape: SwiftUI.View {
    typealias Body = SwiftUI._ShapeView<Spec.RingShape, SwiftUI.ForegroundStyle>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.CircleWithBite: SwiftUI.Shape {
    var layoutDirectionBehavior: SwiftUI.LayoutDirectionBehavior {
        get
    }

    func path(in: __C.CGRect) -> SwiftUI.Path
    func sizeThatFits(_: SwiftUI.ProposedViewSize) -> __C.CGSize

    static var role: SwiftUI.ShapeRole {
        get
    }
}
extension Spec.CircleWithBite: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.CircleWithBite: SwiftUI.View {
    typealias Body = SwiftUI._ShapeView<Spec.CircleWithBite, SwiftUI.ForegroundStyle>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AnyShape: SwiftUI.Shape {
    var layoutDirectionBehavior: SwiftUI.LayoutDirectionBehavior {
        get
    }

    func path(in: __C.CGRect) -> SwiftUI.Path
    func sizeThatFits(_: SwiftUI.ProposedViewSize) -> __C.CGSize

    static var role: SwiftUI.ShapeRole {
        get
    }
}
extension Spec.AnyShape: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.AnyShape: SwiftUI.View {
    typealias Body = SwiftUI._ShapeView<Spec.AnyShape, SwiftUI.ForegroundStyle>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.CollapsedToolUseGroup: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.ForEach<[(offset: Swift.Int, element: (type: Swift.String, icon: Swift.String, color: SwiftUI.Color))], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>>>>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<Spec.AnyShape>>, SwiftUI._TraitWritingModifier<SwiftUI.ZIndexTraitKey>>>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._RotationEffect>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>SwiftUI.PlainButtonStyle, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[(Swift.String, [Spec.GroupedToolUseRow.ToolUseInfo])], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.GroupedToolUseRow, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>, SwiftUI._AnimationModifier<Swift.Bool>>>>, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>?)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.CollapsedToolUseGroup: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ContactDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(Spec.ContactHeaderView, SwiftUI.Divider, SwiftUI.TupleView<(Spec.RelationshipSectionView, SwiftUI.Divider)>?, SwiftUI.TupleView<(Spec.ChannelMetricsSectionView, SwiftUI.Divider)>?, SwiftUI.TupleView<(Spec.EmploymentSectionView, SwiftUI.Divider)>?, SwiftUI.TupleView<(Spec.EducationSectionView, SwiftUI.Divider)>?, SwiftUI.TupleView<(Spec.TopicsSectionView, SwiftUI.Divider)>?, Spec.AddressesSectionView?)>>, SwiftUI._PaddingLayout>>?>Swift.StringSpec.RelationshipEditView, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ContactHeaderView: SwiftUI.View {
    typealias Body = SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.Text>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>)>>, SwiftUI.Spacer)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.RelationshipSectionView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.BorderlessButtonStyle)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>?, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>?, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<Spec.RelationshipHistoryView, SwiftUI._PaddingLayout>?)>?)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.RelationshipHistoryView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.Text?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.Text?)>>)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI.Divider?)>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ChannelMetricsSectionView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ForEach<[Spec.ContactOverview.ChannelMetrics], Swift.String, Spec.ChannelMetricRow>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ChannelMetricRow: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EmploymentSectionView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.ContactOverview.Employment)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.Text?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.Text?)>>)>>, SwiftUI._PaddingLayout>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EducationSectionView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.ContactOverview.Education)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TopicsSectionView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._VariadicView.Tree<SwiftUI._LayoutRoot<Spec.FlowLayout>, SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.ContactOverview.Topic)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AddressesSectionView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.ContactOverview.Address)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>?, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>)>>, SwiftUI._PaddingLayout>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.RelationshipEditView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Picker<SwiftUI.Text, Swift.String, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.TextSwift.String>>SwiftUI.MenuPickerStyle)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI._ShapeView<SwiftUI._StrokedShape<SwiftUI.Rectangle._Inset>, SwiftUI.Color>>>)>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ConversationConfirmationView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI._OpacityShapeStyle<SwiftUI.HierarchicalShapeStyle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._HoverRegionModifier>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Material>>, SwiftUI._BackgroundStyleModifier<SwiftUI._OpacityShapeStyle<SwiftUI.HierarchicalShapeStyle>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OffsetEffect>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>, SwiftUI._OffsetEffect>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>)>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._FixedSizeLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.UnevenRoundedRectangle, SwiftUI.Color>>>)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Material>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>SwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>, SwiftUI._FixedSizeLayout>, SwiftUI._AppearanceActionModifier>Swift.String, SwiftUI._PaddingLayout>, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI._OpacityShapeStyle<SwiftUI.HierarchicalShapeStyle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Material>>, SwiftUI._BackgroundStyleModifier<SwiftUI._OpacityShapeStyle<SwiftUI.HierarchicalShapeStyle>>>)>>, SwiftUI._FrameLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._ClipEffect<SwiftUI.Rectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ConversationSummary: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.ConversationSummary: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.ConversationSummary: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.ConversationSummary.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.ConversationSummary.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.ConversationSummary.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ConversationSummary.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.ConversationSummary.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.CursorLogoPopupManager.ActionType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.CursorLogoPopupManager.ActionType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.CursorLogoPopupManager.ActionType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.CursorLogoPopupViewModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.CursorLogoPopupView: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._FixedSizeLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OffsetEffect>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OffsetEffect>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>?)>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>?, SwiftUI._PaddingLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.SelectedTextBadge, SwiftUI._FrameLayout>, SwiftUI._FrameLayout>, SwiftUI._OpacityEffect>, SwiftUI._AllowsHitTestingModifier>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.IDView<Spec.FocusedTextFieldNS, Foundation.UUID>, SwiftUI._FrameLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._FixedSizeLayout>, SwiftUI._OpacityEffect>)>>, SwiftUI._FrameLayout>, SwiftUI._FixedSizeLayout>, SwiftUI._AlignmentWritingModifier>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._TransactionModifier>, SwiftUI._FlexFrameLayout>, SwiftUI._TransactionModifier>?, SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.Spacer>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.DraftSendButton, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>>, SwiftUI._AllowsHitTestingModifier>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?)>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>>>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>, SwiftUI._ValueActionModifier<CoreGraphics.CGFloat>>, SwiftUI._ValueActionModifier<Swift.String>>, SwiftUI._ValueActionModifier<Swift.Bool>>, SwiftUI._ValueActionModifier<Swift.Bool>>, SwiftUI._ValueActionModifier<Swift.Bool>>, SwiftUI._AppearanceActionModifier>>>>>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MiniVisualEffectView: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSVisualEffectView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.MiniVisualEffectView: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension __C.CGEventFlags: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.CGEventFlags

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.CGEventFlags: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.CGEventFlags: Swift.SetAlgebra {
    typealias Element = __C.CGEventFlags

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.CGEventFlags: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt64

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.CGEventFlags: Swift.OptionSet {
    typealias Element = __C.CGEventFlags

    init(rawValue: Self.RawValue)
}
extension __C.PropertyKey: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.PropertyKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.PropertyKey: Swift._SwiftNewtypeWrapper {}
extension __C.PropertyKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.PropertyKey: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.PropertyKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.PasteboardType: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.PasteboardType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.PasteboardType: Swift._SwiftNewtypeWrapper {}
extension __C.PasteboardType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.PasteboardType: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.PasteboardType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.LiquidGlassBackground: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.MiniVisualEffectView, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient>, SwiftUI._OpacityEffect>, SwiftUI._BlendModeEffect>, SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>, SwiftUI._MaskEffect<SwiftUI.ModifiedContent<SwiftUI.RoundedRectangle, SwiftUI._PaddingLayout>>>>>>)>>, SwiftUI._CompositingGroupEffect>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SelectedTextBadge: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.MiniVisualEffectView, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PopupTranscriptView: SwiftUI.View {
    typealias Body = SwiftUI.ScrollViewReader<SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.IDView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, Swift.String>>, SwiftUI._FlexFrameLayout>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.DraftSendButton: SwiftUI.View {
    typealias Body = SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>>>, SwiftUI._ShadowEffect>>SwiftUI.PlainButtonStyle

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.CursorLogoPopupManager.Shortcut: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.CursorLogoPopupManager.Shortcut: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.EventType: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.CIContextOption: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.CIContextOption: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.CIContextOption: Swift._SwiftNewtypeWrapper {}
extension __C.CIContextOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.CIContextOption: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.CIContextOption: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.CGEventType: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.CursorLogoPopupStagedView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._OpacityEffect>)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>>>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.DarkBlurEffectView: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSVisualEffectView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.DarkBlurEffectView: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.DraftedActionDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Rectangle, SwiftUI.Color>, SwiftUI._FrameLayout>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.MarkdownTextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.Color, SwiftUI.ModifiedContent<Spec.VisualEffectBlur, SwiftUI._OpacityEffect>, SwiftUI.Color)>>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.DraftedActionDetailView_Previews: SwiftUI.PreviewProvider {
    typealias Previews = Spec.DraftedActionDetailView

    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var previews: Self.Previews {
        get
    }
}
extension Spec.DraftedActionDetailView_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension Spec.DraftingRepliesPopupModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.DraftingRepliesPopupView: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._FixedSizeLayout>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OffsetEffect>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OffsetEffect>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>)>>, SwiftUI._FrameLayout>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>>>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>, SwiftUI._FixedSizeLayout>, SwiftUI._AllowsHitTestingModifier>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.Effect: SwiftUI.View {
    typealias Body = SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.AngularGradient, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._BlurEffect>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EffectNoBlur: SwiftUI.View {
    typealias Body = SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.AngularGradient, SwiftUI.EmptyView>, SwiftUI._FrameLayout>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EmailReplyPreviewView: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI.Spacer)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>?, SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer)>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OpacityEffect>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<Spec.VisualEffectView>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>)>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>)>>, SwiftUI._PaddingLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OpacityEffect>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EnhancedEmailDraftCard.GmailThreadMessage: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.EnhancedEmailDraftCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, (SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)?)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.ForEach<[Spec.EnhancedEmailDraftCard.GmailThreadMessage], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.Text>>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>>>, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._PaddingLayout>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>?)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.PlainTextFieldStyle, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.PlainTextFieldStyle, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.PlainTextFieldStyle, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.PlainTextFieldStyle, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>)>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._ClipEffect<SwiftUI.Rectangle>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EventDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Rectangle, SwiftUI.Color>, SwiftUI._FrameLayout>>>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<CoreGraphics.CGFloat>>, SwiftUI._FixedSizeLayout>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.ForEach<[(Swift.String, Swift.String)], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>>>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ForEach<[Spec.EventAction], Foundation.UUID, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle>, SwiftUI.ForEach<[Spec.EventAction], Foundation.UUID, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle>)>>)>>, SwiftUI._PaddingLayout>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EventFullScreenDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ZStack<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI.Spacer)>>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<CoreGraphics.CGFloat>>, SwiftUI._FixedSizeLayout>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.ForEach<[Spec.EventAction], Foundation.UUID, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle>, SwiftUI.ForEach<[Spec.EventAction], Foundation.UUID, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>?, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>?, SwiftUI.ModifiedContent<Spec.MarkdownTextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>?)>>)>>??)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FlowingGradientBackground: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.RadialGradient, SwiftUI._ScaleEffect>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._AppearanceActionModifier>, SwiftUI._AllowsHitTestingModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FocusedTextFieldNS: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSTextField
    typealias Coordinator = Spec.FocusedTextFieldNS.Coordinator

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.FocusedTextFieldNS: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessageCommitmentTestViewModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.CommitmentValidationResult: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.FocusRequestor: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.FocusRequestor: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.CursorModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.CursorModifier>, SwiftUI._BackgroundModifier<Spec.CursorView>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.CursorView: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.CursorView: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FoldedCornerShape: SwiftUI.InsettableShape {
    typealias InsetShape = Spec.FoldedCornerShape

    func inset(by: CoreGraphics.CGFloat) -> Self.InsetShape
}
extension Spec.FoldedCornerShape: SwiftUI.Shape {
    var layoutDirectionBehavior: SwiftUI.LayoutDirectionBehavior {
        get
    }

    func path(in: __C.CGRect) -> SwiftUI.Path
    func sizeThatFits(_: SwiftUI.ProposedViewSize) -> __C.CGSize

    static var role: SwiftUI.ShapeRole {
        get
    }
}
extension Spec.FoldedCornerShape: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.FoldedCornerShape: SwiftUI.View {
    typealias Body = SwiftUI._ShapeView<Spec.FoldedCornerShape, SwiftUI.ForegroundStyle>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FoldedCornerCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.StrokeBorderShapeView<Spec.FoldedCornerShape, SwiftUI.Color, SwiftUI._ShapeView<Spec.FoldedCornerShape, SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Bool>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._ShapeView<SwiftUI.Path, SwiftUI.Color>)>>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Rectangle>>, SwiftUI._PaddingLayout>, SwiftUI._OffsetEffect>, SwiftUI._HoverRegionModifier>>SwiftUI.PlainButtonStyle, SwiftUI._HoverRegionModifier>, SwiftUI._MaskEffect<SwiftUI.LinearGradient>>, SwiftUI._AnimationModifier<Swift.Bool>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.DynamicFoldedCornerCard: SwiftUI.View {
    typealias Body = SwiftUI.GeometryReader<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<Spec.FoldedCornerShape, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<Spec.FoldedCornerShape, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShapeView<SwiftUI.Path, SwiftUI.LinearGradient>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<CoreGraphics.CGFloat>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FoldedCornerCard_Previews: SwiftUI.PreviewProvider {
    typealias Previews = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(Spec.FoldedCornerCard, SwiftUI.ModifiedContent<Spec.DynamicFoldedCornerCard, SwiftUI._FrameLayout>, Spec.FoldedCornerCard)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>

    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var previews: Self.Previews {
        get
    }
}
extension Spec.FoldedCornerCard_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension Spec.FullDiskAccessGuidePopupView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.MiniVisualEffectView, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._AllowsHitTestingModifier>)>>, SwiftUI._FrameLayout>, SwiftUI._AllowsHitTestingModifier>, SwiftUI._ValueActionModifier<CoreGraphics.CGFloat>>, SwiftUI._AnimationModifier<CoreGraphics.CGFloat>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.WordFadeText, SwiftUI._FlexFrameLayout>, SwiftUI._OpacityEffect>, SwiftUI._AnimationModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI._MaskEffect<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Rectangle, SwiftUI._FrameLayout>, SwiftUI.Spacer)>>>>, SwiftUI._FrameLayout>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<CoreGraphics.CGFloat>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GmailInboxView: SwiftUI.View {
    typealias Body = SwiftUI.NavigationStack<SwiftUI.NavigationPath, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>?, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, (SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle)?, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ContentUnavailableView<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Text?, SwiftUI.EmptyView>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.List<Swift.Never, SwiftUI.ForEach<[Spec.ExtractedEmail], Swift.String, Spec.GEmailRowView>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text)>, SwiftUI.Text>?, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>SwiftUI.TupleToolbarContent<(SwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Text>>, SwiftUI.ToolbarItem<(), SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>?, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>>)>Spec.EmailDetailView?SwiftUI.Button<SwiftUI.Text>SwiftUI.Text, SwiftUI._TaskModifier>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GEmailRowView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EmailDetailView: SwiftUI.View {
    typealias Body = SwiftUI.NavigationStack<SwiftUI.NavigationPath, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>)>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>>SwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Text>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0025GmailInboxViewswift_jqFBgfMX299_0_33_1427BA44F03587623720D14C6A92452ALl7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.GodLogsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._FlexFrameLayout>, SwiftUI.Menu<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Divider, SwiftUI.ForEach<[Spec.GodLogger.Category], Spec.GodLogger.Category, SwiftUI.Button<SwiftUI.Text>>)>>, SwiftUI.Menu<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Divider, SwiftUI.ForEach<[Spec.GodLogger.Level], Spec.GodLogger.Level, SwiftUI.Button<SwiftUI.Text>>)>>, SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.List<Swift.Never, SwiftUI.ForEach<[Spec.GodLogger.Entry], Swift.String, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Text, SwiftUI.Text?, SwiftUI.ScrollView<SwiftUI.TextSwiftUI.EnabledTextSelectability>?)>>, SwiftUI._PaddingLayout>>>)>>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GoogleReauthOverlay: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.EmptyView, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Rectangle, SwiftUI.Color>, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>, SwiftUI._AllowsHitTestingModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._ForegroundStyleModifier<SwiftUI.HierarchicalShapeStyle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._ForegroundStyleModifier<SwiftUI.Color>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ForegroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.HierarchicalShapeStyle>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle>)>>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Material>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Material>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._TraitWritingModifier<SwiftUI.ZIndexTraitKey>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<[Swift.String]>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ButtonState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ButtonState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.HoverView: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSView
    typealias Coordinator = Spec.HoverView<A>.Coordinator

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.HoverView: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.IntraDayPrepDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>)>>, SwiftUI._PaddingLayout>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>?, SwiftUI.Text)>>, SwiftUI.ModifiedContent<Spec.MarkdownTextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>?, SwiftUI.Text)>>, SwiftUI.ModifiedContent<Spec.MarkdownTextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>?, SwiftUI.Text)>>, SwiftUI.ModifiedContent<Spec.MarkdownTextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>?, SwiftUI.Text)>>, SwiftUI.ModifiedContent<Spec.MarkdownTextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>?, SwiftUI.Text)>>, SwiftUI.ModifiedContent<Spec.MarkdownTextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>?, SwiftUI.Text)>>, SwiftUI.ModifiedContent<Spec.MarkdownTextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>)>>?, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>?, SwiftUI.Text)>>, SwiftUI.ModifiedContent<Spec.MarkdownTextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>)>>?>?)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.InviteGateView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.Case?>>, SwiftUI._ValueActionModifier<Swift.String>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>?, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI._ConditionalContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI.Text>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.InviteManagementView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient>>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.PlainTextFieldStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, (SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle)?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>, SwiftUI._FlexFrameLayout>, SwiftUI.Spacer)>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._FlexFrameLayout>>, SwiftUI.ScrollView<SwiftUI.LazyVStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.Spacer)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ForEach<[Spec.InviteService.InviteCode], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>)>>>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>?)>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0031InviteManagementViewswift_yFFIifMX464_0_33_4C04BA7BA45D428A67D4FB6E2CEDD77BLl7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.InviteQuickSharePopup: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.LumaKeyVideoView, SwiftUI._ColorMultiplyEffect>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI._FrameLayout>?, SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.IosSyncReminderToastView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.AccessibilityAttachmentModifier>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.AccessibilityAttachmentModifier>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Material>, SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>)>>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Capsule, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>, SwiftUI.AccessibilityAttachmentModifier>, SwiftUI._FixedSizeLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.XTweet.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XTweet.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.ReferencedTweet: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.ReferencedTweet: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet.Attachments.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.Attachments.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.Attachments.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XTweet.Attachments.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.Attachments.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.Attachments.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.Attachments: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.Attachments: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet.PublicMetrics.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.PublicMetrics.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.PublicMetrics.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XTweet.PublicMetrics.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.PublicMetrics.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.PublicMetrics.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.PublicMetrics: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.PublicMetrics: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet.Entities.URL.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.Entities.URL.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.Entities.URL.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XTweet.Entities.URL.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.Entities.URL.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.Entities.URL.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.Entities.URL: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.Entities.URL: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet.Entities.Hashtag: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.Entities.Hashtag: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet.Entities.Mention: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.Entities.Mention: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet.Entities.Cashtag: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.Entities.Cashtag: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet.Entities: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.Entities: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet.ContextAnnotation.Domain: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.ContextAnnotation.Domain: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet.ContextAnnotation.Entity: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.ContextAnnotation.Entity: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet.ContextAnnotation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet.ContextAnnotation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XTweet: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XTweet: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.XUser.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XUser.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XUser.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XUser.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XUser.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XUser.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XUser.PublicMetrics.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XUser.PublicMetrics.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XUser.PublicMetrics.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XUser.PublicMetrics.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XUser.PublicMetrics.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XUser.PublicMetrics.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XUser.PublicMetrics: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XUser.PublicMetrics: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XUser: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XUser: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XUser: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.XDirectMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XDirectMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XDirectMessage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XDirectMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XDirectMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XDirectMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XDirectMessage.Attachments.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XDirectMessage.Attachments.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XDirectMessage.Attachments.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XDirectMessage.Attachments.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XDirectMessage.Attachments.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XDirectMessage.Attachments.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XDirectMessage.Attachments: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XDirectMessage.Attachments: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XDirectMessage.ReferencedTweet: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XDirectMessage.ReferencedTweet: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XDirectMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XDirectMessage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XDirectMessage: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.XDMConversation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XDMConversation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XDMConversation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XDMConversation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XDMConversation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XDMConversation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XDMConversation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XDMConversation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XDMConversation: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.XSpace.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XSpace.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XSpace.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XSpace.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XSpace.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XSpace.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XSpace: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XSpace: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XSpace: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.XMedia.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XMedia.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XMedia.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XMedia.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XMedia.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XMedia.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XMedia.PublicMetrics.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XMedia.PublicMetrics.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XMedia.PublicMetrics.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XMedia.PublicMetrics.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XMedia.PublicMetrics.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XMedia.PublicMetrics.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XMedia.PublicMetrics: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XMedia.PublicMetrics: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XMedia: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XMedia: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XMedia: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.XList.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XList.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XList.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XList.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XList.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XList.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XList: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XList: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XList: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.XPoll.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XPoll.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XPoll.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XPoll.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XPoll.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XPoll.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XPoll.Option: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XPoll.Option: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XPoll: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XPoll: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XPoll: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.XAPIResponse.Includes.Place.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XAPIResponse.Includes.Place.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XAPIResponse.Includes.Place.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XAPIResponse.Includes.Place.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XAPIResponse.Includes.Place.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XAPIResponse.Includes.Place.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XAPIResponse.Includes.Place.Geo: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XAPIResponse.Includes.Place.Geo: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XAPIResponse.Includes.Place: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XAPIResponse.Includes.Place: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XAPIResponse.Includes: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XAPIResponse.Includes: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XAPIResponse.Meta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XAPIResponse.Meta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XAPIResponse.Meta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XAPIResponse.Meta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XAPIResponse.Meta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XAPIResponse.Meta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XAPIResponse.Meta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XAPIResponse.Meta: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XAPIResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XAPIResponse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XAPIError.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XAPIError.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XAPIError.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XAPIError.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XAPIError.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XAPIError.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XAPIError: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XAPIError: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XAPIError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Spec.XAPIError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Spec.XCreateTweetRequest.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XCreateTweetRequest.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XCreateTweetRequest.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XCreateTweetRequest.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XCreateTweetRequest.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XCreateTweetRequest.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XCreateTweetRequest.Geo.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XCreateTweetRequest.Geo.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XCreateTweetRequest.Geo.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XCreateTweetRequest.Geo.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XCreateTweetRequest.Geo.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XCreateTweetRequest.Geo.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XCreateTweetRequest.Geo: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XCreateTweetRequest.Geo: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XCreateTweetRequest.Media.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XCreateTweetRequest.Media.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XCreateTweetRequest.Media.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XCreateTweetRequest.Media.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XCreateTweetRequest.Media.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XCreateTweetRequest.Media.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XCreateTweetRequest.Media: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XCreateTweetRequest.Media: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XCreateTweetRequest.Poll.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XCreateTweetRequest.Poll.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XCreateTweetRequest.Poll.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XCreateTweetRequest.Poll.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XCreateTweetRequest.Poll.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XCreateTweetRequest.Poll.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XCreateTweetRequest.Poll: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XCreateTweetRequest.Poll: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XCreateTweetRequest.Reply.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XCreateTweetRequest.Reply.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XCreateTweetRequest.Reply.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XCreateTweetRequest.Reply.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XCreateTweetRequest.Reply.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XCreateTweetRequest.Reply.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XCreateTweetRequest.Reply: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XCreateTweetRequest.Reply: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XCreateTweetRequest: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XCreateTweetRequest: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XSendDMRequest.Attachment.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XSendDMRequest.Attachment.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XSendDMRequest.Attachment.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.XSendDMRequest.Attachment.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XSendDMRequest.Attachment.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XSendDMRequest.Attachment.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XSendDMRequest.Attachment: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XSendDMRequest.Attachment: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XSendDMRequest: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.XSendDMRequest: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.XSendDMRequest.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XSendDMRequest.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XSendDMRequest.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XSendDMRequest.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XSendDMRequest.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XAPIResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XAPIResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XAPIResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XAPIResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XAPIResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XAPIResponse.Includes.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XAPIResponse.Includes.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XAPIResponse.Includes.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XAPIResponse.Includes.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XAPIResponse.Includes.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XAPIResponse.Includes.Place.Geo.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XAPIResponse.Includes.Place.Geo.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XAPIResponse.Includes.Place.Geo.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XAPIResponse.Includes.Place.Geo.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XAPIResponse.Includes.Place.Geo.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XPoll.Option.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XPoll.Option.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XPoll.Option.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XPoll.Option.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XPoll.Option.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XDirectMessage.ReferencedTweet.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XDirectMessage.ReferencedTweet.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XDirectMessage.ReferencedTweet.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XDirectMessage.ReferencedTweet.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XDirectMessage.ReferencedTweet.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.ContextAnnotation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.ContextAnnotation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.ContextAnnotation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.ContextAnnotation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.ContextAnnotation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.ContextAnnotation.Entity.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.ContextAnnotation.Entity.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.ContextAnnotation.Entity.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.ContextAnnotation.Entity.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.ContextAnnotation.Entity.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.ContextAnnotation.Domain.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.ContextAnnotation.Domain.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.ContextAnnotation.Domain.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.ContextAnnotation.Domain.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.ContextAnnotation.Domain.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.Entities.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.Entities.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.Entities.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.Entities.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.Entities.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.Entities.Cashtag.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.Entities.Cashtag.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.Entities.Cashtag.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.Entities.Cashtag.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.Entities.Cashtag.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.Entities.Mention.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.Entities.Mention.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.Entities.Mention.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.Entities.Mention.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.Entities.Mention.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.Entities.Hashtag.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.Entities.Hashtag.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.Entities.Hashtag.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.Entities.Hashtag.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.Entities.Hashtag.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.XTweet.ReferencedTweet.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.XTweet.ReferencedTweet.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.XTweet.ReferencedTweet.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.XTweet.ReferencedTweet.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.XTweet.ReferencedTweet.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.KnowledgeGraphView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>?)>>, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Menu<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>)>>SwiftUI.BorderlessButtonMenuStyle, SwiftUI._FixedSizeLayout>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedButtonStyle, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Image.Scale>>>SwiftUI.BorderlessButtonStyle)>>)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.Int, SwiftUI.TupleView<(SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int)>>SwiftUI.SegmentedPickerStyle, SwiftUI._PaddingLayout>, SwiftUI.TabView<Swift.Int, SwiftUI.TupleView<(Spec.KnowledgeGraphContentViewSwift.Int, Spec.ThreadsListViewSwift.Int, Spec.ProcessingLogViewSwift.Int)>>SwiftUI.DefaultTabViewStyle)>>Spec.KnowledgeGraphSettingsViewSpec.KnowledgeGraphVisualizationView

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.KnowledgeGraphContentView: SwiftUI.View {
    typealias Body = SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(Spec.KGStatusCard?, Spec.DataSourcesCard, Spec.GraphStatisticsCard?, Spec.HighlightsCard?)>>, SwiftUI._PaddingLayout>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ThreadsListView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TextField<SwiftUI.Text>SwiftUI.PlainTextFieldStyle>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Toggle<SwiftUI.Text>SwiftUI.ButtonToggleStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.List<Swift.Never, SwiftUI.ForEach<[Spec.WorkThread], Swift.String, SwiftUI.ModifiedContent<Spec.ThreadRowView, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>>SwiftUI.PlainListStyle)>>Spec.ThreadDetailContentView?

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ProcessingLogView: SwiftUI.View {
    typealias Body = SwiftUI.ScrollViewReader<SwiftUI.ModifiedContent<SwiftUI.List<Swift.Never, SwiftUI.ForEach<[Spec.KnowledgeGraphLLMAgent.LogEntry], Foundation.UUID, SwiftUI.IDView<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, Foundation.UUID>>>SwiftUI.PlainListStyle, SwiftUI._ValueActionModifier<Swift.Int>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.KGStatusCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.DataSourcesCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ForEach<[Spec.DataSourceStatus], Spec.DataSourceStatus.DataSource, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text?, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>)>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GraphStatisticsCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[(key: Swift.String, value: Swift.Int)], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[(key: Swift.String, value: Swift.Int)], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>>)>>, SwiftUI._FlexFrameLayout>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.HighlightsCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[Spec.KGHighlights.ContactHighlight], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?, SwiftUI.Spacer, SwiftUI.Text)>>>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[Spec.KGHighlights.TripHighlight], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>>)>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ThreadRowView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Text?)>>?, SwiftUI.ScrollView<SwiftUI.HStack<SwiftUI.ForEach<Swift.ArraySlice<Swift.String>, Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>>?)>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.KnowledgeGraphSettingsView: SwiftUI.View {
    typealias Body = SwiftUI.NavigationView<SwiftUI.Form<SwiftUI.TupleView<(SwiftUI.Section<SwiftUI.Text, SwiftUI.TupleView<(SwiftUI.Stepper<SwiftUI.Text>, SwiftUI.Toggle<SwiftUI.Text>, SwiftUI.Stepper<SwiftUI.Text>?)>, SwiftUI.EmptyView>, SwiftUI.Section<SwiftUI.Text, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Button<SwiftUI.Text>)>, SwiftUI.EmptyView>)>>SwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Text>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ThreadDetailContentView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Text, SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.HStack<SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>>, SwiftUI._PaddingLayout>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>?)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.ForEach<[Spec.ThreadDetailContentView.ThreadMessage], Swift.String, Spec.MessageBubbleView>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI._PaddingLayout>>)>>, SwiftUI._FrameLayout>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessageBubbleView: SwiftUI.View {
    typealias Body = SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Text)>>, SwiftUI.Spacer?)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.KnowledgeGraphVisualizationView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>, SwiftUI._PaddingLayout>?)>>, SwiftUI._FlexFrameLayout>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(Spec.StatBadge, Spec.StatBadge, Spec.StatBadge)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI.TabView<Swift.Int, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.GeometryReader<SwiftUI.Canvas<SwiftUI.EmptyView>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Image>SwiftUI.BorderlessButtonStyle, SwiftUI.Button<SwiftUI.Image>SwiftUI.BorderlessButtonStyle, SwiftUI.Spacer, SwiftUI.Menu<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Divider, SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>>SwiftUI.BorderlessButtonMenuStyle)>>, SwiftUI._PaddingLayout>, SwiftUI.Spacer)>>)>>Swift.IntSwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._FrameLayout>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Charts.Chart<SwiftUI.ForEach<[(date: Foundation.Date, count: Swift.Int, type: Swift.String)], Foundation.Date, Charts.BarMarkSwift.String>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, Spec.TimelineEventRow>)>>, SwiftUI._PaddingLayout>)>>>Swift.IntSwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.LazyVGrid<SwiftUI.ForEach<[Spec.PersonContactNode], Swift.String, SwiftUI.ModifiedContent<Spec.ContactCard, SwiftUI._HoverRegionModifier>>>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<Charts.Chart<SwiftUI.ForEach<[(contact: Swift.String, week: Swift.Int, messageCount: Swift.Int)], Swift.String, Charts.LineMarkSwift.String>>, SwiftUI._FrameLayout>)>>, SwiftUI._PaddingLayout>)>>>Swift.IntSwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<Spec.HeatmapGrid, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(Spec.ActivityBreakdown, Spec.ActivityBreakdown)>>, SwiftUI._PaddingLayout>)>>Swift.IntSwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.Text>>, SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, Spec.ContactNode>)>>, SwiftUI._FlexFrameLayout>>)>>, SwiftUI._PaddingLayout>Swift.IntSwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._AppearanceActionModifier>)>>, SwiftUI._FlexFrameLayout>)>>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.StatBadge: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TimelineEventRow: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ContactCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.Text>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI.Divider, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._ShadowEffect>, SwiftUI._ScaleEffect>, SwiftUI._AnimationModifier<Swift.Bool>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.HeatmapGrid: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ForEach<[Swift.Int], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>)>>, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ForEach<[Swift.Int], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Rectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>)>>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ActivityBreakdown: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[(Swift.String, Swift.Int)], Swift.String, SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ContactNode: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.Text>>, SwiftUI._OffsetEffect>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.LumaKeyVideoView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.LumaPlayerContainerView, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension __C.AVMediaType: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.AVMediaType: Swift._SwiftNewtypeWrapper {}
extension __C.AVMediaType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.AVMediaType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.AVMediaType: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.AVMediaType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.CIImageOption: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.CIImageOption: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.CIImageOption: Swift._SwiftNewtypeWrapper {}
extension __C.CIImageOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.CIImageOption: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.CIImageOption: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.LumaPlayerContainerView: SwiftUI.NSViewRepresentable {
    typealias NSViewType = Spec.LumaPlayerContainerView.RenderView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.LumaPlayerContainerView: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MacBlurView: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSVisualEffectView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.MacBlurView: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MacPairingAcceptView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.PlainTextFieldStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.Text?)>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>)>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FrameLayout>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._FrameLayout>>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Material>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>, SwiftUI._FrameLayout>)>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MacPairingState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MacPairingState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MacPairingMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MacPairingMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MacPairingOverlay: SwiftUI.View {
    typealias Body = SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI.Text?)>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>)>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedButtonStyle, SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI._TrimmedShape<SwiftUI.Circle>, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._RotationEffect>, Spec.RotatingModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI._FrameLayout>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._OpacityEffect>)>>, SwiftUI._FrameLayout>, SwiftUI._AppearanceActionModifier>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Material>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.RotatingModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.RotatingModifier>, SwiftUI._RotationEffect>, SwiftUI._AppearanceActionModifier>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.XTweetComposeView: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI._TrimmedShape<SwiftUI.Circle>, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._RotationEffect>, SwiftUI.Text?)>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Spacer, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>Swift.StringSwift.String>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0028XTweetComposeViewswift_IxAFhfMX295_0_33_C71A03E5690659FC409BACF6172CF061Ll7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.MacSyncGateState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MacSyncGateState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MacSyncGateView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Material>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>, SwiftUI._FixedSizeLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI._FrameLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._IndefiniteSymbolEffectModifier>, SwiftUI._PaddingLayout>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FixedSizeLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._IndefiniteSymbolEffectModifier>, SwiftUI._PaddingLayout>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>, SwiftUI._FixedSizeLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>, SwiftUI._FrameLayout>)>>, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.WindowAccessor: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.WindowAccessor: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SparkleUpdaterController: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.DraftedAction: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.DraftedAction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DraftedAction: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MeetingPrepDoc: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MeetingPrepDoc: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MeetingPrepDoc: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MeetingDebriefDoc: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MeetingDebriefDoc: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.MeetingDebriefDoc: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.IntraDayPrep: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.IntraDayPrep: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.IntraDayPrep: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.IntraDayPrep: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.EventUrgentAction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.EventUrgentAction: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.EventUrgentAction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.UrgentActionStep: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.UrgentActionStep: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.UrgentActionStep: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.UrgentActionPayload: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.UrgentActionPayload: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.UrgentActionPayload: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DraftNotionAction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.DraftNotionAction: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.DraftNotionAction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SpecEvent.TimeFilter: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SpecEvent.TimeFilter: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.SpecEvent.EventCategory: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SpecEvent.EventCategory: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.SpecEvent: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.EventAction: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.EventPreview: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.MainViewNavigationState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainViewNavigationState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.IosSyncScreen: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainView.IosSyncScreen: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.ChatAnimationPhase: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainView.ChatAnimationPhase: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.EventDetailAnimationPhase: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainView.EventDetailAnimationPhase: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.IntraDayPrepAnimationPhase: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainView.IntraDayPrepAnimationPhase: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.DraftedActionAnimationPhase: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainView.DraftedActionAnimationPhase: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.DraftsOverlayAnimationPhase: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainView.DraftsOverlayAnimationPhase: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.TodoDetailAnimationPhase: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainView.TodoDetailAnimationPhase: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.CycleDirection: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainView.CycleDirection: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.PasteAwareTextField: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSTextField
    typealias Coordinator = Spec.MainView.PasteAwareTextField.Coordinator

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.MainView.PasteAwareTextField: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView: SwiftUI.View {
    typealias Body = SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Combine.Published<[Spec.PermissionStatus]>.Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.AnyView, SwiftUI._OverlayModifier<SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaRegionsIgnoringLayout>>, SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.VideoPlayerLoopView, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>)>>>, SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.SpecLogoBlinkView, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle, SwiftUI._PaddingLayout>, SwiftUI.Spacer)>>>>?)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._TaskValueModifier<Swift.Int>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.SpecLogoBlinkView, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>>, SwiftUI._FrameLayout>?, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._OpacityEffect>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.SpecLogoBlinkView, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>)>>, SwiftUI._FrameLayout>, SwiftUI._TransactionModifier>)>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.SpecGreetingBubbleView, SwiftUI._TransactionModifier>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.TypingIndicatorBubbleView, SwiftUI._BackgroundModifier<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._PreferenceWritingModifier<Spec.MainView.TypingIndicatorHeightKey>>>>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?)>>, SwiftUI._BackgroundModifier<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._PreferenceWritingModifier<Spec.MainView.GreetingBubbleHeightKey>>>>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>??, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.AnyView>>>SwiftUI.PlainButtonStyle, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._OffsetEffect>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ForEach<[(offset: Swift.Int, element: (Swift.String, Swift.String, Swift.String?, Swift.String, Spec.PermissionType))], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>>>, SwiftUI._PaddingLayout>, SwiftUI._AnimationModifier<Swift.Bool>>?)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>??, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.AnyView>>>SwiftUI.PlainButtonStyle, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._OpacityEffect>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI._PaddingLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Int>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._OffsetEffect>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>>>, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Int>>?>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI._FlexFrameLayout>>SwiftUI.PlainButtonStyle, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Int>>?)>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.Int>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>>>, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Int>>?>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI._FlexFrameLayout>>SwiftUI.PlainButtonStyle, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Int>>?)>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.Int>>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>??, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.AnyView>>>SwiftUI.PlainButtonStyle, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Int>>)>?)>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._OffsetEffect>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>??, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.AnyView>>>SwiftUI.PlainButtonStyle, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>??, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.AnyView>>>SwiftUI.PlainButtonStyle, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Bool>>)>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._PaddingLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text, SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>?)>>)>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?, SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.LinearProgressViewStyle)>>)>>>>, SwiftUI._PaddingLayout>?)>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.Text>)>>, SwiftUI._PaddingLayout>?, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>??, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.AnyView>>>SwiftUI.PlainButtonStyle, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Bool>>?)>>?>, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._OffsetEffect>?)>>)>>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AppearanceActionModifier>?)>>)>>, SwiftUI._BackgroundModifier<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<__C.CGSize>>>>>, SwiftUI._OffsetEffect>>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.ContinueWithGoogleButton, SwiftUI._FrameLayout>, SwiftUI._OpacityEffect>, SwiftUI._OffsetEffect>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._EnvironmentKeyWritingModifier<Spec.AuthViewModel?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.PlainButtonStyle, SwiftUI.Text, SwiftUI.Button<SwiftUI.Text>SwiftUI.PlainButtonStyle)>>)>>, SwiftUI._OpacityEffect>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI.AccessibilityAttachmentModifier>, SwiftUI._OpacityEffect>)>?)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Spacer)>>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._AppearanceActionModifier>>>>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>>)>>, SwiftUI._ValueActionModifier<FirebaseAuth.User?>>, SwiftUI._TaskValueModifier<Swift.Bool>>, SwiftUI._OverlayModifier<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Menu<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>)>>SwiftUI.BorderlessButtonMenuStyle, SwiftUI._FixedSizeLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>?, SwiftUI.SubscriptionView<Publisher, Spec.MainView.InviteGateOverlay>?, SwiftUI.ModifiedContent<Spec.MacSyncGateView, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?)>>>?>>>, SwiftUI._OverlayModifier<SwiftUI.Group<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)?>>>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.Bool>>>>>Swift.StringSwiftUI.Button<SwiftUI.Text>SwiftUI.TextSwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.Button<SwiftUI.Text>)>>, SwiftUI._FrameLayout>>Spec.GmailAccountManagerView, SwiftUI._OverlayModifier<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<Spec.OfflineToastView, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._AnimationModifier<Swift.Bool>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<Spec.IosSyncReminderToastView, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._AnimationModifier<Swift.Bool>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<Spec.AnthropicOverloadedToastView, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._AnimationModifier<Swift.Bool>>?)>>>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AnimationModifier<Swift.Bool>>?>>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<Spec.MacPairingOverlay, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?>>, Spec.GoogleReauthOverlay)>>, SwiftUI._AppearanceActionModifier>>>>>>>>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<Spec.PopupChatBridge, SwiftUI._AllowsHitTestingModifier>>>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.Bool>>>>>>>>>>>>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.Int>>>>, SwiftUI._ValueActionModifier<Swift.Bool>>, SwiftUI._ValueActionModifier<Swift.Bool>>, SwiftUI._ValueActionModifier<Swift.Bool>>>, SwiftUI._OverlayModifier<SwiftUI.Group<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>)>?)>>>>SwiftUI.ScenePhase>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.HomeGreetingMarkdownView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Swift.Substring)], Swift.Int, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>>?>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension __C.CAEdgeAntialiasingMask: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.CAEdgeAntialiasingMask

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.CAEdgeAntialiasingMask: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.CAEdgeAntialiasingMask: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.CAEdgeAntialiasingMask: Swift.OptionSet {
    typealias Element = __C.CAEdgeAntialiasingMask

    init(rawValue: Self.RawValue)
}
extension __C.CAEdgeAntialiasingMask: Swift.SetAlgebra {
    typealias Element = __C.CAEdgeAntialiasingMask

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.VideoPlayerLoopView: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.VideoPlayerLoopView: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.AVPlayerView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.GlassEffectWrapper: SwiftUI.ViewModifier {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI._ViewModifier_Content<Spec.GlassEffectWrapper>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.CenterInViewport: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.CenterInViewport>, SwiftUI._FlexFrameLayout>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.MainView.LiveChatPopoverButton: SwiftUI.View {
    typealias Body = SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyleSwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.PlainButtonStyle, SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.PlainButtonStyle, SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.GiftInvitePopoverButton: SwiftUI.View {
    typealias Body = SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyleSpec.InviteQuickSharePopup

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.UrgentAvatarIconView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI.Color>>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.VisitSiteButton: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._OpacityEffect>)>>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle, SwiftUI._TaskModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.ContextAppsPillView.IconSquare: SwiftUI.View {
    typealias Body = SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<Spec.RoundedRectangleWithBite, SwiftUI.Color>, SwiftUI._FrameLayout>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.PackedTile.Size: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainView.PackedTile.Size: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.PackedTile: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.MainView.TimeOfDayBucket: Swift.CaseIterable {
    typealias AllCases = [Spec.MainView.TimeOfDayBucket]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.MainView.TimeOfDayBucket: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MainView.TimeOfDayBucket: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MainView.TimeOfDayBucket: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MainView.DraftsOverlayCard: SwiftUI.View {
    typealias Body = SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.VisualEffectBlur, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ForEach<[Spec.DraftListItem], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>?, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.TypingIndicatorHeightKey: SwiftUI.PreferenceKey {
    typealias Value = CoreGraphics.CGFloat

    static var defaultValue: Self.Value {
        get
    }
    static var _isReadableByHost: Swift.Bool {
        get
    }
    static var _includesRemovedValues: Swift.Bool {
        get
    }

    static func reduce(value: inout Self.Value, nextValue: () -> Self.Value)
}
extension Spec.MainView.GreetingBubbleHeightKey: SwiftUI.PreferenceKey {
    typealias Value = CoreGraphics.CGFloat

    static var defaultValue: Self.Value {
        get
    }
    static var _isReadableByHost: Swift.Bool {
        get
    }
    static var _includesRemovedValues: Swift.Bool {
        get
    }

    static func reduce(value: inout Self.Value, nextValue: () -> Self.Value)
}
extension Spec.MainView.InviteGateOverlay: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, Spec.MainView.InviteGateInline, SwiftUI.Divider, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._FlexFrameLayout>, SwiftUI._ShadowEffect>)>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.InviteGatePreAuthInline: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._ValueActionModifier<Swift.String>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI.Text?, SwiftUI.Text?)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.InviteGateInline: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI.Text?)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.ManualHeroRect: SwiftUI.View {
    typealias Body = SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PositionLayout>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SearchBarHeightPreferenceKey: SwiftUI.PreferenceKey {
    typealias Value = CoreGraphics.CGFloat

    static var defaultValue: Self.Value {
        get
    }
    static var _isReadableByHost: Swift.Bool {
        get
    }
    static var _includesRemovedValues: Swift.Bool {
        get
    }

    static func reduce(value: inout Self.Value, nextValue: () -> Self.Value)
}
extension Spec.DraftNotionAction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DraftNotionAction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DraftNotionAction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DraftNotionAction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DraftNotionAction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.UrgentActionPayload.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.UrgentActionPayload.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.UrgentActionPayload.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.UrgentActionPayload.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.UrgentActionPayload.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.UrgentActionStep.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.UrgentActionStep.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.UrgentActionStep.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.UrgentActionStep.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.UrgentActionStep.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.EventUrgentAction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.EventUrgentAction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.EventUrgentAction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.EventUrgentAction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.EventUrgentAction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.IntraDayPrep.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.IntraDayPrep.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.IntraDayPrep.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.IntraDayPrep.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.IntraDayPrep.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MeetingDebriefDoc.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MeetingDebriefDoc.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MeetingDebriefDoc.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MeetingDebriefDoc.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MeetingDebriefDoc.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MeetingPrepDoc.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MeetingPrepDoc.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MeetingPrepDoc.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MeetingPrepDoc.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MeetingPrepDoc.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.DraftedAction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.DraftedAction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.DraftedAction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.DraftedAction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.DraftedAction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.LiquidGlassContainer: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<A, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Material>>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.ContextSourcePreviewView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<CoreGraphics.CGFloat>>, SwiftUI._FlexFrameLayout>SwiftUI.EnabledTextSelectability>, SwiftUI._FlexFrameLayout>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MainView.HoverHighlightPillModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.MainView.HoverHighlightPillModifier>, SwiftUI._ContentShapeModifier<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._HoverRegionModifier>, SwiftUI._AnimationModifier<Swift.Bool>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.MainView.ContextAppsPillView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.MainView.ContextAppsPillView.IconSquare, SwiftUI._FrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.ZIndexTraitKey>>>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Bool>>)>>, Spec.MainView.HoverHighlightPillModifier>SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.MainView.ContextSourcePreviewView, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._ShadowEffect>>>, SwiftUI.EmptyView>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FocusEffectSuppressor: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI._ViewModifier_Content<Spec.FocusEffectSuppressor>>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.GroupModifierMacCorners: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.GroupModifierMacCorners>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._ClipEffect<SwiftUI.Rectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension __C.ActivationType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.Level: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.Level: Swift._SwiftNewtypeWrapper {}
extension __C.Level: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.Level: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.Level: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSNumber

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.Level: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MarkdownText: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.AnyView>, SwiftUI.Text>>, SwiftUI._FlexFrameLayout>, SwiftUI._FixedSizeLayout>SwiftUI.EnabledTextSelectability

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SelectableMarkdownText: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSScrollView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.SelectableMarkdownText: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ChecklistItemView: SwiftUI.View {
    typealias Body = SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>>SwiftUI.PlainButtonStyle, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<CoreGraphics.CGFloat>>, SwiftUI._FixedSizeLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<CoreGraphics.CGFloat>>, SwiftUI._FixedSizeLayout>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MarkdownTextTest: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<Spec.MarkdownText, SwiftUI._PaddingLayout>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0027MarkdownTextTestswift_ovFAhfMX62_0_33_700297F5BB2BF39432276DFAE8983393Ll7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.MeetingPrepViewMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MeetingPrepViewMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MeetingPrepViewMode: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.MeetingPrepViewMode: Swift.CaseIterable {
    typealias AllCases = [Spec.MeetingPrepViewMode]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.MeetingPrepDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<Spec.MarkdownText, SwiftUI._ConditionalContent<Spec.MarkdownText, SwiftUI.Text>>, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>>SwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[Spec.MeetingPrepViewMode], Spec.MeetingPrepViewMode, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?>>>>SwiftUI.PlainButtonStyle>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.Color, SwiftUI.ModifiedContent<Spec.VisualEffectBlur, SwiftUI._OpacityEffect>)>>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._ShadowEffect>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.Color, SwiftUI.ModifiedContent<Spec.VisualEffectBlur, SwiftUI._OpacityEffect>, SwiftUI.Color)>>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MeshGradient: SwiftUI.View {
    typealias Body = SwiftUI.Canvas<SwiftUI.EmptyView>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MeshGradientButton: SwiftUI.View {
    typealias Body = SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.LinearGradient>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.TimelineView<SwiftUI.AnimationTimelineSchedule, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>, SwiftUI._BlurEffect>, SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>, Spec.MovingShimmer)>>>>>, SwiftUI._ShadowEffect>, SwiftUI._ShadowEffect>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>Spec.ScaleButtonStyle

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessageSentNotificationView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._ScaleEffect>, SwiftUI._AnimationModifier<Swift.Bool>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>??, SwiftUI.Text)>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._AnimationModifier<Swift.Bool>>, (SwiftUI.Button<SwiftUI.Text>SwiftUI.PlainButtonStyle)?)>>, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._OpacityEffect>, SwiftUI._ScaleEffect>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._OpacityEffect>, SwiftUI._AnimationModifier<Swift.Bool>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessageSentSystemView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessagesReplyPreviewView: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI.ForEach<[(offset: Swift.Int, element: (message: Spec.Message, reactions: [Swift.String]))], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer?, SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._FlexFrameLayout>SwiftUI.EnabledTextSelectability, SwiftUI._OverlayModifier<SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Swift.String)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._ShadowEffect>>>>>, SwiftUI._OffsetEffect>?>>>>, SwiftUI.Spacer?)>>, SwiftUI._PaddingLayout>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._FlexFrameLayout>SwiftUI.EnabledTextSelectability, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>)>>>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<Spec.VisualEffectView>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>, SwiftUI._FlexFrameLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>Swift.String>Swift.String?Swift.String?SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>, SwiftUI.ForEach<[(offset: Swift.Int, element: (message: Spec.Message, reactions: [Swift.String]))], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>, SwiftUI._OverlayModifier<SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Swift.String)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._ShadowEffect>>>>>, SwiftUI._OffsetEffect>?>>>, SwiftUI.Spacer?)>>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OpacityEffect>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>)>>, SwiftUI._AppearanceActionModifier>Swift.String>Swift.String?Swift.String?, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Material>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessageTriageTestView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Toggle<SwiftUI.Text>SwiftUI.SwitchToggleStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI.Text)>>?, SwiftUI._ConditionalContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.Contact)], Swift.Int, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>SwiftUI.PlainButtonStyle>>, SwiftUI._PaddingLayout>>, SwiftUI.Text>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._PaddingLayout>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, (SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)?)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>SwiftUI.EnabledTextSelectability>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI._PaddingLayout>>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0032MessageTriageTestViewswift_jIADjfMX218_0_33_D782ACEF5AEE841BE8F0E082BD236D96Ll7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.MessageTriageTestViewModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.MessageTriageTestViewModel.TriageResult.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Spec.MessageTriageTestViewModel.TriageResult.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Spec.MessageTriageTestViewModel.TriageResult.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageTriageTestViewModel.TriageResult.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Spec.MessageTriageTestViewModel.TriageResult.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.MessageTriageTestViewModel.TriageResult: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.MessageTriageTestViewModel.TriageResult: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Spec.VisualEffectBlur: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSVisualEffectView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.VisualEffectBlur: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.RoundedRectangleWithBite: SwiftUI.Shape {
    var layoutDirectionBehavior: SwiftUI.LayoutDirectionBehavior {
        get
    }

    func path(in: __C.CGRect) -> SwiftUI.Path
    func sizeThatFits(_: SwiftUI.ProposedViewSize) -> __C.CGSize

    static var role: SwiftUI.ShapeRole {
        get
    }
}
extension Spec.RoundedRectangleWithBite: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.RoundedRectangleWithBite: SwiftUI.View {
    typealias Body = SwiftUI._ShapeView<Spec.RoundedRectangleWithBite, SwiftUI.ForegroundStyle>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AppleMapsPreviewCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<_MapKit_SwiftUI.Map<_MapKit_SwiftUI.MapContentView<Swift.Never, (_MapKit_SwiftUI.Marker<SwiftUI.Text>SwiftUI.Color)?>>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>>>?>, SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>)>>>>>)>>, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>, SwiftUI._PaddingLayout>>SwiftUI.PlainButtonStyle, SwiftUI._FrameLayout>, SwiftUI._HoverRegionModifier>, SwiftUI._MaskEffect<SwiftUI.LinearGradient>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FeatheredAppleMapsPreviewCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._ForegroundStyleModifier<SwiftUI.HierarchicalShapeStyle>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._InsettableBackgroundShapeModifier<SwiftUI.Material, SwiftUI.Capsule>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Capsule, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._MaskEffect<SwiftUI.LinearGradient>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.CombinedMapAndDraftedCardView: SwiftUI.View {
    typealias Body = SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.FoldedCornerCard, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>, SwiftUI._HoverRegionModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.AppleMapsPreviewCard, SwiftUI._OffsetEffect>, SwiftUI._OpacityEffect>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._TraitWritingModifier<SwiftUI.ZIndexTraitKey>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EventRowWrapper: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<A, SwiftUI._HoverRegionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MessageEventTestView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Toggle<SwiftUI.Text>SwiftUI.SwitchToggleStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text?)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI.Text)>>?, SwiftUI._ConditionalContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.Contact)], Swift.Int, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>SwiftUI.PlainButtonStyle>>, SwiftUI._PaddingLayout>>, SwiftUI.Text>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._PaddingLayout>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>)>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, (SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)?)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>SwiftUI.EnabledTextSelectability>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.ForEach<[Spec.EventValidationResult], Foundation.UUID, Spec.EventValidationResultRow>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI._PaddingLayout>>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.$s4Spec0031MessageEventTestViewswift_yFFIifMX396_0_33_C84BCBEA4FB165B55A9EBA49CF88715ELl7PreviewfMf_15PreviewRegistryfMu_: DeveloperToolsSupport.PreviewRegistry {
    static var fileID: Swift.String {
        get
    }
    static var preview: DeveloperToolsSupport.Preview {
        get
    }
    static var column: Swift.Int {
        get
    }
    static var line: Swift.Int {
        get
    }

    static func makePreview() throws -> DeveloperToolsSupport.Preview
}
extension Spec.EventValidationResultRow: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI.Text?, SwiftUI.Text?)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI.ModifiedContent<SwiftUI.DisclosureGroup<SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Spacer)>>>>, SwiftUI._PaddingLayout>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.MovingShimmer: SwiftUI.View {
    typealias Body = SwiftUI.TimelineView<SwiftUI.AnimationTimelineSchedule, SwiftUI.ModifiedContent<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.AngularGradient, SwiftUI._BlurEffect>>, SwiftUI._MaskEffect<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.ForegroundStyle, SwiftUI.EmptyView>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.NetworkErrorBanner: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Rectangle, SwiftUI._FrameLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.OfflineToastView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.AccessibilityAttachmentModifier>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.AccessibilityAttachmentModifier>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Material>, SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>)>>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Capsule, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>, SwiftUI.AccessibilityAttachmentModifier>, SwiftUI._FixedSizeLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PermissionType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PermissionType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PermissionType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.PermissionType: Swift.CaseIterable {
    typealias AllCases = [Spec.PermissionType]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.PermissionStatus: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.PermissionOnboardingView: SwiftUI.View {
    typealias Body = SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ForEach<[Spec.PermissionStatus], Foundation.UUID, Spec.PermissionCard>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Image)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>, SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Button<SwiftUI.Text>SwiftUI.LinkButtonStyle)>>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>)>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PermissionOnboardingViewModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.PermissionOnboardingView_Previews: SwiftUI.PreviewProvider {
    typealias Previews = Spec.PermissionOnboardingView

    static var previews: Self.Previews {
        get
    }
    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
}
extension Spec.PermissionOnboardingView_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension __C.CFString: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.CFString: CoreFoundation._CFObject {}
extension __C.CFString: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PermissionCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>)>>, SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedButtonStyle, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedButtonStyle)>>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>)>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>?, SwiftUI.VStack<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>>?, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>, (SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._FlexFrameLayout>>SwiftUI.BorderedButtonStyle)?)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._FlexFrameLayout>>SwiftUI.BorderedProminentButtonStyle>)>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.Phase2MainViewDemo: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>?, SwiftUI.Spacer)>>, SwiftUI._FrameLayout>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.Phase2MainViewDemo_Previews: SwiftUI.PreviewProvider {
    typealias Previews = Spec.Phase2MainViewDemo

    static var previews: Self.Previews {
        get
    }
    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
}
extension Spec.Phase2MainViewDemo_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension Spec.Phase2TaskDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>>>, SwiftUI.Text, SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>?)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image?, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.Spacer)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.Phase2TasksView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[Spec.Phase2Task], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.Phase2TaskCard, SwiftUI._FrameLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>?, Spec.PersonalTasksRow?)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.Phase2TaskCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>, SwiftUI._FrameLayout>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>, SwiftUI._FrameLayout>>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>, SwiftUI._FrameLayout>>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.AsyncImage<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>>>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>, SwiftUI._FrameLayout>>>>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>, SwiftUI._FrameLayout>>)>>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>, SwiftUI._BlendModeEffect>>>, SwiftUI._CompositingGroupEffect>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>)>>, SwiftUI._AppearanceActionModifier>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._OpacityEffect>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._AppearanceActionModifier>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._OffsetEffect>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>>>?, SwiftUI.Spacer)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Material>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PersonalTasksRow: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._RotationEffect>)>>, SwiftUI._PaddingLayout>>SwiftUI.PlainButtonStyle, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[Spec.Phase2Task], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.Phase2TaskCard, SwiftUI._FrameLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>?)>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.Phase2TasksView_Previews: SwiftUI.PreviewProvider {
    typealias Previews = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.Phase2TasksView, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>

    static var previews: Self.Previews {
        get
    }
    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
}
extension Spec.Phase2TasksView_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension Spec.PillTextField: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.Capsule>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.PlainTextFieldStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<Spec.FocusRequestor, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>>Spec.ScaleButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI._HoverRegionModifier>)>>, SwiftUI.ModifiedContent<SwiftUI.StrokeBorderShapeView<SwiftUI.Capsule, SwiftUI.AngularGradient, SwiftUI.EmptyView>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Capsule, SwiftUI.Color, SwiftUI.EmptyView>>>)>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.OrbitSatellite: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.PlanetOrbitView: SwiftUI.View {
    typealias Body = SwiftUI.GeometryReader<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ForEach<[(offset: Swift.Int, element: CoreGraphics.CGFloat)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>>, SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.PlanetOrbitView.PlacedItem)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._PositionLayout>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.AnyView, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OffsetEffect>, SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.PlanetOrbitView.PlacedItem)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.AnyView, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._SaturationEffect>, SwiftUI._ContrastEffect>, SwiftUI._BrightnessEffect>, SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>>>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>?>>>>SwiftUI.PlainButtonStyle, SwiftUI._PositionLayout>?>)>>, SwiftUI._FrameLayout>, SwiftUI.Color>, SwiftUI.Color>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SeededGenerator: Swift.RandomNumberGenerator {
    func next() -> Swift.UInt64
}
extension Spec.PopupChatBridge: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.PopupChatBridge.BridgeContent, SwiftUI._FrameLayout>, SwiftUI._OpacityEffect>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PopupChatBridge.BridgeContent: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.String>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GmailAccount: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.GmailAccount: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GmailAccount: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GranolaOnlyRefreshKey: SwiftUI.EnvironmentKey {
    typealias Value = Swift.Bool

    static var defaultValue: Self.Value {
        get
    }

    static func _valuesEqual(_: Self.Value, _: Self.Value) -> Swift.Bool
}
extension Spec.QuillOnlyRefreshKey: SwiftUI.EnvironmentKey {
    typealias Value = Swift.Bool

    static var defaultValue: Self.Value {
        get
    }

    static func _valuesEqual(_: Self.Value, _: Self.Value) -> Swift.Bool
}
extension Spec.ProfileBuilderTestView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, (SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedButtonStyle)?, SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedButtonStyle, SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedProminentButtonStyle, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>?, SwiftUI.Text)>>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.Text?)>>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>?)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>?)>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.String, SwiftUI.TupleView<(SwiftUI.TextSwift.String, SwiftUI.TextSwift.String, SwiftUI.TextSwift.String, SwiftUI.TextSwift.String)>>SwiftUI.SegmentedPickerStyle, SwiftUI._FlexFrameLayout>)>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI.Text)>, SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.Text)>>?>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._FrameLayout>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle)>>, SwiftUI.Text>, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>>, SwiftUI.Text>?, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>?)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle)>>, SwiftUI._ConditionalContent<SwiftUI.ForEach<[Spec.GmailAccount], Foundation.UUID, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._PaddingLayout>>?, SwiftUI.Divider, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.Int, SwiftUI.TupleView<(SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int)>>SwiftUI.SegmentedPickerStyle, SwiftUI._FrameLayout>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, (SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle)?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle)>>)>>)>>?, SwiftUI.Text?, SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._PaddingLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text?)>>?, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>?)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.Int, SwiftUI.TupleView<(SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int)>>SwiftUI.SegmentedPickerStyle, SwiftUI._FrameLayout>)>>, SwiftUI.HStack<SwiftUI.Toggle<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.CheckboxToggleStyle>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, (SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle)?)>>)>>?, SwiftUI.Text?, SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._PaddingLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text?)>>?, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>?)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.Int, SwiftUI.TupleView<(SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int)>>SwiftUI.SegmentedPickerStyle, SwiftUI._FrameLayout>)>>, SwiftUI.HStack<SwiftUI.Toggle<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.CheckboxToggleStyle>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, (SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle)?)>>)>>?, SwiftUI.Text?, SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._PaddingLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text?)>>?, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>?)>>, SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.Int, SwiftUI.TupleView<(SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int)>>SwiftUI.SegmentedPickerStyle, SwiftUI._FrameLayout>)>>, SwiftUI.HStack<SwiftUI.Toggle<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.CheckboxToggleStyle>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, (SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle)?)>>)>>>?, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text?)>>?, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>?)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Slider<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI.DisclosureGroup<SwiftUI.Text, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.HStack<SwiftUI.Toggle<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.CheckboxToggleStyle>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, (SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle)?)>>)>>>)>>?, SwiftUI.Text?, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI.Text, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>>?)>>, SwiftUI._PaddingLayout>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text?)>>?, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>?)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Slider<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI.DisclosureGroup<SwiftUI.Text, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.HStack<SwiftUI.Toggle<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.CheckboxToggleStyle>, SwiftUI.HStack<SwiftUI.Toggle<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.CheckboxToggleStyle>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, (SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle)?)>>)>>>)>>?, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>?)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.Text>, SwiftUI.Text?)>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, (SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle)?)>>)>>?, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text)>>?, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>?)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, (SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.BorderlessButtonStyle)?)>>, SwiftUI.Text)>>?, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>?)>>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>)>?, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._ScaleEffect>, SwiftUI.Text)>>, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>?, SwiftUI.Text, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>SwiftUI.LinkButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI.ScrollViewReader<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>)>?, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>)>?, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>?, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.IDView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, Swift.String>)>?)>>, SwiftUI._ValueActionModifier<Swift.Bool>>>>, SwiftUI.Spacer)>>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._FrameLayout>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._FrameLayout>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._FrameLayout>)>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>Spec.GmailResultsViewSpec.GmailAccountManagerViewSpec.ChromeResultsViewSpec.WhatsAppResultsViewSpec.GranolaResultsViewSpec.NotionResultsViewSpec.AppleNotesResultsViewSpec.RemindersResultsViewSpec.ScreenTimeResultsViewSpec.SavedDataViewSpec.SavedDataViewSpec.SavedDataViewSwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI._FlexFrameLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>Spec.SavedDataView, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GmailResultsView.EmailRowView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>?)>>, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>?>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.Case?>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.Case?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>?, (SwiftUI.ModifiedContent<SwiftUI.Link<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>SwiftUI.PlainButtonStyle)?, SwiftUI.Spacer)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GmailResultsView.ProfileBuilderTestView_Previews: SwiftUI.PreviewProvider {
    typealias Previews = Spec.ProfileBuilderTestView

    static var previews: Self.Previews {
        get
    }
    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
}
extension Spec.GmailResultsView.ProfileBuilderTestView_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension Spec.GmailResultsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.LazyVStack<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>?>, SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>?>, SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text, SwiftUI.Text?, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>?)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TextField<SwiftUI.Text>SwiftUI.PlainTextFieldStyle>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, Spec.GmailResultsView.EmailRowView>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.Spacer)>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI.Spacer)>>?)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>SwiftUI.BorderlessButtonStyle, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>)>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>?)>>, SwiftUI._PaddingLayout>>>, SwiftUI._PaddingLayout>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GmailAccountManagerView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>?, SwiftUI.Divider, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.BorderedButtonStyle)>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ForEach<[Spec.GmailAccount], Foundation.UUID, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._ForegroundStyleModifier<SwiftUI.Color>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._ForegroundStyleModifier<SwiftUI.Color>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI._PaddingLayout>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>SwiftUI.Text

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GranolaResultsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Toggle<SwiftUI.Text>SwiftUI.SwitchToggleStyle, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._PaddingLayout>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.Bool, SwiftUI.TupleView<(SwiftUI.TextSwift.Bool, SwiftUI.TextSwift.Bool)>>SwiftUI.SegmentedPickerStyle, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._FrameLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI.List<Swift.Never, SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text?)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>?)>>, SwiftUI.HStack<SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._PaddingLayout>?)>>, SwiftUI._PaddingLayout>>>>)>>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>)>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ChromeResultsView.HistoryItemView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Link<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ChromeResultsView.BookmarkItemView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>?, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Link<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ChromeResultsView.EmptySearchView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ChromeResultsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.Int, SwiftUI.TupleView<(SwiftUI.TextSwift.Int, SwiftUI.TextSwift.Int)>>SwiftUI.SegmentedPickerStyle, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TextField<SwiftUI.Text>SwiftUI.PlainTextFieldStyle>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Text, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>?, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.LazyVStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, Spec.ChromeResultsView.HistoryItemView>, Spec.ChromeResultsView.EmptySearchView?)>, SwiftUI.TupleView<(SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI._ConditionalContent<Spec.ChromeResultsView.BookmarkItemView, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._AppearanceActionModifier>>>, SwiftUI._ConditionalContent<Spec.ChromeResultsView.EmptySearchView, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>?)>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>>>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>SwiftUI.BorderlessButtonStyle, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.WhatsAppResultsView.ConversationView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>>SwiftUI.PlainButtonStyle, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, Spec.WhatsAppResultsView.MessageBubbleView>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>?)>>, SwiftUI._PaddingLayout>?)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.WhatsAppResultsView.MessageBubbleView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Text?)>>, SwiftUI.Spacer?)>>, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.WhatsAppResultsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TextField<SwiftUI.Text>SwiftUI.PlainTextFieldStyle>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.LazyVStack<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, Spec.WhatsAppResultsView.ConversationView>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>?)>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>>>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>SwiftUI.BorderlessButtonStyle, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.NotionResultsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Toggle<SwiftUI.Text>SwiftUI.SwitchToggleStyle, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._PaddingLayout>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.Bool, SwiftUI.TupleView<(SwiftUI.TextSwift.Bool, SwiftUI.TextSwift.Bool)>>SwiftUI.SegmentedPickerStyle, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._FrameLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ScrollView<SwiftUI.LazyVStack<SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.NotionPageRow, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider?)>>>>)>>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>)>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.NotionPageRow: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle)>>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI._FlexFrameLayout>?)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AppleNotesResultsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Toggle<SwiftUI.Text>SwiftUI.SwitchToggleStyle, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._PaddingLayout>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.String, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.TextSwift.String>>SwiftUI.MenuPickerStyle, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.Bool, SwiftUI.TupleView<(SwiftUI.TextSwift.Bool, SwiftUI.TextSwift.Bool)>>SwiftUI.SegmentedPickerStyle, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI._FrameLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ScrollView<SwiftUI.LazyVStack<SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.AppleNoteRow, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider?)>>>>)>>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>)>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AppleNoteRow: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.BorderlessButtonStyle)>>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI._FlexFrameLayout>?)>?)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.RemindersResultsView: SwiftUI.View {
    typealias Body = SwiftUI.NavigationStack<SwiftUI.NavigationPath, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>>SwiftUI.TupleToolbarContent<(SwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Text>>, SwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ScreenTimeResultsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>?)>>, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.String, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.TextSwift.String>>SwiftUI.MenuPickerStyle, SwiftUI._FrameLayout>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>)>>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI._ConditionalContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>)>>, SwiftUI.Divider, SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[(offset: Swift.Int, element: Swift.String)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._FlexFrameLayout>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>)>>, SwiftUI.Divider)>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text?, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>)>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text?)>>>)>>, SwiftUI._PaddingLayout>?)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>)>>?)>>, SwiftUI._PaddingLayout>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._PaddingLayout>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>?)>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SavedDataView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.NavigationView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>?, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>)>>, SwiftUI._FlexFrameLayout>Swift.StringSwiftUI.ToolbarItem<(), SwiftUI.Button<SwiftUI.Text>>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ProfileBuilderView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(Spec.ProfileBuilderOnboardingView, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Menu<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Divider, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.TupleView<(SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>)>?)>>SwiftUI.PlainButtonStyleSwiftUI.DefaultMenuStyle)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI.Spacer, Spec.ProfileBuilderProgressView, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.ControlSize>>, SwiftUI._PaddingLayout>)>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<Spec.ProfileQuestionsView, Spec.ProfileBuilderCompletionView>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>>>?>, SwiftUI._PaddingLayout>>)>>, SwiftUI._FlexFrameLayout>SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<Spec.ProfileDatabaseView, SwiftUI._FlexFrameLayout>)>>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.Bool>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ProfileQuestionsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>)>>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.ForEach<[[Swift.String : Swift.String]], [Swift.String : Swift.String], SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle)>>, SwiftUI._PaddingLayout>?>>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ProfileStatusView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text?)>>)>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ProfileDatabaseView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Picker<SwiftUI.Text, Swift.String, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.TextSwift.String>>SwiftUI.MenuPickerStyle, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Image>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.Text, SwiftUI.EmptyView>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.LazyVStack<SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, Spec.DatabaseRowView>>, SwiftUI._PaddingLayout>>>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.String>>SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>SwiftUI.Text

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.DatabaseRowView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._FrameLayout>, SwiftUI.Text, SwiftUI.Text)>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI.Text>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.QuickSummarizePopupModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.KeyCapView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GlassOrFallback: SwiftUI.ViewModifier {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.GlassOrFallback>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>>>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.QuickSummarizePopupView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>?, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI._OpacityShapeStyle<SwiftUI.HierarchicalShapeStyle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>?)>>)>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, Spec.GlassOrFallback>, SwiftUI._FixedSizeLayout>, SwiftUI._AllowsHitTestingModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ReasoningEffort: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ReasoningEffort: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ReasoningEffort: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ReasoningEffort: Swift.CaseIterable {
    typealias AllCases = [Spec.ReasoningEffort]

    static var allCases: Self.AllCases {
        get
    }
}
extension Spec.ReasoningEffort: Swift.Identifiable {
    typealias ID = Spec.ReasoningEffort

    var id: Self.ID {
        get
    }
}
extension Spec.ReasoningEffortPicker: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Capsule, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Divider, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._PaddingLayout>, SwiftUI.ForEach<[Spec.ReasoningEffort], Spec.ReasoningEffort, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FlexFrameLayout>, SwiftUI._ConditionalContent<SwiftUI.Image, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>>>>?)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>SwiftUI.PlainButtonStyle, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Color>>>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.VisualEffectView, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI._ShadowEffect>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>>?)>>, SwiftUI._AnimationModifier<Swift.Bool>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ReasoningEffortPicker_Previews.Wrapper: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Spacer, Spec.ReasoningEffortPicker, SwiftUI.Spacer)>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ReasoningEffortPicker_Previews: SwiftUI.PreviewProvider {
    typealias Previews = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.ReasoningEffortPicker_Previews.Wrapper, SwiftUI._TraitWritingModifier<SwiftUI.PreviewLayoutTraitKey>>, SwiftUI._PreferenceWritingModifier<SwiftUI.PreferredColorSchemeKey>>

    static var previews: Self.Previews {
        get
    }
    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
}
extension Spec.ReasoningEffortPicker_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension Spec.RingSpinner: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI._TrimmedShape<SwiftUI.Circle>, SwiftUI.AngularGradient, SwiftUI.EmptyView>, SwiftUI._RotationEffect>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._FrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI.AccessibilityAttachmentModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ScaleButtonStyle: SwiftUI.ButtonStyle {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ButtonStyleConfiguration.Label, SwiftUI._ScaleEffect>, SwiftUI._BrightnessEffect>, SwiftUI._AnimationModifier<Swift.Bool>>

    func makeBody(configuration: SwiftUI.ButtonStyleConfiguration) -> Self.Body
}
extension Spec.ShimmerEffect: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.ShimmerEffect>, SwiftUI._OverlayModifier<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.LinearGradient, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>, SwiftUI._AnimationModifier<CoreGraphics.CGFloat>>>>>, SwiftUI._AppearanceActionModifier>, SwiftUI._MaskEffect<SwiftUI._ViewModifier_Content<Spec.ShimmerEffect>>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.SidebarButton: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>, SwiftUI._ShadowEffect>, SwiftUI._FrameLayout>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._ContentShapeModifier<SwiftUI.Capsule>>>SwiftUI.PlainButtonStyle, SwiftUI._HoverRegionModifier>, SwiftUI._ClipEffect<SwiftUI.Rectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SimpleThreadDiscoveryView: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(Spec.StatusCard, Spec.StatusCard)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedProminentButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>>SwiftUI.BorderedButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.LazyVStack<SwiftUI.ForEach<[Spec.WorkThread], Swift.String, Spec.SimpleThreadRow>>, SwiftUI._PaddingLayout>>)>>, SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI.Spacer)>>)>>Spec.ThreadDetailView?

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.StatusCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI.Text)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>>, SwiftUI.Text>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SimpleThreadRow: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ThreadDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(Spec.StatBox, Spec.StatBox, Spec.StatBox)>>, SwiftUI._PaddingLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._PaddingLayout>>)>>?, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI._VariadicView.Tree<SwiftUI._LayoutRoot<Spec.FlowLayout>, SwiftUI.ForEach<[Swift.String], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._PaddingLayout>)>>?)>>>)>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.StatBox: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FlowLayout: SwiftUI.Layout {
    typealias Cache = ()

    func makeCache(subviews: SwiftUI.LayoutSubviews) -> Self.Cache
    func updateCache(_: inout Self.Cache, subviews: SwiftUI.LayoutSubviews)
    func spacing(subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> SwiftUI.ViewSpacing
    func sizeThatFits(proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> __C.CGSize
    func placeSubviews(in: __C.CGRect, proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache)
    func explicitAlignment(of: SwiftUI.HorizontalAlignment, in: __C.CGRect, proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> CoreGraphics.CGFloat?
    func explicitAlignment(of: SwiftUI.VerticalAlignment, in: __C.CGRect, proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> CoreGraphics.CGFloat?

    static var layoutProperties: SwiftUI.LayoutProperties {
        get
    }

    static func _makeLayoutView(root: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewOutputs
}
extension Spec.FlowLayout: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.SlackReplyPreviewView: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>>, SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>, SwiftUI.Spacer?)>>>>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._FlexFrameLayout>SwiftUI.EnabledTextSelectability, SwiftUI.Text)>)>>, SwiftUI._PaddingLayout>)>>>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI.Divider, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._AppearanceActionModifier>Swift.String>, SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>>, SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String : Any])], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>, SwiftUI.Spacer?)>>>>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Label<SwiftUI.Text, SwiftUI.Image>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._AppearanceActionModifier>Swift.String>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ActivityIndicatorType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ActivityIndicatorType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ActivityIndicatorType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.FeedbackStateManager: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.InlineToolInfo.State: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.InlineToolInfo.State: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.InlineToolInfo: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.InlineToolInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SpecChatView.ChatConfig: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.SpecChatView.ChatConfig: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.SpecChatView.ScrollOffsetReader: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._PreferenceWritingModifier<Spec.SpecChatView.ScrollOffsetPreferenceKey>>>, SwiftUI._PreferenceActionModifier<Spec.SpecChatView.ScrollOffsetPreferenceKey>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SpecChatView.BottomSentinelPosKey: SwiftUI.PreferenceKey {
    typealias Value = CoreGraphics.CGFloat

    static var _isReadableByHost: Swift.Bool {
        get
    }
    static var defaultValue: Self.Value {
        get
    }
    static var _includesRemovedValues: Swift.Bool {
        get
    }

    static func reduce(value: inout Self.Value, nextValue: () -> Self.Value)
}
extension Spec.SpecChatView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.SubscriptionView<Combine.Published<Swift.String>.Publisher, SwiftUI.SubscriptionView<Combine.Published<Swift.Bool>.Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.VStack<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.AnyView?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.AnyView, SwiftUI._TraitWritingModifier<SwiftUI.LayoutPriorityTraitKey>>, SwiftUI._TransactionModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.ChatInputField, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._PaddingLayout>?)>>>>, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.EmptyView>, SwiftUI._OpacityEffect>>>, SwiftUI._ValueActionModifier<Swift.Bool>>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.String>>, SwiftUI._AppearanceActionModifier>>>>>>>>>, SwiftUI._OverlayModifier<SwiftUI.EmptyView>>, SwiftUI._OverlayModifier<SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>, SwiftUI.Spacer, (SwiftUI.Button<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>>SwiftUI.BorderedButtonStyle)?, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Spacer)>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?>>>, SwiftUI._OverlayModifier<SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaIgnoringLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>)>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>SwiftUI.CircularProgressViewStyle, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._PaddingLayout>)>>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Material>, SwiftUI._ShadowEffect>>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PerActionThinkingView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.ThinkingDisplayView, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.Double?>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ThinkingDisplayView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OffsetEffect>?, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._OpacityEffect>)>>>?, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>?)>>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextSwiftUI.EnabledTextSelectability, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>, SwiftUI._FlexFrameLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>?)>>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>?>>>, SwiftUI._OverlayModifier<SwiftUI.Group<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>?>>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.CustomChatBubble: SwiftUI.Shape {
    var layoutDirectionBehavior: SwiftUI.LayoutDirectionBehavior {
        get
    }

    func path(in: __C.CGRect) -> SwiftUI.Path
    func sizeThatFits(_: SwiftUI.ProposedViewSize) -> __C.CGSize

    static var role: SwiftUI.ShapeRole {
        get
    }
}
extension Spec.CustomChatBubble: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.CustomChatBubble: SwiftUI.View {
    typealias Body = SwiftUI._ShapeView<Spec.CustomChatBubble, SwiftUI.ForegroundStyle>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.RectCorner: Swift.OptionSet {
    typealias Element = Spec.RectCorner

    init(rawValue: Self.RawValue)
}
extension Spec.RectCorner: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.RectCorner: Swift.SetAlgebra {
    typealias Element = Spec.RectCorner

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.RectCorner: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.RectCorner: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Spec.RectCorner

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension Spec.UserMessageView: SwiftUI.View {
    typealias Body = SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<Spec.CustomChatBubble>>, SwiftUI._FlexFrameLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>SwiftUI.EnabledTextSelectability, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Spec.Attachment], Foundation.UUID, Spec.AttachmentPreviewView>>, SwiftUI._FlexFrameLayout>?, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>SwiftUI.PlainButtonStyle, SwiftUI._OpacityEffect>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>SwiftUI.PlainButtonStyle, SwiftUI._OpacityEffect>?)>>, SwiftUI._HoverRegionModifier>)>>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AIMessageCopyButton: SwiftUI.View {
    typealias Body = SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>SwiftUI.PlainButtonStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>?>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FeedbackTextFieldState: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.FeedbackInputView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.PlainTextFieldStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>SwiftUI.PlainButtonStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>)>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AIMessageFeedbackButtons: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>SwiftUI.PlainButtonStyle, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>SwiftUI.PlainButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>?, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AttachmentPreviewView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Rectangle>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Rectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>?>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Text)>>, SwiftUI._FixedSizeLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EquatableMarkdownText: SwiftUI.View {
    typealias Body = Spec.MarkdownText

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.EquatableMarkdownText: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.IsolatedUpdates: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.IsolatedUpdates>, SwiftUI._CompositingGroupEffect>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.StreamingMarkdownText: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<Spec.MarkdownText, SwiftUI._AnimationModifier<Swift.String>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AnimatedStreamingMarkdownText: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.MarkdownText, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.String>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FadingStreamingMarkdownText: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.MarkdownText, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<Spec.MarkdownText, SwiftUI._OpacityEffect>)>>, SwiftUI._CompositingGroupEffect>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.String>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.OptimizedStreamingMarkdownText: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.MarkdownText, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.String>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.InstantStreamingMarkdownText: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.IDView<Spec.MarkdownText, Foundation.UUID>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.String>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.RateLimitedStreamingMarkdownText: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.FadingStreamingMarkdownText, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.String>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.FeedbackButtonsWrapper: SwiftUI.View {
    typealias Body = SwiftUI.IDView<Spec.AIMessageFeedbackButtons, Foundation.UUID>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.StreamingMessageContainer: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.EmptyView, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.IDView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<Spec.MarkdownText, SwiftUI._AnimationModifier<Swift.String>>, Spec.OptimizedStreamingMarkdownText>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._FixedSizeLayout>, Foundation.UUID>, SwiftUI.ModifiedContent<Spec.FeedbackButtonsWrapper, SwiftUI._TransactionModifier>?)>>, SwiftUI._AnimationModifier<Swift.String>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ActionItemView: SwiftUI.View {
    typealias Body = SwiftUI.IDView<SwiftUI.Group<SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.PerActionThinkingView, SwiftUI._PaddingLayout>?, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.MessageSentNotificationView, SwiftUI._PaddingLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.MessageSentNotificationView, SwiftUI._PaddingLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.UserMessageView, SwiftUI._PaddingLayout>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.StreamingMessageContainer, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI.ModifiedContent<Spec.ActiveToolsBanner, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<Spec.ThinkingDisplayView, SwiftUI._PaddingLayout>?)>>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.ToolUseRow, SwiftUI._FlexFrameLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.StreamingMessageContainer, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI.ModifiedContent<Spec.ActiveToolsBanner, SwiftUI._PaddingLayout>?)>>>)>>, Foundation.UUID>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ActionItemView: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.MessageListView.AIActionGroup: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.MessageListView: SwiftUI.View {
    typealias Body = SwiftUI.LazyVStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._FrameLayout>, SwiftUI.HStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>>>?, SwiftUI.ForEach<[Spec.MessageListView.AIActionGroup], Swift.String, SwiftUI.ModifiedContent<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.IDView<Spec.ActionItemView, Foundation.UUID>, SwiftUI._AppearanceActionModifier>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.IDView<SwiftUI.HStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.GroupedToolUseRow, SwiftUI._FlexFrameLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>>, Swift.String>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AppearanceActionModifier>?>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.IDView<SwiftUI.EquatableView<Spec.CollapsedToolUseGroup>, Swift.String>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._AppearanceActionModifier>?>>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.IDView<Spec.EmailReplyPreviewView, Swift.String>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._PaddingLayout>?, SwiftUI._ConditionalContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<Spec.SlackReplyPreviewView, SwiftUI._AppearanceActionModifier>>, SwiftUI.ModifiedContent<SwiftUI.EmptyView, SwiftUI._AppearanceActionModifier>>?, SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.IDView<Spec.MessagesReplyPreviewView, Swift.String>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.IDView<Spec.XDMReplyPreviewView, Swift.String>, SwiftUI._TraitWritingModifier<SwiftUI.TransitionTraitKey>>, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.IDView<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._FrameLayout>, Swift.String>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>)>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension CodingKeys in SummaryResponse #1 in Spec.SpecChatView: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension CodingKeys in SummaryResponse #1 in Spec.SpecChatView: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension CodingKeys in SummaryResponse #1 in Spec.SpecChatView: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CodingKeys in SummaryResponse #1 in Spec.SpecChatView: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension CodingKeys in SummaryResponse #1 in Spec.SpecChatView: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SummaryResponse #1 in Spec.SpecChatView: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SummaryResponse #1 in Spec.SpecChatView: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Spec.TimelineInteractorOverlay: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.TimelineInteractor, SwiftUI._FlexFrameLayout>, SwiftUI._FrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI.EmptyView>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ActiveToolsBanner: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI._VariadicView.Tree<SwiftUI._LayoutRoot<Spec.WrappingFlowLayout>, SwiftUI.ForEach<[Spec.ActiveBannerTool], Swift.String, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.ActiveToolsBanner.BannerItemView, SwiftUI._FixedSizeLayout>, SwiftUI._TraitWritingModifier<SwiftUI.LayoutPriorityTraitKey>>>>, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.InlineToolsList: SwiftUI.View {
    typealias Body = SwiftUI.VStack<SwiftUI.ForEach<[Spec.InlineToolInfo], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.Capsule>>)>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ActiveBannerTool: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.TimelineInteractor: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._PositionLayout>, SwiftUI._FlexFrameLayout>, SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._PositionLayout>>)>>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>SwiftUI._ChangedGesture<SwiftUI.DragGesture>>, SwiftUI._FrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ActiveToolsBanner.BannerItemView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>>, SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.Capsule>>)>>, SwiftUI.Text>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.Capsule>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SpecChatView.NotificationObserver: Combine.ObservableObject {
    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.SpecChatView.ScrollOffsetPreferenceKey: SwiftUI.PreferenceKey {
    typealias Value = CoreGraphics.CGFloat

    static var _isReadableByHost: Swift.Bool {
        get
    }
    static var defaultValue: Self.Value {
        get
    }
    static var _includesRemovedValues: Swift.Bool {
        get
    }

    static func reduce(value: inout Self.Value, nextValue: () -> Self.Value)
}
extension Spec.SpecGreetingBubbleView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>?, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.AccessibilityAttachmentModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SpecLogoBlinkView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.BlinkSmallLids, SwiftUI._FrameLayout>, SwiftUI._PositionLayout>>, Spec.BlinkLids>>>>, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>, SwiftUI._AppearanceActionModifier>, SwiftUI._ValueActionModifier<Swift.Int>>, SwiftUI._AnimationModifier<CoreGraphics.CGFloat>>, SwiftUI.AccessibilityAttachmentModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.BlinkSmallLids: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Capsule>>, SwiftUI._OffsetEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Capsule>>, SwiftUI._OffsetEffect>)>>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>>, SwiftUI._AllowsHitTestingModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.BlinkLids: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Capsule>>, SwiftUI._OffsetEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Capsule>>, SwiftUI._OffsetEffect>)>>, SwiftUI._FrameLayout>, SwiftUI._MaskEffect<SwiftUI.Circle._Inset>>>, SwiftUI._AllowsHitTestingModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.StreamData: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.StreamsOverviewViewIntegrated: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.ScrollOffsetReader, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.LazyVStack<SwiftUI.ForEach<[Spec.StreamData], Swift.String, SwiftUI.ModifiedContent<Spec.StreamRowView, SwiftUI._HoverRegionModifier>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<Spec.PlanetOrbitView>, SwiftUI._CompositingGroupEffect>, SwiftUI._FrameLayout>, SwiftUI._AllowsHitTestingModifier>, SwiftUI._OpacityEffect>, SwiftUI._ScaleEffect>, SwiftUI._AnimationModifier<CoreGraphics.CGFloat>>>>>>>)>>, SwiftUI._AppearanceActionModifier>>>, SwiftUI._ValueActionModifier<Swift.Int>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.StreamRowView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.PlanetOrbitView, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>?, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?, SwiftUI.Spacer)>>)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._OpacityEffect>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.MiniVisualEffectView, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>)>>>>>SwiftUI.PlainButtonStyle, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.StreamTimelineViewIntegrated.PersonBadge: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.StreamTimelineViewIntegrated: SwiftUI.View {
    typealias Body = SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Publisher, SwiftUI.SubscriptionView<Combine.Publishers.Autoconnect<TimerPublisher>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI.Text)>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>?)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>SwiftUI.CircularProgressViewStyle, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.LazyVStack<SwiftUI.TupleView<(SwiftUI.ForEach<[(offset: Swift.Int, element: (header: Swift.String, subheader: Swift.String, items: [(event: Spec.SpecEvent, index: Swift.Int)]))], Swift.Int, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ForEach<[(event: Spec.SpecEvent, index: Swift.Int)], Foundation.UUID, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>, SwiftUI.Spacer)>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ForEach<[(offset: Swift.Int, element: Swift.String)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._OpacityEffect>?>, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.StreamTimelineViewIntegrated.PersonBadge)], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.Text>>>>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>>, SwiftUI.Text?)>>, SwiftUI._PaddingLayout>?)>>, SwiftUI._PaddingLayout>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>>)>>, SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._FrameLayout>)>>>, SwiftUI._PaddingLayout>>)>>)>>, SwiftUI._AppearanceActionModifier>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension __C.Base64DecodingOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.Base64DecodingOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.Base64DecodingOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.Base64DecodingOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.Base64DecodingOptions: Swift.OptionSet {
    typealias Element = __C.Base64DecodingOptions

    init(rawValue: Self.RawValue)
}
extension __C.Base64DecodingOptions: Swift.SetAlgebra {
    typealias Element = __C.Base64DecodingOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.ScrollOffsetReader: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.ScrollOffsetReader: SwiftUI.NSViewRepresentable {
    typealias NSViewType = Spec.ScrollOffsetReader.ObservingView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.StreamsOverviewViewIntegrated.StreamsScrollOffsetKey: SwiftUI.PreferenceKey {
    typealias Value = CoreGraphics.CGFloat

    static var _isReadableByHost: Swift.Bool {
        get
    }
    static var defaultValue: Self.Value {
        get
    }
    static var _includesRemovedValues: Swift.Bool {
        get
    }

    static func reduce(value: inout Self.Value, nextValue: () -> Self.Value)
}
extension Spec.TasksListView: SwiftUI.View {
    typealias Body = SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>SwiftUI.CircularProgressViewStyle, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>)>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>>, SwiftUI.LazyVStack<SwiftUI.ForEach<[Spec.SpecTask], Swift.String, Spec.TaskRowViewSwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>, SwiftUI.Button<SwiftUI.Text>)>>>>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>>SwiftUI.ModifiedContent<Spec.CreateTaskSheet, SwiftUI._FlexFrameLayout>Spec.SpecTaskSwiftUI.ModifiedContent<Spec.TaskLogsSheet, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TaskLogsSheet: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.TaskLogsSheet: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.Divider, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._FlexFrameLayout>, SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Spec.ExecutionLog], Swift.String, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>?)>>)>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[Spec.ActionSetLog], Swift.String, SwiftUI.ForEach<[Spec.ActionLog], Swift.String, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>?)>>, SwiftUI.Spacer)>>>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._PaddingLayout>?)>>>>, SwiftUI._PaddingLayout>>>)>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TaskRowView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>?)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._HoverRegionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.CreateTaskSheet: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>SwiftUI.PlainButtonStyle)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI.Text, SwiftUI.TextField<SwiftUI.Text>SwiftUI.RoundedBorderTextFieldStyle, SwiftUI.Toggle<SwiftUI.Text>)>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.Button<SwiftUI.Text>, SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI.Text>, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TodayTodosView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.Spacer, (SwiftUI.Button<SwiftUI.Text>SwiftUI.PlainButtonStyle)?)>>, SwiftUI._PaddingLayout>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._FlexFrameLayout>, SwiftUI._FrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[Spec.Todo], Foundation.UUID, SwiftUI.ModifiedContent<Spec.TodoCard, SwiftUI._ContentShapeModifier<SwiftUI.Rectangle>>>>, SwiftUI._PaddingLayout>>, SwiftUI._PaddingLayout>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TodoCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>?)>>>SwiftUI.PlainButtonStyle, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Text?)>>, SwiftUI.Spacer, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?>, SwiftUI.Spacer, SwiftUI.Group<SwiftUI.Text?>)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>, SwiftUI._ScaleEffect>, SwiftUI._HoverRegionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TodayTodosView_Previews: SwiftUI.PreviewProvider {
    typealias Previews = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.TodayTodosView, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>

    static var previews: Self.Previews {
        get
    }
    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
}
extension Spec.TodayTodosView_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension Spec.TodoDetailView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextField<SwiftUI.Text>SwiftUI.PlainTextFieldStyle, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._FlexFrameLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Toggle<SwiftUI.Text>SwiftUI.SwitchToggleStyle, (SwiftUI.DatePicker<SwiftUI.Text>)?, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.Toggle<SwiftUI.Text>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Menu<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.ForEach<[Spec.Todo.Priority], Spec.Todo.Priority, SwiftUI.Button<SwiftUI.Text>>>, SwiftUI.Menu<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.Image, SwiftUI.Text)>, SwiftUI.Text>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>, SwiftUI.Divider, SwiftUI.ForEach<[Spec.Todo.Category], Spec.Todo.Category, SwiftUI.Button<SwiftUI.Text>>)>>, SwiftUI.Spacer)>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedProminentButtonStyle, SwiftUI.Button<SwiftUI.Text>SwiftUI.BorderedButtonStyle, SwiftUI.Spacer)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TodoDraftPopupModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.TodoDraftPopupView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._FlexFrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FlexFrameLayout>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Rectangle>>, SwiftUI._AllowsHitTestingModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TodoDraftPopupCloneModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Spec.TodoDraftPopupCloneView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.Text)>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.Text)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, Spec.GlassOrFallback>, SwiftUI._FixedSizeLayout>, SwiftUI._AllowsHitTestingModifier>, SwiftUI._AppearanceActionModifier>, SwiftUI._AnimationModifier<Swift.Int>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GlassOrFallback: SwiftUI.ViewModifier {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.GlassOrFallback>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._ShadowEffect>>>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.TodoRowView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>?)>>>SwiftUI.PlainButtonStyle, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._OpacityEffect>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._OpacityEffect>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>?>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>?>, SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.Text)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>?>, SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>)>>)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._HoverRegionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TodoRowView_Previews: SwiftUI.PreviewProvider {
    typealias Previews = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(Spec.TodoRowView, Spec.TodoRowView)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>

    static var previews: Self.Previews {
        get
    }
    static var platform: SwiftUI.PreviewPlatform? {
        get
    }
}
extension Spec.TodoRowView_Previews: SwiftUI._PreviewProvider {
    static var _platform: SwiftUI.PreviewPlatform? {
        get
    }
    static var _previews: Any {
        get
    }
}
extension Spec.ToolUseRow: SwiftUI.View {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>, SwiftUI._OpacityEffect>, SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI._TrimmedShape<SwiftUI.Circle>, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._RotationEffect>, SwiftUI._AnimationModifier<Swift.Double>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>)>?)>>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, Spec.RingSpinner>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI.Text, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._AppearanceActionModifier>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.Capsule>>)>>)>>, SwiftUI.Text>, SwiftUI.Text>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>, SwiftUI.Text>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>)>>, SwiftUI.Text>, SwiftUI.Text>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>)>>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._OpacityEffect>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>)>>, SwiftUI.Spacer)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>?)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>)>>, SwiftUI.Spacer)>>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>?, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>>>?)>>, SwiftUI.Spacer)>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._OpacityEffect>>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._AppearanceActionModifier>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>)>>, SwiftUI.Spacer)>>, SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._OpacityEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>, SwiftUI._OpacityEffect>, SwiftUI.TupleView<(SwiftUI.Spacer, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI._TrimmedShape<SwiftUI.Circle>, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._RotationEffect>, SwiftUI._AnimationModifier<Swift.Double>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>)>?)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>, SwiftUI._OpacityEffect>)>>>, SwiftUI.EmptyView>, SwiftUI._ConditionalContent<SwiftUI.EmptyView, SwiftUI.EmptyView>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>, SwiftUI._OpacityEffect>)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>, SwiftUI._OpacityEffect>)>>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI._ConditionalContent<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>>>, SwiftUI._OpacityEffect>)>>>>?>, SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, Spec.RingSpinner>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>, SwiftUI._OpacityEffect>, SwiftUI._ValueActionModifier<Swift.Bool>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GroupedToolUseRow: SwiftUI.View {
    typealias Body = SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.Text)>>, SwiftUI.Spacer)>>, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[(offset: Swift.Int, element: Spec.GroupedToolUseRow.ToolUseInfo)], Swift.Int, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ProgressView<SwiftUI.EmptyView, SwiftUI.EmptyView>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>)>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>>>, SwiftUI._PaddingLayout>?)>>, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>>, SwiftUI._ConditionalContent<SwiftUI.Text, SwiftUI.Text>)>>, SwiftUI._AppearanceActionModifier>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>, SwiftUI._ClipEffect<SwiftUI.Capsule>>)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>?)>>, SwiftUI._PaddingLayout>, SwiftUI.Spacer)>>>>, SwiftUI._PaddingLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(Spec.VisualEffectView, SwiftUI.Color)>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.GroupedToolUseRow.CommandType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.GroupedToolUseRow.CommandType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.GroupedToolUseRow.CommandType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.ToolUseRow.CommandType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.ToolUseRow.CommandType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.ToolUseRow.CommandType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Spec.TopPriorityContactsView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI._ConditionalContent<SwiftUI.IDView<SwiftUI.ModifiedContent<SwiftUI.GeometryReader<SwiftUI.ZStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.AvatarImageView, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>>>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._OffsetEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._OffsetEffect>>?>>, SwiftUI._PositionLayout>>>>, SwiftUI._ClipEffect<SwiftUI.Rectangle>>, Foundation.UUID>, SwiftUI.Color>?>, SwiftUI._FlexFrameLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PulseView: SwiftUI.View {
    typealias Body = SwiftUI.SubscriptionView<Publisher, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI.VStack<SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.TupleView<(SwiftUI.ModifiedContent<Spec.PulseScrollOffsetReader, SwiftUI._FrameLayout>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Text, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Rectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.LazyVStack<SwiftUI.ForEach<[Spec.Phase2Task], Swift.String, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<Spec.PulseTodoDraftCard, SwiftUI._PaddingLayout>, SwiftUI._AppearanceActionModifier>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Rectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>?)>>>>, SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._FrameLayout>)>>)>>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<Spec.PlanetOrbitView>, SwiftUI._CompositingGroupEffect>, SwiftUI._FrameLayout>, SwiftUI._AllowsHitTestingModifier>, SwiftUI._OpacityEffect>, SwiftUI._ScaleEffect>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.LinearGradient, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Rectangle, SwiftUI.Color>, SwiftUI._FrameLayout>)>>, SwiftUI._OffsetEffect>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._ScaleEffect>, SwiftUI._OpacityEffect>, SwiftUI._AllowsHitTestingModifier>, SwiftUI._TraitWritingModifier<SwiftUI.ZIndexTraitKey>>)>>, SwiftUI._AllowsHitTestingModifier>>>>>>)>>, SwiftUI._AppearanceActionModifier>, SwiftUI._AnimationModifier<CoreGraphics.CGFloat>>, SwiftUI._ValueActionModifier<Swift.Int>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PulseScrollOffsetReader: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PulseScrollOffsetReader: SwiftUI.NSViewRepresentable {
    typealias NSViewType = Spec.PulseScrollOffsetReader.ObservingView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.PulseTodoDraftCard.RoundedCornerShape: SwiftUI.View {
    typealias Body = SwiftUI._ShapeView<Spec.PulseTodoDraftCard.RoundedCornerShape, SwiftUI.ForegroundStyle>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PulseTodoDraftCard.RoundedCornerShape: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.PulseTodoDraftCard.RoundedCornerShape: SwiftUI.Shape {
    var layoutDirectionBehavior: SwiftUI.LayoutDirectionBehavior {
        get
    }

    func path(in: __C.CGRect) -> SwiftUI.Path
    func sizeThatFits(_: SwiftUI.ProposedViewSize) -> __C.CGSize

    static var role: SwiftUI.ShapeRole {
        get
    }
}
extension Spec.PulseTodoDraftCard.ChipHeightPreferenceKey: SwiftUI.PreferenceKey {
    typealias Value = CoreGraphics.CGFloat

    static var _isReadableByHost: Swift.Bool {
        get
    }
    static var defaultValue: Self.Value {
        get
    }
    static var _includesRemovedValues: Swift.Bool {
        get
    }

    static func reduce(value: inout Self.Value, nextValue: () -> Self.Value)
}
extension Spec.PulseTodoDraftCard.TodoAction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PulseTodoDraftCard.TodoAction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PulseTodoDraftCard.SourceChip: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.PulseTodoDraftCard.QuickAction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.PulseTodoDraftCard.QuickAction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.PulseTodoDraftCard: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI.Spacer, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Capsule, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI.Text)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Capsule, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Capsule, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>, SwiftUI._FrameLayout>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>, SwiftUI._FrameLayout>>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>, SwiftUI._FrameLayout>>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.AsyncImage<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>>>, SwiftUI._FrameLayout>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ClipEffect<SwiftUI.Circle>>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>, SwiftUI._FrameLayout>>>>, SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI.Text)>>, SwiftUI._FrameLayout>>)>>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>, SwiftUI._FrameLayout>, SwiftUI._OffsetEffect>, SwiftUI._BlendModeEffect>>>, SwiftUI._CompositingGroupEffect>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._ScaleEffect>, SwiftUI._FrameLayout>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>>)>>, SwiftUI._AppearanceActionModifier>, SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._AppearanceActionModifier>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<Spec.PulseTodoDraftCard.RoundedCornerShape, SwiftUI.Color>>>)>>, SwiftUI.Spacer)>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ScrollView<SwiftUI.HStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>>SwiftUI.PlainButtonStyle>>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.TextEditor, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.TextAlignment>>, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundStyleModifier<SwiftUI.Color>>)>>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<Spec.PulseTodoDraftCard.RoundedCornerShape, SwiftUI.Color>>>?, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ScrollView<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<[Spec.PulseTodoDraftCard.SourceChip], Foundation.UUID, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>>>, SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._FlexFrameLayout>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Text.TruncationMode>>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>, SwiftUI._BackgroundModifier<SwiftUI.GeometryReader<SwiftUI.ModifiedContent<SwiftUI.Color, SwiftUI._PreferenceWritingModifier<Spec.PulseTodoDraftCard.ChipHeightPreferenceKey>>>>>>SwiftUI.PlainButtonStyle>>, SwiftUI._PaddingLayout>>, SwiftUI._FlexFrameLayout>, SwiftUI.Spacer, (SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.Circle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle)?)>>, SwiftUI._PreferenceActionModifier<Spec.PulseTodoDraftCard.ChipHeightPreferenceKey>>)>>, SwiftUI._OpacityEffect>, SwiftUI._ScaleEffect>, SwiftUI._OffsetEffect>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.PulseView.ContactAggregate: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.TopPriorityContactsView.ContactAggregate: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Spec.TopPriorityContactsView.ContactAggregate: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension Spec.AvatarImageView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.Text)>>>, SwiftUI.AsyncImage<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.Text)>>>>>, SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.Text)>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.Text)>>>, SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.Text)>>>>>, SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._OverlayStyleModifier<SwiftUI.Color>>, SwiftUI.Text)>>>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TypingIndicatorBubbleView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ForEach<Swift.Range<Swift.Int>, Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.Circle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI._ScaleEffect>, SwiftUI._AnimationModifier<Swift.Double>>>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>>>, SwiftUI._AppearanceActionModifier>, SwiftUI.AccessibilityAttachmentModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.TypingTextView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._AppearanceActionModifier>, SwiftUI._AppearanceActionModifier>, SwiftUI.AccessibilityAttachmentModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.UndoVisualEffectView: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSVisualEffectView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.UndoVisualEffectView: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.VisualEffectView: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSVisualEffectView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.VisualEffectView: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.WordFadeText: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.ForEach<[(offset: Swift.Int, element: [Swift.String])], Swift.Int, Spec.WordFadeParagraph>>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.WordFlowLayout: SwiftUI.Animatable {
    typealias AnimatableData = SwiftUI.EmptyAnimatableData

    var animatableData: Self.AnimatableData {
        get
        set
    }

    static func _makeAnimatable(value: inout SwiftUI._GraphValue<Self>, inputs: SwiftUI._GraphInputs)
}
extension Spec.WordFlowLayout: SwiftUI.Layout {
    typealias Cache = ()

    func makeCache(subviews: SwiftUI.LayoutSubviews) -> Self.Cache
    func updateCache(_: inout Self.Cache, subviews: SwiftUI.LayoutSubviews)
    func spacing(subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> SwiftUI.ViewSpacing
    func sizeThatFits(proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> __C.CGSize
    func placeSubviews(in: __C.CGRect, proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache)
    func explicitAlignment(of: SwiftUI.HorizontalAlignment, in: __C.CGRect, proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> CoreGraphics.CGFloat?
    func explicitAlignment(of: SwiftUI.VerticalAlignment, in: __C.CGRect, proposal: SwiftUI.ProposedViewSize, subviews: SwiftUI.LayoutSubviews, cache: inout Self.Cache) -> CoreGraphics.CGFloat?

    static var layoutProperties: SwiftUI.LayoutProperties {
        get
    }

    static func _makeLayoutView(root: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewOutputs
}
extension Spec.WordFadeParagraph: SwiftUI.View {
    typealias Body = SwiftUI._VariadicView.Tree<SwiftUI._LayoutRoot<Spec.WordFlowLayout>, SwiftUI.ForEach<[(offset: Swift.Int, element: Swift.String)], Swift.Int, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._OpacityEffect>, SwiftUI._AnimationModifier<Swift.Bool>>>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.KeyPressHandler: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSView
    typealias Coordinator = ()

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.KeyPressHandler: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.CustomTextField: SwiftUI.NSViewRepresentable {
    typealias NSViewType = __C.NSTextField
    typealias Coordinator = Spec.CustomTextField.Coordinator

    func makeNSView(context: SwiftUI.NSViewRepresentableContext<Self>) -> Self.NSViewType
    func updateNSView(_: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>)
    func makeCoordinator() -> Self.Coordinator
    func _identifiedViewTree(in: Self.NSViewType) -> SwiftUI._IdentifiedViewTree
    func sizeThatFits(_: SwiftUI.ProposedViewSize, nsView: Self.NSViewType, context: SwiftUI.NSViewRepresentableContext<Self>) -> __C.CGSize?
    func _overrideSizeThatFits(_: inout __C.CGSize, in: SwiftUI._ProposedSize, nsView: Self.NSViewType)
    func _overrideLayoutTraits(_: inout SwiftUI._LayoutTraits, for: Self.NSViewType)

    static var _invalidatesSizeOnConstraintChanges: Swift.Bool {
        get
    }

    static func dismantleNSView(_: Self.NSViewType, coordinator: Self.Coordinator)
    static func _modifyBridgedViewInputs(_: inout SwiftUI._ViewInputs)
    static func _layoutOptions(_: Self.NSViewType) -> SwiftUI._PlatformViewRepresentableLayoutOptions
}
extension Spec.CustomTextField: SwiftUI.View {
    typealias Body = Swift.Never

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.UrgentLeavePopupView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.Color, SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._AspectRatioLayout>, SwiftUI._FrameLayout>, SwiftUI._ShadowEffect>, SwiftUI._PaddingLayout>, SwiftUI._OffsetEffect>?, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.VStack<SwiftUI.TupleView<(SwiftUI.Group<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._EnvironmentKeyWritingModifier<Swift.Int?>>, SwiftUI._FixedSizeLayout>>, SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Image, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>)>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle, SwiftUI.Button<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.HStack<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._PaddingLayout>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._BackgroundModifier<SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeBorderShapeView<SwiftUI.RoundedRectangle, SwiftUI.LinearGradient, SwiftUI.EmptyView>>>>>>SwiftUI.PlainButtonStyle)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.Spacer, SwiftUI._FrameLayout>)>>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI._OffsetEffect>)>>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.Group<SwiftUI._ConditionalContent<SwiftUI.AnyView, SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI.StrokeShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color, SwiftUI.EmptyView>>>>>>>, SwiftUI._FlexFrameLayout>, SwiftUI._OffsetEffect>, SwiftUI.Spacer)>>, SwiftUI._FlexFrameLayout>)>>, SwiftUI._SafeAreaRegionsIgnoringLayout>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.AppInfo: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Spec.AppInfo: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Spec.AppInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.ActivityOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.ActivityOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.ActivityOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.ActivityOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt64

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.ActivityOptions: Swift.OptionSet {
    typealias Element = __C.ActivityOptions

    init(rawValue: Self.RawValue)
}
extension __C.ActivityOptions: Swift.SetAlgebra {
    typealias Element = __C.ActivityOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension Spec.ConditionalShimmer: SwiftUI.ViewModifier {
    typealias Body = SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Spec.ConditionalShimmer>, Shimmer.Shimmer>, SwiftUI._ViewModifier_Content<Spec.ConditionalShimmer>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Spec.ContentView: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.GeometryReader<SwiftUI.ZStack<SwiftUI.HStack<SwiftUI.EmptyView>>>, SwiftUI._FlexFrameLayout>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.KeepAwakeToggle: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Toggle<SwiftUI.Text>SwiftUI.SwitchToggleStyle, SwiftUI._PaddingLayout>, SwiftUI._ValueActionModifier<Swift.Bool>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Spec.SpecApp: SwiftUI.App {
    typealias Body = SwiftUI.Settings<SwiftUI.EmptyView>SwiftUI.CommandGroup<SwiftUI.EmptyView>

    init()

    var body: Self.Body {
        get
    }
}
extension AIProxy.AIProxyActor: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension AIProxy.AIProxyActor: Swift.GlobalActor {
    typealias ActorType = AIProxy.AIProxyActor

    static var sharedUnownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
    static var shared: Self.ActorType {
        get
    }
}
extension AIProxy.AIProxyError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension AIProxy.AIProxyError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AIProxyError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension AIProxy.AIProxyHTTPVerb: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AIProxyHTTPVerb: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AIProxyHTTPVerb: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AIProxyJSONValue: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AIProxyJSONValue: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.AIProxyJSONValue: Swift.ExpressibleByNilLiteral {
    init(nilLiteral: ())
}
extension AIProxy.AIProxyJSONValue: Swift.ExpressibleByBooleanLiteral {
    typealias BooleanLiteralType = Swift.Bool

    init(booleanLiteral: Self.BooleanLiteralType)
}
extension AIProxy.AIProxyJSONValue: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int

    init(integerLiteral: Self.IntegerLiteralType)
}
extension AIProxy.AIProxyJSONValue: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Double

    init(floatLiteral: Self.FloatLiteralType)
}
extension AIProxy.AIProxyJSONValue: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension AIProxy.AIProxyJSONValue: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension AIProxy.AIProxyJSONValue: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension AIProxy.AIProxyJSONValue: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = AIProxy.AIProxyJSONValue

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension AIProxy.AIProxyJSONValue: Swift.ExpressibleByDictionaryLiteral {
    typealias Key = Swift.String
    typealias Value = AIProxy.AIProxyJSONValue

    init(dictionaryLiteral: (Self.Key, Self.Value)...)
}
extension AIProxy.AIProxyLogLevel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AIProxyLogLevel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AIProxyLogLevel: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnonymousAccount: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnonymousAccount: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.AnonymousAccount: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnonymousAccount.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnonymousAccount.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnonymousAccount.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnonymousAccount.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnonymousAccount.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicAsyncChunks.AsyncIterator: Swift.AsyncIteratorProtocol {
    typealias Element = AIProxy.AnthropicMessageStreamingChunk
    typealias Failure = Swift.Error

    func next() async throws -> Self.Element?
    func next(isolation: isolated Swift.Actor?) async throws(Self.Failure) -> Self.Element?
}
extension AIProxy.AnthropicAsyncChunks: Swift.AsyncSequence {
    typealias AsyncIterator = AIProxy.AnthropicAsyncChunks.AsyncIterator
    typealias Element = AIProxy.AnthropicMessageStreamingChunk
    typealias Failure = Swift.Error

    func makeAsyncIterator() -> Self.AsyncIterator
}
extension AIProxy.AnthropicDirectService: AIProxy.ServiceMixin {}
extension AIProxy.AnthropicDirectService: AIProxy.DirectService {}
extension AIProxy.AnthropicDirectService: AIProxy.AnthropicService {}
extension AIProxy.AnthropicMessageRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.AnthropicImageMediaType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicImageMediaType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicImageMediaType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicInputContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.AnthropicInputMessage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.AnthropicInputMessageRole: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicInputMessageRole: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicInputMessageRole: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicInputMessageRole: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.AnthropicRequestMetadata: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.AnthropicToolChoice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.AnthropicTool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.AnthropicMessageRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicMessageRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicInputContent.SourceCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicInputContent.SourceCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicInputContent.SourceCodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicInputContent.SourceCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicInputContent.SourceCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicInputContent.SourceCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicInputContent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicInputContent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicInputContent.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicInputContent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicInputContent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicInputContent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicInputMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicInputMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicInputMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicInputMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicInputMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicRequestMetadata.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicRequestMetadata.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicRequestMetadata.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicRequestMetadata.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicRequestMetadata.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicToolChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicToolChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicToolChoice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicToolChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicToolChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicToolChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicTool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicTool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicTool.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicTool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicTool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicTool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicMessageResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnthropicMessageResponseContent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnthropicMessageUsage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnthropicMessageUsage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageUsage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageUsage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicMessageUsage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageUsage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageUsage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicMessageResponseContent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageResponseContent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageResponseContent.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicMessageResponseContent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageResponseContent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageResponseContent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicMessageResponseContent.ContentType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicMessageResponseContent.ContentType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageResponseContent.ContentType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageResponseContent.ContentType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnthropicMessageResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicMessageResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock.PossibleTypes: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock.PossibleTypes: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock.PossibleTypes: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageStreamingContentBlockStart.ContentBlock.PossibleTypes: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta.PossibleTypes: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta.PossibleTypes: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta.PossibleTypes: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AnthropicMessageStreamingDeltaBlock.Delta.PossibleTypes: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.AnthropicProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.AnthropicProxiedService: AIProxy.ProxiedService {}
extension AIProxy.AnthropicProxiedService: AIProxy.AnthropicService {}
extension AIProxy.AudioController.Mode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.AudioController.Mode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.AudioPCMPlayerError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension AIProxy.AudioPCMPlayerError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension AIProxy.BraveDirectService: AIProxy.ServiceMixin {}
extension AIProxy.BraveDirectService: AIProxy.DirectService {}
extension AIProxy.BraveDirectService: AIProxy.BraveService {}
extension AIProxy.BraveProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.BraveProxiedService: AIProxy.ProxiedService {}
extension AIProxy.BraveProxiedService: AIProxy.BraveService {}
extension AIProxy.BraveWebSearchResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.BraveWebSearchResponseBody.Query: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.MixedItem: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.BraveWebSearchResponseBody.Mixed: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.BraveWebSearchResponseBody.Web: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Profile: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.MetaURL: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Thumbnail: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Thumbnail.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Thumbnail.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Thumbnail.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Thumbnail.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Thumbnail.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Thumbnail.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.MetaURL.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.MetaURL.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.MetaURL.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.MetaURL.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.MetaURL.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.MetaURL.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Profile.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Profile.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Profile.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Profile.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Profile.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.Profile.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.BraveWebSearchResponseBody.Web.SearchResult.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Web.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.BraveWebSearchResponseBody.Web.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.BraveWebSearchResponseBody.Web.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.MixedItem.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.MixedItem.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.MixedItem.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.MixedItem.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.BraveWebSearchResponseBody.Mixed.MixedItem.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Query.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Query.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Query.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.Query.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.BraveWebSearchResponseBody.Query.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.BraveWebSearchResponseBody.Query.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.BraveWebSearchResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.BraveWebSearchResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.BraveWebSearchResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.Payload: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.Payload.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.Payload.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.Payload.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.Payload.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.Payload.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepLAccountType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepLAccountType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepLDirectService: AIProxy.ServiceMixin {}
extension AIProxy.DeepLDirectService: AIProxy.DirectService {}
extension AIProxy.DeepLDirectService: AIProxy.DeepLService {}
extension AIProxy.DeepLProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.DeepLProxiedService: AIProxy.ProxiedService {}
extension AIProxy.DeepLProxiedService: AIProxy.DeepLService {}
extension AIProxy.DeepLTranslateRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.DeepLFormality: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepLFormality: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepLFormality: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepLFormality: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.DeepLSplitSentencesOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepLSplitSentencesOption: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepLSplitSentencesOption: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepLSplitSentencesOption: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.DeepLTagHandling: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepLTagHandling: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepLTagHandling: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepLTagHandling: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.DeepLTranslateRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepLTranslateRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepLTranslateRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepLTranslateRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepLTranslateRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepLTranslateRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepLTranslateResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepLTranslation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepLTranslation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepLTranslation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepLTranslation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepLTranslation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepLTranslation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepLTranslation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepLTranslateResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepLTranslateResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepLTranslateResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepLTranslateResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepLTranslateResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Message: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ResponseFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ResponseFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.DeepSeekChatCompletionRequestBody.StreamOptions: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.DeepSeekChatCompletionRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Message.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Message.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Message.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Message.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Message.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Message.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ResponseFormat.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ResponseFormat.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ResponseFormat.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool.FunctionKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool.FunctionKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool.FunctionKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool.FunctionKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool.FunctionKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionRequestBody.Tool.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionRequestBody.ToolChoice.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.Function: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionResponseBody.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.Delta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionChunk.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekChatCompletionChunk.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekChatCompletionChunk.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekChatCompletionChunk.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekDirectService: AIProxy.ServiceMixin {}
extension AIProxy.DeepSeekDirectService: AIProxy.DirectService {}
extension AIProxy.DeepSeekDirectService: AIProxy.DeepSeekService {}
extension AIProxy.DeepSeekProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.DeepSeekProxiedService: AIProxy.ProxiedService {}
extension AIProxy.DeepSeekProxiedService: AIProxy.DeepSeekService {}
extension AIProxy.DeepSeekUsage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepSeekUsage.CompletionTokenDetails: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.DeepSeekUsage.CompletionTokenDetails.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekUsage.CompletionTokenDetails.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekUsage.CompletionTokenDetails.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekUsage.CompletionTokenDetails.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekUsage.CompletionTokenDetails.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekUsage.CompletionTokenDetails.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekUsage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekUsage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.DeepSeekUsage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.DeepSeekUsage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.DeepSeekUsage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.DeepSeekUsage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAICreatePredictionRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.EachAICreatePredictionRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAICreatePredictionRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAICreatePredictionRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAICreatePredictionRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAICreatePredictionRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAICreatePredictionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.EachAICreatePredictionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAICreatePredictionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAICreatePredictionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAICreatePredictionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAICreatePredictionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAIDirectService: AIProxy.DirectService {}
extension AIProxy.EachAIDirectService: AIProxy.ServiceMixin {}
extension AIProxy.EachAIError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension AIProxy.EachAIError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAIError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAIError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension AIProxy.EachAIImagenInput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.EachAIImagenInput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAIImagenInput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAIImagenInput.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.EachAIImagenInput.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAIImagenInput.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAIImagenInput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.EachAIPrediction.Input: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.EachAIPrediction.Metrics: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.EachAIPrediction.ActionURLs: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.EachAIPrediction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAIPrediction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAIPrediction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.Input.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.Input.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.Input.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAIPrediction.Input.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAIPrediction.Input.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.ActionURLs.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.ActionURLs.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.ActionURLs.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAIPrediction.ActionURLs.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAIPrediction.ActionURLs.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.Metrics.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.Metrics.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAIPrediction.Metrics.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.EachAIPrediction.Metrics.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAIPrediction.Metrics.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAIPrediction.Metrics.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAIProxiedService: AIProxy.ProxiedService {}
extension AIProxy.EachAIProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.EachAITriggerWorkflowRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.EachAITriggerWorkflowRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAITriggerWorkflowRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAITriggerWorkflowRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAITriggerWorkflowRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAITriggerWorkflowRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAITriggerWorkflowResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.EachAITriggerWorkflowResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAITriggerWorkflowResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAITriggerWorkflowResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.EachAITriggerWorkflowResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAITriggerWorkflowResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAITriggerWorkflowResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAIVeoInput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.EachAIVeoInput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAIVeoInput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAIVeoInput.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.EachAIVeoInput.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAIVeoInput.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAIVeoInput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAIWorkflowExecutionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.StepResult: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.StepResult.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.StepResult.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.StepResult.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.StepResult.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.StepResult.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.StepResult.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.EachAIWorkflowExecutionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsDirectService: AIProxy.ServiceMixin {}
extension AIProxy.ElevenLabsDirectService: AIProxy.DirectService {}
extension AIProxy.ElevenLabsDirectService: AIProxy.ElevenLabsService {}
extension AIProxy.ElevenLabsProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.ElevenLabsProxiedService: AIProxy.ProxiedService {}
extension AIProxy.ElevenLabsProxiedService: AIProxy.ElevenLabsService {}
extension AIProxy.ElevenLabsSpeechToSpeechRequestBody: AIProxy.MultipartFormEncodable {}
extension AIProxy.ElevenLabsSpeechToTextRequestBody: AIProxy.MultipartFormEncodable {}
extension AIProxy.ElevenLabsSpeechToTextRequestBody.ModelID: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ElevenLabsSpeechToTextRequestBody.ModelID: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ElevenLabsSpeechToTextRequestBody.ModelID: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextRequestBody.ModelID: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ElevenLabsSpeechToTextRequestBody.TimestampGranularity: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ElevenLabsSpeechToTextRequestBody.TimestampGranularity: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ElevenLabsSpeechToTextRequestBody.TimestampGranularity: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextRequestBody.TimestampGranularity: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.AdditionalFormat: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.Character: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.WordType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.WordType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.WordType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.WordType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.Character.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.Character.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.Character.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.Character.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.Character.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.AdditionalFormat.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.AdditionalFormat.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.AdditionalFormat.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.AdditionalFormat.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.AdditionalFormat.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.AdditionalFormat.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.Word.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ElevenLabsSpeechToTextResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ElevenLabsTTSRequestBody.PronunciationDictionaryLocator: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ElevenLabsTTSRequestBody.VoiceSettings: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ElevenLabsTTSRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ElevenLabsTTSRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ElevenLabsTTSRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.PronunciationDictionaryLocator.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.PronunciationDictionaryLocator.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.PronunciationDictionaryLocator.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.PronunciationDictionaryLocator.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ElevenLabsTTSRequestBody.PronunciationDictionaryLocator.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ElevenLabsTTSRequestBody.PronunciationDictionaryLocator.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.VoiceSettings.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.VoiceSettings.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.VoiceSettings.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ElevenLabsTTSRequestBody.VoiceSettings.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ElevenLabsTTSRequestBody.VoiceSettings.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ElevenLabsTTSRequestBody.VoiceSettings.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalDirectService: AIProxy.ServiceMixin {}
extension AIProxy.FalDirectService: AIProxy.DirectService {}
extension AIProxy.FalDirectService: AIProxy.FalService {}
extension AIProxy.FalError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension AIProxy.FalError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension AIProxy.FalFastSDXLInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFastSDXLInputSchema.ImageSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFastSDXLInputSchema.ImageSize: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFastSDXLInputSchema.ImageSize: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.ImageSize: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFastSDXLInputSchema.LoraWeight: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFastSDXLInputSchema.Embedding: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFastSDXLInputSchema.SafetyCheckerVersion: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFastSDXLInputSchema.SafetyCheckerVersion: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFastSDXLInputSchema.SafetyCheckerVersion: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.SafetyCheckerVersion: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFastSDXLInputSchema.Format: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFastSDXLInputSchema.Format: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFastSDXLInputSchema.Format: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.Format: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFastSDXLInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFastSDXLInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFastSDXLInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.LoraWeight.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.LoraWeight.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.LoraWeight.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFastSDXLInputSchema.LoraWeight.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFastSDXLInputSchema.LoraWeight.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.Embedding.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.Embedding.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLInputSchema.Embedding.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFastSDXLInputSchema.Embedding.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFastSDXLInputSchema.Embedding.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLOutputSchema: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalFastSDXLOutputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLOutputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFastSDXLOutputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFastSDXLOutputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFastSDXLOutputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFastSDXLOutputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFluxLoRAFastTrainingInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxLoRAFastTrainingInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxLoRAFastTrainingInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.File: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.File.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.File.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.File.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.File.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.File.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxLoRAFastTrainingOutputSchema.File.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFluxLoRAInputSchema.ImageSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxLoRAInputSchema.ImageSize: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxLoRAInputSchema.ImageSize: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxLoRAInputSchema.ImageSize: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFluxLoRAInputSchema.Lora: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFluxLoRAInputSchema.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxLoRAInputSchema.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxLoRAInputSchema.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxLoRAInputSchema.OutputFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFluxLoRAInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxLoRAInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxLoRAInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxLoRAInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAInputSchema.Lora.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAInputSchema.Lora.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAInputSchema.Lora.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxLoRAInputSchema.Lora.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxLoRAInputSchema.Lora.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAOutputSchema: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalFluxLoRAOutputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAOutputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFluxLoRAOutputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxLoRAOutputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxLoRAOutputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxLoRAOutputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFluxProKontextInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFluxProKontextInputSchema.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxProKontextInputSchema.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxProKontextInputSchema.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxProKontextInputSchema.OutputFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFluxProKontextInputSchema.AspectRatio: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxProKontextInputSchema.AspectRatio: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxProKontextInputSchema.AspectRatio: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxProKontextInputSchema.AspectRatio: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFluxProKontextInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFluxProKontextInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFluxProKontextInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxProKontextInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxProKontextInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxProKontextInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFluxProKontextOutputSchema: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalFluxProKontextOutputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFluxProKontextOutputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFluxProKontextOutputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxProKontextOutputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxProKontextOutputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFluxSchnellInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFluxSchnellInputSchema.ImageSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxSchnellInputSchema.ImageSize: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxSchnellInputSchema.ImageSize: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxSchnellInputSchema.ImageSize: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalFluxSchnellInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFluxSchnellInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFluxSchnellInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxSchnellInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxSchnellInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxSchnellInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalFluxSchnellOutputSchema: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalFluxSchnellOutputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalFluxSchnellOutputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalFluxSchnellOutputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalFluxSchnellOutputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalFluxSchnellOutputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalFluxSchnellOutputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalInitiateUploadRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalInitiateUploadRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalInitiateUploadRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalInitiateUploadRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalInitiateUploadRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalInitiateUploadRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalInitiateUploadRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalInitiateUploadResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalInitiateUploadResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalInitiateUploadResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalInitiateUploadResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalInitiateUploadResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalInitiateUploadResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalInitiateUploadResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalOutputImage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalOutputImage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalOutputImage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalOutputImage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalOutputImage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalOutputImage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalOutputImage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.FalProxiedService: AIProxy.ProxiedService {}
extension AIProxy.FalProxiedService: AIProxy.FalService {}
extension AIProxy.FalQueueResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalQueueResponseBody.Status: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalQueueResponseBody.Status: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalQueueResponseBody.Status: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalQueueResponseBody.Status: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalQueueResponseBody.Metrics: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalQueueResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalQueueResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalQueueResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalQueueResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalQueueResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalQueueResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalQueueResponseBody.Metrics.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalQueueResponseBody.Metrics.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalQueueResponseBody.Metrics.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalQueueResponseBody.Metrics.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalQueueResponseBody.Metrics.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalQueueResponseBody.Metrics.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalTimings: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalTimings.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalTimings.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalTimings.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalTimings.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalTimings.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalTimings.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalTryonInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalTryonInputSchema.Category: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalTryonInputSchema.Category: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalTryonInputSchema.Category: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalTryonInputSchema.Category: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalTryonInputSchema.GarmentPhotoType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalTryonInputSchema.GarmentPhotoType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalTryonInputSchema.GarmentPhotoType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalTryonInputSchema.GarmentPhotoType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.FalTryonInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalTryonInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalTryonInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalTryonInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalTryonInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalTryonInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalTryonOutputSchema: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalTryonOutputSchema.TryonImage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.FalTryonOutputSchema.TryonImage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalTryonOutputSchema.TryonImage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalTryonOutputSchema.TryonImage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.FalTryonOutputSchema.TryonImage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalTryonOutputSchema.TryonImage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalTryonOutputSchema.TryonImage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FalTryonOutputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.FalTryonOutputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.FalTryonOutputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.FalTryonOutputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.FalTryonOutputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.FireworksAIDirectService: AIProxy.ServiceMixin {}
extension AIProxy.FireworksAIDirectService: AIProxy.DirectService {}
extension AIProxy.FireworksAIDirectService: AIProxy.FireworksAIService {}
extension AIProxy.FireworksAIProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.FireworksAIProxiedService: AIProxy.ProxiedService {}
extension AIProxy.FireworksAIProxiedService: AIProxy.FireworksAIService {}
extension AIProxy.GeminiBatchRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiBatchRequestBody.InputConfigKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.InputConfigKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.InputConfigKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.InputConfigKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiBatchRequestBody.InputConfigKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiBatchRequestBody.InputConfigKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.BatchKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.BatchKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.BatchKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.BatchKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiBatchRequestBody.BatchKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiBatchRequestBody.BatchKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiBatchRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiBatchRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiBatchRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiBatchResponseBody.BatchResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.State: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.State: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.State: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.State: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.InputConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.OutputConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.BatchStats: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.InputConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.InputConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.InputConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.InputConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.InputConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.OutputConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.OutputConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.OutputConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.OutputConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.OutputConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.BatchStats.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.BatchStats.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.BatchStats.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.BatchStats.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.BatchStats.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchResponse.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiBatchResponseBody.BatchResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiBatchResponseBody.BatchResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiBatchResponseBody.BatchMetadata.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiBatchResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiBatchResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiBatchResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiDirectService: AIProxy.ServiceMixin {}
extension AIProxy.GeminiDirectService: AIProxy.DirectService {}
extension AIProxy.GeminiDirectService: AIProxy.GeminiService {}
extension AIProxy.GeminiError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension AIProxy.GeminiError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension AIProxy.GeminiFile: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiFile.State: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiFile.State: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiFile.State: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiFile.State: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiFile.VideoMetadata: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiFile.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiFile.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiFile.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiFile.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiFile.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiFile.VideoMetadata.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiFile.VideoMetadata.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiFile.VideoMetadata.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiFile.VideoMetadata.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiFile.VideoMetadata.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiFileUploadResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiFileUploadResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiFileUploadResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiFileUploadResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiFileUploadResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiFileUploadResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.Content: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.GoogleSearch: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.Mode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.Mode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.Mode: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.Mode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.FunctionDeclaration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.Mode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.Mode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.Mode: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.Mode: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.SafetyCategory: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.SafetyCategory: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.SafetyCategory: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.SafetyCategory: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.HarmBlockThreshold: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.HarmBlockThreshold: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.HarmBlockThreshold: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.HarmBlockThreshold: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.SystemInstruction: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.ThinkingConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.MultiSpeakerVoiceConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.PrebuiltVoiceConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.SpeakerVoiceConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceName: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceName: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceName: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceName: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiGenerateContentRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.FileDataNestedKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.FileDataNestedKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.FileDataNestedKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.FileDataNestedKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.FileDataNestedKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.FileDataNestedKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.InlineDataNestedKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.InlineDataNestedKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.InlineDataNestedKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.InlineDataNestedKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.InlineDataNestedKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.InlineDataNestedKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.Content.Part.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GoogleSearch.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GoogleSearch.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GoogleSearch.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.NestedKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.NestedKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.NestedKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.NestedKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.NestedKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.DynamicRetrievalConfig.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.FunctionDeclaration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.FunctionDeclaration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.FunctionDeclaration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.FunctionDeclaration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.Tool.FunctionDeclaration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.ToolConfig.FunctionCallingConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.SafetySetting.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.SystemInstruction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.SystemInstruction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.SystemInstruction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.SystemInstruction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.SystemInstruction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.ThinkingConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.ThinkingConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.ThinkingConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.ThinkingConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.ThinkingConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.VoiceConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.MultiSpeakerVoiceConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.MultiSpeakerVoiceConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.MultiSpeakerVoiceConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.MultiSpeakerVoiceConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.MultiSpeakerVoiceConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.PrebuiltVoiceConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.PrebuiltVoiceConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.PrebuiltVoiceConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.PrebuiltVoiceConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.PrebuiltVoiceConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.SpeakerVoiceConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.SpeakerVoiceConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.SpeakerVoiceConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.SpeakerVoiceConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentRequestBody.GenerationConfig.SpeechConfig.SpeakerVoiceConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SafetyRating: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingMetadata: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SearchEntryPoint: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingChunk: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.WebInfo: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingSupport: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Segment: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.UsageMetadata: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SearchEntryPoint.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SearchEntryPoint.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SearchEntryPoint.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SearchEntryPoint.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SearchEntryPoint.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.UsageMetadata.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.UsageMetadata.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.UsageMetadata.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.UsageMetadata.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.UsageMetadata.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Segment.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Segment.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Segment.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Segment.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Segment.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingSupport.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingSupport.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingSupport.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingSupport.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingSupport.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.WebInfo.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.WebInfo.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.WebInfo.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.WebInfo.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.WebInfo.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingChunk.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingChunk.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingChunk.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingChunk.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingChunk.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingMetadata.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingMetadata.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingMetadata.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingMetadata.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingMetadata.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.GroundingMetadata.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SafetyRating.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SafetyRating.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SafetyRating.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SafetyRating.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.SafetyRating.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._InlineData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._FunctionCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._FunctionCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._FunctionCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._FunctionCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._FunctionCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._FunctionCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._InlineData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._InlineData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._InlineData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._InlineData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiGenerateContentResponseBody.Candidate.Content.Part._InlineData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiImagenRequestBody.Instance: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiImagenRequestBody.Parameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiImagenRequestBody.Parameters.SafetyLevel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiImagenRequestBody.Parameters.SafetyLevel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiImagenRequestBody.Parameters.SafetyLevel: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Parameters.SafetyLevel: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiImagenRequestBody.Parameters.PersonGeneration: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiImagenRequestBody.Parameters.PersonGeneration: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiImagenRequestBody.Parameters.PersonGeneration: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Parameters.PersonGeneration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiImagenRequestBody.Instance.InputImage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig.UpscaleFactor: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig.UpscaleFactor: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig.UpscaleFactor: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig.UpscaleFactor: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GeminiImagenRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiImagenRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiImagenRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Instance.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Instance.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Instance.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiImagenRequestBody.Instance.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiImagenRequestBody.Instance.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Parameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Parameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Parameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiImagenRequestBody.Parameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiImagenRequestBody.Parameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Instance.InputImage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Instance.InputImage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Instance.InputImage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Instance.InputImage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiImagenRequestBody.Instance.InputImage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiImagenRequestBody.Instance.InputImage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiImagenRequestBody.Parameters.UpscaleConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiImagenResponseBody.Prediction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GeminiImagenResponseBody.Prediction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenResponseBody.Prediction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenResponseBody.Prediction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiImagenResponseBody.Prediction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiImagenResponseBody.Prediction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GeminiImagenResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GeminiImagenResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GeminiImagenResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GeminiProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.GeminiProxiedService: AIProxy.ProxiedService {}
extension AIProxy.GeminiProxiedService: AIProxy.GeminiService {}
extension AIProxy.GroqChatCompletionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GroqChatCompletionResponseBody.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.Message: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GroqChatCompletionResponseBody.Usage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GroqChatCompletionResponseBody.Usage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Usage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Usage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Usage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionResponseBody.Usage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionResponseBody.Usage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionResponseBody.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GroqChatCompletionRequestBody.Message: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.ImageDetail: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.ImageDetail: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.ImageDetail: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.ImageDetail: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GroqChatCompletionRequestBody.ResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionRequestBody.ResponseFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionRequestBody.ResponseFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GroqChatCompletionRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionRequestBody.Message.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionRequestBody.Message.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.ImageKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.ImageKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.ImageKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.ImageKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.ImageKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionRequestBody.Message.UserContent.ContentPart.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.ResponseFormat.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GroqChatCompletionRequestBody.ResponseFormat.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionRequestBody.ResponseFormat.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionStreamingChunk: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.Delta: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionStreamingChunk.Choice.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionStreamingChunk.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionStreamingChunk.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqChatCompletionStreamingChunk.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqChatCompletionStreamingChunk.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqChatCompletionStreamingChunk.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqDirectService: AIProxy.ServiceMixin {}
extension AIProxy.GroqDirectService: AIProxy.DirectService {}
extension AIProxy.GroqDirectService: AIProxy.GroqService {}
extension AIProxy.GroqProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.GroqProxiedService: AIProxy.ProxiedService {}
extension AIProxy.GroqProxiedService: AIProxy.GroqService {}
extension AIProxy.GroqTranscriptionRequestBody: AIProxy.MultipartFormEncodable {}
extension AIProxy.GroqTranscriptionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GroqTranscriptionResponseBody.Word: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GroqTranscriptionResponseBody.Segment: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.GroqTranscriptionResponseBody.Segment.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqTranscriptionResponseBody.Segment.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqTranscriptionResponseBody.Segment.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.GroqTranscriptionResponseBody.Segment.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqTranscriptionResponseBody.Segment.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqTranscriptionResponseBody.Segment.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqTranscriptionResponseBody.Word.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqTranscriptionResponseBody.Word.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqTranscriptionResponseBody.Word.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqTranscriptionResponseBody.Word.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqTranscriptionResponseBody.Word.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.GroqTranscriptionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.GroqTranscriptionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.GroqTranscriptionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.GroqTranscriptionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.GroqTranscriptionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MicrophonePCMSampleVendorAE: AIProxy.MicrophonePCMSampleVendor {}
extension AIProxy.MicrophonePCMSampleVendorAT: AIProxy.MicrophonePCMSampleVendor {}
extension AIProxy.MicrophonePCMSampleVendorError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension AIProxy.MicrophonePCMSampleVendorError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension AIProxy.MistralChatCompletionRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.MistralChatCompletionRequestBody.Message: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.MistralChatCompletionRequestBody.ResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatCompletionRequestBody.ResponseFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatCompletionRequestBody.ResponseFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.MistralChatCompletionRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatCompletionRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatCompletionRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.Message.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.Message.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.Message.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.Message.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatCompletionRequestBody.Message.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatCompletionRequestBody.Message.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.ResponseFormat.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralChatCompletionRequestBody.ResponseFormat.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatCompletionRequestBody.ResponseFormat.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralChatCompletionResponseBody.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.Message: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatCompletionResponseBody.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatCompletionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatCompletionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionStreamingChunk: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.Delta: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatCompletionStreamingChunk.Choice.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionStreamingChunk.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionStreamingChunk.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralChatCompletionStreamingChunk.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatCompletionStreamingChunk.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatCompletionStreamingChunk.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralChatUsage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralChatUsage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralChatUsage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralChatUsage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralChatUsage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralChatUsage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralChatUsage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralDirectService: AIProxy.ServiceMixin {}
extension AIProxy.MistralDirectService: AIProxy.DirectService {}
extension AIProxy.MistralDirectService: AIProxy.MistralService {}
extension AIProxy.MistralOCRRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.MistralOCRRequestBody.Model: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralOCRRequestBody.Model: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralOCRRequestBody.Model: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralOCRRequestBody.Model: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.MistralOCRRequestBody.Document: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.MistralOCRRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralOCRRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralOCRRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralOCRRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRRequestBody.Document.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRRequestBody.Document.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRRequestBody.Document.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralOCRRequestBody.Document.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralOCRRequestBody.Document.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralOCRRequestBody.Document.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralOCRResponseBody.Page: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralOCRResponseBody.UsageInfo: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralOCRResponseBody.Page.ExtractedImage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralOCRResponseBody.Page.Dimensions: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.MistralOCRResponseBody.Page.ExtractedImage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.Page.ExtractedImage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.Page.ExtractedImage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.Page.ExtractedImage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralOCRResponseBody.Page.ExtractedImage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralOCRResponseBody.Page.ExtractedImage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.Page.Dimensions.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.Page.Dimensions.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.Page.Dimensions.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralOCRResponseBody.Page.Dimensions.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralOCRResponseBody.Page.Dimensions.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.UsageInfo.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.UsageInfo.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.UsageInfo.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.UsageInfo.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralOCRResponseBody.UsageInfo.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralOCRResponseBody.UsageInfo.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.Page.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.Page.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.Page.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralOCRResponseBody.Page.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralOCRResponseBody.Page.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.MistralOCRResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.MistralOCRResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.MistralOCRResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.MistralProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.MistralProxiedService: AIProxy.ProxiedService {}
extension AIProxy.MistralProxiedService: AIProxy.MistralService {}
extension AIProxy.OpenAIChatCompletionRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.MessageContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.MessageContent: AIProxy.SingleOrPartsEncodable {}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.ImageDetail: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.ImageDetail: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.ImageDetail: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.ImageDetail: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.Function: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.StreamOptions: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.RequireApproval: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.RequireApproval: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.RequireApproval: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.RequireApproval: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.RequireApproval: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.SearchContextSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.SearchContextSize: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.SearchContextSize: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.SearchContextSize: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.Approximate: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIChatCompletionRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.ImageKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.ImageKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.ImageKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.ImageKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.ImageKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ContentPart.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.Function.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.Function.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.Function.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.Function.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.Message.ToolCall.Function.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.MCPKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.MCPKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.MCPKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.MCPKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.MCPKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.MCPKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.FunctionKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.FunctionKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.FunctionKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.FunctionKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.FunctionKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.Tool.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.ToolChoice.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.Approximate.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.Approximate.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.Approximate.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.Approximate.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.Approximate.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.UserLocation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.Function: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionResponseBody.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionChunk.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.Function: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.Function.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.Function.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.Function.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.Function.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.Function.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionChunk.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatCompletionChunk.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatCompletionChunk.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatCompletionChunk.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatUsage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatUsage.Details: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIChatUsage.Details.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatUsage.Details.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatUsage.Details.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatUsage.Details.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatUsage.Details.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatUsage.Details.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatUsage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatUsage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIChatUsage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIChatUsage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIChatUsage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIChatUsage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateImageEditRequestBody: AIProxy.MultipartFormEncodable {}
extension AIProxy.OpenAICreateImageEditRequestBody.Background: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageEditRequestBody.Background: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageEditRequestBody.Background: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageEditRequestBody.InputFidelity: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageEditRequestBody.InputFidelity: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageEditRequestBody.InputFidelity: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageEditRequestBody.Model: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageEditRequestBody.Model: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageEditRequestBody.Model: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageEditRequestBody.Model: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageEditRequestBody.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageEditRequestBody.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageEditRequestBody.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageEditRequestBody.Quality: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageEditRequestBody.Quality: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageEditRequestBody.Quality: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageEditRequestBody.Quality: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageEditRequestBody.ResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageEditRequestBody.ResponseFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageEditRequestBody.ResponseFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageEditRequestBody.ResponseFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageRequestBody.Background: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageRequestBody.Background: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageRequestBody.Background: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageRequestBody.Background: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageRequestBody.Model: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageRequestBody.Model: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageRequestBody.Model: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageRequestBody.Model: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageRequestBody.Moderation: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageRequestBody.Moderation: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageRequestBody.Moderation: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageRequestBody.Moderation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageRequestBody.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageRequestBody.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageRequestBody.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageRequestBody.OutputFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageRequestBody.Quality: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageRequestBody.Quality: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageRequestBody.Quality: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageRequestBody.Quality: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageRequestBody.ResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageRequestBody.ResponseFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageRequestBody.ResponseFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageRequestBody.ResponseFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageRequestBody.Style: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageRequestBody.Style: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageRequestBody.Style: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageRequestBody.Style: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateImageRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateImageRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateImageRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateImageResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateImageResponseBody.ImageData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateImageResponseBody.ImageData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateImageResponseBody.ImageData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateImageResponseBody.ImageData.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateImageResponseBody.ImageData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageResponseBody.ImageData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageResponseBody.ImageData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateImageResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateImageResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateImageResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateImageResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateImageResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.Include: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.Include: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.Include: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Include: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.Include: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.Truncation: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.Truncation: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.Truncation: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Truncation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.Prompt: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.Variable: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.Tool: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.Tool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.RankingOptions: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.RankingOptions: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonFilter: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonFilter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonOperator: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonOperator: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonOperator: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonOperator: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonOperator: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundFilter: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundFilter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundOperator: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundOperator: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundOperator: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundOperator: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundOperator: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.SearchContextSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.SearchContextSize: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.SearchContextSize: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.SearchContextSize: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.SearchContextSize: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.UserLocation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.UserLocation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.Environment: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.Environment: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.Environment: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.Environment: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.Environment: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FunctionTool: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.FunctionTool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.Effort: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.Effort: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.Effort: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.Effort: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.SummaryType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.SummaryType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.SummaryType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.SummaryType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.ToolChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.ToolChoice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateResponseRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Prompt.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Prompt.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Prompt.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.Prompt.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.Prompt.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Tool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Tool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Tool.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Tool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.Tool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.Tool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.RankingOptions.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.RankingOptions.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.RankingOptions.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.RankingOptions.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.RankingOptions.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.RankingOptions.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchTool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonFilter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonFilter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonFilter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonFilter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonFilter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundFilter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundFilter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundFilter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundFilter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundFilter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.UserLocation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.UserLocation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.UserLocation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.UserLocation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.UserLocation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.WebSearchTool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.ComputerUseTool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FunctionTool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FunctionTool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FunctionTool.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FunctionTool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.FunctionTool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.FunctionTool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.Reasoning.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.ToolChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.ToolChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.ToolChoice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.ToolChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.ToolChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.ToolChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CompoundCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.ComparisonCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateResponseRequestBody.FileSearchFilter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionRequestBody: AIProxy.MultipartFormEncodable {}
extension AIProxy.OpenAICreateTranscriptionRequestBody.TimestampGranularity: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateTranscriptionRequestBody.TimestampGranularity: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateTranscriptionRequestBody.TimestampGranularity: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Word: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Segment: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Segment.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Segment.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Segment.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Segment.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Segment.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Segment.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Word.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Word.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Word.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Word.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Word.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.Word.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateTranscriptionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreFileRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateVectorStoreFileRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreFileRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreFileRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreFileRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateVectorStoreFileRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateVectorStoreFileRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.NestedKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.NestedKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.NestedKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.NestedKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.NestedKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.NestedKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAICreateVectorStoreRequestBody.ChunkingStrategy.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIDirectRequestBuilder: AIProxy.OpenAIRequestBuilder {}
extension AIProxy.OpenAIDirectService: AIProxy.ServiceMixin {}
extension AIProxy.OpenAIDirectService: AIProxy.DirectService {}
extension AIProxy.OpenAIDirectServiceNetworker: AIProxy.DirectService {}
extension AIProxy.OpenAIDirectServiceNetworker: AIProxy.ServiceMixin {}
extension AIProxy.OpenAIEmbeddingRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIEmbeddingRequestBody.EmbeddingInput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIEmbeddingRequestBody.EncodingFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIEmbeddingRequestBody.EncodingFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIEmbeddingRequestBody.EncodingFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIEmbeddingRequestBody.EncodingFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIEmbeddingRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIEmbeddingRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIEmbeddingRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIEmbeddingRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIEmbeddingResponseBody.Embedding: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIEmbeddingResponseBody.Usage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIEmbeddingResponseBody.Usage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingResponseBody.Usage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingResponseBody.Usage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIEmbeddingResponseBody.Usage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIEmbeddingResponseBody.Usage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIEmbeddingResponseBody.Usage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingResponseBody.Embedding.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingResponseBody.Embedding.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingResponseBody.Embedding.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIEmbeddingResponseBody.Embedding.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIEmbeddingResponseBody.Embedding.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIEmbeddingResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIEmbeddingResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIEmbeddingResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIFilePurpose: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIFilePurpose: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIFilePurpose: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIFileUploadRequestBody: AIProxy.MultipartFormEncodable {}
extension AIProxy.OpenAIFileUploadResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIFileUploadResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIFileUploadResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIFileUploadResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIFileUploadResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIFileUploadResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIFileUploadResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIModerationRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIModerationRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIModerationRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.NestedKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.NestedKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.NestedKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.NestedKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.NestedKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.NestedKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIModerationRequestBody.ModerationInput.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.Categories: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryScores: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.InputType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryAppliedInputTypes.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryScores.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryScores.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryScores.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryScores.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryScores.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CategoryScores.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.Categories.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.Categories.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.Categories.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.Categories.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.Categories.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.Categories.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIModerationResponseBody.ModerationResult.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIModerationResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIModerationResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIModerationResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIProxiedRequestBuilder: AIProxy.OpenAIRequestBuilder {}
extension AIProxy.OpenAIProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.OpenAIProxiedService: AIProxy.ProxiedService {}
extension AIProxy.OpenAIProxiedServiceNetworker: AIProxy.ProxiedService {}
extension AIProxy.OpenAIProxiedServiceNetworker: AIProxy.ServiceMixin {}
extension AIProxy.OpenAIRealtimeConversationItemCreate: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.Content: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.Content.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.Content.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.Content.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.Content.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeConversationItemCreate.Item.Content.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeInputAudioBufferAppend: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeInputAudioBufferAppend.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeInputAudioBufferAppend.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeInputAudioBufferAppend.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeInputAudioBufferAppend.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeInputAudioBufferAppend.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeInputAudioBufferSpeechStarted: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIRealtimeInputAudioBufferSpeechStarted.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeInputAudioBufferSpeechStarted.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeInputAudioBufferSpeechStarted.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIRealtimeInputAudioBufferSpeechStarted.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeInputAudioBufferSpeechStarted.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeInputAudioBufferSpeechStarted.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseCreate: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.Tool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeResponseCreate.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseCreate.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseCreate.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeResponseCreate.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeResponseCreate.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.Tool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.Tool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.Tool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.Tool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeResponseCreate.Response.Tool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseFunctionCallArgumentsDone: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeResponseFunctionCallArgumentsDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseFunctionCallArgumentsDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeResponseFunctionCallArgumentsDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeResponseFunctionCallArgumentsDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeResponseFunctionCallArgumentsDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.InputAudioTranscription: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.MaxResponseOutputTokens: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.Tool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.AudioFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.AudioFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.AudioFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.AudioFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.Modality: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.Modality: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.Modality: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.Modality: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.Eagerness: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.Eagerness: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.Eagerness: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.Eagerness: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice.FunctionKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice.FunctionKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice.FunctionKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice.FunctionKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice.FunctionKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.ToolChoice.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.InputAudioTranscription.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.InputAudioTranscription.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.InputAudioTranscription.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.InputAudioTranscription.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.InputAudioTranscription.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.Tool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.Tool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.Tool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.Tool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.Tool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.SemanticVADCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.SemanticVADCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.SemanticVADCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.SemanticVADCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.SemanticVADCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.ServerVADCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.ServerVADCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.ServerVADCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.ServerVADCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.ServerVADCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionConfiguration.TurnDetection.DetectionType.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionUpdate: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIRealtimeSessionUpdate.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionUpdate.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionUpdate.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIRealtimeSessionUpdate.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIRealtimeSessionUpdate.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIRealtimeSessionUpdate.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Instructions: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.IncompleteDetails: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.ResponseError: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Reasoning: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Status: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.Status: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.Status: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.Status: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.ToolChoiceOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.ToolChoiceOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.ToolChoiceOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.ToolChoiceOptions: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.OutputTokensDetails: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.ResponseUsage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Reasoning.Effort: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.Reasoning.Effort: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.Reasoning.Effort: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.Reasoning.Effort: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.ResponseOutputItem: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchAction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchSource: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.WebSearchCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.FileSearchCall.FileSearchResult: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.FileSearchCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.FunctionCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.ComputerCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.ComputerAction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.SafetyCheck: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.ResponseOutputMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Content: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.OutputText: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Annotation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.URLCitation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.FileCitation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.FilePath: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.IncompleteDetails.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.IncompleteDetails.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.IncompleteDetails.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.IncompleteDetails.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.IncompleteDetails.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.OutputTokensDetails.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.OutputTokensDetails.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.OutputTokensDetails.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.OutputTokensDetails.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.OutputTokensDetails.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.OutputTokensDetails.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Annotation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Annotation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Annotation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.Annotation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.Annotation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.Annotation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.URLCitation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.URLCitation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.URLCitation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.URLCitation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.URLCitation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.URLCitation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FileCitation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FileCitation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FileCitation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.FileCitation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.FileCitation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.FileCitation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FilePath.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FilePath.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FilePath.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.FilePath.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.FilePath.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.FilePath.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.OutputText.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.OutputText.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.OutputText.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.OutputText.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.OutputText.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Content.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Content.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Content.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.Content.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.Content.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.Content.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.SafetyCheck.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.SafetyCheck.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.SafetyCheck.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.SafetyCheck.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.SafetyCheck.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ComputerAction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ComputerAction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ComputerAction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.ComputerAction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.ComputerAction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FileSearchCall.FileSearchResult.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FileSearchCall.FileSearchResult.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FileSearchCall.FileSearchResult.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.FileSearchCall.FileSearchResult.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.FileSearchCall.FileSearchResult.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchSource.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchSource.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchSource.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchSource.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchSource.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchAction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchAction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchAction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchAction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.WebSearchCall.WebSearchAction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ComputerCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ComputerCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ComputerCall.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.ComputerCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.ComputerCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.ComputerCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FunctionCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FunctionCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FunctionCall.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.FunctionCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.FunctionCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.FunctionCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FileSearchCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FileSearchCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.FileSearchCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.FileSearchCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.FileSearchCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.WebSearchCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.WebSearchCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.WebSearchCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.WebSearchCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.WebSearchCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseOutputMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseOutputMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseOutputMessage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseOutputMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.ResponseOutputMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.ResponseOutputMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseOutputItem.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseOutputItem.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseOutputItem.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseOutputItem.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.ResponseOutputItem.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.ResponseOutputItem.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseUsage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseUsage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseUsage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseUsage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.ResponseUsage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.ResponseUsage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Reasoning.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Reasoning.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Reasoning.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.Reasoning.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.Reasoning.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.Reasoning.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseError.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseError.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.ResponseError.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.ResponseError.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.ResponseError.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Input: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Input: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem.Role: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.Input.InputItem.Role: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.Input.InputItem.Role: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.Input.InputItem.Role: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem.Role: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem.Content: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem.Content: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem.Content.ItemContent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem.Content.ItemContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem._Message: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem._Message: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIResponse.Input.InputItem.Content.ItemContent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Input.InputItem.Content.ItemContent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Input.InputItem.Content.ItemContent.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.Input.InputItem.Content.ItemContent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.Input.InputItem.Content.ItemContent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.Input.InputItem.Content.ItemContent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Input.InputItem._Message.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Input.InputItem._Message.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.Input.InputItem._Message.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.Input.InputItem._Message.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.Input.InputItem._Message.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamEventType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamEventType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamEventType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCreated: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseInProgress: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCompleted: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseFailed: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseIncomplete: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemAdded: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartAdded: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextAnnotationAdded: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallInProgress: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallSearching: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallCompleted: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallInProgress: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallSearching: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallCompleted: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.CodeInterpreterCallProgress: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ComputerCallProgress: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPart: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartAdded: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallProgress: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallPartialImage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDone: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallProgress: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.McpListToolsProgress: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseQueued: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.ErrorEvent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponseStreamingEvent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextAnnotationAdded.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextAnnotationAdded.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextAnnotationAdded.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextAnnotationAdded.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextAnnotationAdded.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextAnnotationAdded.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPart.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPart.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPart.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPart.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPart.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDelta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ComputerCallProgress.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ComputerCallProgress.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ComputerCallProgress.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ComputerCallProgress.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ComputerCallProgress.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ComputerCallProgress.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.CodeInterpreterCallProgress.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.CodeInterpreterCallProgress.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.CodeInterpreterCallProgress.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.CodeInterpreterCallProgress.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.CodeInterpreterCallProgress.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.CodeInterpreterCallProgress.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDelta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioTranscriptDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDelta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.AudioDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCreated.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCreated.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCreated.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCreated.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCreated.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCreated.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseInProgress.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseInProgress.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseInProgress.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseInProgress.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseInProgress.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseInProgress.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCompleted.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCompleted.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCompleted.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCompleted.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCompleted.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseCompleted.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseFailed.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseFailed.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseFailed.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseFailed.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseFailed.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseFailed.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseIncomplete.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseIncomplete.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseIncomplete.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseIncomplete.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseIncomplete.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseIncomplete.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemAdded.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemAdded.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemAdded.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemAdded.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemAdded.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemAdded.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputItemDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartAdded.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartAdded.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartAdded.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartAdded.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartAdded.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartAdded.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ContentPartDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDelta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.OutputTextDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDelta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.RefusalDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDelta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.FunctionCallArgumentsDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallInProgress.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallInProgress.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallInProgress.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallInProgress.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallInProgress.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallInProgress.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallSearching.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallSearching.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallSearching.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallSearching.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallSearching.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallSearching.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallCompleted.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallCompleted.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallCompleted.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallCompleted.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallCompleted.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.FileSearchCallCompleted.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallInProgress.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallInProgress.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallInProgress.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallInProgress.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallInProgress.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallInProgress.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallSearching.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallSearching.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallSearching.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallSearching.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallSearching.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallSearching.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallCompleted.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallCompleted.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallCompleted.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallCompleted.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallCompleted.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.WebSearchCallCompleted.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartAdded.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartAdded.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartAdded.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartAdded.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartAdded.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartAdded.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryPartDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDelta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryTextDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDelta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ReasoningSummaryDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallProgress.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallProgress.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallProgress.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallProgress.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallProgress.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallProgress.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallPartialImage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallPartialImage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallPartialImage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallPartialImage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallPartialImage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ImageGenerationCallPartialImage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDelta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDone.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDone.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDone.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDone.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDone.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallArgumentsDone.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallProgress.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallProgress.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallProgress.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallProgress.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallProgress.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.McpCallProgress.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpListToolsProgress.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpListToolsProgress.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpListToolsProgress.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.McpListToolsProgress.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.McpListToolsProgress.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.McpListToolsProgress.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseQueued.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseQueued.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseQueued.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseQueued.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseQueued.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ResponseQueued.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ErrorEvent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ErrorEvent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ErrorEvent.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponseStreamingEvent.ErrorEvent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponseStreamingEvent.ErrorEvent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponseStreamingEvent.ErrorEvent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.TextConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.TextConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIResponse.TextConfiguration.Format: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.TextConfiguration.Format: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIResponse.TextConfiguration.Verbosity: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.TextConfiguration.Verbosity: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.TextConfiguration.Verbosity: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.TextConfiguration.Verbosity: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIResponse.TextConfiguration.Verbosity: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIResponse.TextConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.TextConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.TextConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.TextConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.TextConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.TextConfiguration.Format.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.TextConfiguration.Format.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIResponse.TextConfiguration.Format.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIResponse.TextConfiguration.Format.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIResponse.TextConfiguration.Format.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIResponse.TextConfiguration.Format.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAITextToSpeechRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAITextToSpeechRequestBody.Model: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAITextToSpeechRequestBody.Model: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAITextToSpeechRequestBody.Model: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAITextToSpeechRequestBody.Model: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAITextToSpeechRequestBody.ResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAITextToSpeechRequestBody.ResponseFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAITextToSpeechRequestBody.ResponseFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAITextToSpeechRequestBody.ResponseFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAITextToSpeechRequestBody.Voice: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAITextToSpeechRequestBody.Voice: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAITextToSpeechRequestBody.Voice: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAITextToSpeechRequestBody.Voice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAITextToSpeechRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAITextToSpeechRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAITextToSpeechRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAITextToSpeechRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAITextToSpeechRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAITextToSpeechRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStore: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIVectorStore.FileCounts: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIVectorStore.Status: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStore.Status: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStore.Status: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIVectorStore.Status: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIVectorStore.FileCounts.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStore.FileCounts.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStore.FileCounts.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIVectorStore.FileCounts.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStore.FileCounts.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStore.FileCounts.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStore.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStore.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStore.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIVectorStore.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStore.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStore.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.NestedKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.NestedKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.NestedKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.NestedKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.NestedKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.NestedKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStoreChunkingStrategy.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreExpiresAfter: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIVectorStoreExpiresAfter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIVectorStoreExpiresAfter.Anchor: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStoreExpiresAfter.Anchor: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStoreExpiresAfter.Anchor: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIVectorStoreExpiresAfter.Anchor: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIVectorStoreExpiresAfter.Anchor: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenAIVectorStoreExpiresAfter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreExpiresAfter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreExpiresAfter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStoreExpiresAfter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStoreExpiresAfter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreFile: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIVectorStoreFile.LastError: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIVectorStoreFile.Status: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStoreFile.Status: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStoreFile.Status: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIVectorStoreFile.Status: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIVectorStoreFile.LastError.Code: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStoreFile.LastError.Code: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStoreFile.LastError.Code: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIVectorStoreFile.LastError.Code: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenAIVectorStoreFile.LastError.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreFile.LastError.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreFile.LastError.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStoreFile.LastError.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStoreFile.LastError.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreFile.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreFile.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenAIVectorStoreFile.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenAIVectorStoreFile.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenAIVectorStoreFile.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenAIVectorStoreFile.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.Function: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.Function: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.Function.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.Function.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.Function.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.Function.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.Delta.ToolCall.Function.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionChunk.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionChunk.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionChunk.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionChunk.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Route: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Route: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Route: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Route: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.AssistantContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.SystemContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.ImageDetail: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.ImageDetail: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.ImageDetail: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.ImageDetail: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Reasoning.Effort: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Reasoning.Effort: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Reasoning.Effort: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Reasoning.Effort: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Reasoning: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.StreamOptions: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Prediction: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.Quantization: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.Quantization: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.Quantization: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.Quantization: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.DataCollection: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.DataCollection: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.DataCollection: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.DataCollection: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.OpenRouterChatCompletionRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.ImageKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.ImageKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.ImageKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.ImageKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.ImageKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Message.UserContent.Part.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Reasoning.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Reasoning.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Reasoning.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Reasoning.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Reasoning.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.SchemaKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ResponseFormat.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.StreamOptions.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool.FunctionKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool.FunctionKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool.FunctionKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool.FunctionKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool.FunctionKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Tool.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice.FunctionKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ToolChoice.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Prediction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Prediction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Prediction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Prediction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.Prediction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionRequestBody.ProviderPreferences.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Usage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.Annotation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.URLCitation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.Function: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.Function.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.URLCitation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.URLCitation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.URLCitation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.URLCitation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.URLCitation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.URLCitation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.Annotation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.Annotation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.Annotation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.Annotation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.Annotation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.Annotation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Usage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Usage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Usage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Usage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Usage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionResponseBody.Usage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.OpenRouterChatCompletionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.OpenRouterChatCompletionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.OpenRouterChatCompletionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.OpenRouterDirectService: AIProxy.ServiceMixin {}
extension AIProxy.OpenRouterDirectService: AIProxy.DirectService {}
extension AIProxy.OpenRouterDirectService: AIProxy.OpenRouterService {}
extension AIProxy.OpenRouterProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.OpenRouterProxiedService: AIProxy.ProxiedService {}
extension AIProxy.OpenRouterProxiedService: AIProxy.OpenRouterService {}
extension AIProxy.PerplexityChatCompletionRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.PerplexityChatCompletionRequestBody.Message: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.PerplexityChatCompletionRequestBody.SearchRecencyFilter: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionRequestBody.SearchRecencyFilter: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionRequestBody.SearchRecencyFilter: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.SearchRecencyFilter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.PerplexityChatCompletionRequestBody.WebSearchOptions: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.PerplexityChatCompletionRequestBody.SearchContextSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionRequestBody.SearchContextSize: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionRequestBody.SearchContextSize: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.SearchContextSize: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.PerplexityChatCompletionRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.Message.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.Message.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.Message.RootKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.Message.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionRequestBody.Message.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionRequestBody.Message.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.PerplexityChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionRequestBody.WebSearchOptions.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.FinishReason: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.FinishReason: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.FinishReason: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.FinishReason: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Message: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.PerplexityChatCompletionResponseBody.Usage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.PerplexityChatCompletionResponseBody.Usage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Usage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Usage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Usage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionResponseBody.Usage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionResponseBody.Usage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Message.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionResponseBody.Choice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.PerplexityChatCompletionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityChatCompletionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityChatCompletionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.PerplexityDirectService: AIProxy.ServiceMixin {}
extension AIProxy.PerplexityDirectService: AIProxy.DirectService {}
extension AIProxy.PerplexityDirectService: AIProxy.PerplexityService {}
extension AIProxy.PerplexityProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.PerplexityProxiedService: AIProxy.ProxiedService {}
extension AIProxy.PerplexityProxiedService: AIProxy.PerplexityService {}
extension AIProxy.PerplexityRole: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.PerplexityRole: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.PerplexityRole: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.PerplexityRole: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.PerplexityRole: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReceiptValidationRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReceiptValidationRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReceiptValidationRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReceiptValidationRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReceiptValidationRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReceiptValidationRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ReceiptValidationResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReceiptValidationResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReceiptValidationResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReceiptValidationResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReceiptValidationResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReceiptValidationResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ReceiptValidationService: AIProxy.ServiceMixin {}
extension AIProxy.ReceiptValidationService: AIProxy.ProxiedService {}
extension AIProxy.RemoteLoggerService: AIProxy.ServiceMixin {}
extension AIProxy.RemoteLoggerService: AIProxy.ProxiedService {}
extension AIProxy.ReplicateCreateModelRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateCreateModelRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateCreateModelRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateCreateModelRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateCreateModelRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateCreateModelRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ReplicateDeepSeekVL7BInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateDeepSeekVL7BInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateDeepSeekVL7BInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateDeepSeekVL7BInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateDeepSeekVL7BInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateDeepSeekVL7BInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateDeepSeekVL7BInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension AIProxy.ReplicateDirectService: AIProxy.ServiceMixin {}
extension AIProxy.ReplicateDirectService: AIProxy.DirectService {}
extension AIProxy.ReplicateDirectService: AIProxy.ReplicateService {}
extension AIProxy.ReplicateError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension AIProxy.ReplicateError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension AIProxy.ReplicateFileUploadResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateFileUploadResponseBody.Checksums: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateFileUploadResponseBody.ActionURLs: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateFileUploadResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFileUploadResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFileUploadResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFileUploadResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFileUploadResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFileUploadResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFileUploadResponseBody.ActionURLs.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFileUploadResponseBody.ActionURLs.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFileUploadResponseBody.ActionURLs.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFileUploadResponseBody.ActionURLs.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFileUploadResponseBody.ActionURLs.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFileUploadResponseBody.Checksums.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFileUploadResponseBody.Checksums.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFileUploadResponseBody.Checksums.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFileUploadResponseBody.Checksums.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFileUploadResponseBody.Checksums.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.ControlType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.ControlType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.ControlType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.ControlType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.DepthPreprocessor: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.DepthPreprocessor: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.DepthPreprocessor: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.DepthPreprocessor: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.OutputFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.SoftEdgePreprocessor: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.SoftEdgePreprocessor: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.SoftEdgePreprocessor: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.SoftEdgePreprocessor: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxDevControlNetInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFluxDevInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxDevInputSchema.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxDevInputSchema.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxDevInputSchema.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxDevInputSchema.OutputFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxDevInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxDevInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxDevInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxDevInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxDevInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxDevInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFluxFineTuneInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.FluxModel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.FluxModel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.FluxModel: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.FluxModel: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.OutputFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxFineTuneInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFluxKontextInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxKontextInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxKontextInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxKontextInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxKontextInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxKontextInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxKontextInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFluxProInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxProInputSchema.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxProInputSchema.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxProInputSchema.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxProInputSchema.OutputFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxProInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxProInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxProInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxProInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxProInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxProInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1.OutputFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxProInputSchema_v1_1.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1.OutputFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxProUltraInputSchema_v1_1.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFluxPulidInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxPulidInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxPulidInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxPulidInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxPulidInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxPulidInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxPulidInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFluxSchnellInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxSchnellInputSchema.OutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxSchnellInputSchema.OutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxSchnellInputSchema.OutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxSchnellInputSchema.OutputFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxSchnellInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxSchnellInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxSchnellInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxSchnellInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxSchnellInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxSchnellInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateFluxTrainingInput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateFluxTrainingInput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxTrainingInput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateFluxTrainingInput.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateFluxTrainingInput.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateFluxTrainingInput.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateFluxTrainingInput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateModelResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateModelResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateModelResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateModelResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateModelResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateModelResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateModelVisibility: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateModelVisibility: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateModelVisibility: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateModelVisibility: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateModelVisibility: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicatePredictionRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicatePredictionRequestBody.RootKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicatePredictionRequestBody.RootKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicatePredictionRequestBody.RootKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicatePredictionRequestBody.RootKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicatePredictionRequestBody.RootKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicatePrediction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicatePrediction.ActionURLs: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicatePrediction.Metrics: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicatePrediction.Status: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicatePrediction.Status: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicatePrediction.Status: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicatePrediction.Status: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicatePrediction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicatePrediction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicatePrediction.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicatePrediction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicatePrediction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicatePrediction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicatePrediction.ActionURLs.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicatePrediction.ActionURLs.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicatePrediction.ActionURLs.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicatePrediction.ActionURLs.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicatePrediction.ActionURLs.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicatePrediction.Metrics.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicatePrediction.Metrics.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicatePrediction.Metrics.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicatePrediction.Metrics.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicatePrediction.Metrics.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicatePrediction.Metrics.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.ReplicateProxiedService: AIProxy.ProxiedService {}
extension AIProxy.ReplicateProxiedService: AIProxy.ReplicateService {}
extension AIProxy.ReplicateSDXLFreshInkInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.Refiner: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.Refiner: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.Refiner: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.Refiner: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.Scheduler: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.Scheduler: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.Scheduler: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.Scheduler: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateSDXLFreshInkInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateSDXLInputSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateSDXLInputSchema.Refiner: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateSDXLInputSchema.Refiner: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateSDXLInputSchema.Refiner: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateSDXLInputSchema.Refiner: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateSDXLInputSchema.Scheduler: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateSDXLInputSchema.Scheduler: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateSDXLInputSchema.Scheduler: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateSDXLInputSchema.Scheduler: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateSDXLInputSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateSDXLInputSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateSDXLInputSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateSDXLInputSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateSDXLInputSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateSDXLInputSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateSynchronousResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateSynchronousResponseBody.NestedKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateSynchronousResponseBody.NestedKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateSynchronousResponseBody.NestedKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateSynchronousResponseBody.NestedKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateSynchronousResponseBody.NestedKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateSynchronousResponseBody.NestedKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateSynchronousResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateSynchronousResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateSynchronousResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateSynchronousResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateSynchronousResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateSynchronousResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateTrainingRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.ReplicateTrainingRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateTrainingRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateTrainingRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateTrainingRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateTrainingRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.Metrics: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateTrainingResponseBody.TrainingOutput: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateTrainingResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateTrainingResponseBody.ActionURLs: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateTrainingResponseBody.Status: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateTrainingResponseBody.Status: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateTrainingResponseBody.Status: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.Status: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.ReplicateTrainingResponseBody.Metrics.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.Metrics.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.Metrics.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.Metrics.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateTrainingResponseBody.Metrics.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateTrainingResponseBody.Metrics.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateTrainingResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateTrainingResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.ActionURLs.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.ActionURLs.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.ActionURLs.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateTrainingResponseBody.ActionURLs.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateTrainingResponseBody.ActionURLs.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.TrainingOutput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.TrainingOutput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.ReplicateTrainingResponseBody.TrainingOutput.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.ReplicateTrainingResponseBody.TrainingOutput.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.ReplicateTrainingResponseBody.TrainingOutput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.StabilityAIDirectService: AIProxy.ServiceMixin {}
extension AIProxy.StabilityAIDirectService: AIProxy.DirectService {}
extension AIProxy.StabilityAIDirectService: AIProxy.StabilityAIService {}
extension AIProxy.StabilityAIProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.StabilityAIProxiedService: AIProxy.ProxiedService {}
extension AIProxy.StabilityAIProxiedService: AIProxy.StabilityAIService {}
extension AIProxy.StabilityAIStableDiffusionRequestBody: AIProxy.MultipartFormEncodable {}
extension AIProxy.StabilityAIStableDiffusionOutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.StabilityAIStableDiffusionOutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.StabilityAIStableDiffusionOutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.StabilityAIGenerationMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.StabilityAIGenerationMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.StabilityAIGenerationMode: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.StabilityAIStableDiffusionModel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.StabilityAIStableDiffusionModel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.StabilityAIStableDiffusionModel: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.StabilityAIUltraRequestBody: AIProxy.MultipartFormEncodable {}
extension AIProxy.StabilityAIUltraOutputFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.StabilityAIUltraOutputFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.StabilityAIUltraOutputFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionRequestBody: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.TogetherAIMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.TogetherAIMessage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.TogetherAIRole: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIRole: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIRole: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.TogetherAIRole: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.TogetherAIRole: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.TogetherAIResponseFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.TogetherAITool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.TogetherAIFunction: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension AIProxy.TogetherAIChatCompletionRequestBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionRequestBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionRequestBody.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionRequestBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIChatCompletionRequestBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIChatCompletionRequestBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAIMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAIResponseFormat.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIResponseFormat.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIResponseFormat.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIResponseFormat.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIResponseFormat.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAITool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAITool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAITool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAITool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAITool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAIFunction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIFunction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIFunction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIFunction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIFunction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionResponseBody: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.TogetherAIChatCompletionChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.TogetherAIFinishReason: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIFinishReason: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIFinishReason: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.TogetherAIFinishReason: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.TogetherAILogprobs: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.TogetherAIChatUsage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.TogetherAIChatUsage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIChatUsage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIChatUsage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.TogetherAIChatUsage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIChatUsage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIChatUsage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAILogprobs.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAILogprobs.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAILogprobs.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.TogetherAILogprobs.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAILogprobs.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAILogprobs.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionChoice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIChatCompletionChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIChatCompletionChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionResponseBody.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionResponseBody.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionResponseBody.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIChatCompletionResponseBody.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIChatCompletionResponseBody.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionStreamingChunk: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.TogetherAIStreamingChunkChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.TogetherAIStreamingChunkDelta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension AIProxy.TogetherAIStreamingChunkDelta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIStreamingChunkDelta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIStreamingChunkDelta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIStreamingChunkDelta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIStreamingChunkDelta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAIStreamingChunkChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIStreamingChunkChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIStreamingChunkChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIStreamingChunkChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIStreamingChunkChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionStreamingChunk.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionStreamingChunk.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension AIProxy.TogetherAIChatCompletionStreamingChunk.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension AIProxy.TogetherAIChatCompletionStreamingChunk.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension AIProxy.TogetherAIChatCompletionStreamingChunk.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension AIProxy.TogetherAIDirectService: AIProxy.ServiceMixin {}
extension AIProxy.TogetherAIDirectService: AIProxy.DirectService {}
extension AIProxy.TogetherAIDirectService: AIProxy.TogetherAIService {}
extension AIProxy.TogetherAIProxiedService: AIProxy.ServiceMixin {}
extension AIProxy.TogetherAIProxiedService: AIProxy.ProxiedService {}
extension AIProxy.TogetherAIProxiedService: AIProxy.TogetherAIService {}
extension SwiftyBase64.Alphabet: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftyBase64.Alphabet: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseCoreInternal.Heartbeat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCoreInternal.Heartbeat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseCoreInternal.Heartbeat: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseCoreInternal.Heartbeat: FirebaseCoreInternal.HeartbeatsPayloadConvertible {}
extension FirebaseCoreInternal.TimePeriod: Swift.CaseIterable {
    typealias AllCases = [FirebaseCoreInternal.TimePeriod]

    static var allCases: Self.AllCases {
        get
    }
}
extension FirebaseCoreInternal.TimePeriod: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseCoreInternal.TimePeriod: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseCoreInternal.TimePeriod: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCoreInternal.TimePeriod: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseCoreInternal.TimePeriod: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseCoreInternal.Heartbeat.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseCoreInternal.Heartbeat.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseCoreInternal.Heartbeat.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseCoreInternal.Heartbeat.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCoreInternal.Heartbeat.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseCoreInternal.HeartbeatStorage: FirebaseCoreInternal.HeartbeatStorageProtocol {}
extension FirebaseCoreInternal.HeartbeatsBundle: FirebaseCoreInternal.HeartbeatsPayloadConvertible {}
extension FirebaseCoreInternal.HeartbeatsBundle: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseCoreInternal.HeartbeatsBundle: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseCoreInternal.HeartbeatsBundle.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseCoreInternal.HeartbeatsBundle.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseCoreInternal.HeartbeatsBundle.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseCoreInternal.HeartbeatsBundle.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCoreInternal.HeartbeatsBundle.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseCoreInternal.HeartbeatsPayload: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseCoreInternal.HeartbeatsPayload: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseCoreInternal.HeartbeatsPayload: FirebaseCoreInternal.HTTPHeaderRepresentable {}
extension FirebaseCoreInternal.HeartbeatsPayload: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCoreInternal.HeartbeatsPayload.UserAgentPayload: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseCoreInternal.HeartbeatsPayload.UserAgentPayload: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCoreInternal.HeartbeatsPayload.UserAgentPayload: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseCoreInternal.HeartbeatsPayload.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseCoreInternal.HeartbeatsPayload.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseCoreInternal.HeartbeatsPayload.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseCoreInternal.HeartbeatsPayload.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseCoreInternal.HeartbeatsPayload.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCoreInternal.HeartbeatsPayload.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseCoreInternal.HeartbeatsPayload.UserAgentPayload.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseCoreInternal.HeartbeatsPayload.UserAgentPayload.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseCoreInternal.HeartbeatsPayload.UserAgentPayload.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseCoreInternal.HeartbeatsPayload.UserAgentPayload.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCoreInternal.HeartbeatsPayload.UserAgentPayload.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseCoreInternal.RingBuffer: Swift.Encodable where A: Swift.Decodable, A: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseCoreInternal.RingBuffer: Swift.Decodable where A: Swift.Decodable, A: Swift.Encodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseCoreInternal.RingBuffer: Swift.Sequence {
    typealias Element = A
    typealias Iterator = Swift.IndexingIterator<[A]>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension FirebaseCoreInternal.RingBuffer.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseCoreInternal.RingBuffer.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseCoreInternal.RingBuffer.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseCoreInternal.RingBuffer.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCoreInternal.RingBuffer.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseCoreInternal.RingBuffer.Error: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseCoreInternal.UserDefaultsStorage: FirebaseCoreInternal.Storage {}
extension FirebaseCoreInternal.UserDefaultsStorage: FirebaseCoreInternal.StorageFactory {}
extension FirebaseCoreInternal.FileStorage: FirebaseCoreInternal.Storage {}
extension FirebaseCoreInternal.FileStorage: FirebaseCoreInternal.StorageFactory {}
extension FirebaseCoreInternal.StorageError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseCoreInternal.StorageError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCoreInternal.StorageError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseCoreInternal._ObjC_HeartbeatsPayload: FirebaseCoreInternal.HTTPHeaderRepresentable {}
extension Swift.Dictionary: FirebaseSharedSwift._JSONStringDictionaryEncodableMarker where A == Swift.String, B: Swift.Encodable {}
extension Swift.Dictionary: FirebaseSharedSwift._JSONStringDictionaryDecodableMarker where A == Swift.String, B: Swift.Decodable {}
extension FirebaseSharedSwift.__JSONDecoder: Swift.SingleValueDecodingContainer {
    var codingPath: [Swift.CodingKey] {
        get
    }

    func decodeNil() -> Swift.Bool
    func decode(_: Swift.Bool.Type) throws -> Swift.Bool
    func decode(_: Swift.String.Type) throws -> Swift.String
    func decode(_: Swift.Double.Type) throws -> Swift.Double
    func decode(_: Swift.Float.Type) throws -> Swift.Float
    func decode(_: Swift.Int.Type) throws -> Swift.Int
    func decode(_: Swift.Int8.Type) throws -> Swift.Int8
    func decode(_: Swift.Int16.Type) throws -> Swift.Int16
    func decode(_: Swift.Int32.Type) throws -> Swift.Int32
    func decode(_: Swift.Int64.Type) throws -> Swift.Int64
    func decode(_: Swift.Int128.Type) throws -> Swift.Int128
    func decode(_: Swift.UInt.Type) throws -> Swift.UInt
    func decode(_: Swift.UInt8.Type) throws -> Swift.UInt8
    func decode(_: Swift.UInt16.Type) throws -> Swift.UInt16
    func decode(_: Swift.UInt32.Type) throws -> Swift.UInt32
    func decode(_: Swift.UInt64.Type) throws -> Swift.UInt64
    func decode(_: Swift.UInt128.Type) throws -> Swift.UInt128
    func decode<A1>(_: A1.Type) throws -> A1 where A1: Swift.Decodable
}
extension FirebaseSharedSwift.__JSONDecoder: Swift.Decoder {
    var userInfo: [Swift.CodingUserInfoKey : Any] {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func container<A1>(keyedBy: A1.Type) throws -> Swift.KeyedDecodingContainer<A1> where A1: Swift.CodingKey
    func unkeyedContainer() throws -> Swift.UnkeyedDecodingContainer
    func singleValueContainer() throws -> Swift.SingleValueDecodingContainer
}
extension FirebaseSharedSwift.__JSONEncoder: Swift.SingleValueEncodingContainer {
    var codingPath: [Swift.CodingKey] {
        get
    }

    func encodeNil() throws
    func encode(_: Swift.Bool) throws
    func encode(_: Swift.String) throws
    func encode(_: Swift.Double) throws
    func encode(_: Swift.Float) throws
    func encode(_: Swift.Int) throws
    func encode(_: Swift.Int8) throws
    func encode(_: Swift.Int16) throws
    func encode(_: Swift.Int32) throws
    func encode(_: Swift.Int64) throws
    func encode(_: Swift.Int128) throws
    func encode(_: Swift.UInt) throws
    func encode(_: Swift.UInt8) throws
    func encode(_: Swift.UInt16) throws
    func encode(_: Swift.UInt32) throws
    func encode(_: Swift.UInt64) throws
    func encode(_: Swift.UInt128) throws
    func encode<A1>(_: A1) throws where A1: Swift.Encodable
}
extension FirebaseSharedSwift.__JSONEncoder: Swift.Encoder {
    var userInfo: [Swift.CodingUserInfoKey : Any] {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func container<A1>(keyedBy: A1.Type) -> Swift.KeyedEncodingContainer<A1> where A1: Swift.CodingKey
    func unkeyedContainer() -> Swift.UnkeyedEncodingContainer
    func singleValueContainer() -> Swift.SingleValueEncodingContainer
}
extension FirebaseSharedSwift.NoPassthroughTypes: FirebaseSharedSwift.StructureCodingPassthroughTypeResolver {}
extension FirebaseSharedSwift._JSONKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseSharedSwift._JSONKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseSharedSwift._JSONKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseSharedSwift._JSONKeyedEncodingContainer: Swift.KeyedEncodingContainerProtocol {
    typealias Key = A

    var codingPath: [Swift.CodingKey] {
        get
    }

    func encodeNil(forKey: Self.Key) throws
    func encode(_: Swift.Bool, forKey: Self.Key) throws
    func encode(_: Swift.String, forKey: Self.Key) throws
    func encode(_: Swift.Double, forKey: Self.Key) throws
    func encode(_: Swift.Float, forKey: Self.Key) throws
    func encode(_: Swift.Int, forKey: Self.Key) throws
    func encode(_: Swift.Int8, forKey: Self.Key) throws
    func encode(_: Swift.Int16, forKey: Self.Key) throws
    func encode(_: Swift.Int32, forKey: Self.Key) throws
    func encode(_: Swift.Int64, forKey: Self.Key) throws
    func encode(_: Swift.Int128, forKey: Self.Key) throws
    func encode(_: Swift.UInt, forKey: Self.Key) throws
    func encode(_: Swift.UInt8, forKey: Self.Key) throws
    func encode(_: Swift.UInt16, forKey: Self.Key) throws
    func encode(_: Swift.UInt32, forKey: Self.Key) throws
    func encode(_: Swift.UInt64, forKey: Self.Key) throws
    func encode(_: Swift.UInt128, forKey: Self.Key) throws
    func encode<A1>(_: A1, forKey: Self.Key) throws where A1: Swift.Encodable
    func encodeConditional<A1>(_: A1, forKey: Self.Key) throws where A1: AnyObject, A1: Swift.Encodable
    func encodeIfPresent(_: Swift.Bool?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.String?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Double?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Float?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int8?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int16?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int32?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int64?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int128?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt8?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt16?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt32?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt64?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt128?, forKey: Self.Key) throws
    func encodeIfPresent<A1>(_: A1?, forKey: Self.Key) throws where A1: Swift.Encodable
    func nestedContainer<A1>(keyedBy: A1.Type, forKey: Self.Key) -> Swift.KeyedEncodingContainer<A1> where A1: Swift.CodingKey
    func nestedUnkeyedContainer(forKey: Self.Key) -> Swift.UnkeyedEncodingContainer
    func superEncoder() -> Swift.Encoder
    func superEncoder(forKey: Self.Key) -> Swift.Encoder
}
extension FirebaseSharedSwift._JSONUnkeyedEncodingContainer: Swift.UnkeyedEncodingContainer {
    var count: Swift.Int {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func encodeNil() throws
    func encode(_: Swift.Bool) throws
    func encode(_: Swift.String) throws
    func encode(_: Swift.Double) throws
    func encode(_: Swift.Float) throws
    func encode(_: Swift.Int) throws
    func encode(_: Swift.Int8) throws
    func encode(_: Swift.Int16) throws
    func encode(_: Swift.Int32) throws
    func encode(_: Swift.Int64) throws
    func encode(_: Swift.Int128) throws
    func encode(_: Swift.UInt) throws
    func encode(_: Swift.UInt8) throws
    func encode(_: Swift.UInt16) throws
    func encode(_: Swift.UInt32) throws
    func encode(_: Swift.UInt64) throws
    func encode(_: Swift.UInt128) throws
    func encode<A1>(_: A1) throws where A1: Swift.Encodable
    func encodeConditional<A1>(_: A1) throws where A1: AnyObject, A1: Swift.Encodable
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Bool
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.String
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Double
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Float
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int8
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int16
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int32
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int64
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int128
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt8
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt16
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt32
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt64
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt128
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element: Swift.Encodable
    func nestedContainer<A1>(keyedBy: A1.Type) -> Swift.KeyedEncodingContainer<A1> where A1: Swift.CodingKey
    func nestedUnkeyedContainer() -> Swift.UnkeyedEncodingContainer
    func superEncoder() -> Swift.Encoder
}
extension FirebaseSharedSwift._JSONKeyedDecodingContainer: Swift.KeyedDecodingContainerProtocol {
    typealias Key = A

    var allKeys: [Self.Key] {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func contains(_: Self.Key) -> Swift.Bool
    func decodeNil(forKey: Self.Key) throws -> Swift.Bool
    func decode(_: Swift.Bool.Type, forKey: Self.Key) throws -> Swift.Bool
    func decode(_: Swift.String.Type, forKey: Self.Key) throws -> Swift.String
    func decode(_: Swift.Double.Type, forKey: Self.Key) throws -> Swift.Double
    func decode(_: Swift.Float.Type, forKey: Self.Key) throws -> Swift.Float
    func decode(_: Swift.Int.Type, forKey: Self.Key) throws -> Swift.Int
    func decode(_: Swift.Int8.Type, forKey: Self.Key) throws -> Swift.Int8
    func decode(_: Swift.Int16.Type, forKey: Self.Key) throws -> Swift.Int16
    func decode(_: Swift.Int32.Type, forKey: Self.Key) throws -> Swift.Int32
    func decode(_: Swift.Int64.Type, forKey: Self.Key) throws -> Swift.Int64
    func decode(_: Swift.Int128.Type, forKey: Self.Key) throws -> Swift.Int128
    func decode(_: Swift.UInt.Type, forKey: Self.Key) throws -> Swift.UInt
    func decode(_: Swift.UInt8.Type, forKey: Self.Key) throws -> Swift.UInt8
    func decode(_: Swift.UInt16.Type, forKey: Self.Key) throws -> Swift.UInt16
    func decode(_: Swift.UInt32.Type, forKey: Self.Key) throws -> Swift.UInt32
    func decode(_: Swift.UInt64.Type, forKey: Self.Key) throws -> Swift.UInt64
    func decode(_: Swift.UInt128.Type, forKey: Self.Key) throws -> Swift.UInt128
    func decode<A1>(_: A1.Type, forKey: Self.Key) throws -> A1 where A1: Swift.Decodable
    func decodeIfPresent(_: Swift.Bool.Type, forKey: Self.Key) throws -> Swift.Bool?
    func decodeIfPresent(_: Swift.String.Type, forKey: Self.Key) throws -> Swift.String?
    func decodeIfPresent(_: Swift.Double.Type, forKey: Self.Key) throws -> Swift.Double?
    func decodeIfPresent(_: Swift.Float.Type, forKey: Self.Key) throws -> Swift.Float?
    func decodeIfPresent(_: Swift.Int.Type, forKey: Self.Key) throws -> Swift.Int?
    func decodeIfPresent(_: Swift.Int8.Type, forKey: Self.Key) throws -> Swift.Int8?
    func decodeIfPresent(_: Swift.Int16.Type, forKey: Self.Key) throws -> Swift.Int16?
    func decodeIfPresent(_: Swift.Int32.Type, forKey: Self.Key) throws -> Swift.Int32?
    func decodeIfPresent(_: Swift.Int64.Type, forKey: Self.Key) throws -> Swift.Int64?
    func decodeIfPresent(_: Swift.Int128.Type, forKey: Self.Key) throws -> Swift.Int128?
    func decodeIfPresent(_: Swift.UInt.Type, forKey: Self.Key) throws -> Swift.UInt?
    func decodeIfPresent(_: Swift.UInt8.Type, forKey: Self.Key) throws -> Swift.UInt8?
    func decodeIfPresent(_: Swift.UInt16.Type, forKey: Self.Key) throws -> Swift.UInt16?
    func decodeIfPresent(_: Swift.UInt32.Type, forKey: Self.Key) throws -> Swift.UInt32?
    func decodeIfPresent(_: Swift.UInt64.Type, forKey: Self.Key) throws -> Swift.UInt64?
    func decodeIfPresent(_: Swift.UInt128.Type, forKey: Self.Key) throws -> Swift.UInt128?
    func decodeIfPresent<A1>(_: A1.Type, forKey: Self.Key) throws -> A1? where A1: Swift.Decodable
    func nestedContainer<A1>(keyedBy: A1.Type, forKey: Self.Key) throws -> Swift.KeyedDecodingContainer<A1> where A1: Swift.CodingKey
    func nestedUnkeyedContainer(forKey: Self.Key) throws -> Swift.UnkeyedDecodingContainer
    func superDecoder() throws -> Swift.Decoder
    func superDecoder(forKey: Self.Key) throws -> Swift.Decoder
}
extension FirebaseSharedSwift._JSONUnkeyedDecodingContainer: Swift.UnkeyedDecodingContainer {
    var count: Swift.Int? {
        get
    }
    var isAtEnd: Swift.Bool {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }
    var currentIndex: Swift.Int {
        get
    }

    func decodeNil() throws -> Swift.Bool
    func decode(_: Swift.Bool.Type) throws -> Swift.Bool
    func decode(_: Swift.String.Type) throws -> Swift.String
    func decode(_: Swift.Double.Type) throws -> Swift.Double
    func decode(_: Swift.Float.Type) throws -> Swift.Float
    func decode(_: Swift.Int.Type) throws -> Swift.Int
    func decode(_: Swift.Int8.Type) throws -> Swift.Int8
    func decode(_: Swift.Int16.Type) throws -> Swift.Int16
    func decode(_: Swift.Int32.Type) throws -> Swift.Int32
    func decode(_: Swift.Int64.Type) throws -> Swift.Int64
    func decode(_: Swift.Int128.Type) throws -> Swift.Int128
    func decode(_: Swift.UInt.Type) throws -> Swift.UInt
    func decode(_: Swift.UInt8.Type) throws -> Swift.UInt8
    func decode(_: Swift.UInt16.Type) throws -> Swift.UInt16
    func decode(_: Swift.UInt32.Type) throws -> Swift.UInt32
    func decode(_: Swift.UInt64.Type) throws -> Swift.UInt64
    func decode(_: Swift.UInt128.Type) throws -> Swift.UInt128
    func decode<A1>(_: A1.Type) throws -> A1 where A1: Swift.Decodable
    func decodeIfPresent(_: Swift.Bool.Type) throws -> Swift.Bool?
    func decodeIfPresent(_: Swift.String.Type) throws -> Swift.String?
    func decodeIfPresent(_: Swift.Double.Type) throws -> Swift.Double?
    func decodeIfPresent(_: Swift.Float.Type) throws -> Swift.Float?
    func decodeIfPresent(_: Swift.Int.Type) throws -> Swift.Int?
    func decodeIfPresent(_: Swift.Int8.Type) throws -> Swift.Int8?
    func decodeIfPresent(_: Swift.Int16.Type) throws -> Swift.Int16?
    func decodeIfPresent(_: Swift.Int32.Type) throws -> Swift.Int32?
    func decodeIfPresent(_: Swift.Int64.Type) throws -> Swift.Int64?
    func decodeIfPresent(_: Swift.Int128.Type) throws -> Swift.Int128?
    func decodeIfPresent(_: Swift.UInt.Type) throws -> Swift.UInt?
    func decodeIfPresent(_: Swift.UInt8.Type) throws -> Swift.UInt8?
    func decodeIfPresent(_: Swift.UInt16.Type) throws -> Swift.UInt16?
    func decodeIfPresent(_: Swift.UInt32.Type) throws -> Swift.UInt32?
    func decodeIfPresent(_: Swift.UInt64.Type) throws -> Swift.UInt64?
    func decodeIfPresent(_: Swift.UInt128.Type) throws -> Swift.UInt128?
    func decodeIfPresent<A1>(_: A1.Type) throws -> A1? where A1: Swift.Decodable
    func nestedContainer<A1>(keyedBy: A1.Type) throws -> Swift.KeyedDecodingContainer<A1> where A1: Swift.CodingKey
    func nestedUnkeyedContainer() throws -> Swift.UnkeyedDecodingContainer
    func superDecoder() throws -> Swift.Decoder
}
extension FirebaseFirestore.FirestoreDecodingError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseFirestore.FirestoreEncodingError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseFirestore.FirestorePassthroughTypes: FirebaseSharedSwift.StructureCodingPassthroughTypeResolver {}
extension Swift.String: FirebaseFirestore.DocumentIDWrappable {}
extension Swift.String: LocalLLMClientCore.ToolArgumentType {}
extension Swift.String: Hub.StringConvertible {}
extension Swift.String: GRDB.DatabaseValueConvertible {}
extension Swift.String: GRDB.StatementColumnConvertible {}
extension Swift.String: GRDB.SQLExpressible {}
extension Swift.String: GRDB.StatementBinding {}
extension __C.FIRDocumentReference: FirebaseFirestore.DocumentIDWrappable {}
extension __C.FIRDocumentReference: FirebaseFirestore.CodableDocumentReference {}
extension __C.FIRDocumentReference: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension __C.FIRDocumentReference: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseFirestore.DocumentID: FirebaseSharedSwift.StructureCodingUncodedUnkeyed {}
extension FirebaseFirestore.DocumentID: FirebaseFirestore.DocumentIDProtocol {}
extension FirebaseFirestore.DocumentID: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseFirestore.DocumentID: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseFirestore.DocumentID: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFirestore.DocumentID: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFirestore.ExplicitNull: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFirestore.ExplicitNull: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFirestore.ExplicitNull: Swift.Encodable where A: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseFirestore.ExplicitNull: Swift.Decodable where A: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension __C.FIRFieldValue: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension __C.FIRGeoPoint: FirebaseFirestore.CodableGeoPoint {}
extension __C.FIRGeoPoint: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension __C.FIRGeoPoint: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseFirestore.GeoPointKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseFirestore.GeoPointKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseFirestore.GeoPointKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseFirestore.GeoPointKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFirestore.GeoPointKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFirestore.GeoPointKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Foundation.Date: FirebaseFirestore.ServerTimestampWrappable {}
extension Foundation.Date: LocalLLMClientCore.DefaultFormattedType {}
extension Foundation.Date: LocalLLMClientCore.ToolArgumentType {}
extension Foundation.Date: GRDB.DatabaseValueConvertible {}
extension Foundation.Date: GRDB.SQLExpressible {}
extension Foundation.Date: GRDB.StatementBinding {}
extension Foundation.Date: GRDB.StatementColumnConvertible {}
extension __C.FIRTimestamp: FirebaseFirestore.ServerTimestampWrappable {}
extension __C.FIRTimestamp: FirebaseFirestore.CodableTimestamp {}
extension __C.FIRTimestamp: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension __C.FIRTimestamp: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseFirestore.ServerTimestamp: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseFirestore.ServerTimestamp: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseFirestore.ServerTimestamp: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFirestore.ServerTimestamp: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFirestore.TimestampKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseFirestore.TimestampKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseFirestore.TimestampKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseFirestore.TimestampKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFirestore.TimestampKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFirestore.TimestampKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension __C.FIRVectorValue: FirebaseFirestore.CodableVectorValue {}
extension __C.FIRVectorValue: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension __C.FIRVectorValue: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseFirestore.VectorValueKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseFirestore.VectorValueKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseFirestore.VectorValueKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseFirestore.VectorValueKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFirestore.VectorValueKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFirestore.VectorValueKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseFirestore.DecodingFailureStrategy: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFirestore.DecodingFailureStrategy: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFirestore.FirestoreQuery: SwiftUI.DynamicProperty {
    func update()

    static var _propertyBehaviors: Swift.UInt32 {
        get
    }

    static func _makeProperty<A1>(in: inout SwiftUI._DynamicPropertyBuffer, container: SwiftUI._GraphValue<A1>, fieldOffset: Swift.Int, inputs: inout SwiftUI._GraphInputs)
}
extension FirebaseFirestore.FirestoreQueryObservable: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension GTMAppAuth.AuthSession.Error: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension GTMAppAuth.AuthSession.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GTMAppAuth.AuthSession.Error: Foundation.CustomNSError {
    var errorCode: Swift.Int {
        get
    }
    var errorUserInfo: [Swift.String : Any] {
        get
    }

    static var errorDomain: Swift.String {
        get
    }
}
extension GTMAppAuth.AuthSession.ErrorCode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GTMAppAuth.AuthSession.ErrorCode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GTMAppAuth.AuthSession.ErrorCode: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GTMAppAuth.KeychainStore.Error: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension GTMAppAuth.KeychainStore.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GTMAppAuth.KeychainStore.Error: Foundation.CustomNSError {
    var errorCode: Swift.Int {
        get
    }
    var errorUserInfo: [Swift.String : Any] {
        get
    }

    static var errorDomain: Swift.String {
        get
    }
}
extension GTMAppAuth.KeychainStore.ErrorCode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GTMAppAuth.KeychainStore.ErrorCode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GTMAppAuth.KeychainStore.ErrorCode: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Shimmer.Shimmer: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI._ConditionalContent<SwiftUI._ConditionalContent<SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Shimmer.Shimmer>, SwiftUI._MaskEffect<SwiftUI.LinearGradient>>, SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Shimmer.Shimmer>, SwiftUI._OverlayModifier<SwiftUI.ModifiedContent<SwiftUI.LinearGradient, SwiftUI._BlendModeEffect>>>>, SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Shimmer.Shimmer>, SwiftUI._BackgroundModifier<SwiftUI.LinearGradient>>>, SwiftUI._AnimationModifier<Swift.Bool>>, SwiftUI._AppearanceActionModifier>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension SwiftOpenAI.AIProxyService: SwiftOpenAI.OpenAIService {}
extension SwiftOpenAI.AzureOpenAIAPI: SwiftOpenAI.Endpoint {}
extension SwiftOpenAI.DefaultOpenAIAzureService: SwiftOpenAI.OpenAIService {}
extension SwiftOpenAI.OpenAIAPI: SwiftOpenAI.Endpoint {}
extension SwiftOpenAI.OpenAIAPI.AudioCategory: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.OpenAIAPI.AudioCategory: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.OpenAIAPI.AudioCategory: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.OpenAIAPI.ImageCategory: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.OpenAIAPI.ImageCategory: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.OpenAIAPI.ImageCategory: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AssistantParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.AssistantParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.AssistantParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.AssistantParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AssistantParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AssistantParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AssistantParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.AudioSpeechParameters.TTSModel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioSpeechParameters.TTSModel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioSpeechParameters.TTSModel: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AudioSpeechParameters.Voice: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioSpeechParameters.Voice: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioSpeechParameters.Voice: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AudioSpeechParameters.ResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioSpeechParameters.ResponseFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioSpeechParameters.ResponseFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AudioSpeechParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.AudioSpeechParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioSpeechParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioSpeechParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AudioSpeechParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioSpeechParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioSpeechParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.AudioTranscriptionParameters.Model: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioTranscriptionParameters.Model: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioTranscriptionParameters.Model: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AudioTranscriptionParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.AudioTranscriptionParameters: SwiftOpenAI.MultipartFormDataParameters {}
extension SwiftOpenAI.AudioTranscriptionParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioTranscriptionParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioTranscriptionParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AudioTranscriptionParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioTranscriptionParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioTranscriptionParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.AudioTranslationParameters.Model: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioTranslationParameters.Model: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioTranslationParameters.Model: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AudioTranslationParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.AudioTranslationParameters: SwiftOpenAI.MultipartFormDataParameters {}
extension SwiftOpenAI.AudioTranslationParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioTranslationParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioTranslationParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AudioTranslationParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioTranslationParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioTranslationParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.BatchParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.BatchParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.BatchParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.BatchParameter.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.BatchParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.BatchParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.BatchParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.ImageDetail: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.ImageDetail: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.ImageDetail: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.Message.Role: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.Message.Role: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.Message.Role: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.FunctionCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.FunctionCall: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.Tool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.JSONType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.JSONType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.JSONType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.JSONType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.JSONType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Items: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Items: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Items: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.ImageDetail.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.ImageDetail.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.ImageDetail.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.ImageDetail.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.ImageDetail.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.ImageDetail.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.Message.ContentType.MessageContent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Message.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.Message.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.Message.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.FunctionCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.FunctionCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.FunctionCall.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.FunctionCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.FunctionCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.FunctionCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Tool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Tool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.Tool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.Tool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.Tool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Property.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Items.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Items.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Items.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Items.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Items.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.Items.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.JSONSchema.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.ChatFunction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.EmbeddingParameter.Model: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.EmbeddingParameter.Model: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.EmbeddingParameter.Model: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.EmbeddingParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.EmbeddingParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.EmbeddingParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.EmbeddingParameter.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.EmbeddingParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.EmbeddingParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.EmbeddingParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FileParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FileParameters: SwiftOpenAI.MultipartFormDataParameters {}
extension SwiftOpenAI.FileParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FileParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FileParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.Model: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FineTuningJobParameters.Model: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FineTuningJobParameters.Model: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.HyperParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.Wandb: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FineTuningJobParameters.Integration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FineTuningJobParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FineTuningJobParameters.HyperParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.HyperParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.HyperParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.HyperParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FineTuningJobParameters.HyperParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FineTuningJobParameters.HyperParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.Wandb.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.Wandb.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.Wandb.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.Wandb.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.Wandb.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FineTuningJobParameters.Integration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FineTuningJobParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FineTuningJobParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FineTuningJobParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.Dalle.Dalle2ImageSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.Dalle.Dalle2ImageSize: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.Dalle.Dalle2ImageSize: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.Dalle.Dalle3ImageSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.Dalle.Dalle3ImageSize: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.Dalle.Dalle3ImageSize: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageCreateParameters.ImageSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ImageCreateParameters.ImageSize: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ImageCreateParameters.ImageSize: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageCreateParameters.ImageResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ImageCreateParameters.ImageResponseFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ImageCreateParameters.ImageResponseFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageCreateParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ImageCreateParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageCreateParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageCreateParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageCreateParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ImageCreateParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ImageCreateParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ImageEditParameters.ImageResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ImageEditParameters.ImageResponseFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ImageEditParameters.ImageResponseFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageEditParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ImageEditParameters: SwiftOpenAI.MultipartFormDataParameters {}
extension SwiftOpenAI.ImageEditParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageEditParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageEditParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageEditParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ImageEditParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ImageEditParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ImageVariationParameters.ImageResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ImageVariationParameters.ImageResponseFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ImageVariationParameters.ImageResponseFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageVariationParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ImageVariationParameters: SwiftOpenAI.MultipartFormDataParameters {}
extension SwiftOpenAI.ImageVariationParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageVariationParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageVariationParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageVariationParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ImageVariationParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ImageVariationParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.MessageParameter.Role: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.MessageParameter.Role: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.MessageParameter.Role: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.MessageParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.MessageParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageParameter.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.MessageParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.MessageParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.MessageParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ModifyMessageParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ModifyMessageParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModifyMessageParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModifyMessageParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ModifyMessageParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ModifyMessageParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ModerationParameter.Model: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ModerationParameter.Model: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ModerationParameter.Model: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ModerationParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ModerationParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModerationParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModerationParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ModerationParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ModerationParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.CreateThreadAndRunParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.CreateThreadAndRunParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.CreateThreadAndRunParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.CreateThreadAndRunParameter.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.CreateThreadAndRunParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.CreateThreadAndRunParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.CreateThreadAndRunParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ModifyRunParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ModifyRunParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModifyRunParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModifyRunParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ModifyRunParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ModifyRunParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.RunParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunParameter.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunToolsOutputParameter.ToolOutput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.RunToolsOutputParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.RunToolsOutputParameter.ToolOutput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunToolsOutputParameter.ToolOutput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunToolsOutputParameter.ToolOutput.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunToolsOutputParameter.ToolOutput.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunToolsOutputParameter.ToolOutput.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunToolsOutputParameter.ToolOutput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunToolsOutputParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunToolsOutputParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunToolsOutputParameter.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunToolsOutputParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunToolsOutputParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunToolsOutputParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.CreateThreadParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.CreateThreadParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.CreateThreadParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.CreateThreadParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.CreateThreadParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.CreateThreadParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.CreateThreadParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ModifyThreadParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ModifyThreadParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModifyThreadParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModifyThreadParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ModifyThreadParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ModifyThreadParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.VectorStoreParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.VectorStoreParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreParameter.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.VectorStoreParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.VectorStoreParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.VectorStoreParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileBatchParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.VectorStoreFileBatchParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileBatchParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileBatchParameter.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileBatchParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.VectorStoreFileBatchParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.VectorStoreFileBatchParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileParameter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.VectorStoreFileParameter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileParameter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileParameter.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileParameter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.VectorStoreFileParameter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.VectorStoreFileParameter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.AssistantObject.Tool.ToolType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AssistantObject.Tool.ToolType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AssistantObject.Tool.ToolType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AssistantObject.Tool.ToolType: Swift.CaseIterable {
    typealias AllCases = [SwiftOpenAI.AssistantObject.Tool.ToolType]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftOpenAI.AssistantObject.Tool: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.AssistantObject.Tool: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.AssistantObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.AssistantObject.Tool.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.AssistantObject.Tool.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.AssistantObject.Tool.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AssistantObject.Tool.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AssistantObject.Tool.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.AssistantObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.AssistantObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.AssistantObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AssistantObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AssistantObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AssistantObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.AssistantStreamEventObject: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AssistantStreamEventObject: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AssistantStreamEventObject: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AudioObject.Word: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.AudioObject.Segment: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.AudioObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.AudioObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.AudioObject.Segment.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioObject.Segment.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioObject.Segment.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.AudioObject.Segment.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioObject.Segment.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioObject.Segment.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.AudioObject.Word.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioObject.Word.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioObject.Word.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioObject.Word.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioObject.Word.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.AudioSpeechObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.AudioSpeechObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioSpeechObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.AudioSpeechObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.AudioSpeechObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.AudioSpeechObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.BatchObject.Error.Data: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.BatchObject.Error: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.BatchObject.RequestCount: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.BatchObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.BatchObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.BatchObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.BatchObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.BatchObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.BatchObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.BatchObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.BatchObject.RequestCount.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.BatchObject.RequestCount.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.BatchObject.RequestCount.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.BatchObject.RequestCount.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.BatchObject.RequestCount.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.BatchObject.Error.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.BatchObject.Error.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.BatchObject.Error.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.BatchObject.Error.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.BatchObject.Error.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.BatchObject.Error.Data.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.BatchObject.Error.Data.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.BatchObject.Error.Data.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.BatchObject.Error.Data.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.BatchObject.Error.Data.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.LogProb: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.FinishDetails: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionChunkObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.FinishDetails.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.FinishDetails.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.FinishDetails.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.FinishDetails.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.FinishDetails.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.TopLogProb: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.TopLogProb.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.TopLogProb.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.TopLogProb.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.TopLogProb.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.TopLogProb.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionChunkObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionChunkObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.TokenDetail.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.LogProb.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.LogProb.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.LogProb.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.LogProb.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.LogProb.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.Delta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionChunkObject.ChatChoice.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.FinishDetails: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.LogProb: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionObject.ChatUsage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.FinishDetails.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.FinishDetails.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.FinishDetails.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.FinishDetails.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.FinishDetails.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.TopLogProb: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.TopLogProb.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.TopLogProb.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.TopLogProb.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.TopLogProb.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.TopLogProb.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatUsage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatUsage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatUsage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatUsage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionObject.ChatUsage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionObject.ChatUsage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.TokenDetail.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.LogProb.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.LogProb.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.LogProb.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.LogProb.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.LogProb.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ChatCompletionObject.ChatChoice.ChatMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.EmbeddingObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.EmbeddingObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.EmbeddingObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.EmbeddingObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.EmbeddingObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.EmbeddingObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FileObject.Status: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FileObject.Status: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FileObject.Status: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FileObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FileObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FileObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FileObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FileObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FineTuningJobEventObject.Data: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FineTuningJobEventObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FineTuningJobEventObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobEventObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobEventObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FineTuningJobEventObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FineTuningJobEventObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FineTuningJobEventObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FineTuningJobEventObject.Data.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobEventObject.Data.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobEventObject.Data.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FineTuningJobEventObject.Data.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FineTuningJobEventObject.Data.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FineTuningJobEventObject.Data.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FineTuningJobObject.Status: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FineTuningJobObject.Status: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FineTuningJobObject.Status: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FineTuningJobObject.HyperParameters: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FineTuningJobObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.IntOrStringValue: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FineTuningJobObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FineTuningJobObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FineTuningJobObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FineTuningJobObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FineTuningJobObject.HyperParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobObject.HyperParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FineTuningJobObject.HyperParameters.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FineTuningJobObject.HyperParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FineTuningJobObject.HyperParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FineTuningJobObject.HyperParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ImageObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ImageObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ImageObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ImageObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.MessageContent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.MessageContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ImageFile.ImageFileContent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ImageFile.ImageFileContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ImageFile: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ImageFile: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.Text.TextContent: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.Text.TextContent: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.Text: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.Text: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.Annotation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.Annotation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FileCitation.FileCitationDetails: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FileCitation.FileCitationDetails: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FileCitation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FileCitation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FilePath.FilePathDetails: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FilePath.FilePathDetails: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FilePath: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FilePath: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.MessageContent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageContent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageContent.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.MessageContent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.MessageContent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.MessageContent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ImageFile.ImageFileContent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageFile.ImageFileContent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageFile.ImageFileContent.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageFile.ImageFileContent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ImageFile.ImageFileContent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ImageFile.ImageFileContent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ImageFile.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageFile.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ImageFile.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ImageFile.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ImageFile.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ImageFile.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.Text.TextContent.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.Text.TextContent.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.Text.TextContent.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.Text.TextContent.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.Text.TextContent.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.Text.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.Text.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.Text.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.Text.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.Text.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.Annotation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.Annotation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.Annotation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.Annotation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.Annotation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.Annotation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FileCitation.FileCitationDetails.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileCitation.FileCitationDetails.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileCitation.FileCitationDetails.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FileCitation.FileCitationDetails.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FileCitation.FileCitationDetails.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FileCitation.FileCitationDetails.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FileCitation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileCitation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileCitation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FileCitation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FileCitation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FileCitation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FilePath.FilePathDetails.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FilePath.FilePathDetails.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FilePath.FilePathDetails.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FilePath.FilePathDetails.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FilePath.FilePathDetails.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FilePath.FilePathDetails.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FilePath.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FilePath.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FilePath.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FilePath.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FilePath.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FilePath.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.Annotation.AnnotationTypeKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.Annotation.AnnotationTypeKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.Annotation.AnnotationTypeKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.Annotation.AnnotationTypeKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.Annotation.AnnotationTypeKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.MessageContent.ContentTypeKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageContent.ContentTypeKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageContent.ContentTypeKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.MessageContent.ContentTypeKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.MessageContent.ContentTypeKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.MessageDeltaObject.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.MessageDeltaObject: SwiftOpenAI.Delta {
    typealias T = SwiftOpenAI.MessageDeltaObject.Delta
}
extension SwiftOpenAI.MessageDeltaObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.MessageDeltaObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageDeltaObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageDeltaObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.MessageDeltaObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.MessageDeltaObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.MessageDeltaObject.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageDeltaObject.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageDeltaObject.Delta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.MessageDeltaObject.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.MessageDeltaObject.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.MessageDeltaObject.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.MessageObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.MessageObject: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.MessageObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.MessageObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.MessageObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.MessageObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ModelObject.Permission: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ModelObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ModelObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModelObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModelObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ModelObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ModelObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ModelObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ModelObject.Permission.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModelObject.Permission.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModelObject.Permission.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ModelObject.Permission.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ModelObject.Permission.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ModelObject.Permission.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ModerationObject.Moderation.Category: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ModerationObject.Moderation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ModerationObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ModerationObject.Moderation.Category.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModerationObject.Moderation.Category.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModerationObject.Moderation.Category.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ModerationObject.Moderation.Category.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ModerationObject.Moderation.Category.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ModerationObject.Moderation.Category.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ModerationObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModerationObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModerationObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ModerationObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ModerationObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ModerationObject.Moderation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModerationObject.Moderation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ModerationObject.Moderation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ModerationObject.Moderation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ModerationObject.Moderation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ModerationObject.Moderation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.OpenAIErrorResponse.Error: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.OpenAIErrorResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.OpenAIErrorResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.OpenAIErrorResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.OpenAIErrorResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.OpenAIErrorResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.OpenAIErrorResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.OpenAIErrorResponse.Error.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.OpenAIErrorResponse.Error.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.OpenAIErrorResponse.Error.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.OpenAIErrorResponse.Error.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.OpenAIErrorResponse.Error.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.OpenAIResponse.Usage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.OpenAIResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.OpenAIResponse.Usage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.OpenAIResponse.Usage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.OpenAIResponse.Usage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.OpenAIResponse.Usage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.OpenAIResponse.Usage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.OpenAIResponse.Usage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.OpenAIResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.OpenAIResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.OpenAIResponse.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.OpenAIResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.OpenAIResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.OpenAIResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunObject.Status: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunObject.Status: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunObject.Status: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunObject.RequiredAction.SubmitToolOutput: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunObject.RequiredAction: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunObject.RequiredAction.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunObject.RequiredAction.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunObject.RequiredAction.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunObject.RequiredAction.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunObject.RequiredAction.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunObject.RequiredAction.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunObject.RequiredAction.SubmitToolOutput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunObject.RequiredAction.SubmitToolOutput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunObject.RequiredAction.SubmitToolOutput.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunObject.RequiredAction.SubmitToolOutput.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunObject.RequiredAction.SubmitToolOutput.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunObject.RequiredAction.SubmitToolOutput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunStepDeltaObject.Delta: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunStepDeltaObject: SwiftOpenAI.Delta {
    typealias T = SwiftOpenAI.RunStepDeltaObject.Delta
}
extension SwiftOpenAI.RunStepDeltaObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunStepDeltaObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepDeltaObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepDeltaObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunStepDeltaObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunStepDeltaObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunStepDeltaObject.Delta.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepDeltaObject.Delta.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepDeltaObject.Delta.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunStepDeltaObject.Delta.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunStepDeltaObject.Delta.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunStepDeltaObject.Delta.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.MessageCreation: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunStepDetails.MessageCreation: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.RunStepDetails.ToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunStepDetails.ToolCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.RunStepDetails: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunStepDetails: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.RunStepToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunStepToolCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.CodeInterpreterToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.CodeInterpreterToolCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.CodeInterpreterOutput: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.CodeInterpreterOutput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.CodeInterpreterLogOutput: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.CodeInterpreterLogOutput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.CodeInterpreterImageOutput.Image: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.CodeInterpreterImageOutput.Image: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.CodeInterpreterImageOutput: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.CodeInterpreterImageOutput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FileSearchToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FileSearchToolCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FunctionToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FunctionToolCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.RunStepDetails.MessageCreation.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.MessageCreation.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.MessageCreation.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.MessageCreation.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunStepDetails.MessageCreation.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunStepDetails.MessageCreation.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.ToolCall.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunStepDetails.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunStepDetails.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunStepDetails.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunStepDetails.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunStepDetails.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterToolCall.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.CodeInterpreterToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.CodeInterpreterToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterOutput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterOutput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterOutput.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterOutput.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.CodeInterpreterOutput.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.CodeInterpreterOutput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterLogOutput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterLogOutput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterLogOutput.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.CodeInterpreterLogOutput.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.CodeInterpreterLogOutput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterImageOutput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterImageOutput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterImageOutput.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.CodeInterpreterImageOutput.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.CodeInterpreterImageOutput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterImageOutput.Image.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterImageOutput.Image.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterImageOutput.Image.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterImageOutput.Image.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.CodeInterpreterImageOutput.Image.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.CodeInterpreterImageOutput.Image.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FileSearchToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileSearchToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileSearchToolCall.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FileSearchToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FileSearchToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FileSearchToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FunctionToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FunctionToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FunctionToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FunctionToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FunctionToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterOutput.OutputType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.CodeInterpreterOutput.OutputType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.CodeInterpreterOutput.OutputType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.CodeInterpreterOutput.OutputType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunStepToolCall.TypeEnum: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunStepToolCall.TypeEnum: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunStepToolCall.TypeEnum: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunStepToolCall.TypeEnum: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunStepObject.Status: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunStepObject.Status: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunStepObject.Status: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunStepObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.RunStepObject: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.RunStepObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.RunStepObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.RunStepObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.RunStepObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.RunStepObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ThreadObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ThreadObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ThreadObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ThreadObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ThreadObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ThreadObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ThreadObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.VectorStoreObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.VectorStoreObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.VectorStoreObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.VectorStoreObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.VectorStoreObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.VectorStoreFileObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.VectorStoreFileObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.VectorStoreFileObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileBatchObject: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.VectorStoreFileBatchObject.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileBatchObject.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileBatchObject.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.VectorStoreFileBatchObject.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.VectorStoreFileBatchObject.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.VectorStoreFileBatchObject.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.DefaultOpenAIService: SwiftOpenAI.OpenAIService {}
extension SwiftOpenAI.APIError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftOpenAI.DeletionStatus: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.DeletionStatus.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.DeletionStatus.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.DeletionStatus.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.DeletionStatus.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.DeletionStatus.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ExpirationPolicy: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ExpirationPolicy: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ExpirationPolicy.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ExpirationPolicy.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ExpirationPolicy.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ExpirationPolicy.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ExpirationPolicy.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FileCount: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FileCount.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileCount.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FileCount.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.FileCount.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FileCount.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FileCount.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.IncompleteDetails: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.IncompleteDetails: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.IncompleteDetails.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.IncompleteDetails.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.IncompleteDetails.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.IncompleteDetails.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.IncompleteDetails.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.LastError: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.LastError: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.LastError.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.LastError.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.LastError.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.LastError.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.LastError.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.MessageAttachment: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.MessageAttachment: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.MessageAttachment.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageAttachment.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.MessageAttachment.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.MessageAttachment.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.MessageAttachment.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.MessageAttachment.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ResponseFormat: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ResponseFormat: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ResponseFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ResponseFormat.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ResponseFormat.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ResponseFormat.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ResponseFormat.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ResponseFormat.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ResponseFormat.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ToolCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.FunctionCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.FunctionCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.FunctionCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.FunctionCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.FunctionCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.FunctionCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.FunctionCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ToolChoice: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ToolChoice: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ToolChoice: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ToolChoice.FunctionCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolChoice.FunctionCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolChoice.FunctionCodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ToolChoice.FunctionCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ToolChoice.FunctionCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ToolChoice.FunctionCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ToolChoice.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolChoice.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolChoice.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ToolChoice.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ToolChoice.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ToolChoice.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ToolResources.FileSearch: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ToolResources.FileSearch: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ToolResources.CodeInterpreter: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ToolResources.CodeInterpreter: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ToolResources: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.ToolResources: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.ToolResources.FileSearch.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolResources.FileSearch.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolResources.FileSearch.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ToolResources.FileSearch.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ToolResources.FileSearch.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ToolResources.FileSearch.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ToolResources.CodeInterpreter.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolResources.CodeInterpreter.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolResources.CodeInterpreter.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ToolResources.CodeInterpreter.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ToolResources.CodeInterpreter.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ToolResources.CodeInterpreter.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.ToolResources.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolResources.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.ToolResources.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.ToolResources.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.ToolResources.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.ToolResources.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.TruncationStrategy: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.TruncationStrategy: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.TruncationStrategy.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.TruncationStrategy.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.TruncationStrategy.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.TruncationStrategy.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.TruncationStrategy.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.TruncationStrategy.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftOpenAI.Usage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftOpenAI.Usage: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftOpenAI.Usage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftOpenAI.Usage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftOpenAI.Usage.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftOpenAI.Usage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftOpenAI.Usage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftOpenAI.Usage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension LocalLLMClientUtility.FileDownloader.Source: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientUtility.FileDownloader: LocalLLMClientUtility.FileDownloadable {}
extension LocalLLMClientUtility.FilesMetadata.FileMetadata: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension LocalLLMClientUtility.FilesMetadata.FileMetadata: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension LocalLLMClientUtility.FilesMetadata: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension LocalLLMClientUtility.FilesMetadata: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension LocalLLMClientUtility.FilesMetadata.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension LocalLLMClientUtility.FilesMetadata.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension LocalLLMClientUtility.FilesMetadata.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientUtility.FilesMetadata.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientUtility.FilesMetadata.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension LocalLLMClientUtility.FilesMetadata.FileMetadata.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension LocalLLMClientUtility.FilesMetadata.FileMetadata.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension LocalLLMClientUtility.FilesMetadata.FileMetadata.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientUtility.FilesMetadata.FileMetadata.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientUtility.FilesMetadata.FileMetadata.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension LocalLLMClientUtility.Globs: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientUtility.Globs: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Swift.String

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension LocalLLMClientUtility.HuggingFaceAPI.RepoType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientUtility.HuggingFaceAPI.RepoType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientUtility.HuggingFaceAPI.RepoType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension LocalLLMClientUtility.HuggingFaceAPI.Repo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientUtility.HuggingFaceAPI.FileInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientUtility.HuggingFaceAPI.FileInfo: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.Sibling: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.Sibling: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.Sibling.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.Sibling.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.Sibling.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.Sibling.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientUtility.HuggingFaceAPI.SiblingsResponse.Sibling.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Node: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Node: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Jinja.Node: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Jinja.Node: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.UnaryOp: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.UnaryOp: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Jinja.Expression.UnaryOp: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.UnaryOp: Swift.CaseIterable {
    typealias AllCases = [Jinja.Expression.UnaryOp]

    static var allCases: Self.AllCases {
        get
    }
}
extension Jinja.Expression.UnaryOp: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Jinja.Expression.UnaryOp: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Jinja.Expression.BinaryOp: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.BinaryOp: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Jinja.Expression.BinaryOp: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.BinaryOp: Swift.CaseIterable {
    typealias AllCases = [Jinja.Expression.BinaryOp]

    static var allCases: Self.AllCases {
        get
    }
}
extension Jinja.Expression.BinaryOp: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Jinja.Expression.BinaryOp: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Jinja.Expression: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Jinja.Expression: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Jinja.Expression: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.LoopVar: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.LoopVar: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Jinja.Statement.LoopVar: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Jinja.Statement.LoopVar: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Jinja.Statement: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Jinja.Statement: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Node.CommentCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Node.CommentCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Node.CommentCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Node.CommentCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Node.CommentCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Node.StatementCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Node.StatementCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Node.StatementCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Node.StatementCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Node.StatementCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Node.ExpressionCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Node.ExpressionCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Node.ExpressionCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Node.ExpressionCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Node.ExpressionCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Node.TextCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Node.TextCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Node.TextCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Node.TextCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Node.TextCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Node.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Node.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Node.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Node.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Node.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.TestCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.TestCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.TestCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.TestCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.TestCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.FilterCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.FilterCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.FilterCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.FilterCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.FilterCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.SliceCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.SliceCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.SliceCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.SliceCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.SliceCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.MemberCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.MemberCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.MemberCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.MemberCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.MemberCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.CallCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.CallCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.CallCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.CallCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.CallCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.TernaryCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.TernaryCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.TernaryCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.TernaryCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.TernaryCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.BinaryCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.BinaryCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.BinaryCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.BinaryCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.BinaryCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.UnaryCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.UnaryCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.UnaryCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.UnaryCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.UnaryCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.IdentifierCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.IdentifierCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.IdentifierCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.IdentifierCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.IdentifierCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.ObjectCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.ObjectCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.ObjectCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.ObjectCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.ObjectCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.TupleCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.TupleCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.TupleCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.TupleCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.TupleCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.ArrayCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.ArrayCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.ArrayCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.ArrayCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.ArrayCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.NullCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.NullCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.NullCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.BooleanCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.BooleanCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.BooleanCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.BooleanCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.BooleanCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.IntegerCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.IntegerCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.IntegerCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.IntegerCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.IntegerCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.NumberCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.NumberCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.NumberCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.NumberCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.NumberCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.StringCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.StringCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.StringCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.StringCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.StringCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Expression.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Expression.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Expression.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Expression.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Expression.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.LoopVar.TupleCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.LoopVar.TupleCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.LoopVar.TupleCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.LoopVar.TupleCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.LoopVar.TupleCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.LoopVar.SingleCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.LoopVar.SingleCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.LoopVar.SingleCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.LoopVar.SingleCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.LoopVar.SingleCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.LoopVar.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.LoopVar.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.LoopVar.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.LoopVar.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.LoopVar.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.FilterCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.FilterCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.FilterCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.FilterCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.FilterCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.CallCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.CallCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.CallCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.CallCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.CallCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.ContinueCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.ContinueCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.ContinueCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.BreakCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.BreakCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.BreakCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.MacroCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.MacroCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.MacroCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.MacroCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.MacroCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.ForCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.ForCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.ForCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.ForCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.ForCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.IfCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.IfCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.IfCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.IfCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.IfCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.SetCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.SetCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.SetCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.SetCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.SetCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.ProgramCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.ProgramCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.ProgramCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.ProgramCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.ProgramCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Statement.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Statement.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Statement.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Statement.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Statement.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.JinjaError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Jinja.TemplateException: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Jinja.ControlFlow: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.ControlFlow: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.ControlFlow: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Jinja.Macro: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Macro: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Macro: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Jinja.Macro: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Jinja.Macro.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Macro.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Macro.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Jinja.Macro.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Macro.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Macro.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Template.Options: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Template.Options: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Template: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Template: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Token.Kind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Token.Kind: Swift.CaseIterable {
    typealias AllCases = [Jinja.Token.Kind]

    static var allCases: Self.AllCases {
        get
    }
}
extension Jinja.Token.Kind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Token.Kind: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Jinja.Token.Kind: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Jinja.Token: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Token: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Token: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Jinja.Token: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Jinja.Token.Kind.EofCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EofCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EofCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.CommentCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CommentCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CommentCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.EndfilterCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndfilterCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndfilterCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.FilterCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.FilterCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.FilterCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.EndcallCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndcallCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndcallCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.CallCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CallCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CallCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.ContinueCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ContinueCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ContinueCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.BreakCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.BreakCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.BreakCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.EndmacroCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndmacroCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndmacroCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.MacroCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.MacroCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.MacroCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.EndsetCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndsetCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndsetCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.SetCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.SetCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.SetCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.EndforCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndforCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndforCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.ForCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ForCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ForCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.EndifCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndifCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EndifCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.ElifCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ElifCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ElifCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.ElseCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ElseCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ElseCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.IfCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.IfCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.IfCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.IsCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.IsCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.IsCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.NotInCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.NotInCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.NotInCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.InCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.InCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.InCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.NotCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.NotCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.NotCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.OrCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OrCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OrCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.AndCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.AndCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.AndCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.GreaterEqualCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.GreaterEqualCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.GreaterEqualCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.GreaterCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.GreaterCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.GreaterCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.LessEqualCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.LessEqualCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.LessEqualCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.LessCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.LessCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.LessCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.NotEqualCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.NotEqualCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.NotEqualCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.EqualCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EqualCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EqualCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.ConcatCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ConcatCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ConcatCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.ModuloCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ModuloCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ModuloCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.PowerCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.PowerCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.PowerCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.FloorDivideCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.FloorDivideCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.FloorDivideCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.DivideCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.DivideCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.DivideCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.MultiplyCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.MultiplyCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.MultiplyCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.MinusCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.MinusCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.MinusCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.PlusCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.PlusCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.PlusCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.EqualsCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EqualsCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.EqualsCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.PipeCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.PipeCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.PipeCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.ColonCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ColonCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.ColonCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.DotCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.DotCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.DotCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.CommaCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CommaCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CommaCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.CloseBraceCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CloseBraceCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CloseBraceCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.OpenBraceCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OpenBraceCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OpenBraceCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.CloseBracketCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CloseBracketCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CloseBracketCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.OpenBracketCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OpenBracketCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OpenBracketCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.CloseParenCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CloseParenCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CloseParenCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.OpenParenCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OpenParenCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OpenParenCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.IdentifierCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.IdentifierCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.IdentifierCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.NullCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.NullCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.NullCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.BooleanCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.BooleanCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.BooleanCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.NumberCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.NumberCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.NumberCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.StringCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.StringCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.StringCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.CloseStatementCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CloseStatementCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CloseStatementCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.OpenStatementCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OpenStatementCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OpenStatementCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.CloseExpressionCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CloseExpressionCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CloseExpressionCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.OpenExpressionCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OpenExpressionCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.OpenExpressionCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.TextCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.TextCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.TextCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.Kind.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.Kind.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Token.Kind.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Token.Kind.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Token.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Token.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Jinja.Token.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Jinja.Token.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Token.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Token.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Jinja.Value: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Jinja.Value: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Jinja.Value: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Jinja.Value: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Jinja.Value: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Jinja.Value: Swift.ExpressibleByNilLiteral {
    init(nilLiteral: ())
}
extension Jinja.Value: Swift.ExpressibleByBooleanLiteral {
    typealias BooleanLiteralType = Swift.Bool

    init(booleanLiteral: Self.BooleanLiteralType)
}
extension Jinja.Value: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int

    init(integerLiteral: Self.IntegerLiteralType)
}
extension Jinja.Value: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Double

    init(floatLiteral: Self.FloatLiteralType)
}
extension Jinja.Value: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension Jinja.Value: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension Jinja.Value: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension Jinja.Value: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Jinja.Value

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension Jinja.Value: Swift.ExpressibleByDictionaryLiteral {
    typealias Key = Swift.String
    typealias Value = Jinja.Value

    init(dictionaryLiteral: (Self.Key, Self.Value)...)
}
extension OrderedCollections._HashTable.Bucket: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OrderedCollections._HashTable.Bucket: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections._HashTable.Header: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections._HashTable.UnsafeHandle: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections._HashTable: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections._HashTable.Storage: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections._HashTable.BucketIterator: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedDictionary: Swift.Encodable where A: Swift.Encodable, B: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension OrderedCollections.OrderedDictionary: Swift.Decodable where A: Swift.Decodable, B: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension OrderedCollections.OrderedDictionary: Swift.CustomReflectable {
    var customMirror: Swift.Mirror {
        get
    }
}
extension OrderedCollections.OrderedDictionary: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedDictionary: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedDictionary: Swift.Equatable where B: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OrderedCollections.OrderedDictionary: Swift.ExpressibleByDictionaryLiteral {
    typealias Key = A
    typealias Value = B

    init(dictionaryLiteral: (Self.Key, Self.Value)...)
}
extension OrderedCollections.OrderedDictionary: Swift.Hashable where B: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OrderedCollections.OrderedDictionary: Swift.Sequence {
    typealias Element = (key: A, value: B)
    typealias Iterator = OrderedCollections.OrderedDictionary<A, B>.Iterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension OrderedCollections.OrderedDictionary.Elements.SubSequence: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedDictionary.Elements.SubSequence: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedDictionary.Elements.SubSequence: Swift.Sequence {
    typealias Element = (key: A, value: B)
    typealias Iterator = OrderedCollections.OrderedDictionary<A, B>.Elements.SubSequence.Iterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension OrderedCollections.OrderedDictionary.Elements.SubSequence: Swift.RandomAccessCollection {
    typealias Element = (key: A, value: B)
    typealias Index = Swift.Int
    typealias SubSequence = OrderedCollections.OrderedDictionary<A, B>.Elements.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension OrderedCollections.OrderedDictionary.Elements.SubSequence: Swift.BidirectionalCollection {
    typealias Element = (key: A, value: B)
    typealias Index = Swift.Int
    typealias SubSequence = OrderedCollections.OrderedDictionary<A, B>.Elements.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension OrderedCollections.OrderedDictionary.Elements.SubSequence: Swift.Collection {
    typealias Element = (key: A, value: B)
    typealias Index = Swift.Int
    typealias Iterator = OrderedCollections.OrderedDictionary<A, B>.Elements.SubSequence.Iterator
    typealias SubSequence = OrderedCollections.OrderedDictionary<A, B>.Elements.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension OrderedCollections.OrderedDictionary.Elements.SubSequence.Iterator: Swift.IteratorProtocol {
    typealias Element = (key: A, value: B)

    func next() -> Self.Element?
}
extension OrderedCollections.OrderedDictionary.Elements: Swift.Sequence {
    typealias Element = (key: A, value: B)
    typealias Iterator = OrderedCollections.OrderedDictionary<A, B>.Iterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension OrderedCollections.OrderedDictionary.Elements: Swift.RandomAccessCollection {
    typealias Element = (key: A, value: B)
    typealias Index = Swift.Int
    typealias SubSequence = OrderedCollections.OrderedDictionary<A, B>.Elements.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension OrderedCollections.OrderedDictionary.Elements: Swift.BidirectionalCollection {
    typealias Element = (key: A, value: B)
    typealias Index = Swift.Int
    typealias SubSequence = OrderedCollections.OrderedDictionary<A, B>.Elements.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension OrderedCollections.OrderedDictionary.Elements: Swift.Collection {
    typealias Element = (key: A, value: B)
    typealias Index = Swift.Int
    typealias Iterator = OrderedCollections.OrderedDictionary<A, B>.Iterator
    typealias SubSequence = OrderedCollections.OrderedDictionary<A, B>.Elements.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension OrderedCollections.OrderedDictionary.Elements: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedDictionary.Elements: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedDictionary.Elements: Swift.CustomReflectable {
    var customMirror: Swift.Mirror {
        get
    }
}
extension OrderedCollections.OrderedDictionary.Elements: Swift.Equatable where B: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OrderedCollections.OrderedDictionary.Elements: Swift.Hashable where B: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OrderedCollections.OrderedDictionary.Iterator: Swift.IteratorProtocol {
    typealias Element = (key: A, value: B)

    func next() -> Self.Element?
}
extension OrderedCollections.OrderedDictionary.Values: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedDictionary.Values: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedDictionary.Values: Swift.Sequence {
    typealias Element = B
    typealias Iterator = Swift.IndexingIterator<OrderedCollections.OrderedDictionary<A, B>.Values>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension OrderedCollections.OrderedDictionary.Values: Swift.RandomAccessCollection {
    typealias Element = B
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<OrderedCollections.OrderedDictionary<A, B>.Values>
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension OrderedCollections.OrderedDictionary.Values: Swift.BidirectionalCollection {
    typealias Element = B
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<OrderedCollections.OrderedDictionary<A, B>.Values>
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension OrderedCollections.OrderedDictionary.Values: Swift.Collection {
    typealias Element = B
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<OrderedCollections.OrderedDictionary<A, B>.Values>
    typealias SubSequence = Swift.Slice<OrderedCollections.OrderedDictionary<A, B>.Values>
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension OrderedCollections.OrderedDictionary.Values: Swift.MutableCollection {
    typealias Element = B
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<OrderedCollections.OrderedDictionary<A, B>.Values>

    func partition(by: (_: Self.Element) throws -> Swift.Bool) throws -> Self.Index
    func swapAt(_: Self.Index, _: Self.Index)
    func _withUnsafeMutableBufferPointerIfSupported<A1>(_: (_: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> A1) throws -> A1?
    func withContiguousMutableStorageIfAvailable<A1>(_: (_: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension OrderedCollections.OrderedDictionary.Values: Swift.Equatable where B: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OrderedCollections.OrderedDictionary.Values: Swift.Hashable where B: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OrderedCollections.OrderedSet: Swift.Encodable where A: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension OrderedCollections.OrderedSet: Swift.Decodable where A: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension OrderedCollections.OrderedSet: Swift.CustomReflectable {
    var customMirror: Swift.Mirror {
        get
    }
}
extension OrderedCollections.OrderedSet: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedSet: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedSet: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OrderedCollections.OrderedSet: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = A

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension OrderedCollections.OrderedSet: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OrderedCollections.OrderedSet: Swift.Sequence {
    typealias Element = A
    typealias Iterator = Swift.IndexingIterator<OrderedCollections.OrderedSet<A>>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension OrderedCollections.OrderedSet: Swift.RandomAccessCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = OrderedCollections.OrderedSet<A>.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension OrderedCollections.OrderedSet: Swift.BidirectionalCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = OrderedCollections.OrderedSet<A>.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension OrderedCollections.OrderedSet: Swift.Collection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<OrderedCollections.OrderedSet<A>>
    typealias SubSequence = OrderedCollections.OrderedSet<A>.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension OrderedCollections.OrderedSet: InternalCollectionsUtilities._UniqueCollection {}
extension OrderedCollections.OrderedSet.SubSequence: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedSet.SubSequence: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedSet.SubSequence: Swift.Sequence {
    typealias Element = A
    typealias Iterator = Swift.IndexingIterator<OrderedCollections.OrderedSet<A>.SubSequence>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension OrderedCollections.OrderedSet.SubSequence: InternalCollectionsUtilities._UniqueCollection {}
extension OrderedCollections.OrderedSet.SubSequence: Swift.RandomAccessCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = OrderedCollections.OrderedSet<A>.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension OrderedCollections.OrderedSet.SubSequence: Swift.BidirectionalCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = OrderedCollections.OrderedSet<A>.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension OrderedCollections.OrderedSet.SubSequence: Swift.Collection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<OrderedCollections.OrderedSet<A>.SubSequence>
    typealias SubSequence = OrderedCollections.OrderedSet<A>.SubSequence
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension OrderedCollections.OrderedSet.SubSequence: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OrderedCollections.OrderedSet.SubSequence: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OrderedCollections.OrderedSet.UnorderedView: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedSet.UnorderedView: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OrderedCollections.OrderedSet.UnorderedView: Swift.CustomReflectable {
    var customMirror: Swift.Mirror {
        get
    }
}
extension OrderedCollections.OrderedSet.UnorderedView: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OrderedCollections.OrderedSet.UnorderedView: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OrderedCollections.OrderedSet.UnorderedView: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = A

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension OrderedCollections.OrderedSet.UnorderedView: Swift.SetAlgebra {
    typealias Element = A

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension InternalCollectionsUtilities._UnsafeBitSet.Index: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension InternalCollectionsUtilities._UnsafeBitSet.Index: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension InternalCollectionsUtilities._UnsafeBitSet.Index: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension InternalCollectionsUtilities._UnsafeBitSet._Word: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension InternalCollectionsUtilities._UnsafeBitSet._Word: Swift.Sequence {
    typealias Element = Swift.UInt
    typealias Iterator = InternalCollectionsUtilities._UnsafeBitSet._Word

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension InternalCollectionsUtilities._UnsafeBitSet._Word: Swift.IteratorProtocol {
    typealias Element = Swift.UInt

    func next() -> Self.Element?
}
extension InternalCollectionsUtilities._UnsafeBitSet._Word: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension InternalCollectionsUtilities._UnsafeBitSet._Word: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension InternalCollectionsUtilities._UnsafeBitSet.Iterator: Swift.IteratorProtocol {
    typealias Element = Swift.UInt

    func next() -> Self.Element?
}
extension InternalCollectionsUtilities._UnsafeBitSet: Swift.Sequence {
    typealias Element = Swift.UInt
    typealias Iterator = InternalCollectionsUtilities._UnsafeBitSet.Iterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension InternalCollectionsUtilities._UnsafeBitSet: Swift.BidirectionalCollection {
    typealias Element = Swift.UInt
    typealias Index = InternalCollectionsUtilities._UnsafeBitSet.Index
    typealias SubSequence = Swift.Slice<InternalCollectionsUtilities._UnsafeBitSet>
    typealias Indices = Swift.DefaultIndices<InternalCollectionsUtilities._UnsafeBitSet>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension InternalCollectionsUtilities._UnsafeBitSet: Swift.Collection {
    typealias Element = Swift.UInt
    typealias Index = InternalCollectionsUtilities._UnsafeBitSet.Index
    typealias Iterator = InternalCollectionsUtilities._UnsafeBitSet.Iterator
    typealias SubSequence = Swift.Slice<InternalCollectionsUtilities._UnsafeBitSet>
    typealias Indices = Swift.DefaultIndices<InternalCollectionsUtilities._UnsafeBitSet>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension Swift.Slice: InternalCollectionsUtilities._SortedCollection where A: InternalCollectionsUtilities._SortedCollection {}
extension Swift.Slice: InternalCollectionsUtilities._UniqueCollection where A: InternalCollectionsUtilities._UniqueCollection {}
extension Swift.Set: InternalCollectionsUtilities._UniqueCollection {}
extension Swift.Dictionary.Keys: InternalCollectionsUtilities._UniqueCollection {}
extension LocalLLMClientCore.AnyLLMClient: LocalLLMClientCore.LLMClient {
    typealias TextGenerator = Swift.AsyncThrowingStream<Swift.String, Swift.Error>
    typealias ResponseGenerator = Swift.AsyncThrowingStream<LocalLLMClientCore.StreamingChunk, Swift.Error>
    typealias ResumeGenerator = Swift.AsyncThrowingStream<LocalLLMClientCore.StreamingChunk, Swift.Error>
}
extension LocalLLMClientCore.LLMError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension LocalLLMClientCore.LLMError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension LocalLLMClientCore.LLMInput: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension LocalLLMClientCore.LLMInput: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension LocalLLMClientCore.LLMInput: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension LocalLLMClientCore.LLMAttachment.Content: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientCore.LLMAttachment.Content: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientCore.LLMAttachment: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientCore.LLMAttachment: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientCore.LLMAttachment: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension LocalLLMClientCore.LLMInput.Message.Role: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientCore.LLMInput.Message.Role: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientCore.LLMInput.Message: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientCore.LLMInput.Message: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientCore.LLMInput.Message: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension LocalLLMClientCore.LLMSession.ToolCallError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension LocalLLMClientCore.LLMSession.SystemModel: LocalLLMClientCore.LLMSession.Model {}
extension LocalLLMClientCore.LLMSession.DownloadModel: LocalLLMClientCore.LLMSession.Model {}
extension LocalLLMClientCore.LLMSession.LocalModel: LocalLLMClientCore.LLMSession.Model {}
extension LocalLLMClientCore.LLMSession: Observation.Observable {}
extension LocalLLMClientCore.LLMSession.Generator: Observation.Observable {}
extension LocalLLMClientCore.PauseHandler: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension LocalLLMClientCore.ToolError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension LocalLLMClientCore.ToolError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension LocalLLMClientCore.AnyLLMTool: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientCore.AnyLLMTool: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientCore.LLMToolCall: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientCore.LLMToolCall: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension LocalLLMClientCore.LLMToolCall: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension LocalLLMClientCore.StreamingToolCallProcessor.State: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension LocalLLMClientCore.StreamingToolCallProcessor.State: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Foundation.Data: LocalLLMClientCore.DefaultFormattedType {}
extension Foundation.Data: LocalLLMClientCore.ToolArgumentType {}
extension Foundation.Data: SwiftProtobuf.SwiftProtobufContiguousBytes {}
extension Foundation.Data: GRDB.DatabaseValueConvertible {}
extension Foundation.Data: GRDB.StatementColumnConvertible {}
extension Foundation.Data: GRDB.SQLExpressible {}
extension Foundation.Data: GRDB.StatementBinding {}
extension Foundation.URL: LocalLLMClientCore.DefaultFormattedType {}
extension Foundation.URL: LocalLLMClientCore.ToolArgumentType {}
extension Foundation.URL: GRDB.DatabaseValueConvertible {}
extension Foundation.URL: GRDB.SQLExpressible {}
extension Foundation.URL: GRDB.StatementBinding {}
extension LocalLLMClientCore.ToolArgument: LocalLLMClientCore.ToolArgumentConvertible {}
extension Swift.Int: LocalLLMClientCore.ToolArgumentType {}
extension Swift.Int: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic_long
}
extension Swift.Int: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.Int: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.Int: Atomics.AtomicInteger {}
extension Swift.Int: MLX.HasDType {}
extension Swift.Int: MLX.ScalarOrArray {}
extension Swift.Int: MLX.MLXArrayIndex {}
extension Swift.Int: MLX.KernelTemplateArg {}
extension Swift.Int: GRDB.DatabaseValueConvertible {}
extension Swift.Int: GRDB.StatementColumnConvertible {}
extension Swift.Int: GRDB.SQLExpressible {}
extension Swift.Int: GRDB.StatementBinding {}
extension Swift.Int32: LocalLLMClientCore.ToolArgumentType {}
extension Swift.Int32: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic_int_least32_t
}
extension Swift.Int32: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.Int32: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.Int32: Atomics.AtomicInteger {}
extension Swift.Int32: MLX.HasDType {}
extension Swift.Int32: MLX.ScalarOrArray {}
extension Swift.Int32: GRDB.DatabaseValueConvertible {}
extension Swift.Int32: GRDB.StatementColumnConvertible {}
extension Swift.Int32: GRDB.SQLExpressible {}
extension Swift.Int32: GRDB.StatementBinding {}
extension Swift.Int64: LocalLLMClientCore.ToolArgumentType {}
extension Swift.Int64: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic_long_long
}
extension Swift.Int64: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.Int64: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.Int64: Atomics.AtomicInteger {}
extension Swift.Int64: MLX.HasDType {}
extension Swift.Int64: MLX.ScalarOrArray {}
extension Swift.Int64: GRDB.DatabaseValueConvertible {}
extension Swift.Int64: GRDB.StatementColumnConvertible {}
extension Swift.Int64: GRDB.SQLExpressible {}
extension Swift.Int64: GRDB.StatementBinding {}
extension Swift.UInt: LocalLLMClientCore.ToolArgumentType {}
extension Swift.UInt: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic_unsigned_long
}
extension Swift.UInt: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.UInt: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.UInt: Atomics.AtomicInteger {}
extension Swift.UInt: MLX.HasDType {}
extension Swift.UInt: MLX.ScalarOrArray {}
extension Swift.UInt: GRDB.DatabaseValueConvertible {}
extension Swift.UInt: GRDB.StatementColumnConvertible {}
extension Swift.UInt: GRDB.SQLExpressible {}
extension Swift.UInt: GRDB.StatementBinding {}
extension Swift.UInt32: LocalLLMClientCore.ToolArgumentType {}
extension Swift.UInt32: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic_uint_least32_t
}
extension Swift.UInt32: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.UInt32: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.UInt32: Atomics.AtomicInteger {}
extension Swift.UInt32: CryptoSwift._UInt32Type {}
extension Swift.UInt32: MLX.HasDType {}
extension Swift.UInt32: MLX.ScalarOrArray {}
extension Swift.UInt32: GRDB.DatabaseValueConvertible {}
extension Swift.UInt32: GRDB.StatementColumnConvertible {}
extension Swift.UInt32: GRDB.SQLExpressible {}
extension Swift.UInt32: GRDB.StatementBinding {}
extension Swift.UInt64: LocalLLMClientCore.ToolArgumentType {}
extension Swift.UInt64: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic_unsigned_long_long
}
extension Swift.UInt64: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.UInt64: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.UInt64: Atomics.AtomicInteger {}
extension Swift.UInt64: MLX.HasDType {}
extension Swift.UInt64: MLX.ScalarOrArray {}
extension Swift.UInt64: GRDB.DatabaseValueConvertible {}
extension Swift.UInt64: GRDB.StatementColumnConvertible {}
extension Swift.UInt64: GRDB.SQLExpressible {}
extension Swift.UInt64: GRDB.StatementBinding {}
extension Swift.Double: LocalLLMClientCore.ToolArgumentType {}
extension Swift.Double: ForceSimulation.HasDeterministicRandomGenerator {
    typealias Generator = ForceSimulation.DoubleLinearCongruentialGenerator
}
extension Swift.Double: MLX.HasDType {}
extension Swift.Double: MLX.ScalarOrArray {}
extension Swift.Double: RealModule.Real {}
extension Swift.Double: RealModule.RealFunctions {}
extension Swift.Double: RealModule.AlgebraicField {}
extension Swift.Double: RealModule.ElementaryFunctions {}
extension Swift.Double: GRDB.DatabaseValueConvertible {}
extension Swift.Double: GRDB.StatementColumnConvertible {}
extension Swift.Double: GRDB.SQLExpressible {}
extension Swift.Double: GRDB.StatementBinding {}
extension Swift.Float: LocalLLMClientCore.ToolArgumentType {}
extension Swift.Float: ForceSimulation.HasDeterministicRandomGenerator {
    typealias Generator = ForceSimulation.FloatLinearCongruentialGenerator
}
extension Swift.Float: MLX.HasDType {}
extension Swift.Float: MLX.ScalarOrArray {}
extension Swift.Float: RealModule.Real {}
extension Swift.Float: RealModule.RealFunctions {}
extension Swift.Float: RealModule.AlgebraicField {}
extension Swift.Float: RealModule.ElementaryFunctions {}
extension Swift.Float: GRDB.DatabaseValueConvertible {}
extension Swift.Float: GRDB.StatementColumnConvertible {}
extension Swift.Float: GRDB.SQLExpressible {}
extension Swift.Float: GRDB.StatementBinding {}
extension Swift.Bool: LocalLLMClientCore.ToolArgumentType {}
extension Swift.Bool: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic__Bool
}
extension Swift.Bool: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.Bool: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.Bool: MLX.HasDType {}
extension Swift.Bool: MLX.ScalarOrArray {}
extension Swift.Bool: MLX.KernelTemplateArg {}
extension Swift.Bool: GRDB.DatabaseValueConvertible {}
extension Swift.Bool: GRDB.StatementColumnConvertible {}
extension Swift.Bool: GRDB.SQLExpressible {}
extension Swift.Bool: GRDB.StatementBinding {}
extension Swift.Optional: LocalLLMClientCore.ToolArgumentType where A: LocalLLMClientCore.ToolArgumentType {}
extension Swift.Optional: Atomics.AtomicValue where A: Atomics.AtomicOptionalWrappable, A == A.AtomicValue.AtomicRepresentation.AtomicStorage.Value {
    typealias AtomicRepresentation = A.AtomicOptionalWrappable.AtomicOptionalRepresentation
}
extension Swift.Optional: Swift.CustomStringConvertible where A == Swift.UnsafeMutablePointer<__C.pb_bytes_array_s> {
    var description: Swift.String {
        get
    }
}
extension Swift.Optional: GRDB.StatementBinding where A: GRDB.StatementBinding {}
extension Swift.Optional: GRDB.SQLExpressible where A: GRDB.SQLExpressible {}
extension Swift.Optional: GRDB.SQLOrderingTerm where A: GRDB.SQLOrderingTerm {}
extension Swift.Optional: GRDB.SQLSelectable where A: GRDB.SQLSelectable {}
extension Swift.Optional: GRDB.SQLSpecificExpressible where A: GRDB.SQLSpecificExpressible {}
extension Swift.Optional: GRDB.DatabaseValueConvertible where A: GRDB.DatabaseValueConvertible {}
extension Swift.Optional: GRDB.StatementColumnConvertible where A: GRDB.StatementColumnConvertible {}
extension Swift.Array: LocalLLMClientCore.ToolArgumentType where A: LocalLLMClientCore.ToolArgumentType {}
extension Swift.Array: MLX.ScalarOrArray where A: MLX.HasDType {}
extension Swift.Array: MLX.Updatable where A == MLX.MLXArray {}
extension Swift.Array: MLX.Evaluatable where A == MLX.MLXArray {}
extension Swift.Array: SwiftProtobuf.SwiftProtobufContiguousBytes where A == Swift.UInt8 {}
extension LocalLLMClientCore.ToolExecutor: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension LocalLLMClientCore.ToolExecutionError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension LocalLLMClientCore.ToolExecutionError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension LocalLLMClientCore.LLMToolArgumentType.ArrayWithFormatToolArgument: LocalLLMClientCore.ToolArgumentConvertible {}
extension LocalLLMClientCore.LLMToolArgumentType.NestedArrayToolArgument: LocalLLMClientCore.ToolArgumentConvertible {}
extension LocalLLMClientCore.LLMToolArgumentType.ArrayOfObjectsToolArgument: LocalLLMClientCore.ToolArgumentConvertible {}
extension LocalLLMClientCore.LLMToolArgumentType.ArrayOfEnumsToolArgument: LocalLLMClientCore.ToolArgumentConvertible {}
extension LocalLLMClientCore.LLMToolArgumentType.ArrayOfOptionalsToolArgument: LocalLLMClientCore.ToolArgumentConvertible {}
extension LocalLLMClientCore.LLMToolArgumentType.ObjectToolArgument: LocalLLMClientCore.ToolArgumentConvertible {}
extension LocalLLMClientCore.LLMToolArgumentType.OptionalToolArgument: LocalLLMClientCore.ToolArgumentConvertible {}
extension ForceSimulation.Kinetics.LinkForce: ForceSimulation.Force2D where A == Swift.SIMD2<Swift.Double> {}
extension ForceSimulation.Kinetics.LinkForce: ForceSimulation.Force3D where A == Swift.SIMD3<Swift.Float> {}
extension ForceSimulation.Kinetics.LinkForce: ForceSimulation.ForceProtocol {
    typealias Vector = A
}
extension ForceSimulation.Kinetics.ManyBodyForce: ForceSimulation.Force2D where A == Swift.SIMD2<Swift.Double> {}
extension ForceSimulation.Kinetics.ManyBodyForce: ForceSimulation.Force3D where A == Swift.SIMD3<Swift.Float> {}
extension ForceSimulation.Kinetics.ManyBodyForce: ForceSimulation.ForceProtocol {
    typealias Vector = A
}
extension ForceSimulation.Kinetics.CenterForce: ForceSimulation.Force2D where A == Swift.SIMD2<Swift.Double> {}
extension ForceSimulation.Kinetics.CenterForce: ForceSimulation.Force3D where A == Swift.SIMD3<Swift.Float> {}
extension ForceSimulation.Kinetics.CenterForce: ForceSimulation.ForceProtocol {
    typealias Vector = A
}
extension ForceSimulation.Kinetics.CollideForce: ForceSimulation.Force2D where A == Swift.SIMD2<Swift.Double> {}
extension ForceSimulation.Kinetics.CollideForce: ForceSimulation.Force3D where A == Swift.SIMD3<Swift.Float> {}
extension ForceSimulation.Kinetics.CollideForce: ForceSimulation.ForceProtocol {
    typealias Vector = A
}
extension ForceSimulation.Kinetics.PositionForce: ForceSimulation.Force2D where A == Swift.SIMD2<Swift.Double> {}
extension ForceSimulation.Kinetics.PositionForce: ForceSimulation.Force3D where A == Swift.SIMD3<Swift.Float> {}
extension ForceSimulation.Kinetics.PositionForce: ForceSimulation.ForceProtocol {
    typealias Vector = A
}
extension ForceSimulation.Kinetics.RadialForce: ForceSimulation.Force2D where A == Swift.SIMD2<Swift.Double> {}
extension ForceSimulation.Kinetics.RadialForce: ForceSimulation.Force3D where A == Swift.SIMD3<Swift.Float> {}
extension ForceSimulation.Kinetics.RadialForce: ForceSimulation.ForceProtocol {
    typealias Vector = A
}
extension ForceSimulation.Kinetics.EmptyForce: ForceSimulation.Force2D where A == Swift.SIMD2<Swift.Double> {}
extension ForceSimulation.Kinetics.EmptyForce: ForceSimulation.Force3D where A == Swift.SIMD3<Swift.Float> {}
extension ForceSimulation.Kinetics.EmptyForce: ForceSimulation.ForceProtocol {
    typealias Vector = A
}
extension ForceSimulation.CompositedForce: ForceSimulation.Force2D where A == Swift.SIMD2<Swift.Double>, B.ForceProtocol.Vector == Swift.SIMD2<Swift.Double>, C.ForceProtocol.Vector == Swift.SIMD2<Swift.Double> {}
extension ForceSimulation.CompositedForce: ForceSimulation.Force3D where A == Swift.SIMD3<Swift.Float>, B.ForceProtocol.Vector == Swift.SIMD3<Swift.Float>, C.ForceProtocol.Vector == Swift.SIMD3<Swift.Float> {}
extension ForceSimulation.CompositedForce: ForceSimulation.ForceProtocol {
    typealias Vector = A
}
extension ForceSimulation.MaxRadiusNDTreeDelegate: ForceSimulation.KDTreeDelegate {
    typealias NodeID = Swift.Int
    typealias Vector = A
}
extension ForceSimulation.Kinetics.LinkStiffness: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension ForceSimulation.Kinetics.LinkLength: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension ForceSimulation.MassCentroidKDTreeDelegate: ForceSimulation.KDTreeDelegate {
    typealias NodeID = Swift.Int
    typealias Vector = A
}
extension ForceSimulation.Kinetics.DirectionOfPositionForce: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension ForceSimulation.SealedForce2D: ForceSimulation.Force2D {}
extension ForceSimulation.SealedForce2D: ForceSimulation.ForceProtocol {
    typealias Vector = Swift.SIMD2<Swift.Double>
}
extension ForceSimulation.SealedForce3D: ForceSimulation.Force3D {}
extension ForceSimulation.SealedForce3D: ForceSimulation.ForceProtocol {
    typealias Vector = Swift.SIMD3<Swift.Float>
}
extension ForceSimulation.BufferedKDTree: ForceSimulation.Disposable {}
extension ForceSimulation.KDBox: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension ForceSimulation.KDTreeNode.NodeIndex: ForceSimulation.Disposable {}
extension ForceSimulation.AttributeDescriptor: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension ForceSimulation.EdgeID: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension ForceSimulation.EdgeID: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension ForceSimulation.DoubleLinearCongruentialGenerator: ForceSimulation.DeterministicRandomGenerator {
    typealias Scalar = Swift.Double
    typealias OverflowingInteger = Swift.UInt32
}
extension ForceSimulation.FloatLinearCongruentialGenerator: ForceSimulation.DeterministicRandomGenerator {
    typealias Scalar = Swift.Float
    typealias OverflowingInteger = Swift.UInt16
}
extension Swift.SIMD2: ForceSimulation.SimulatableVector where A: ForceSimulation.HasDeterministicRandomGenerator {}
extension Swift.SIMD2: ForceSimulation.L2NormCalculatable where A == Swift.Double {}
extension Swift.SIMD3: ForceSimulation.SimulatableVector where A: ForceSimulation.HasDeterministicRandomGenerator {}
extension Swift.SIMD3: ForceSimulation.L2NormCalculatable where A == Swift.Float {}
extension VecturaKit.FileStorageProvider: VecturaKit.VecturaStorage {}
extension VecturaKit.VecturaDocument: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension VecturaKit.VecturaDocument: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension VecturaKit.VecturaDocument: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension VecturaKit.VecturaDocument.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension VecturaKit.VecturaDocument.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension VecturaKit.VecturaDocument.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension VecturaKit.VecturaDocument.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension VecturaKit.VecturaDocument.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension VecturaKit.VecturaDocument.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension VecturaKit.VecturaError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension VecturaKit.VecturaError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension VecturaKit.VecturaKit: VecturaKit.VecturaProtocol {}
extension VecturaKit.VecturaModelSource: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension VecturaKit.VecturaSearchResult: Swift.Identifiable {
    typealias ID = Foundation.UUID

    var id: Self.ID {
        get
    }
}
extension Embeddings.Bert.ModelConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Embeddings.Bert.ModelConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Embeddings.Bert.ModelConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Embeddings.Bert.ModelConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Embeddings.Bert.ModelConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Embeddings.Bert.ModelConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Embeddings.Bert.ModelConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Embeddings.Clip.TextConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Embeddings.Clip.TextConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Embeddings.Clip.VisionConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Embeddings.Clip.VisionConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Embeddings.Clip.ModelConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Embeddings.Clip.ModelConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Embeddings.Clip.TextConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Embeddings.Clip.TextConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Embeddings.Clip.TextConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Embeddings.Clip.TextConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Embeddings.Clip.TextConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Embeddings.Clip.VisionConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Embeddings.Clip.VisionConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Embeddings.Clip.VisionConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Embeddings.Clip.VisionConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Embeddings.Clip.VisionConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Embeddings.Clip.ModelConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Embeddings.Clip.ModelConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Embeddings.Clip.ModelConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Embeddings.Clip.ModelConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Embeddings.Clip.ModelConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Embeddings.EmbeddingsError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Embeddings.EmbeddingsError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Embeddings.EmbeddingsError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Embeddings.Model2Vec.ModelConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Embeddings.Model2Vec.ModelConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Embeddings.Model2Vec.ModelConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Embeddings.Model2Vec.ModelConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Embeddings.Model2Vec.ModelConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Embeddings.Model2Vec.ModelConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Embeddings.Model2Vec.ModelConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Embeddings.Roberta.ModelConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Embeddings.Roberta.ModelConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Embeddings.Roberta.ModelConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Embeddings.Roberta.ModelConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Embeddings.Roberta.ModelConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Embeddings.Roberta.ModelConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Embeddings.Roberta.ModelConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Embeddings.Pair: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Embeddings.Pair: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Embeddings.ClipTokenizer: Embeddings.TextTokenizer {}
extension Embeddings.TokenizerWrapper: Embeddings.TextTokenizer {}
extension Embeddings.XLMRobetaTokenizer: Embeddings.TextTokenizer {}
extension Embeddings.XLMRoberta.ModelConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Embeddings.XLMRoberta.ModelConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Embeddings.XLMRoberta.ModelConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Embeddings.XLMRoberta.ModelConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Embeddings.XLMRoberta.ModelConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Embeddings.XLMRoberta.ModelConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Embeddings.XLMRoberta.ModelConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLTensorUtils.GELUApproximation: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLTensorUtils.GELUApproximation: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.MLMultiArray: Safetensors.SafetensorsEncodable {}
extension CoreML.MLShapedArray: Safetensors.SafetensorsEncodable {}
extension Safetensors.HeaderElement: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Safetensors.HeaderElement: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Safetensors.OffsetRange: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Safetensors.OffsetRange: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Safetensors.OffsetRange: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Safetensors.ParsedSafetensorsIndexData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Safetensors.ParsedSafetensorsIndexData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Safetensors.ParsedSafetensorsIndexData.Metadata: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Safetensors.ParsedSafetensorsIndexData.Metadata: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Safetensors.ParsedSafetensorsIndexData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Safetensors.ParsedSafetensorsIndexData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Safetensors.ParsedSafetensorsIndexData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Safetensors.ParsedSafetensorsIndexData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Safetensors.ParsedSafetensorsIndexData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Safetensors.ParsedSafetensorsIndexData.Metadata.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Safetensors.ParsedSafetensorsIndexData.Metadata.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Safetensors.ParsedSafetensorsIndexData.Metadata.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Safetensors.ParsedSafetensorsIndexData.Metadata.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Safetensors.ParsedSafetensorsIndexData.Metadata.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Safetensors.Safetensors.Error: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Safetensors.TensorData: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Safetensors.TensorData: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Safetensors.TensorData.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Safetensors.TensorData.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Safetensors.TensorData.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Safetensors.TensorData.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Safetensors.TensorData.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Tokenizers.BytePair: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Tokenizers.BytePair: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Tokenizers.BPETokenizer: Tokenizers.TokenizingModel {}
extension Tokenizers.BPETokenizer: Tokenizers.PreTrainedTokenizerModel {}
extension Tokenizers.BertTokenizer: Tokenizers.PreTrainedTokenizerModel {}
extension Tokenizers.BertTokenizer: Tokenizers.TokenizingModel {}
extension Tokenizers.MetaspaceDecoder: Tokenizers.Decoder {}
extension Tokenizers.StripDecoder: Tokenizers.Decoder {}
extension Tokenizers.FuseDecoder: Tokenizers.Decoder {}
extension Tokenizers.ByteFallbackDecoder: Tokenizers.Decoder {}
extension Tokenizers.ReplaceDecoder: Tokenizers.Decoder {}
extension Tokenizers.ByteLevelDecoder: Tokenizers.Decoder {}
extension Tokenizers.DecoderSequence: Tokenizers.Decoder {}
extension Tokenizers.WordPieceDecoder: Tokenizers.Decoder {}
extension Tokenizers.StripNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.StripAccentsNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.PrecompiledNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.BertNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.NFKCNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.NFKDNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.NFCNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.NFDNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.LowercaseNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.ReplaceNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.PrependNormalizer: Tokenizers.Normalizer {}
extension Tokenizers.NormalizerSequence: Tokenizers.Normalizer {}
extension Tokenizers.SequenceProcessing: Tokenizers.PostProcessor {}
extension Tokenizers.BertProcessing: Tokenizers.PostProcessor {}
extension Tokenizers.RobertaProcessing: Tokenizers.PostProcessor {}
extension Tokenizers.ByteLevelPostProcessor: Tokenizers.PostProcessor {}
extension Tokenizers.TemplateProcessing: Tokenizers.PostProcessor {}
extension Tokenizers.PreTokenizerOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Tokenizers.PreTokenizerOption: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Tokenizers.PreTokenizerOption: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Tokenizers.MetaspacePreTokenizer.PrependScheme: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Tokenizers.MetaspacePreTokenizer.PrependScheme: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Tokenizers.MetaspacePreTokenizer.PrependScheme: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Tokenizers.SplitPreTokenizer: Tokenizers.PreTokenizer {}
extension Tokenizers.DigitsPreTokenizer: Tokenizers.PreTokenizer {}
extension Tokenizers.PunctuationPreTokenizer: Tokenizers.PreTokenizer {}
extension Tokenizers.ByteLevelPreTokenizer: Tokenizers.PreTokenizer {}
extension Tokenizers.MetaspacePreTokenizer: Tokenizers.PreTokenizer {}
extension Tokenizers.WhitespacePreTokenizer: Tokenizers.PreTokenizer {}
extension Tokenizers.PreTokenizerSequence: Tokenizers.PreTokenizer {}
extension Tokenizers.BertPreTokenizer: Tokenizers.PreTokenizer {}
extension Tokenizers.TokenLatticeNode: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Tokenizers.TokenizerError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Tokenizers.TokenizerError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Tokenizers.PreTrainedTokenizer: Tokenizers.Tokenizer {}
extension Tokenizers.LeavesWithCommonPrefixIterator: Swift.IteratorProtocol {
    typealias Element = [A]

    func next() -> Self.Element?
}
extension Tokenizers.LeavesWithCommonPrefixIterator: Swift.Sequence {
    typealias Element = [A]
    typealias Iterator = Tokenizers.LeavesWithCommonPrefixIterator<A>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension Tokenizers.UnigramTokenizer: Tokenizers.TokenizingModel {}
extension Tokenizers.UnigramTokenizer: Tokenizers.PreTrainedTokenizerModel {}
extension Generation.GenerationMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Generation.GenerationMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Generation.GenerationConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Generation.GenerationConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Generation.GenerationConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Generation.GenerationConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Generation.GenerationConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Generation.GenerationConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension Models.LanguageModel: Models.TextGenerationModel {}
extension Models.LanguageModel: Generation.Generation {}
extension Models.LanguageModel: Models.LanguageModelProtocol {}
extension Models.TokenizerError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Models.TokenizerError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Models.TokenizerError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Models.TokenizerError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension __C.MLModelMetadataKey: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.MLModelMetadataKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.MLModelMetadataKey: Swift._SwiftNewtypeWrapper {}
extension __C.MLModelMetadataKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.MLModelMetadataKey: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.MLModelMetadataKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Models.LanguageModelWithStatefulKVCache.Mode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Models.LanguageModelWithStatefulKVCache.Mode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Models.Weights.WeightsError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Models.Weights.WeightsError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Models.Safetensor.Header.Offset: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Models.Safetensor.Header.Offset.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Models.Safetensor.Header.Offset.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Models.Safetensor.Header.Offset.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Models.Safetensor.Header.Offset.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Models.Safetensor.Header.Offset.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension __C.ProgressUserInfoKey: Swift._HasCustomAnyHashableRepresentation {
    func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension __C.ProgressUserInfoKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.ProgressUserInfoKey: Swift._SwiftNewtypeWrapper {}
extension __C.ProgressUserInfoKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.ProgressUserInfoKey: Swift._ObjectiveCBridgeable {
    typealias _ObjectiveCType = __C.NSString

    func _bridgeToObjectiveC() -> Self._ObjectiveCType

    static func _forceBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?)
    static func _conditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType, result: inout Self?) -> Swift.Bool
    static func _unconditionallyBridgeFromObjectiveC(_: Self._ObjectiveCType?) -> Self
}
extension __C.ProgressUserInfoKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hub.BinaryDistinctString: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Hub.BinaryDistinctString: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hub.BinaryDistinctString: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension Hub.BinaryDistinctString: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Hub.BinaryDistinctString: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension Hub.BinaryDistinctString: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension Hub.BinaryDistinctString: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension Hub.BinaryDistinctString: Swift.Sequence {
    typealias Element = Hub.BinaryDistinctCharacter
    typealias Iterator = Swift.AnyIterator<Hub.BinaryDistinctCharacter>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension Hub.BinaryDistinctString: Hub.StringConvertible {}
extension __C.NSString: Hub.StringConvertible {}
extension __C.NSString: GRDB.DatabaseValueConvertible {}
extension __C.NSString: GRDB.SQLExpressible {}
extension __C.NSString: GRDB.StatementBinding {}
extension Hub.BinaryDistinctCharacter: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Hub.BinaryDistinctCharacter: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hub.BinaryDistinctCharacter: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Hub.BinaryDistinctCharacter: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension Hub.BinaryDistinctCharacter: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension Hub.BinaryDistinctCharacter: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension Hub.Config: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hub.Config: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension Hub.Config: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int

    init(integerLiteral: Self.IntegerLiteralType)
}
extension Hub.Config: Swift.ExpressibleByBooleanLiteral {
    typealias BooleanLiteralType = Swift.Bool

    init(booleanLiteral: Self.BooleanLiteralType)
}
extension Hub.Config: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Float

    init(floatLiteral: Self.FloatLiteralType)
}
extension Hub.Config: Swift.ExpressibleByDictionaryLiteral {
    typealias Key = Hub.BinaryDistinctString
    typealias Value = Hub.Config

    init(dictionaryLiteral: (Self.Key, Self.Value)...)
}
extension Hub.Config: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Hub.Config

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension Hub.Config: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension Hub.Config: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Hub.Config: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension Hub.Config: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Hub.Config: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Hub.Config: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Hub.Config.Data: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hub.Config.Data: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Hub.ConfigError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Hub.Config.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Hub.Config.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Hub.Config.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Hub.TaskActor: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Hub.SessionActor: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Hub.Broadcaster: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Hub.DownloadResumeState: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension Hub.Downloader: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Hub.Downloader.DownloadError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hub.Downloader.DownloadError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Hub.Downloader.DownloadError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Hub.Hub.HubClientError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Hub.Hub.HubClientError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Hub.Hub.RepoType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Hub.Hub.RepoType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hub.Hub.RepoType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Hub.Hub.RepoType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Hub.Hub.RepoType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Hub.Hub.Repo: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Hub.Hub.Repo: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Hub.Hub.Repo.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Hub.Hub.Repo.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Hub.Hub.Repo.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hub.Hub.Repo.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Hub.Hub.Repo.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Hub.HubApi.Sibling: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Hub.HubApi.Sibling: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Hub.HubApi.SiblingsResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension Hub.HubApi.SiblingsResponse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension Hub.HubApi.EnvironmentError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension Hub.HubApi.EnvironmentError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension Hub.HubApi.Sibling.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Hub.HubApi.Sibling.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Hub.HubApi.Sibling.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hub.HubApi.Sibling.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Hub.HubApi.Sibling.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Hub.HubApi.SiblingsResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Hub.HubApi.SiblingsResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Hub.HubApi.SiblingsResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Hub.HubApi.SiblingsResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Hub.HubApi.SiblingsResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Hub.HubApi.NetworkStateActor: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension SentencepieceTokenizer.SentencepieceTokenizer.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SentencepieceTokenizer.SentencepieceTokenizer.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SentencepieceTokenizer.SentencepieceTokenizer.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension TinyHTTPServer.TinyHTTPServer.HTTPHandler: NIOCore.ChannelHandler {}
extension TinyHTTPServer.TinyHTTPServer.HTTPHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension TinyHTTPServer.TinyHTTPServer.HTTPHandler: NIOCore._ChannelInboundHandler {}
extension TinyHTTPServer.TinyHTTPServer.HTTPHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.ByteBuffer>
    typealias InboundOut = Swift.Never
}
extension Swift.Int8: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic_int_least8_t
}
extension Swift.Int8: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.Int8: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.Int8: Atomics.AtomicInteger {}
extension Swift.Int8: MLX.HasDType {}
extension Swift.Int8: MLX.ScalarOrArray {}
extension Swift.Int8: GRDB.DatabaseValueConvertible {}
extension Swift.Int8: GRDB.StatementColumnConvertible {}
extension Swift.Int8: GRDB.SQLExpressible {}
extension Swift.Int8: GRDB.StatementBinding {}
extension Swift.UInt8: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic_uint_least8_t
}
extension Swift.UInt8: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.UInt8: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.UInt8: Atomics.AtomicInteger {}
extension Swift.UInt8: CryptoSwift._UInt8Type {}
extension Swift.UInt8: MLX.HasDType {}
extension Swift.UInt8: MLX.ScalarOrArray {}
extension Swift.UInt8: GRDB.DatabaseValueConvertible {}
extension Swift.UInt8: GRDB.StatementColumnConvertible {}
extension Swift.UInt8: GRDB.SQLExpressible {}
extension Swift.UInt8: GRDB.StatementBinding {}
extension Swift.Int16: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic_int_least16_t
}
extension Swift.Int16: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.Int16: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.Int16: Atomics.AtomicInteger {}
extension Swift.Int16: MLX.HasDType {}
extension Swift.Int16: MLX.ScalarOrArray {}
extension Swift.Int16: GRDB.DatabaseValueConvertible {}
extension Swift.Int16: GRDB.StatementColumnConvertible {}
extension Swift.Int16: GRDB.SQLExpressible {}
extension Swift.Int16: GRDB.StatementBinding {}
extension Swift.UInt16: NIOConcurrencyHelpers.NIOAtomicPrimitive {
    typealias AtomicWrapper = __C.catmc_nio_atomic_uint_least16_t
}
extension Swift.UInt16: NIOConcurrencyHelpers.AtomicPrimitive {}
extension Swift.UInt16: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.UInt16: Atomics.AtomicInteger {}
extension Swift.UInt16: MLX.HasDType {}
extension Swift.UInt16: MLX.ScalarOrArray {}
extension Swift.UInt16: GRDB.DatabaseValueConvertible {}
extension Swift.UInt16: GRDB.StatementColumnConvertible {}
extension Swift.UInt16: GRDB.SQLExpressible {}
extension Swift.UInt16: GRDB.StatementBinding {}
extension _NIOBase64.Base64Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension _NIOBase64.Base64Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension _NIOBase64.Base64Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension _NIODataStructures.Heap: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension _NIODataStructures.Heap: Swift.Sequence {
    typealias Element = A
    typealias Iterator = _NIODataStructures.HeapIterator<A>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension _NIODataStructures.HeapIterator: Swift.IteratorProtocol {
    typealias Element = A

    func next() -> Self.Element?
}
extension _NIODataStructures.PriorityQueue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension _NIODataStructures.PriorityQueue: Swift.Sequence {
    typealias Element = A
    typealias Iterator = _NIODataStructures.PriorityQueue<A>.Iterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension _NIODataStructures.PriorityQueue: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension _NIODataStructures.PriorityQueue.Iterator: Swift.IteratorProtocol {
    typealias Element = A

    func next() -> Self.Element?
}
extension _NIODataStructures._TinyArray: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension _NIODataStructures._TinyArray: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension _NIODataStructures._TinyArray: Swift.RandomAccessCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<_NIODataStructures._TinyArray<A>>
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension _NIODataStructures._TinyArray: Swift.BidirectionalCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<_NIODataStructures._TinyArray<A>>
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension _NIODataStructures._TinyArray: Swift.Collection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias Iterator = _NIODataStructures._TinyArray<A>.Iterator
    typealias SubSequence = Swift.Slice<_NIODataStructures._TinyArray<A>>
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension _NIODataStructures._TinyArray: Swift.Sequence {
    typealias Element = A
    typealias Iterator = _NIODataStructures._TinyArray<A>.Iterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension _NIODataStructures._TinyArray.Iterator: Swift.IteratorProtocol {
    typealias Element = A

    func next() -> Self.Element?
}
extension _NIODataStructures._TinyArray.Storage: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension _NIODataStructures._TinyArray.Storage: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension _NIODataStructures._TinyArray.Storage: Swift.RandomAccessCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<_NIODataStructures._TinyArray<A>.Storage>
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension _NIODataStructures._TinyArray.Storage: Swift.BidirectionalCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<_NIODataStructures._TinyArray<A>.Storage>
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension _NIODataStructures._TinyArray.Storage: Swift.Collection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<_NIODataStructures._TinyArray<A>.Storage>
    typealias SubSequence = Swift.Slice<_NIODataStructures._TinyArray<A>.Storage>
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension _NIODataStructures._TinyArray.Storage: Swift.Sequence {
    typealias Element = A
    typealias Iterator = Swift.IndexingIterator<_NIODataStructures._TinyArray<A>.Storage>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension DequeModule.Deque: Swift.Encodable where A: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension DequeModule.Deque: Swift.Decodable where A: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension DequeModule.Deque: Swift.Sequence {
    typealias Element = A
    typealias Iterator = DequeModule.Deque<A>.Iterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension DequeModule.Deque: Swift.RandomAccessCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<DequeModule.Deque<A>>
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension DequeModule.Deque: Swift.BidirectionalCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<DequeModule.Deque<A>>
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension DequeModule.Deque: Swift.Collection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias Iterator = DequeModule.Deque<A>.Iterator
    typealias SubSequence = Swift.Slice<DequeModule.Deque<A>>
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension DequeModule.Deque: Swift.MutableCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<DequeModule.Deque<A>>

    func partition(by: (_: Self.Element) throws -> Swift.Bool) throws -> Self.Index
    func swapAt(_: Self.Index, _: Self.Index)
    func _withUnsafeMutableBufferPointerIfSupported<A1>(_: (_: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> A1) throws -> A1?
    func withContiguousMutableStorageIfAvailable<A1>(_: (_: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension DequeModule.Deque: Swift.RangeReplaceableCollection {
    typealias SubSequence = Swift.Slice<DequeModule.Deque<A>>

    init()
    init(repeating: Self.Element, count: Swift.Int)
    init<A1>(_: A1) where A1: Swift.Sequence, Self.Element == A1.Element

    func replaceSubrange<A1>(_: Swift.Range<Self.Index>, with: __owned A1) where A1: Swift.Collection, Self.Element == A1.Element
    func reserveCapacity(_: Swift.Int)
    func append(_: __owned Self.Element)
    func append<A1>(contentsOf: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element
    func insert(_: __owned Self.Element, at: Self.Index)
    func insert<A1>(contentsOf: __owned A1, at: Self.Index) where A1: Swift.Collection, Self.Element == A1.Element
    func remove(at: Self.Index) -> Self.Element
    func removeSubrange(_: Swift.Range<Self.Index>)
    func _customRemoveLast() -> Self.Element?
    func _customRemoveLast(_: Swift.Int) -> Swift.Bool
    func removeFirst() -> Self.Element
    func removeFirst(_: Swift.Int)
    func removeAll(keepingCapacity: Swift.Bool)
    func removeAll(where: (_: Self.Element) throws -> Swift.Bool) throws
}
extension DequeModule.Deque: Swift.CustomReflectable {
    var customMirror: Swift.Mirror {
        get
    }
}
extension DequeModule.Deque: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension DequeModule.Deque: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension DequeModule.Deque: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension DequeModule.Deque: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = A

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension DequeModule.Deque: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension DequeModule.Deque.Iterator: Swift.IteratorProtocol {
    typealias Element = A

    func next() -> Self.Element?
}
extension DequeModule.Deque._Storage: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension DequeModule._DequeBuffer: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension DequeModule._DequeBufferHeader: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension DequeModule._DequeSlot: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension DequeModule._DequeSlot: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension DequeModule._DequeSlot: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension Atomics.AtomicOptionalRawRepresentableStorage: Atomics.AtomicStorage {
    typealias Value = A?
}
extension Atomics.AtomicRawRepresentableStorage: Atomics.AtomicStorage {
    typealias Value = A
}
extension Swift.Bool.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.Bool
}
extension Swift.Int8.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.Int8
}
extension Swift.Int8.AtomicRepresentation: Atomics.AtomicIntegerStorage {}
extension Swift.Int16.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.Int16
}
extension Swift.Int16.AtomicRepresentation: Atomics.AtomicIntegerStorage {}
extension Swift.Int32.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.Int32
}
extension Swift.Int32.AtomicRepresentation: Atomics.AtomicIntegerStorage {}
extension Swift.Int64.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.Int64
}
extension Swift.Int64.AtomicRepresentation: Atomics.AtomicIntegerStorage {}
extension Swift.UInt8.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UInt8
}
extension Swift.UInt8.AtomicRepresentation: Atomics.AtomicIntegerStorage {}
extension Swift.UInt16.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UInt16
}
extension Swift.UInt16.AtomicRepresentation: Atomics.AtomicIntegerStorage {}
extension Swift.UInt32.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UInt32
}
extension Swift.UInt32.AtomicRepresentation: Atomics.AtomicIntegerStorage {}
extension Swift.UInt64.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UInt64
}
extension Swift.UInt64.AtomicRepresentation: Atomics.AtomicIntegerStorage {}
extension Swift.Int.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.Int
}
extension Swift.Int.AtomicRepresentation: Atomics.AtomicIntegerStorage {}
extension Swift.UInt.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UInt
}
extension Swift.UInt.AtomicRepresentation: Atomics.AtomicIntegerStorage {}
extension Atomics.DoubleWord: Atomics.AtomicValue {
    typealias AtomicRepresentation = Atomics.DoubleWord.AtomicRepresentation
}
extension Atomics.DoubleWord: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Atomics.DoubleWord: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Atomics.DoubleWord: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Atomics.DoubleWord.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Atomics.DoubleWord
}
extension Swift.UnsafeRawPointer: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.UnsafeRawPointer: Atomics.AtomicOptionalWrappable {
    typealias AtomicOptionalRepresentation = AtomicOptionalRepresentation
}
extension Swift.UnsafeRawPointer.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UnsafeRawPointer
}
extension Swift.UnsafeMutableRawPointer: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.UnsafeMutableRawPointer: Atomics.AtomicOptionalWrappable {
    typealias AtomicOptionalRepresentation = AtomicOptionalRepresentation
}
extension Swift.UnsafeMutableRawPointer.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UnsafeMutableRawPointer
}
extension Swift.UnsafePointer: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.UnsafePointer: Atomics.AtomicOptionalWrappable {
    typealias AtomicOptionalRepresentation = AtomicOptionalRepresentation
}
extension Swift.UnsafePointer.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UnsafePointer<A>
}
extension Swift.UnsafeMutablePointer: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.UnsafeMutablePointer: Atomics.AtomicOptionalWrappable {
    typealias AtomicOptionalRepresentation = AtomicOptionalRepresentation
}
extension Swift.UnsafeMutablePointer: Swift.CustomStringConvertible where A == __C.pb_bytes_array_s {
    var description: Swift.String {
        get
    }
}
extension Swift.UnsafeMutablePointer.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UnsafeMutablePointer<A>
}
extension Swift.Unmanaged: Atomics.AtomicValue {
    typealias AtomicRepresentation = AtomicRepresentation
}
extension Swift.Unmanaged: Atomics.AtomicOptionalWrappable {
    typealias AtomicOptionalRepresentation = AtomicOptionalRepresentation
}
extension Swift.Unmanaged<>.AtomicRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.Unmanaged<A>
}
extension Swift.UnsafeRawPointer.AtomicOptionalRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UnsafeRawPointer?
}
extension Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UnsafeMutableRawPointer?
}
extension Swift.UnsafePointer.AtomicOptionalRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UnsafePointer<A>?
}
extension Swift.UnsafeMutablePointer.AtomicOptionalRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.UnsafeMutablePointer<A>?
}
extension Swift.Unmanaged<>.AtomicOptionalRepresentation: Atomics.AtomicStorage {
    typealias Value = Swift.Unmanaged<A>?
}
extension Atomics.AtomicReferenceStorage: Atomics.AtomicStorage {
    typealias Value = A
}
extension Atomics.AtomicOptionalReferenceStorage: Atomics.AtomicStorage {
    typealias Value = A?
}
extension Atomics.AtomicLoadOrdering: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Atomics.AtomicLoadOrdering: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Atomics.AtomicLoadOrdering: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Atomics.AtomicStoreOrdering: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Atomics.AtomicStoreOrdering: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Atomics.AtomicStoreOrdering: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Atomics.AtomicUpdateOrdering: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Atomics.AtomicUpdateOrdering: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Atomics.AtomicUpdateOrdering: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.AddressedEnvelope.Metadata: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.AddressedEnvelope.Metadata: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.AddressedEnvelope: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.AddressedEnvelope: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.AddressedEnvelope: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOExplicitCongestionNotificationState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOExplicitCongestionNotificationState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOPacketInfo: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOPacketInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOTooManyBytesError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.NIOTooManyBytesError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOTooManyBytesError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.AsyncSequenceFromIterator: Swift.AsyncSequence {
    typealias AsyncIterator = A
    typealias Element = A.AsyncIteratorProtocol.Element
    typealias Failure = A.AsyncIteratorProtocol.Failure

    func makeAsyncIterator() -> Self.AsyncIterator
}
extension NIOCore.NIOAsyncChannelHandler._ProducingState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOAsyncChannelHandler._ProducingState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOAsyncChannelHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = A
    typealias InboundOut = Swift.Never
}
extension NIOCore.NIOAsyncChannelHandler: NIOCore._ChannelInboundHandler {}
extension NIOCore.NIOAsyncChannelHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = C
}
extension NIOCore.NIOAsyncChannelHandler: NIOCore.ChannelHandler {}
extension NIOCore.NIOAsyncChannelHandler: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = Any
}
extension NIOCore.NIOAsyncChannelHandler: NIOCore._ChannelOutboundHandler {}
extension NIOCore.NIOAsyncChannelHandlerProducerDelegate: NIOCore.NIOAsyncSequenceProducerDelegate {}
extension NIOCore.NIOAsyncChannelHandlerWriterDelegate: NIOCore.NIOAsyncWriterSinkDelegate {
    typealias Element = A
}
extension NIOCore.NIOAsyncChannelInboundStream.AsyncIterator: Swift.AsyncIteratorProtocol {
    typealias Element = A
    typealias Failure = Swift.Error

    func next() async throws -> Self.Element?
    func next(isolation: isolated Swift.Actor?) async throws(Self.Failure) -> Self.Element?
}
extension NIOCore.NIOAsyncChannelInboundStream: Swift.AsyncSequence {
    typealias AsyncIterator = NIOCore.NIOAsyncChannelInboundStream<A>.AsyncIterator
    typealias Element = A
    typealias Failure = Swift.Error

    func makeAsyncIterator() -> Self.AsyncIterator
}
extension NIOCore.NIOAsyncChannelOutboundWriter.TestSink.AsyncIterator: Swift.AsyncIteratorProtocol {
    typealias Element = A
    typealias Failure = Swift.Never

    func next() async throws -> Self.Element?
    func next(isolation: isolated Swift.Actor?) async throws(Self.Failure) -> Self.Element?
}
extension NIOCore.NIOAsyncChannelOutboundWriter.TestSink: Swift.AsyncSequence {
    typealias AsyncIterator = NIOCore.NIOAsyncChannelOutboundWriter<A>.TestSink.AsyncIterator
    typealias Element = A
    typealias Failure = Swift.Never

    func makeAsyncIterator() -> Self.AsyncIterator
}
extension NIOCore.NIOAsyncSequenceProducer: Swift.AsyncSequence {
    typealias AsyncIterator = NIOCore.NIOAsyncSequenceProducer<A, B, C>.AsyncIterator
    typealias Element = A
    typealias Failure = Swift.Never

    func makeAsyncIterator() -> Self.AsyncIterator
}
extension NIOCore.NIOAsyncSequenceProducer.AsyncIterator: Swift.AsyncIteratorProtocol {
    typealias Element = A
    typealias Failure = Swift.Never

    func next() async throws -> Self.Element?
    func next(isolation: isolated Swift.Actor?) async throws(Self.Failure) -> Self.Element?
}
extension NIOCore.NIOAsyncSequenceProducer.Source.YieldResult: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOAsyncSequenceProducer.Source.YieldResult: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark: NIOCore.NIOAsyncSequenceProducerBackPressureStrategy {}
extension NIOCore.NIOAsyncWriterError._Code: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOAsyncWriterError._Code: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOCore.NIOAsyncWriterError._Code: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOAsyncWriterError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.NIOAsyncWriterError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOAsyncWriterError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.NIOAsyncWriterError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOAsyncWriter.Storage.YieldIDGenerator.YieldID: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOAsyncWriter.StateMachine.YieldResult: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOAsyncWriter.StateMachine.YieldResult: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOAsyncWriter.StateMachine.State: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.NIOThrowingAsyncSequenceProducer: Swift.AsyncSequence {
    typealias AsyncIterator = NIOCore.NIOThrowingAsyncSequenceProducer<A, B, C, D>.AsyncIterator
    typealias Element = A
    typealias Failure = Swift.Error

    func makeAsyncIterator() -> Self.AsyncIterator
}
extension NIOCore.NIOThrowingAsyncSequenceProducer.AsyncIterator: Swift.AsyncIteratorProtocol {
    typealias Element = A
    typealias Failure = Swift.Error

    func next() async throws -> Self.Element?
    func next(isolation: isolated Swift.Actor?) async throws(Self.Failure) -> Self.Element?
}
extension NIOCore.NIOThrowingAsyncSequenceProducer.Source.YieldResult: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOThrowingAsyncSequenceProducer.Source.YieldResult: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOThrowingAsyncSequenceProducer.StateMachine.SequenceDeinitializedAction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOThrowingAsyncSequenceProducer.StateMachine.SequenceDeinitializedAction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOThrowingAsyncSequenceProducer.StateMachine.IteratorDeinitializedAction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOThrowingAsyncSequenceProducer.StateMachine.IteratorDeinitializedAction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOThrowingAsyncSequenceProducer.StateMachine.NextForContinuationAction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOThrowingAsyncSequenceProducer.StateMachine.NextForContinuationAction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOBSDSocket.AddressFamily: Swift.RawRepresentable {
    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOCore.NIOBSDSocket.AddressFamily: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOBSDSocket.AddressFamily: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOBSDSocket.ProtocolFamily: Swift.RawRepresentable {
    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOCore.NIOBSDSocket.ProtocolFamily: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOBSDSocket.ProtocolFamily: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOBSDSocket.OptionLevel: Swift.RawRepresentable {
    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOCore.NIOBSDSocket.OptionLevel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOBSDSocket.OptionLevel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOBSDSocket.Option: Swift.RawRepresentable {
    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOCore.NIOBSDSocket.Option: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOBSDSocket.Option: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension NIOCore.ByteBuffer: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension NIOCore.ByteBuffer: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.ByteBuffer: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension NIOCore.ByteBuffer: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ByteBuffer: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer.ReadUTF8ValidationError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.ByteBuffer.ReadUTF8ValidationError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ByteBuffer.ReadUTF8ValidationError.BaseError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer.ReadUTF8ValidationError.BaseError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore._ByteBufferSlice: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore._ByteBufferSlice: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.ByteBuffer.CopyBytesError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.ByteBuffer.CopyBytesError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer.CopyBytesError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ByteBuffer.CopyBytesError: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension NIOCore.ByteBuffer.CopyBytesError.BaseError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer.CopyBytesError.BaseError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ByteBuffer.HexDumpFormat.Value: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer.HexDumpFormat.Value: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ByteBuffer.HexDumpFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer.HexDumpFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ByteBuffer.HexDecodingError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.ByteBuffer.HexDecodingError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ByteBuffer.HexDecodingError.HexDecodingErrorKind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer.HexDecodingError.HexDecodingErrorKind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.Endianness: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.Endianness: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer.LengthPrefixError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.ByteBuffer.LengthPrefixError.BaseError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer.LengthPrefixError.BaseError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ByteBuffer.QUICBinaryEncodingStrategy.IntegerLength: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ByteBuffer.QUICBinaryEncodingStrategy.IntegerLength: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBuffer.QUICBinaryEncodingStrategy.IntegerLength: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOCore.ByteBuffer.QUICBinaryEncodingStrategy: NIOCore.NIOBinaryIntegerEncodingStrategy {}
extension NIOCore.ByteBufferView: Swift.RandomAccessCollection {
    typealias Element = Swift.UInt8
    typealias Index = Swift.Int
    typealias SubSequence = NIOCore.ByteBufferView
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension NIOCore.ByteBufferView: Swift.BidirectionalCollection {
    typealias Element = Swift.UInt8
    typealias Index = Swift.Int
    typealias SubSequence = NIOCore.ByteBufferView
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension NIOCore.ByteBufferView: Swift.Collection {
    typealias Element = Swift.UInt8
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<NIOCore.ByteBufferView>
    typealias SubSequence = NIOCore.ByteBufferView
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension NIOCore.ByteBufferView: Swift.Sequence {
    typealias Element = Swift.UInt8
    typealias Iterator = Swift.IndexingIterator<NIOCore.ByteBufferView>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOCore.ByteBufferView: Swift.MutableCollection {
    typealias Element = Swift.UInt8
    typealias Index = Swift.Int
    typealias SubSequence = NIOCore.ByteBufferView

    func partition(by: (_: Self.Element) throws -> Swift.Bool) throws -> Self.Index
    func swapAt(_: Self.Index, _: Self.Index)
    func _withUnsafeMutableBufferPointerIfSupported<A1>(_: (_: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> A1) throws -> A1?
    func withContiguousMutableStorageIfAvailable<A1>(_: (_: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOCore.ByteBufferView: Swift.RangeReplaceableCollection {
    typealias SubSequence = NIOCore.ByteBufferView

    init()
    init(repeating: Self.Element, count: Swift.Int)
    init<A1>(_: A1) where A1: Swift.Sequence, Self.Element == A1.Element

    func replaceSubrange<A1>(_: Swift.Range<Self.Index>, with: __owned A1) where A1: Swift.Collection, Self.Element == A1.Element
    func reserveCapacity(_: Swift.Int)
    func append(_: __owned Self.Element)
    func append<A1>(contentsOf: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element
    func insert(_: __owned Self.Element, at: Self.Index)
    func insert<A1>(contentsOf: __owned A1, at: Self.Index) where A1: Swift.Collection, Self.Element == A1.Element
    func remove(at: Self.Index) -> Self.Element
    func removeSubrange(_: Swift.Range<Self.Index>)
    func _customRemoveLast() -> Self.Element?
    func _customRemoveLast(_: Swift.Int) -> Swift.Bool
    func removeFirst() -> Self.Element
    func removeFirst(_: Swift.Int)
    func removeAll(keepingCapacity: Swift.Bool)
    func removeAll(where: (_: Self.Element) throws -> Swift.Bool) throws
}
extension NIOCore.ByteBufferView: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ByteBufferView: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteBufferView: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Swift.UInt8

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension NIOCore.ChannelError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.ChannelError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.NIOAttemptedToRemoveHandlerMultipleTimesError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.DatagramChannelError.WriteOnUnconnectedSocketWithoutAddress: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.DatagramChannelError.WriteOnConnectedSocketWithInvalidAddress: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.ChannelEvent: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ChannelEvent: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.AcceptBackoffHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOCore.Channel
    typealias InboundOut = Swift.Never
}
extension NIOCore.AcceptBackoffHandler: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOCore.Channel
}
extension NIOCore.AcceptBackoffHandler: NIOCore.RemovableChannelHandler {}
extension NIOCore.AcceptBackoffHandler: NIOCore._ChannelInboundHandler {}
extension NIOCore.AcceptBackoffHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = Swift.Never
}
extension NIOCore.AcceptBackoffHandler: NIOCore._ChannelOutboundHandler {}
extension NIOCore.AcceptBackoffHandler: NIOCore.ChannelHandler {}
extension NIOCore.BackPressureHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOCore.ByteBuffer
    typealias InboundOut = NIOCore.ByteBuffer
}
extension NIOCore.BackPressureHandler: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOCore.NIOAny
}
extension NIOCore.BackPressureHandler: NIOCore.RemovableChannelHandler {}
extension NIOCore.BackPressureHandler: NIOCore._ChannelInboundHandler {}
extension NIOCore.BackPressureHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOCore.ByteBuffer
}
extension NIOCore.BackPressureHandler: NIOCore._ChannelOutboundHandler {}
extension NIOCore.BackPressureHandler: NIOCore.ChannelHandler {}
extension NIOCore.IdleStateHandler.IdleStateEvent: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.IdleStateHandler.IdleStateEvent: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.IdleStateHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOCore.NIOAny
    typealias InboundOut = NIOCore.NIOAny
}
extension NIOCore.IdleStateHandler: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOCore.NIOAny
}
extension NIOCore.IdleStateHandler: NIOCore.RemovableChannelHandler {}
extension NIOCore.IdleStateHandler: NIOCore._ChannelInboundHandler {}
extension NIOCore.IdleStateHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOCore.NIOAny
}
extension NIOCore.IdleStateHandler: NIOCore._ChannelOutboundHandler {}
extension NIOCore.IdleStateHandler: NIOCore.ChannelHandler {}
extension NIOCore.CloseMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.CloseMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ChannelOptions.Types.SocketOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.SocketOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.SocketOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.AllocatorOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.AllocatorOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.AllocatorOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.RecvAllocatorOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.RecvAllocatorOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.RecvAllocatorOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.AutoReadOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.AutoReadOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.AutoReadOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.WriteSpinOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.WriteSpinOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.WriteSpinOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.MaxMessagesPerReadOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.MaxMessagesPerReadOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.MaxMessagesPerReadOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.BacklogOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.BacklogOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.BacklogOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.DatagramVectorReadMessageCountOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.DatagramVectorReadMessageCountOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.DatagramVectorReadMessageCountOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.DatagramSegmentSize: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.DatagramSegmentSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.DatagramSegmentSize: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.DatagramReceiveOffload: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.DatagramReceiveOffload: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.DatagramReceiveOffload: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.ExplicitCongestionNotificationsOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.ExplicitCongestionNotificationsOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.ExplicitCongestionNotificationsOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.WriteBufferWaterMarkOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.WriteBufferWaterMarkOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.WriteBufferWaterMarkOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.ConnectTimeoutOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.ConnectTimeoutOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.ConnectTimeoutOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.AllowRemoteHalfClosureOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.AllowRemoteHalfClosureOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.AllowRemoteHalfClosureOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.ReceivePacketInfo: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.ReceivePacketInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.ReceivePacketInfo: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelOptions.Types.BufferedWritableBytesOption: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.BufferedWritableBytesOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.BufferedWritableBytesOption: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.ChannelPipeline: NIOCore.ChannelInvoker {}
extension NIOCore.ChannelPipeline: NIOCore.ChannelOutboundInvoker {}
extension NIOCore.ChannelPipeline: NIOCore.ChannelInboundInvoker {}
extension NIOCore.ChannelPipeline: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension NIOCore.ChannelPipelineError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelPipelineError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ChannelPipelineError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.ChannelHandlerContext: NIOCore.ChannelInvoker {}
extension NIOCore.ChannelHandlerContext: NIOCore.ChannelOutboundInvoker {}
extension NIOCore.ChannelHandlerContext: NIOCore.ChannelInboundInvoker {}
extension NIOCore.TailChannelHandler: NIOCore.ChannelHandler {}
extension NIOCore.TailChannelHandler: NIOCore._ChannelInboundHandler {}
extension NIOCore.HeadChannelHandler: NIOCore.ChannelHandler {}
extension NIOCore.HeadChannelHandler: NIOCore._ChannelOutboundHandler {}
extension NIOCore.CircularBuffer.Index: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.CircularBuffer.Index: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.CircularBuffer: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.CircularBuffer: Swift.Collection {
    typealias Element = A
    typealias Index = NIOCore.CircularBuffer<A>.Index
    typealias Iterator = Swift.IndexingIterator<NIOCore.CircularBuffer<A>>
    typealias SubSequence = NIOCore.CircularBuffer<A>
    typealias Indices = Swift.DefaultIndices<NIOCore.CircularBuffer<A>>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension NIOCore.CircularBuffer: Swift.MutableCollection {
    typealias Element = A
    typealias Index = NIOCore.CircularBuffer<A>.Index
    typealias SubSequence = NIOCore.CircularBuffer<A>

    func partition(by: (_: Self.Element) throws -> Swift.Bool) throws -> Self.Index
    func swapAt(_: Self.Index, _: Self.Index)
    func _withUnsafeMutableBufferPointerIfSupported<A1>(_: (_: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> A1) throws -> A1?
    func withContiguousMutableStorageIfAvailable<A1>(_: (_: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOCore.CircularBuffer: Swift.Sequence {
    typealias Element = A
    typealias Iterator = Swift.IndexingIterator<NIOCore.CircularBuffer<A>>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOCore.CircularBuffer: Swift.RandomAccessCollection {
    typealias Element = A
    typealias Index = NIOCore.CircularBuffer<A>.Index
    typealias SubSequence = NIOCore.CircularBuffer<A>
    typealias Indices = Swift.DefaultIndices<NIOCore.CircularBuffer<A>>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension NIOCore.CircularBuffer: Swift.BidirectionalCollection {
    typealias Element = A
    typealias Index = NIOCore.CircularBuffer<A>.Index
    typealias SubSequence = NIOCore.CircularBuffer<A>
    typealias Indices = Swift.DefaultIndices<NIOCore.CircularBuffer<A>>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension NIOCore.CircularBuffer: Swift.RangeReplaceableCollection {
    typealias SubSequence = NIOCore.CircularBuffer<A>

    init()
    init(repeating: Self.Element, count: Swift.Int)
    init<A1>(_: A1) where A1: Swift.Sequence, Self.Element == A1.Element

    func replaceSubrange<A1>(_: Swift.Range<Self.Index>, with: __owned A1) where A1: Swift.Collection, Self.Element == A1.Element
    func reserveCapacity(_: Swift.Int)
    func append(_: __owned Self.Element)
    func append<A1>(contentsOf: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element
    func insert(_: __owned Self.Element, at: Self.Index)
    func insert<A1>(contentsOf: __owned A1, at: Self.Index) where A1: Swift.Collection, Self.Element == A1.Element
    func remove(at: Self.Index) -> Self.Element
    func removeSubrange(_: Swift.Range<Self.Index>)
    func _customRemoveLast() -> Self.Element?
    func _customRemoveLast(_: Swift.Int) -> Swift.Bool
    func removeFirst() -> Self.Element
    func removeFirst(_: Swift.Int)
    func removeAll(keepingCapacity: Swift.Bool)
    func removeAll(where: (_: Self.Element) throws -> Swift.Bool) throws
}
extension NIOCore.CircularBuffer: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.CircularBuffer: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.CircularBuffer: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = A

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension NIOCore.DecodingState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.DecodingState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteToMessageDecoderError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.ByteToMessageDecoderError.PayloadTooLargeError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.ByteToMessageHandler: NIOCore.CanDequeueWrites where A: NIOCore.WriteObservingByteToMessageDecoder {}
extension NIOCore.ByteToMessageHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOCore.ByteBuffer
    typealias InboundOut = A.ByteToMessageDecoder.InboundOut
}
extension NIOCore.ByteToMessageHandler: NIOCore._ChannelInboundHandler {}
extension NIOCore.ByteToMessageHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = Swift.Never
}
extension NIOCore.ByteToMessageHandler: NIOCore.ChannelHandler {}
extension NIOCore.ByteToMessageHandler: NIOCore.ChannelOutboundHandler where A: NIOCore.WriteObservingByteToMessageDecoder {
    typealias OutboundIn = A.WriteObservingByteToMessageDecoder.OutboundIn
}
extension NIOCore.ByteToMessageHandler: NIOCore._ChannelOutboundHandler where A: NIOCore.WriteObservingByteToMessageDecoder {}
extension NIOCore.ByteToMessageHandler: NIOCore.RemovableChannelHandler {}
extension NIOCore.MessageToByteHandler: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = A.MessageToByteEncoder.OutboundIn
}
extension NIOCore.MessageToByteHandler: NIOCore._ChannelOutboundHandler {}
extension NIOCore.MessageToByteHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOCore.ByteBuffer
}
extension NIOCore.MessageToByteHandler: NIOCore.ChannelHandler {}
extension NIOCore.ByteToMessageHandler.RemovalState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ByteToMessageHandler.RemovalState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.B2MDBuffer.State: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.B2MDBuffer.State: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.TCPConvenienceOption: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ChannelOptions.TCPConvenienceOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.TCPConvenienceOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = NIOCore.ChannelOptions.TCPConvenienceOption

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension NIOCore.ChannelOptions.TCPConvenienceOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ChannelOptions.TCPConvenienceOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.TCPConvenienceOption.ConvenienceOption: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.ChannelOptions.TCPConvenienceOption.ConvenienceOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.DeadChannel: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.DeadChannel: NIOCore.ChannelOutboundInvoker {}
extension NIOCore.DeadChannel: NIOCore.Channel {}
extension NIOCore.DeadChannelCore: NIOCore.ChannelCore {}
extension NIOCore.NIODefaultSerialEventLoopExecutor: Swift.Executor {
    func enqueue(_: Swift.UnownedJob)
    func enqueue(_: __owned Swift.Job)
    func enqueue(_: __owned Swift.ExecutorJob)
}
extension NIOCore.NIODefaultSerialEventLoopExecutor: Swift.SerialExecutor {
    func enqueue(_: Swift.UnownedJob)
    func enqueue(_: __owned Swift.Job)
    func enqueue(_: __owned Swift.ExecutorJob)
    func asUnownedSerialExecutor() -> Swift.UnownedSerialExecutor
    func isSameExclusiveExecutionContext(other: Self) -> Swift.Bool
    func checkIsolated()
    func isIsolatingCurrentContext() -> Swift.Bool?
}
extension NIOCore.EventLoopIterator: Swift.Sequence {
    typealias Element = NIOCore.EventLoop
    typealias Iterator = NIOCore.EventLoopIterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOCore.EventLoopIterator: Swift.IteratorProtocol {
    typealias Element = NIOCore.EventLoop

    func next() -> Self.Element?
}
extension NIOCore.TimeAmount: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.TimeAmount: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.TimeAmount: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.TimeAmount: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.TimeAmount: Swift.AdditiveArithmetic {
    static var zero: Self {
        get
    }

    static func + (_: Self, _: Self) -> Self
    static func += (_: inout Self, _: Self)
    static func - (_: Self, _: Self) -> Self
    static func -= (_: inout Self, _: Self)
}
extension NIOCore.NIODeadline: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIODeadline: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIODeadline: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIODeadline: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.EventLoopError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.EventLoopError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.EventLoopError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.EventLoopError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.TimeAmount.ValidationError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.TimeAmount.ValidationError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.OperationPlaceholderError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.EventLoopPromise: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.EventLoopFuture: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore._NIOEventLoopFutureIdentifier: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore._NIOEventLoopFutureIdentifier: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOFileHandle: NIOCore.FileDescriptor {}
extension NIOCore.NIOFileHandle: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.NIOFileHandle.Mode: Swift.OptionSet {
    typealias Element = NIOCore.NIOFileHandle.Mode

    init(rawValue: Self.RawValue)
}
extension NIOCore.NIOFileHandle.Mode: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt8

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOCore.NIOFileHandle.Mode: Swift.SetAlgebra {
    typealias Element = NIOCore.NIOFileHandle.Mode

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension NIOCore.NIOFileHandle.Mode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOFileHandle.Mode: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = NIOCore.NIOFileHandle.Mode

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension NIOCore.FileRegion: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.FileRegion: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.IOError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.IOError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.IOData: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.IOData: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.NIOIPProtocol: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt8

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOCore.NIOIPProtocol: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOIPProtocol: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOIPProtocol: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore._UInt24: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore._UInt24: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore._UInt56: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore._UInt56: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIONetworkInterface: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension NIOCore.NIONetworkInterface: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIONetworkDevice: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension NIOCore.NIONetworkDevice: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIONetworkDevice: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.MarkedCircularBuffer: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.MarkedCircularBuffer: Swift.Collection {
    typealias Element = A
    typealias Index = NIOCore.CircularBuffer<A>.Index
    typealias Iterator = Swift.IndexingIterator<NIOCore.MarkedCircularBuffer<A>>
    typealias SubSequence = NIOCore.CircularBuffer<A>
    typealias Indices = Swift.DefaultIndices<NIOCore.MarkedCircularBuffer<A>>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension NIOCore.MarkedCircularBuffer: Swift.MutableCollection {
    typealias Element = A
    typealias Index = NIOCore.CircularBuffer<A>.Index
    typealias SubSequence = NIOCore.CircularBuffer<A>

    func partition(by: (_: Self.Element) throws -> Swift.Bool) throws -> Self.Index
    func swapAt(_: Self.Index, _: Self.Index)
    func _withUnsafeMutableBufferPointerIfSupported<A1>(_: (_: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> A1) throws -> A1?
    func withContiguousMutableStorageIfAvailable<A1>(_: (_: inout Swift.UnsafeMutableBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOCore.MarkedCircularBuffer: Swift.Sequence {
    typealias Element = A
    typealias Iterator = Swift.IndexingIterator<NIOCore.MarkedCircularBuffer<A>>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOCore.MarkedCircularBuffer: Swift.RandomAccessCollection {
    typealias Element = A
    typealias Index = NIOCore.CircularBuffer<A>.Index
    typealias SubSequence = NIOCore.CircularBuffer<A>
    typealias Indices = Swift.DefaultIndices<NIOCore.MarkedCircularBuffer<A>>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension NIOCore.MarkedCircularBuffer: Swift.BidirectionalCollection {
    typealias Element = A
    typealias Index = NIOCore.CircularBuffer<A>.Index
    typealias SubSequence = NIOCore.CircularBuffer<A>
    typealias Indices = Swift.DefaultIndices<NIOCore.MarkedCircularBuffer<A>>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension NIOCore.NIOMulticastNotSupportedError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.NIOMulticastNotImplementedError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.NIOAny: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.NIOAny: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension NIOCore.NIOCloseOnErrorHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOCore.NIOAny
    typealias InboundOut = Swift.Never
}
extension NIOCore.NIOCloseOnErrorHandler: NIOCore._ChannelInboundHandler {}
extension NIOCore.NIOCloseOnErrorHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = Swift.Never
}
extension NIOCore.NIOCloseOnErrorHandler: NIOCore.ChannelHandler {}
extension NIOCore.LoopBoundScheduledCallbackHandlerWrapper: NIOCore.NIOScheduledCallbackHandler {}
extension NIOCore.UnsafeTransfer: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.UnsafeTransfer: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.FixedSizeRecvByteBufferAllocator: NIOCore.RecvByteBufferAllocator {}
extension NIOCore.FixedSizeRecvByteBufferAllocator: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.AdaptiveRecvByteBufferAllocator: NIOCore.RecvByteBufferAllocator {}
extension NIOCore.AdaptiveRecvByteBufferAllocator: NIOCore._NIOPreconcurrencySendable {}
extension NIOCore.NIOSingleStepByteToMessageProcessor.DecodeMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOSingleStepByteToMessageProcessor.DecodeMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.SocketAddressError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.SocketAddressError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.SocketAddressError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.SocketAddressError.FailedToParseIPByteBuffer: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOCore.SocketAddressError.FailedToParseIPByteBuffer: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.SocketAddressError.FailedToParseIPByteBuffer: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.SocketAddress: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.SocketAddress: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.SocketAddress: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension __C.sockaddr_in: NIOCore.SockAddrProtocol {}
extension __C.sockaddr_in6: NIOCore.SockAddrProtocol {}
extension __C.sockaddr_un: NIOCore.SockAddrProtocol {}
extension __C.sockaddr_storage: NIOCore.SockAddrProtocol {}
extension NIOCore.NIOInsecureNoTLS: NIOCore.NIOClientTLSProvider {
    typealias Bootstrap = A
}
extension NIOEmbedded.NIOAsyncTestingChannel.WrongTypeError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOEmbedded.NIOAsyncTestingChannel.WrongTypeError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOEmbedded.NIOAsyncTestingChannel.SynchronousOptions: NIOCore.NIOSynchronousChannelOptions {}
extension NIOEmbedded.NIOAsyncTestingChannel: NIOCore.Channel {}
extension NIOEmbedded.NIOAsyncTestingChannel: NIOCore.ChannelOutboundInvoker {}
extension NIOEmbedded.NIOAsyncTestingChannel: NIOCore._NIOPreconcurrencySendable {}
extension NIOEmbedded.NIOAsyncTestingEventLoop: NIOCore.EventLoop {}
extension NIOEmbedded.NIOAsyncTestingEventLoop: NIOCore.EventLoopGroup {}
extension NIOEmbedded.NIOAsyncTestingEventLoop: NIOCore._NIOPreconcurrencySendable {}
extension NIOEmbedded.NIOAsyncTestingEventLoop: NIOCore.NIOSerialEventLoopExecutor {}
extension NIOEmbedded.NIOAsyncTestingEventLoop: Swift.SerialExecutor {
    func enqueue(_: Swift.UnownedJob)
    func enqueue(_: __owned Swift.Job)
    func enqueue(_: __owned Swift.ExecutorJob)
    func asUnownedSerialExecutor() -> Swift.UnownedSerialExecutor
    func isSameExclusiveExecutionContext(other: Self) -> Swift.Bool
    func checkIsolated()
    func isIsolatingCurrentContext() -> Swift.Bool?
}
extension NIOEmbedded.NIOAsyncTestingEventLoop: Swift.Executor {
    func enqueue(_: Swift.UnownedJob)
    func enqueue(_: __owned Swift.Job)
    func enqueue(_: __owned Swift.ExecutorJob)
}
extension NIOEmbedded.NIOAsyncTestingEventLoop.State: Atomics.AtomicValue {
    typealias AtomicRepresentation = Atomics.AtomicRawRepresentableStorage<NIOEmbedded.NIOAsyncTestingEventLoop.State>
}
extension NIOEmbedded.NIOAsyncTestingEventLoop.State: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOEmbedded.NIOAsyncTestingEventLoop.State: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOEmbedded.NIOAsyncTestingEventLoop.State: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOEmbedded.EmbeddedEventLoop: NIOCore.EventLoop {}
extension NIOEmbedded.EmbeddedEventLoop: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOEmbedded.EmbeddedEventLoop: NIOCore.EventLoopGroup {}
extension NIOEmbedded.EmbeddedEventLoop: NIOCore._NIOPreconcurrencySendable {}
extension NIOEmbedded.EmbeddedChannelCore: NIOCore.ChannelCore {}
extension NIOEmbedded.EmbeddedChannel.WrongTypeError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOEmbedded.EmbeddedChannel.WrongTypeError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOEmbedded.EmbeddedChannel: NIOCore.Channel {}
extension NIOEmbedded.EmbeddedChannel: NIOCore.ChannelOutboundInvoker {}
extension NIOEmbedded.EmbeddedChannel: NIOCore._NIOPreconcurrencySendable {}
extension NIOEmbedded.EmbeddedChannel.SynchronousOptions: NIOCore.NIOSynchronousChannelOptions {}
extension NIOEmbedded.EmbeddedEventLoop.State: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOEmbedded.EmbeddedEventLoop.State: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOEmbedded.EmbeddedScheduledTask: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOEmbedded.EmbeddedScheduledTask: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.Shutdown: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.Shutdown: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.Shutdown: NIOPosix._SocketShutdownProtocol {}
extension NIOCore.NIOBSDSocket.SocketType: Swift.RawRepresentable {
    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOCore.NIOBSDSocket.SocketType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOBSDSocket.SocketType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOBSDSocket.ProtocolSubtype: Swift.RawRepresentable {
    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOCore.NIOBSDSocket.ProtocolSubtype: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOCore.NIOBSDSocket.ProtocolSubtype: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.NIOBSDSocket: NIOPosix._BSDSocketProtocol {}
extension NIOPosix.UnixDomainSocketPathWrongType: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.BaseSocket: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.BaseSocket: NIOPosix.Selectable {}
extension NIOPosix.BaseSocket: NIOPosix.BaseSocketProtocol {
    typealias SelectableType = NIOPosix.BaseSocket
}
extension NIOPosix.BaseSocketChannel: NIOCore.SocketOptionProvider {}
extension NIOPosix.BaseSocketChannel: NIOCore._NIOPreconcurrencySendable {}
extension NIOPosix.BaseSocketChannel: NIOCore.ChannelOutboundInvoker {}
extension NIOPosix.BaseSocketChannel: NIOCore.Channel {}
extension NIOPosix.BaseSocketChannel: NIOCore.ChannelCore {}
extension NIOPosix.BaseSocketChannel: NIOPosix.SelectableChannel {
    typealias SelectableType = A.BaseSocketProtocol.SelectableType
}
extension NIOPosix.SocketChannelLifecycleManager.State: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.SocketChannelLifecycleManager.State: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.BaseSocketChannel.SynchronousOptions: NIOCore.NIOSynchronousChannelOptions {}
extension NIOPosix.ClientBootstrap: NIOCore.NIOClientTCPBootstrapProtocol {}
extension NIOPosix.ServerBootstrap.AcceptHandler: NIOCore.ChannelHandler {}
extension NIOPosix.ServerBootstrap.AcceptHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = Swift.Never
}
extension NIOPosix.ServerBootstrap.AcceptHandler: NIOCore._ChannelInboundHandler {}
extension NIOPosix.ServerBootstrap.AcceptHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOPosix.SocketChannel
    typealias InboundOut = NIOPosix.SocketChannel
}
extension NIOPosix.DefaultNIOPipeBootstrapHooks: NIOPosix.NIOPipeBootstrapHooks {}
extension NIOPosix.UnsafeControlMessageCollection: Swift.Sequence {
    typealias Element = NIOPosix.UnsafeControlMessage
    typealias Iterator = Swift.IndexingIterator<NIOPosix.UnsafeControlMessageCollection>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOPosix.UnsafeControlMessageCollection: Swift.Collection {
    typealias Element = NIOPosix.UnsafeControlMessage
    typealias Index = NIOPosix.UnsafeControlMessageCollection.Index
    typealias Iterator = Swift.IndexingIterator<NIOPosix.UnsafeControlMessageCollection>
    typealias SubSequence = Swift.Slice<NIOPosix.UnsafeControlMessageCollection>
    typealias Indices = Swift.DefaultIndices<NIOPosix.UnsafeControlMessageCollection>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension NIOPosix.UnsafeControlMessageCollection.Index: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.UnsafeControlMessageCollection.Index: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.UnsafeControlMessageStorage: Swift.Sequence {
    typealias Element = Swift.UnsafeMutableRawBufferPointer
    typealias Iterator = Swift.IndexingIterator<NIOPosix.UnsafeControlMessageStorage>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOPosix.UnsafeControlMessageStorage: Swift.Collection {
    typealias Element = Swift.UnsafeMutableRawBufferPointer
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<NIOPosix.UnsafeControlMessageStorage>
    typealias SubSequence = Swift.Slice<NIOPosix.UnsafeControlMessageStorage>
    typealias Indices = Swift.DefaultIndices<NIOPosix.UnsafeControlMessageStorage>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension NIOPosix.GetaddrinfoResolver: NIOPosix.Resolver {}
extension NIOPosix.NIOConnectionError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.NIOConnectionError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.HappyEyeballsConnectorRunner.ConnectionState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.HappyEyeballsConnectorRunner.ConnectionState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.TargetIterator: Swift.IteratorProtocol {
    typealias Element = NIOCore.SocketAddress

    func next() -> Self.Element?
}
extension NIOPosix.TargetIterator.AddressFamily: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.TargetIterator.AddressFamily: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.HappyEyeballsConnectorRunner.ConnectorInput: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.HappyEyeballsConnectorRunner.ConnectorInput: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.IOResult: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix._UInt24: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix._UInt24: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix._UInt56: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix._UInt56: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.NIORegistration: NIOPosix.Registration {}
extension NIOPosix.MultiThreadedEventLoopGroup: NIOCore.EventLoopGroup {}
extension NIOPosix.MultiThreadedEventLoopGroup: NIOCore._NIOPreconcurrencySendable {}
extension NIOPosix.MultiThreadedEventLoopGroup: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.ScheduledTask: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.ScheduledTask: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.ScheduledTask: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.MultiThreadedEventLoopGroup._CanBeShutDown: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.MultiThreadedEventLoopGroup._CanBeShutDown: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.NIOThreadPoolError.ThreadPoolInactive: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.NIOThreadPoolError.UnsupportedOperation: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.NIOThreadPool.WorkItemState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.NIOThreadPool.WorkItemState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.NIOThreadPool._WorkState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.NIOThreadPool._WorkState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.NonBlockingFileIO.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.NonBlockingFileIO.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.NonBlockingFileIO.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.NIODirectoryEntry: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.NIODirectoryEntry: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.PendingDatagramWritesManager: NIOPosix.PendingWritesManager {}
extension NIOPosix.PendingDatagramWritesState.FlushedDatagramWriteSequence: Swift.IteratorProtocol {
    typealias Element = NIOPosix.PendingDatagramWrite

    func next() -> Self.Element?
}
extension NIOPosix.PendingDatagramWritesState.FlushedDatagramWriteSequence: Swift.Sequence {
    typealias Element = NIOPosix.PendingDatagramWrite
    typealias Iterator = NIOPosix.PendingDatagramWritesState.FlushedDatagramWriteSequence

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOPosix.NIOReportedIncompleteWritesWhenNoMoreToPerform: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.NIOReportedOpenAfterClose: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.NIOReportedPendingWritesInInvalidState: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.PendingStreamWritesManager: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.PendingStreamWritesManager: NIOPosix.PendingWritesManager {}
extension NIOPosix.PipeChannel: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.PipeChannel.Direction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.PipeChannel.Direction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.PipePair: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.PipePair: NIOPosix.BaseSocketProtocol {
    typealias SelectableType = NIOPosix.SelectablePipeHandle
}
extension NIOPosix.PipePair: NIOPosix.SocketProtocol {}
extension NIOPosix.SelectablePipeHandle: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.SelectablePipeHandle: NIOPosix.Selectable {}
extension NIOPosix.PooledBuffer: NIOPosix.PoolElement {}
extension NIOPosix.PooledMsgBuffer: NIOPosix.PoolElement {}
extension NIOPosix.SelectableEventLoop: NIOPosix.SilenceWarning {}
extension NIOPosix.SelectableEventLoop: NIOCore.EventLoop {}
extension NIOPosix.SelectableEventLoop: NIOCore.EventLoopGroup {}
extension NIOPosix.SelectableEventLoop: NIOCore._NIOPreconcurrencySendable {}
extension NIOPosix.SelectableEventLoop: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.SelectableEventLoop: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension NIOPosix.SelectableEventLoop: NIOCore.NIOSerialEventLoopExecutor {}
extension NIOPosix.SelectableEventLoop: Swift.SerialExecutor {
    func enqueue(_: Swift.UnownedJob)
    func enqueue(_: __owned Swift.Job)
    func enqueue(_: __owned Swift.ExecutorJob)
    func asUnownedSerialExecutor() -> Swift.UnownedSerialExecutor
    func isSameExclusiveExecutionContext(other: Self) -> Swift.Bool
    func checkIsolated()
    func isIsolatingCurrentContext() -> Swift.Bool?
}
extension NIOPosix.SelectableEventLoop: Swift.Executor {
    func enqueue(_: Swift.UnownedJob)
    func enqueue(_: __owned Swift.Job)
    func enqueue(_: __owned Swift.ExecutorJob)
}
extension NIOPosix.NIOEventLoopTickInfo: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.NIOEventLoopTickInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.SelectableEventLoop.InternalState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.SelectableEventLoop.InternalState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.SelectableEventLoop.ExternalState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.SelectableEventLoop.ExternalState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.SelectorLifecycleState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.SelectorLifecycleState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.SelectorEventSet: Swift.OptionSet {
    typealias Element = NIOPosix.SelectorEventSet

    init(rawValue: Self.RawValue)
}
extension NIOPosix.SelectorEventSet: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.SelectorEventSet: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt8

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOPosix.SelectorEventSet: Swift.SetAlgebra {
    typealias Element = NIOPosix.SelectorEventSet

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension NIOPosix.SelectorEventSet: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = NIOPosix.SelectorEventSet

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension NIOPosix.Selector: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.Selector: NIOPosix._SelectorBackendProtocol {
    typealias R = A
}
extension NIOPosix.SelectorRegistrationID: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.SelectorRegistrationID: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.ServerSocket: NIOPosix.ServerSocketProtocol {}
extension NIOPosix.Socket: NIOPosix.SocketProtocol {}
extension NIOPosix.DatagramChannel: NIOCore.MulticastChannel {}
extension NIOPosix.DatagramChannel: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.ServerSocketChannel: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.SocketChannel: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.NIOFcntlFailedError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.NIOFailedToSetSocketNonBlockingError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.NIOThread: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.NIOThread.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.NIOThread.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.NIOThread.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOPosix.UnsafeTransfer: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.UnsafeTransfer: Swift.Hashable where A: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.VsockAddress.ContextID: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOPosix.VsockAddress.ContextID: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.UInt32

    init(integerLiteral: Self.IntegerLiteralType)
}
extension NIOPosix.VsockAddress.ContextID: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.VsockAddress.ContextID: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.VsockAddress.ContextID: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.VsockAddress.Port: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOPosix.VsockAddress.Port: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.UInt32

    init(integerLiteral: Self.IntegerLiteralType)
}
extension NIOPosix.VsockAddress.Port: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.VsockAddress.Port: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.VsockAddress.Port: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOPosix.VsockAddress: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.VsockAddress: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.VsockAddress: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOCore.ChannelOptions.Types.LocalVsockContextID: NIOCore.ChannelOption {}
extension NIOCore.ChannelOptions.Types.LocalVsockContextID: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOCore.ChannelOptions.Types.LocalVsockContextID: NIOCore._NIOPreconcurrencySendable {}
extension NIOPosix.VsockChannelEvents.BindToAddress: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.VsockChannelEvents.BindToAddress: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOPosix.VsockChannelEvents.ConnectToAddress: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOPosix.VsockChannelEvents.ConnectToAddress: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.llhttp_errno: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.llhttp_errno: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPDecoderKind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPDecoderKind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPDecoder: NIOCore.WriteObservingByteToMessageDecoder where A == NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.ByteBuffer>, B == NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.IOData> {
    typealias OutboundIn = B
}
extension NIOHTTP1.HTTPDecoder: NIOCore.ByteToMessageDecoder {
    typealias InboundOut = A
}
extension NIOHTTP1.HTTPDecoder: NIOHTTP1.HTTPDecoderDelegate {}
extension NIOHTTP1.RemoveAfterUpgradeStrategy: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.RemoveAfterUpgradeStrategy: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOInformationalResponseStrategy.Base: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOInformationalResponseStrategy.Base: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOInformationalResponseStrategy: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOInformationalResponseStrategy: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOHTTPDecoderError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOHTTP1.NIOHTTPDecoderError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOHTTPDecoderError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOHTTPDecoderError: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension NIOHTTP1.NIOHTTPDecoderError.BaseError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOHTTPDecoderError.BaseError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPDecodingState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPDecodingState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPRequestEncoder.Configuration: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPRequestEncoder.Configuration: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPRequestEncoder: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.IOData>
}
extension NIOHTTP1.HTTPRequestEncoder: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.HTTPRequestEncoder: NIOCore._ChannelOutboundHandler {}
extension NIOHTTP1.HTTPRequestEncoder: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOCore.IOData
}
extension NIOHTTP1.HTTPRequestEncoder: NIOCore.ChannelHandler {}
extension NIOHTTP1.HTTPResponseEncoder.Configuration: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPResponseEncoder.Configuration: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPResponseEncoder: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension NIOHTTP1.HTTPResponseEncoder: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.HTTPResponseEncoder: NIOCore._ChannelOutboundHandler {}
extension NIOHTTP1.HTTPResponseEncoder: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOCore.IOData
}
extension NIOHTTP1.HTTPResponseEncoder: NIOCore.ChannelHandler {}
extension NIOHTTP1.NIOHTTPRequestHeadersValidator: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.IOData>
}
extension NIOHTTP1.NIOHTTPRequestHeadersValidator: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.NIOHTTPRequestHeadersValidator: NIOCore._ChannelOutboundHandler {}
extension NIOHTTP1.NIOHTTPRequestHeadersValidator: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.IOData>
}
extension NIOHTTP1.NIOHTTPRequestHeadersValidator: NIOCore.ChannelHandler {}
extension NIOHTTP1.NIOHTTPResponseHeadersValidator: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension NIOHTTP1.NIOHTTPResponseHeadersValidator: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.NIOHTTPResponseHeadersValidator: NIOCore._ChannelOutboundHandler {}
extension NIOHTTP1.NIOHTTPResponseHeadersValidator: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension NIOHTTP1.NIOHTTPResponseHeadersValidator: NIOCore.ChannelHandler {}
extension NIOHTTP1.NIOHTTPResponseHeadersValidator.State: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOHTTPResponseHeadersValidator.State: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPServerPipelineHandler.ConnectionStateError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOHTTP1.HTTPServerPipelineHandler.ConnectionStateError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOHTTP1.HTTPServerPipelineHandler.ConnectionStateError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPServerPipelineHandler.ConnectionStateError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPServerPipelineHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.ByteBuffer>
    typealias InboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.ByteBuffer>
}
extension NIOHTTP1.HTTPServerPipelineHandler: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension NIOHTTP1.HTTPServerPipelineHandler: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.HTTPServerPipelineHandler: NIOCore._ChannelInboundHandler {}
extension NIOHTTP1.HTTPServerPipelineHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension NIOHTTP1.HTTPServerPipelineHandler: NIOCore._ChannelOutboundHandler {}
extension NIOHTTP1.HTTPServerPipelineHandler: NIOCore.ChannelHandler {}
extension NIOHTTP1.HTTPServerPipelineHandler.ConnectionState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPServerPipelineHandler.ConnectionState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPServerPipelineHandler.LifecycleState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPServerPipelineHandler.LifecycleState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPServerPipelineHandler.NextExpectedMessageType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPServerPipelineHandler.NextExpectedMessageType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPServerPipelineHandler.ConnectionStateError.Base: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPServerPipelineHandler.ConnectionStateError.Base: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOHTTP1.HTTPServerPipelineHandler.ConnectionStateError.Base: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPServerProtocolErrorHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.ByteBuffer>
    typealias InboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.ByteBuffer>
}
extension NIOHTTP1.HTTPServerProtocolErrorHandler: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension NIOHTTP1.HTTPServerProtocolErrorHandler: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.HTTPServerProtocolErrorHandler: NIOCore._ChannelInboundHandler {}
extension NIOHTTP1.HTTPServerProtocolErrorHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension NIOHTTP1.HTTPServerProtocolErrorHandler: NIOCore._ChannelOutboundHandler {}
extension NIOHTTP1.HTTPServerProtocolErrorHandler: NIOCore.ChannelHandler {}
extension NIOHTTP1.HTTPServerUpgradeErrors: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPServerUpgradeErrors: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPServerUpgradeErrors: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOHTTP1.HTTPServerUpgradeHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.ByteBuffer>
    typealias InboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.ByteBuffer>
}
extension NIOHTTP1.HTTPServerUpgradeHandler: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.HTTPServerUpgradeHandler: NIOCore._ChannelInboundHandler {}
extension NIOHTTP1.HTTPServerUpgradeHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension NIOHTTP1.HTTPServerUpgradeHandler: NIOCore.ChannelHandler {}
extension NIOHTTP1.HTTPRequestHead: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPRequestHead: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOHTTP1.HTTPPart: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPResponseHead: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPResponseHead: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOHTTP1.HTTPHeaders: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOHTTP1.HTTPHeaders: Swift.ExpressibleByDictionaryLiteral {
    typealias Key = Swift.String
    typealias Value = Swift.String

    init(dictionaryLiteral: (Self.Key, Self.Value)...)
}
extension NIOHTTP1.HTTPHeaders: Swift.RandomAccessCollection {
    typealias Element = (name: Swift.String, value: Swift.String)
    typealias Index = NIOHTTP1.HTTPHeaders.Index
    typealias SubSequence = Swift.Slice<NIOHTTP1.HTTPHeaders>
    typealias Indices = Swift.DefaultIndices<NIOHTTP1.HTTPHeaders>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension NIOHTTP1.HTTPHeaders: Swift.BidirectionalCollection {
    typealias Element = (name: Swift.String, value: Swift.String)
    typealias Index = NIOHTTP1.HTTPHeaders.Index
    typealias SubSequence = Swift.Slice<NIOHTTP1.HTTPHeaders>
    typealias Indices = Swift.DefaultIndices<NIOHTTP1.HTTPHeaders>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension NIOHTTP1.HTTPHeaders: Swift.Collection {
    typealias Element = (name: Swift.String, value: Swift.String)
    typealias Index = NIOHTTP1.HTTPHeaders.Index
    typealias Iterator = Swift.IndexingIterator<NIOHTTP1.HTTPHeaders>
    typealias SubSequence = Swift.Slice<NIOHTTP1.HTTPHeaders>
    typealias Indices = Swift.DefaultIndices<NIOHTTP1.HTTPHeaders>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension NIOHTTP1.HTTPHeaders: Swift.Sequence {
    typealias Element = (name: Swift.String, value: Swift.String)
    typealias Iterator = Swift.IndexingIterator<NIOHTTP1.HTTPHeaders>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension NIOHTTP1.HTTPHeaders: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPHeaders.Index: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPHeaders.Index: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPMethod: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPMethod: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension NIOHTTP1.HTTPVersion: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPVersion: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOHTTP1.HTTPParserError: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension NIOHTTP1.HTTPParserError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPParserError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPParserError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOHTTP1.HTTPResponseStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.HTTPResponseStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.HTTPResponseStatus: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOHTTP1.KeepAliveState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.KeepAliveState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOHTTPClientUpgradeError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOHTTPClientUpgradeError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOHTTP1.NIOHTTPClientUpgradeError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOHTTPClientUpgradeError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension NIOHTTP1.NIOHTTPClientUpgradeHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.ByteBuffer>
    typealias InboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.ByteBuffer>
}
extension NIOHTTP1.NIOHTTPClientUpgradeHandler: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.IOData>
}
extension NIOHTTP1.NIOHTTPClientUpgradeHandler: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.NIOHTTPClientUpgradeHandler: NIOCore._ChannelInboundHandler {}
extension NIOHTTP1.NIOHTTPClientUpgradeHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.IOData>
}
extension NIOHTTP1.NIOHTTPClientUpgradeHandler: NIOCore._ChannelOutboundHandler {}
extension NIOHTTP1.NIOHTTPClientUpgradeHandler: NIOCore.ChannelHandler {}
extension NIOHTTP1.NIOHTTPClientUpgradeError.Code: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOHTTPClientUpgradeError.Code: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOHTTPServerRequestFull: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOHTTPClientResponseFull: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOHTTPObjectAggregatorError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension NIOHTTP1.NIOHTTPObjectAggregatorError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOHTTPObjectAggregatorEvent: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOHTTPObjectAggregatorEvent: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOHTTPServerRequestAggregator: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.ByteBuffer>
    typealias InboundOut = NIOHTTP1.NIOHTTPServerRequestFull
}
extension NIOHTTP1.NIOHTTPServerRequestAggregator: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.NIOHTTPServerRequestAggregator: NIOCore._ChannelInboundHandler {}
extension NIOHTTP1.NIOHTTPServerRequestAggregator: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension NIOHTTP1.NIOHTTPServerRequestAggregator: NIOCore.ChannelHandler {}
extension NIOHTTP1.NIOHTTPClientResponseAggregator: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.ByteBuffer>
    typealias InboundOut = NIOHTTP1.NIOHTTPClientResponseFull
}
extension NIOHTTP1.NIOHTTPClientResponseAggregator: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.NIOHTTPClientResponseAggregator: NIOCore._ChannelInboundHandler {}
extension NIOHTTP1.NIOHTTPClientResponseAggregator: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = Swift.Never
}
extension NIOHTTP1.NIOHTTPClientResponseAggregator: NIOCore.ChannelHandler {}
extension NIOHTTP1.NIOHTTPObjectAggregatorError.Base: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOHTTPObjectAggregatorError.Base: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOHTTPObjectAggregatorEvent.Base: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.NIOHTTPObjectAggregatorEvent.Base: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.AggregatorState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension NIOHTTP1.AggregatorState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension NIOHTTP1.NIOTypedHTTPClientUpgradeHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.ByteBuffer>
    typealias InboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.ByteBuffer>
}
extension NIOHTTP1.NIOTypedHTTPClientUpgradeHandler: NIOCore.ChannelOutboundHandler {
    typealias OutboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.IOData>
}
extension NIOHTTP1.NIOTypedHTTPClientUpgradeHandler: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.NIOTypedHTTPClientUpgradeHandler: NIOCore._ChannelInboundHandler {}
extension NIOHTTP1.NIOTypedHTTPClientUpgradeHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.IOData>
}
extension NIOHTTP1.NIOTypedHTTPClientUpgradeHandler: NIOCore._ChannelOutboundHandler {}
extension NIOHTTP1.NIOTypedHTTPClientUpgradeHandler: NIOCore.ChannelHandler {}
extension NIOHTTP1.NIOTypedHTTPServerUpgradeHandler: NIOCore.ChannelInboundHandler {
    typealias InboundIn = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.ByteBuffer>
    typealias InboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPRequestHead, NIOCore.ByteBuffer>
}
extension NIOHTTP1.NIOTypedHTTPServerUpgradeHandler: NIOCore.RemovableChannelHandler {}
extension NIOHTTP1.NIOTypedHTTPServerUpgradeHandler: NIOCore._ChannelInboundHandler {}
extension NIOHTTP1.NIOTypedHTTPServerUpgradeHandler: NIOCore._EmittingChannelHandler {
    typealias OutboundOut = NIOHTTP1.HTTPPart<NIOHTTP1.HTTPResponseHead, NIOCore.IOData>
}
extension NIOHTTP1.NIOTypedHTTPServerUpgradeHandler: NIOCore.ChannelHandler {}
extension OAuth1.BrowserTokenProvider: OAuth1.TokenProvider {}
extension OAuth1.Credentials: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension OAuth1.Credentials: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension OAuth1.AuthError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth1.AuthError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth1.AuthError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension OAuth1.Credentials.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OAuth1.Credentials.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OAuth1.Credentials.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension OAuth1.Credentials.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth1.Credentials.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth1.Credentials.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension OAuth1.Token: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension OAuth1.Token: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension OAuth1.Token.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OAuth1.Token.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OAuth1.Token.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension OAuth1.Token.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth1.Token.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth1.Token.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension CryptoSwift.AEADChaCha20Poly1305: CryptoSwift.AEAD {}
extension CryptoSwift.AES: CryptoSwift.Cryptors {}
extension CryptoSwift.AES: CryptoSwift.BlockCipher {}
extension CryptoSwift.AES: CryptoSwift.Cipher {}
extension CryptoSwift.AES.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.AES.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.AES.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.AES.Variant: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.AES.Variant: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.AES.Variant: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension CryptoSwift.BatchedCollection: Swift.Sequence {
    typealias Element = A.Collection.SubSequence
    typealias Iterator = Swift.IndexingIterator<CryptoSwift.BatchedCollection<A>>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension CryptoSwift.BatchedCollection: Swift.Collection {
    typealias Element = A.Collection.SubSequence
    typealias Index = CryptoSwift.BatchedCollectionIndex<A>
    typealias Iterator = Swift.IndexingIterator<CryptoSwift.BatchedCollection<A>>
    typealias SubSequence = Swift.Slice<CryptoSwift.BatchedCollection<A>>
    typealias Indices = Swift.DefaultIndices<CryptoSwift.BatchedCollection<A>>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension CryptoSwift.BatchedCollectionIndex: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.BatchedCollectionIndex: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.Bit: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.Bit: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.Bit: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension CryptoSwift.BlockDecryptor: CryptoSwift.Cryptor {}
extension CryptoSwift.BlockDecryptor: CryptoSwift.Updatable {}
extension CryptoSwift.BlockEncryptor: CryptoSwift.Updatable {}
extension CryptoSwift.BlockEncryptor: CryptoSwift.Cryptor {}
extension CryptoSwift.BlockModeOption: Swift.OptionSet {
    typealias Element = CryptoSwift.BlockModeOption

    init(rawValue: Self.RawValue)
}
extension CryptoSwift.BlockModeOption: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension CryptoSwift.BlockModeOption: Swift.SetAlgebra {
    typealias Element = CryptoSwift.BlockModeOption

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension CryptoSwift.BlockModeOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.BlockModeOption: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = CryptoSwift.BlockModeOption

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension CryptoSwift.CBC.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.CBC.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.CBC.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.CBC: CryptoSwift.BlockMode {}
extension CryptoSwift.CBCModeWorker: CryptoSwift.BlockModeWorker {}
extension CryptoSwift.CBCModeWorker: CryptoSwift.CipherModeWorker {}
extension CryptoSwift.CCM.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.CCM.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.CCM.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.CCM: CryptoSwift.BlockMode {}
extension CryptoSwift.CCMModeWorker: CryptoSwift.FinalizingDecryptModeWorker {}
extension CryptoSwift.CCMModeWorker: CryptoSwift.FinalizingEncryptModeWorker {}
extension CryptoSwift.CCMModeWorker: CryptoSwift.CounterModeWorker {
    typealias Counter = Swift.Int
}
extension CryptoSwift.CCMModeWorker: CryptoSwift.SeekableModeWorker {}
extension CryptoSwift.CCMModeWorker: CryptoSwift.StreamModeWorker {}
extension CryptoSwift.CCMModeWorker: CryptoSwift.CipherModeWorker {}
extension CryptoSwift.CCMModeWorker.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.CCMModeWorker.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.CCMModeWorker.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.CFB.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.CFB.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.CFB.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.CFB: CryptoSwift.BlockMode {}
extension CryptoSwift.CFBModeWorker: CryptoSwift.BlockModeWorker {}
extension CryptoSwift.CFBModeWorker: CryptoSwift.CipherModeWorker {}
extension CryptoSwift.CTR.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.CTR.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.CTR.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.CTR: CryptoSwift.BlockMode {}
extension CryptoSwift.CTRModeWorker: CryptoSwift.CounterModeWorker {
    typealias Counter = CryptoSwift.CTRModeWorker.CTRCounter
}
extension CryptoSwift.CTRModeWorker: CryptoSwift.SeekableModeWorker {}
extension CryptoSwift.CTRModeWorker: CryptoSwift.StreamModeWorker {}
extension CryptoSwift.CTRModeWorker: CryptoSwift.CipherModeWorker {}
extension CryptoSwift.ECB: CryptoSwift.BlockMode {}
extension CryptoSwift.ECBModeWorker: CryptoSwift.BlockModeWorker {}
extension CryptoSwift.ECBModeWorker: CryptoSwift.CipherModeWorker {}
extension CryptoSwift.GCM.Mode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.GCM.Mode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.GCM.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.GCM.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.GCM.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.GCM: CryptoSwift.BlockMode {}
extension CryptoSwift.GCMModeWorker: CryptoSwift.FinalizingDecryptModeWorker {}
extension CryptoSwift.GCMModeWorker: CryptoSwift.FinalizingEncryptModeWorker {}
extension CryptoSwift.GCMModeWorker: CryptoSwift.BlockModeWorker {}
extension CryptoSwift.GCMModeWorker: CryptoSwift.CipherModeWorker {}
extension CryptoSwift.OFB.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.OFB.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.OFB.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.OFB: CryptoSwift.BlockMode {}
extension CryptoSwift.OFBModeWorker: CryptoSwift.BlockModeWorker {}
extension CryptoSwift.OFBModeWorker: CryptoSwift.CipherModeWorker {}
extension CryptoSwift.PCBC.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.PCBC.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.PCBC.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.PCBC: CryptoSwift.BlockMode {}
extension CryptoSwift.PCBCModeWorker: CryptoSwift.BlockModeWorker {}
extension CryptoSwift.PCBCModeWorker: CryptoSwift.CipherModeWorker {}
extension CryptoSwift.Blowfish.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.Blowfish.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.Blowfish.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.Blowfish: CryptoSwift.Cipher {}
extension CryptoSwift.CMAC.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.CMAC.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.CMAC.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.CMAC: CryptoSwift.Authenticator {}
extension CryptoSwift.ChaCha20.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.ChaCha20.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.ChaCha20.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.ChaCha20: CryptoSwift.BlockCipher {}
extension CryptoSwift.ChaCha20: CryptoSwift.Cipher {}
extension CryptoSwift.ChaCha20: CryptoSwift.Cryptors {}
extension CryptoSwift.ChaCha20.ChaChaEncryptor: CryptoSwift.Cryptor {}
extension CryptoSwift.ChaCha20.ChaChaEncryptor: CryptoSwift.Updatable {}
extension CryptoSwift.ChaCha20.ChaChaDecryptor: CryptoSwift.Cryptor {}
extension CryptoSwift.ChaCha20.ChaChaDecryptor: CryptoSwift.Updatable {}
extension CryptoSwift.CipherError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.CipherError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.CipherError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.HKDF.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.HKDF.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.HKDF.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.HMAC.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.HMAC.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.HMAC.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.HMAC.Variant: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.HMAC.Variant: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.HMAC: CryptoSwift.Authenticator {}
extension CryptoSwift.MD5: CryptoSwift.DigestType {}
extension CryptoSwift.MD5: CryptoSwift.Updatable {}
extension CryptoSwift.PKCS5.PBKDF1.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.PKCS5.PBKDF1.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.PKCS5.PBKDF1.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.PKCS5.PBKDF1.Variant: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.PKCS5.PBKDF1.Variant: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.PKCS5.PBKDF2.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.PKCS5.PBKDF2.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.PKCS5.PBKDF2.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.Padding: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.Padding: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.Padding: CryptoSwift.PaddingProtocol {}
extension CryptoSwift.Poly1305.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.Poly1305.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.Poly1305.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.Poly1305: CryptoSwift.Authenticator {}
extension CryptoSwift.Rabbit.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.Rabbit.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.Rabbit.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.Rabbit: CryptoSwift.BlockCipher {}
extension CryptoSwift.Rabbit: CryptoSwift.Cipher {}
extension CryptoSwift.SHA1: CryptoSwift.DigestType {}
extension CryptoSwift.SHA1: CryptoSwift.Updatable {}
extension CryptoSwift.SHA2.Variant: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.SHA2.Variant: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.SHA2.Variant: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension CryptoSwift.SHA2: CryptoSwift.DigestType {}
extension CryptoSwift.SHA2: CryptoSwift.Updatable {}
extension CryptoSwift.SHA3.Variant: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.SHA3.Variant: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.SHA3: CryptoSwift.DigestType {}
extension CryptoSwift.SHA3: CryptoSwift.Updatable {}
extension CryptoSwift.Scrypt.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension CryptoSwift.Scrypt.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension CryptoSwift.Scrypt.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension CryptoSwift.SecureBytes: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Swift.UInt8

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension CryptoSwift.SecureBytes: Swift.Sequence {
    typealias Element = Swift.UInt8
    typealias Iterator = Swift.IndexingIterator<CryptoSwift.SecureBytes>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension CryptoSwift.SecureBytes: Swift.Collection {
    typealias Element = Swift.UInt8
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<CryptoSwift.SecureBytes>
    typealias SubSequence = Swift.ArraySlice<Swift.UInt8>
    typealias Indices = Swift.DefaultIndices<CryptoSwift.SecureBytes>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension CryptoSwift.StreamDecryptor: CryptoSwift.Updatable {}
extension CryptoSwift.StreamDecryptor: CryptoSwift.Cryptor {}
extension CryptoSwift.StreamEncryptor: CryptoSwift.Updatable {}
extension CryptoSwift.StreamEncryptor: CryptoSwift.Cryptor {}
extension CryptoSwift.UInt128: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.UInt64

    init(integerLiteral: Self.IntegerLiteralType)
}
extension CryptoSwift.UInt128: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GoogleSignInSwift.GoogleSignInButton: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Button<SwiftUI._ConditionalContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._OverlayModifier<SwiftUI._ShapeView<SwiftUI._StrokedShape<SwiftUI.Rectangle._Inset>, SwiftUI.Color>>>, SwiftUI.Image)>>, SwiftUI.HStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI.ZStack<SwiftUI.TupleView<(SwiftUI.ModifiedContent<SwiftUI._ShapeView<SwiftUI.RoundedRectangle, SwiftUI.Color>, SwiftUI._FrameLayout>, SwiftUI.Image)>>, SwiftUI._PaddingLayout>, SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Text, SwiftUI._FixedSizeLayout>, SwiftUI._PaddingLayout>, SwiftUI._FrameLayout>, SwiftUI.Spacer)>>>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Font?>>GoogleSignInSwift.SwiftUIButtonStyle, SwiftUI._EnvironmentKeyTransformModifier<Swift.Bool>>SwiftUI._EndedGesture<SwiftUI._ChangedGesture<SwiftUI.DragGesture>>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension SwiftUI.Image.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension GoogleSignInSwift.GoogleSignInButtonStyle: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GoogleSignInSwift.GoogleSignInButtonStyle: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GoogleSignInSwift.GoogleSignInButtonStyle: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GoogleSignInSwift.GoogleSignInButtonStyle: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension GoogleSignInSwift.GoogleSignInButtonStyle: Swift.CaseIterable {
    typealias AllCases = [GoogleSignInSwift.GoogleSignInButtonStyle]

    static var allCases: Self.AllCases {
        get
    }
}
extension GoogleSignInSwift.GoogleSignInButtonColorScheme: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GoogleSignInSwift.GoogleSignInButtonColorScheme: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GoogleSignInSwift.GoogleSignInButtonColorScheme: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GoogleSignInSwift.GoogleSignInButtonColorScheme: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension GoogleSignInSwift.GoogleSignInButtonColorScheme: Swift.CaseIterable {
    typealias AllCases = [GoogleSignInSwift.GoogleSignInButtonColorScheme]

    static var allCases: Self.AllCases {
        get
    }
}
extension GoogleSignInSwift.GoogleSignInButtonState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GoogleSignInSwift.GoogleSignInButtonState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GoogleSignInSwift.GoogleSignInButtonState: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GoogleSignInSwift.GoogleSignInButtonState: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension GoogleSignInSwift.GoogleSignInButtonState: Swift.CaseIterable {
    typealias AllCases = [GoogleSignInSwift.GoogleSignInButtonState]

    static var allCases: Self.AllCases {
        get
    }
}
extension GoogleSignInSwift.SwiftUIButtonStyle: SwiftUI.ButtonStyle {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.ButtonStyleConfiguration.Label, SwiftUI._FlexFrameLayout>, SwiftUI._BackgroundModifier<SwiftUI.Color>>, SwiftUI._EnvironmentKeyWritingModifier<SwiftUI.Color?>>, SwiftUI._ClipEffect<SwiftUI.RoundedRectangle>>, SwiftUI._ShadowEffect>

    func makeBody(configuration: SwiftUI.ButtonStyleConfiguration) -> Self.Body
}
extension GoogleSignInSwift.GoogleSignInButtonViewModel: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension FirebaseAuth.ActionCodeOperation: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseAuth.ActionCodeOperation: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseAuth.ActionCodeOperation: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseAuth.AuthOperationType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseAuth.AuthOperationType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseAuth.AuthOperationType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseAuth.JWT: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseAuth.JWT.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseAuth.JWT.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseAuth.JWT.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseAuth.JWT.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseAuth.JWT.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseAuth.JWT.FirebasePayload: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseAuth.JWT.FirebasePayload.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseAuth.JWT.FirebasePayload.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseAuth.JWT.FirebasePayload.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseAuth.JWT.FirebasePayload.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseAuth.JWT.FirebasePayload.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseAuth.AuthProviderID: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseAuth.GameCenterAuthProvider: FirebaseAuth.WarningWorkaround {}
extension FirebaseAuth.AuthBackend: FirebaseAuth.AuthBackendProtocol {}
extension FirebaseAuth.AuthBackendRPCIssuer: FirebaseAuth.AuthBackendRPCIssuerProtocol {}
extension FirebaseAuth.CreateAuthURIRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.CreateAuthURIResponse
}
extension FirebaseAuth.CreateAuthURIResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.DeleteAccountRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.DeleteAccountResponse
}
extension FirebaseAuth.DeleteAccountResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.EmailLinkSignInRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.EmailLinkSignInResponse
}
extension FirebaseAuth.EmailLinkSignInResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.EmailLinkSignInResponse: FirebaseAuth.AuthMFAResponse {}
extension FirebaseAuth.GetAccountInfoRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.GetAccountInfoResponse
}
extension FirebaseAuth.GetAccountInfoResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.GetOOBConfirmationCodeRequestType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseAuth.GetOOBConfirmationCodeRequestType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseAuth.GetOOBConfirmationCodeRequestType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseAuth.GetOOBConfirmationCodeRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.GetOOBConfirmationCodeResponse
}
extension FirebaseAuth.GetOOBConfirmationCodeResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.GetProjectConfigRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.GetProjectConfigResponse
}
extension FirebaseAuth.GetProjectConfigResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.GetRecaptchaConfigRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.GetRecaptchaConfigResponse
}
extension FirebaseAuth.GetRecaptchaConfigResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.FinalizeMFAEnrollmentRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.FinalizeMFAEnrollmentResponse
}
extension FirebaseAuth.FinalizeMFAEnrollmentResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.StartMFAEnrollmentRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.StartMFAEnrollmentResponse
}
extension FirebaseAuth.StartMFAEnrollmentResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.FinalizeMFASignInRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.FinalizeMFAEnrollmentResponse
}
extension FirebaseAuth.StartMFASignInRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.StartMFASignInResponse
}
extension FirebaseAuth.StartMFASignInResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.WithdrawMFARequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.WithdrawMFAResponse
}
extension FirebaseAuth.WithdrawMFAResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.AuthProtoMFAEnrollment: FirebaseAuth.AuthProto {}
extension FirebaseAuth.AuthProtoFinalizeMFAPhoneRequestInfo: FirebaseAuth.AuthProto {}
extension FirebaseAuth.AuthProtoFinalizeMFAPhoneResponseInfo: FirebaseAuth.AuthProto {}
extension FirebaseAuth.AuthProtoStartMFAPhoneRequestInfo: FirebaseAuth.AuthProto {}
extension FirebaseAuth.AuthProtoStartMFAPhoneResponseInfo: FirebaseAuth.AuthProto {}
extension FirebaseAuth.AuthProtoStartMFATOTPEnrollmentRequestInfo: FirebaseAuth.AuthProto {}
extension FirebaseAuth.AuthProtoStartMFATOTPEnrollmentResponseInfo: FirebaseAuth.AuthProto {}
extension FirebaseAuth.AuthProtoFinalizeMFATOTPEnrollmentRequestInfo: FirebaseAuth.AuthProto {}
extension FirebaseAuth.AuthProtoFinalizeMFATOTPSignInRequestInfo: FirebaseAuth.AuthProto {}
extension FirebaseAuth.AuthProtoFinalizeMFATOTPEnrollmentResponseInfo: FirebaseAuth.AuthProto {}
extension FirebaseAuth.ResetPasswordRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.ResetPasswordResponse
}
extension FirebaseAuth.ResetPasswordResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.RevokeTokenRequest.TokenType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseAuth.RevokeTokenRequest.TokenType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseAuth.RevokeTokenRequest.TokenType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseAuth.RevokeTokenRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.RevokeTokenResponse
}
extension FirebaseAuth.RevokeTokenResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.SecureTokenRequestGrantType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseAuth.SecureTokenRequestGrantType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseAuth.SecureTokenRequestGrantType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseAuth.SecureTokenRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.SecureTokenResponse
}
extension FirebaseAuth.SecureTokenResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.CodeIdentity: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseAuth.SendVerificationCodeRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.SendVerificationCodeResponse
}
extension FirebaseAuth.SendVerificationCodeResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.SetAccountInfoRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.SetAccountInfoResponse
}
extension FirebaseAuth.SetAccountInfoResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.SignInWithGameCenterRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.SignInWithGameCenterResponse
}
extension FirebaseAuth.SignInWithGameCenterResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.SignUpNewUserRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.SignUpNewUserResponse
}
extension FirebaseAuth.SignUpNewUserResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.VerifyAssertionRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.VerifyAssertionResponse
}
extension FirebaseAuth.VerifyAssertionResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.VerifyAssertionResponse: FirebaseAuth.AuthMFAResponse {}
extension FirebaseAuth.VerifyCustomTokenRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.VerifyCustomTokenResponse
}
extension FirebaseAuth.VerifyCustomTokenResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.VerifyPasswordRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.VerifyPasswordResponse
}
extension FirebaseAuth.VerifyPasswordResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.VerifyPasswordResponse: FirebaseAuth.AuthMFAResponse {}
extension FirebaseAuth.VerifyPhoneNumberRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.VerifyPhoneNumberResponse
}
extension FirebaseAuth.VerifyPhoneNumberResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.VerifyClientRequest: FirebaseAuth.AuthRPCRequest {
    typealias Response = FirebaseAuth.VerifyClientResponse
}
extension FirebaseAuth.VerifyClientResponse: FirebaseAuth.AuthRPCResponse {}
extension FirebaseAuth.AuthKeychainStorageReal: FirebaseAuth.AuthKeychainStorage {}
extension FirebaseAuth.SecureTokenServiceInternal: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension FirebaseAuth.UserProfileUpdate: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension FirebaseAuth.AuthErrorCode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseAuth.AuthErrorCode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseAuth.AuthErrorCode: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseAuth.AuthErrorCode: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseAuth.AuthErrorCode: Foundation._BridgedNSError {
    static var _nsErrorDomain: Swift.String {
        get
    }
}
extension FirebaseAuth.AuthErrorCode: Foundation._ObjectiveCBridgeableError {
    init?(_bridgedNSError: )
}
extension FirebaseFunctions.StreamResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseFunctions.StreamResponse: FirebaseFunctions.StreamResponseProtocol {}
extension FirebaseFunctions.StreamResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseFunctions.StreamResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseFunctions.StreamResponse.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseFunctions.StreamResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFunctions.StreamResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFunctions.StreamResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseFunctions.Callable.CallableError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFunctions.Callable.CallableError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFunctions.Callable.CallableError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseFunctions.Callable<>.StreamResponseMessage: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseFunctions.Callable<>.StreamResponseMessage.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseFunctions.Callable<>.StreamResponseMessage.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseFunctions.Callable<>.StreamResponseMessage.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFunctions.Callable<>.StreamResponseMessage.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFunctions.Callable<>.StreamResponseMessage.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseFunctions.FunctionsErrorCode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseFunctions.FunctionsErrorCode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseFunctions.FunctionsErrorCode: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseFunctions.FunctionsError: Foundation.CustomNSError {
    var errorUserInfo: [Swift.String : Any] {
        get
    }
    var errorCode: Swift.Int {
        get
    }

    static var errorDomain: Swift.String {
        get
    }
}
extension FirebaseFunctions.FunctionsError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseFunctions.FunctionsSerializer.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseStorage.StorageFetcherService: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension FirebaseStorage.StoragePathError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseStorage.StoragePath: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseStorage.StorageTaskState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseStorage.StorageTaskState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseStorage.StorageTaskStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseStorage.StorageTaskStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseStorage.StorageTaskStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseStorage.StorageErrorCode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseStorage.StorageErrorCode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseStorage.StorageErrorCode: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseStorage.StorageErrorCode: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseStorage.StorageErrorCode: Foundation._BridgedNSError {
    static var _nsErrorDomain: Swift.String {
        get
    }
}
extension FirebaseStorage.StorageErrorCode: Foundation._ObjectiveCBridgeableError {
    init?(_bridgedNSError: )
}
extension FirebaseStorage.StorageError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseStorage.StorageError: Foundation.CustomNSError {
    var errorUserInfo: [Swift.String : Any] {
        get
    }
    var errorCode: Swift.Int {
        get
    }

    static var errorDomain: Swift.String {
        get
    }
}
extension FirebaseStorage.StorageMetadata.StorageMetadataType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseStorage.StorageMetadata.StorageMetadataType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth2.AuthError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth2.AuthError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth2.AuthError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension OAuth2.BrowserTokenProvider: OAuth2.TokenProvider {}
extension OAuth2.Credentials: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension OAuth2.Credentials: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension OAuth2.Credentials.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OAuth2.Credentials.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OAuth2.Credentials.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension OAuth2.Credentials.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth2.Credentials.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth2.Credentials.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension OAuth2.DefaultTokenProvider: OAuth2.TokenProvider {}
extension OAuth2.GoogleCloudMetadataTokenProvider: OAuth2.TokenProvider {}
extension OAuth2.GoogleRefreshTokenProvider: OAuth2.TokenProvider {}
extension OAuth2.OAuth2RefreshCredentials: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension OAuth2.OAuth2RefreshCredentials: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension OAuth2.OAuth2RefreshCredentials.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OAuth2.OAuth2RefreshCredentials.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OAuth2.OAuth2RefreshCredentials.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension OAuth2.OAuth2RefreshCredentials.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth2.OAuth2RefreshCredentials.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth2.OAuth2RefreshCredentials.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension OAuth2.ASN1Decoder.DERCode: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt8

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension OAuth2.ASN1Decoder.DERCode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth2.ASN1Decoder.DERCode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth2.JWTClaimSet: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension OAuth2.JWTClaimSet: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension OAuth2.JWTClaimSet.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OAuth2.JWTClaimSet.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OAuth2.JWTClaimSet.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension OAuth2.JWTClaimSet.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth2.JWTClaimSet.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth2.JWTClaimSet.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension OAuth2.JWTHeader: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension OAuth2.JWTHeader: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension OAuth2.JWTHeader.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OAuth2.JWTHeader.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OAuth2.JWTHeader.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension OAuth2.JWTHeader.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth2.JWTHeader.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth2.JWTHeader.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension OAuth2.ServiceAccountTokenProvider: OAuth2.TokenProvider {}
extension OAuth2.ServiceAccountCredentials: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension OAuth2.ServiceAccountCredentials: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension OAuth2.ServiceAccountCredentials.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OAuth2.ServiceAccountCredentials.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OAuth2.ServiceAccountCredentials.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension OAuth2.ServiceAccountCredentials.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth2.ServiceAccountCredentials.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth2.ServiceAccountCredentials.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension OAuth2.Token: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension OAuth2.Token: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension OAuth2.Token.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension OAuth2.Token.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension OAuth2.Token.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension OAuth2.Token.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension OAuth2.Token.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension OAuth2.Token.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension BigInt.BigInt.Sign: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension BigInt.BigInt.Sign: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension BigInt.BigInt: Swift.SignedInteger {
    static func _maskingAdd(_: Self, _: Self) -> Self
    static func _maskingSubtract(_: Self, _: Self) -> Self
}
extension BigInt.BigInt: Swift.BinaryInteger {
    typealias Words = BigInt.BigInt.Words

    init?<A1>(exactly: A1) where A1: Swift.BinaryFloatingPoint
    init<A1>(_: A1) where A1: Swift.BinaryFloatingPoint
    init<A1>(_: A1) where A1: Swift.BinaryInteger
    init<A1>(truncatingIfNeeded: A1) where A1: Swift.BinaryInteger
    init<A1>(clamping: A1) where A1: Swift.BinaryInteger

    var words: Self.Words {
        get
    }
    var trailingZeroBitCount: Swift.Int {
        get
    }
    var bitWidth: Swift.Int {
        get
    }
    var _lowWord: Swift.UInt {
        get
    }

    func _binaryLogarithm() -> Swift.Int
    func quotientAndRemainder(dividingBy: Self) -> (quotient: Self, remainder: Self)
    func isMultiple(of: Self) -> Swift.Bool
    func signum() -> Self

    static var isSigned: Swift.Bool {
        get
    }

    static func / (_: Self, _: Self) -> Self
    static func /= (_: inout Self, _: Self)
    static func % (_: Self, _: Self) -> Self
    static func %= (_: inout Self, _: Self)
    static func ~ (_: Self) -> Self
    static func & (_: Self, _: Self) -> Self
    static func &= (_: inout Self, _: Self)
    static func | (_: Self, _: Self) -> Self
    static func |= (_: inout Self, _: Self)
    static func ^ (_: Self, _: Self) -> Self
    static func ^= (_: inout Self, _: Self)
    static func >> <A1>(_: Self, _: A1) -> Self where A1: Swift.BinaryInteger
    static func >>= <A1>(_: inout Self, _: A1) where A1: Swift.BinaryInteger
    static func << <A1>(_: Self, _: A1) -> Self where A1: Swift.BinaryInteger
    static func <<= <A1>(_: inout Self, _: A1) where A1: Swift.BinaryInteger
}
extension BigInt.BigInt: Swift.SignedNumeric {
    func negate()

    static func - (_: Self) -> Self
}
extension BigInt.BigInt: Swift.Numeric {
    typealias Magnitude = BigInt.BigUInt

    init?<A1>(exactly: A1) where A1: Swift.BinaryInteger

    var magnitude: Self.Magnitude {
        get
    }

    static func * (_: Self, _: Self) -> Self
    static func *= (_: inout Self, _: Self)
}
extension BigInt.BigInt: Swift.AdditiveArithmetic {
    static var zero: Self {
        get
    }

    static func + (_: Self, _: Self) -> Self
    static func += (_: inout Self, _: Self)
    static func - (_: Self, _: Self) -> Self
    static func -= (_: inout Self, _: Self)
}
extension BigInt.BigInt: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension BigInt.BigInt: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension BigInt.BigInt: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension BigInt.BigInt: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension BigInt.BigInt: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension BigInt.BigInt: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int64

    init(integerLiteral: Self.IntegerLiteralType)
}
extension BigInt.BigInt: Swift.Strideable {
    typealias Stride = BigInt.BigInt

    func distance(to: Self) -> Self.Stride
    func advanced(by: Self.Stride) -> Self

    static func _step(after: (index: Swift.Int?, value: Self), from: Self, by: Self.Stride) -> (index: Swift.Int?, value: Self)
}
extension BigInt.BigInt: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension BigInt.BigInt: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension BigInt.BigInt: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.Unicode.Scalar

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension BigInt.BigInt: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension BigInt.BigInt: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension BigInt.BigInt: Swift.CustomPlaygroundDisplayConvertible {
    var playgroundDescription: Any {
        get
    }
}
extension BigInt.BigUInt: Swift.UnsignedInteger {}
extension BigInt.BigUInt: Swift.BinaryInteger {
    typealias Words = BigInt.BigUInt.Words

    init?<A1>(exactly: A1) where A1: Swift.BinaryFloatingPoint
    init<A1>(_: A1) where A1: Swift.BinaryFloatingPoint
    init<A1>(_: A1) where A1: Swift.BinaryInteger
    init<A1>(truncatingIfNeeded: A1) where A1: Swift.BinaryInteger
    init<A1>(clamping: A1) where A1: Swift.BinaryInteger

    var words: Self.Words {
        get
    }
    var trailingZeroBitCount: Swift.Int {
        get
    }
    var bitWidth: Swift.Int {
        get
    }
    var _lowWord: Swift.UInt {
        get
    }

    func _binaryLogarithm() -> Swift.Int
    func quotientAndRemainder(dividingBy: Self) -> (quotient: Self, remainder: Self)
    func isMultiple(of: Self) -> Swift.Bool
    func signum() -> Self

    static var isSigned: Swift.Bool {
        get
    }

    static func / (_: Self, _: Self) -> Self
    static func /= (_: inout Self, _: Self)
    static func % (_: Self, _: Self) -> Self
    static func %= (_: inout Self, _: Self)
    static func ~ (_: Self) -> Self
    static func & (_: Self, _: Self) -> Self
    static func &= (_: inout Self, _: Self)
    static func | (_: Self, _: Self) -> Self
    static func |= (_: inout Self, _: Self)
    static func ^ (_: Self, _: Self) -> Self
    static func ^= (_: inout Self, _: Self)
    static func >> <A1>(_: Self, _: A1) -> Self where A1: Swift.BinaryInteger
    static func >>= <A1>(_: inout Self, _: A1) where A1: Swift.BinaryInteger
    static func << <A1>(_: Self, _: A1) -> Self where A1: Swift.BinaryInteger
    static func <<= <A1>(_: inout Self, _: A1) where A1: Swift.BinaryInteger
}
extension BigInt.BigUInt: Swift.Numeric {
    typealias Magnitude = BigInt.BigUInt

    init?<A1>(exactly: A1) where A1: Swift.BinaryInteger

    var magnitude: Self.Magnitude {
        get
    }

    static func * (_: Self, _: Self) -> Self
    static func *= (_: inout Self, _: Self)
}
extension BigInt.BigUInt: Swift.AdditiveArithmetic {
    static var zero: Self {
        get
    }

    static func + (_: Self, _: Self) -> Self
    static func += (_: inout Self, _: Self)
    static func - (_: Self, _: Self) -> Self
    static func -= (_: inout Self, _: Self)
}
extension BigInt.BigUInt: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension BigInt.BigUInt: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension BigInt.BigUInt: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension BigInt.BigUInt: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension BigInt.BigUInt: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension BigInt.BigUInt: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.UInt64

    init(integerLiteral: Self.IntegerLiteralType)
}
extension BigInt.BigUInt: Swift.Strideable {
    typealias Stride = BigInt.BigInt

    func distance(to: Self) -> Self.Stride
    func advanced(by: Self.Stride) -> Self

    static func _step(after: (index: Swift.Int?, value: Self), from: Self, by: Self.Stride) -> (index: Swift.Int?, value: Self)
}
extension BigInt.BigUInt: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension BigInt.BigUInt: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension BigInt.BigUInt: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.Unicode.Scalar

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension BigInt.BigUInt: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension BigInt.BigUInt: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension BigInt.BigUInt: Swift.CustomPlaygroundDisplayConvertible {
    var playgroundDescription: Any {
        get
    }
}
extension BigInt.Units: Swift.Collection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<BigInt.Units<A, B>>
    typealias SubSequence = Swift.Slice<BigInt.Units<A, B>>
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension BigInt.Units: Swift.BidirectionalCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<BigInt.Units<A, B>>
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension BigInt.Units: Swift.RandomAccessCollection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<BigInt.Units<A, B>>
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension BigInt.Units: Swift.Sequence {
    typealias Element = A
    typealias Iterator = Swift.IndexingIterator<BigInt.Units<A, B>>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension BigInt.BigUInt.Words: Swift.RandomAccessCollection {
    typealias Element = Swift.UInt
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<BigInt.BigUInt.Words>
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension BigInt.BigUInt.Words: Swift.BidirectionalCollection {
    typealias Element = Swift.UInt
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<BigInt.BigUInt.Words>
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension BigInt.BigUInt.Words: Swift.Collection {
    typealias Element = Swift.UInt
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<BigInt.BigUInt.Words>
    typealias SubSequence = Swift.Slice<BigInt.BigUInt.Words>
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension BigInt.BigUInt.Words: Swift.Sequence {
    typealias Element = Swift.UInt
    typealias Iterator = Swift.IndexingIterator<BigInt.BigUInt.Words>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension BigInt.BigInt.Words: Swift.RandomAccessCollection {
    typealias Element = Swift.UInt
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<BigInt.BigInt.Words>
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension BigInt.BigInt.Words: Swift.BidirectionalCollection {
    typealias Element = Swift.UInt
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<BigInt.BigInt.Words>
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension BigInt.BigInt.Words: Swift.Collection {
    typealias Element = Swift.UInt
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<BigInt.BigInt.Words>
    typealias SubSequence = Swift.Slice<BigInt.BigInt.Words>
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension BigInt.BigInt.Words: Swift.Sequence {
    typealias Element = Swift.UInt
    typealias Iterator = Swift.IndexingIterator<BigInt.BigInt.Words>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension LocalLLMClientMLX.LLMUserInputProcessor: MLXLMCommon.UserInputProcessor {}
extension LocalLLMClientMLX.EmptyOutput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension LocalLLMClientMLX.EmptyOutput: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension LocalLLMClientMLX.EmptyInput: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension LocalLLMClientMLX.EmptyInput: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension LocalLLMClientMLX.EmptyInput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension LocalLLMClientMLX.EmptyInput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension LocalLLMClientMLX.EmptyInput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension LocalLLMClientMLX.EmptyOutput.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension LocalLLMClientMLX.EmptyOutput.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension LocalLLMClientMLX.EmptyOutput.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXLLM.LLMModelFactory: MLXLMCommon.ModelFactory {}
extension MLXLLM.TrampolineModelFactory: MLXLMCommon.ModelFactoryTrampoline {}
extension MLXLLM.LLMUserInputProcessor: MLXLMCommon.UserInputProcessor {}
extension MLXLLM.LoRADataError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension MLXLLM.LoRADataError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLXLLM.Line: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Line: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Line.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Line.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Line.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Line.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Line.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.LoRATrain.Progress: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.LoRATrain.ProgressDisposition: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.LoRATrain.ProgressDisposition: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.LoRABatchIterator: Swift.IteratorProtocol {
    typealias Element = (MLX.MLXArray, MLX.MLXArray, MLX.MLXArray)

    func next() -> Self.Element?
}
extension MLXLLM.LoRABatchIterator: Swift.Sequence {
    typealias Element = (MLX.MLXArray, MLX.MLXArray, MLX.MLXArray)
    typealias Iterator = MLXLLM.LoRABatchIterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension MLXLLM.BaichuanM1Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.BaichuanM1Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.BaichuanM1Model: MLXLLM.LLMModel {}
extension MLXLLM.BaichuanM1Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.BaichuanM1Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.BaichuanM1Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.BaichuanM1Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.BaichuanM1Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.BaichuanM1Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.BaichuanM1Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.BaichuanM1Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.BaichuanM1Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.MLP: MLXNN.UnaryLayer {}
extension MLXLLM.BailingMoeConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.BailingMoeConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.BailingMoeModel: MLXLLM.LLMModel {}
extension MLXLLM.BailingMoeModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.BailingMoeModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.BailingMoeModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.BailingMoeConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.BailingMoeConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.BailingMoeConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.BailingMoeConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.BailingMoeConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.BailingMoeConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.BailingMoeSparseMoeBlock: MLXNN.UnaryLayer {}
extension MLXLLM.BailingMoeGate: MLXNN.UnaryLayer {}
extension MLXLLM.BailingMoeMLP: MLXNN.UnaryLayer {}
extension MLXLLM.BitnetConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.BitnetConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.BitnetModel: MLXLLM.LLMModel {}
extension MLXLLM.BitnetModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.BitnetModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.BitnetModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.BitnetConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.BitnetConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.BitnetConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.BitnetConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.BitnetConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.BitnetConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.CohereModel: MLXLLM.LLMModel {}
extension MLXLLM.CohereModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.CohereModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.CohereModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.CohereConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.CohereConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.CohereConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.CohereConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.CohereConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.CohereConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.CohereConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.CohereConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.DeepseekV3Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.DeepseekV3Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.DeepseekV3Model: MLXLLM.LLMModel {}
extension MLXLLM.DeepseekV3Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.DeepseekV3Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.DeepseekV3Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.DeepseekV3Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.DeepseekV3Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.DeepseekV3Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.DeepseekV3Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.DeepseekV3Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.DeepseekV3Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.DeepseekV3MoE: MLXNN.UnaryLayer {}
extension MLXLLM.DeepseekV3MLP: MLXNN.UnaryLayer {}
extension MLXLLM.Ernie45Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Ernie45Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Ernie45Model: MLXLLM.LLMModel {}
extension MLXLLM.Ernie45Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.Ernie45Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.Ernie45Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.Ernie45Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Ernie45Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Ernie45Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Ernie45Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Ernie45Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Ernie45Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Exaone4Model: MLXLLM.LLMModel {}
extension MLXLLM.Exaone4Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.Exaone4Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.Exaone4Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.Exaone4Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Exaone4Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Exaone4Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Exaone4Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Exaone4Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Exaone4Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Exaone4Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Exaone4Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.FalconH1Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.FalconH1Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.FalconH1Model: MLXLLM.LLMModel {}
extension MLXLLM.FalconH1Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.FalconH1Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.FalconH1Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.FalconH1Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.FalconH1Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.FalconH1Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.FalconH1Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.FalconH1Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.FalconH1Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.GLM4Model: MLXLLM.LLMModel {}
extension MLXLLM.GLM4Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.GLM4Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.GLM4Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.GLM4Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.GLM4Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.GLM4Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.GLM4Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.GLM4Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.GLM4Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.GLM4Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.GLM4Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.GPTOSSConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.GPTOSSConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.GPTOSSModel: MLXLLM.LLMModel {}
extension MLXLLM.GPTOSSModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.GPTOSSModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.GPTOSSModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.GPTOSSConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.GPTOSSConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.GPTOSSConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.GPTOSSConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.GPTOSSConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.GPTOSSConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.GemmaModel: MLXLLM.LLMModel {}
extension MLXLLM.GemmaModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.GemmaModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.GemmaModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.GemmaConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.GemmaConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.GemmaConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.GemmaConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.GemmaConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.GemmaConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.GemmaConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.GemmaConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.RMSNorm: MLXNN.UnaryLayer {}
extension MLXLLM.Gemma2Model: MLXLLM.LLMModel {}
extension MLXLLM.Gemma2Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.Gemma2Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.Gemma2Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.Gemma2Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Gemma2Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Gemma2Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Gemma2Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Gemma2Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Gemma2Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Gemma2Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Gemma2Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Gemma3TextConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Gemma3TextConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Gemma3TextModel: MLXLLM.LLMModel {}
extension MLXLLM.Gemma3TextModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.Gemma3TextModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.Gemma3TextConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Gemma3TextConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Gemma3TextConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Gemma3TextConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Gemma3TextConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Gemma3TextConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Gemma3TextConfiguration.VLMCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Gemma3TextConfiguration.VLMCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Gemma3TextConfiguration.VLMCodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Gemma3TextConfiguration.VLMCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Gemma3TextConfiguration.VLMCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Gemma3TextConfiguration.VLMCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Gemma3nTextConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Gemma3nTextConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Gemma3nTextModel: MLXLLM.LLMModel {}
extension MLXLLM.Gemma3nTextModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.Gemma3nTextModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.Gemma3nTextConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Gemma3nTextConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Gemma3nTextConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Gemma3nTextConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Gemma3nTextConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Gemma3nTextConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Gemma3nTextConfiguration.VLMCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Gemma3nTextConfiguration.VLMCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Gemma3nTextConfiguration.VLMCodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Gemma3nTextConfiguration.VLMCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Gemma3nTextConfiguration.VLMCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Gemma3nTextConfiguration.VLMCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.GraniteModel: MLXLLM.LLMModel {}
extension MLXLLM.GraniteModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.GraniteModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.GraniteModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.GraniteConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.GraniteConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.GraniteConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.GraniteConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.GraniteConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.GraniteConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.GraniteConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.GraniteConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.GraniteMoeHybridModel: MLXLLM.LLMModel {}
extension MLXLLM.GraniteMoeHybridModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.GraniteMoeHybridModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.GraniteMoeHybridModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.GraniteMoeHybridConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.GraniteMoeHybridConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.GraniteMoeHybridConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.GraniteMoeHybridConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.GraniteMoeHybridConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.GraniteMoeHybridConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.GraniteMoeHybridConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.GraniteMoeHybridConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.GraniteMoeHybridLayerType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.GraniteMoeHybridLayerType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.GraniteMoeHybridMLP: MLXNN.UnaryLayer {}
extension MLXLLM.GraniteMoeHybridSharedMLP: MLXNN.UnaryLayer {}
extension MLXLLM.GraniteMoeHybridMoE: MLXNN.UnaryLayer {}
extension MLXLLM.InternLM2Model: MLXLLM.LLMModel {}
extension MLXLLM.InternLM2Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.InternLM2Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.InternLM2Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.InternLM2Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.InternLM2Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.InternLM2Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.InternLM2Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.InternLM2Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.InternLM2Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.InternLM2Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.InternLM2Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.LFM2Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.LFM2Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.LFM2Model: MLXLLM.LLMModel {}
extension MLXLLM.LFM2Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.LFM2Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.LFM2Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.LFM2Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.LFM2Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.LFM2Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.LFM2Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.LFM2Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.LFM2Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.LFM2MoEConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.LFM2MoEConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.LFM2MoEModel: MLXLLM.LLMModel {}
extension MLXLLM.LFM2MoEModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.LFM2MoEModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.LFM2MoEModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.LFM2MoEConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.LFM2MoEConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.LFM2MoEConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.LFM2MoEConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.LFM2MoEConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.LFM2MoEConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Lfm2MoeSparseMoeBlock: MLXNN.UnaryLayer {}
extension MLXLLM.Lille130mModel: MLXLLM.LLMModel {}
extension MLXLLM.Lille130mModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.Lille130mModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.Lille130mModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.Lille130mConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Lille130mConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Lille130mConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Lille130mConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Lille130mConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Lille130mConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Lille130mConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Lille130mConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Lille130mMLP: MLXNN.UnaryLayer {}
extension MLXLLM.LlamaModel: MLXLLM.LLMModel {}
extension MLXLLM.LlamaModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.LlamaModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.LlamaModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.LlamaConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.LlamaConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.LlamaConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.LlamaConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.LlamaConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.LlamaConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.LlamaConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.LlamaConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.MiMoModel: MLXLLM.LLMModel {}
extension MLXLLM.MiMoModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.MiMoModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.MiMoModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.MiMoConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.MiMoConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.MiMoConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.MiMoConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.MiMoConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.MiMoConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.MiMoConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.MiMoConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Olmo2Model: MLXLLM.LLMModel {}
extension MLXLLM.Olmo2Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.Olmo2Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.Olmo2Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.Olmo2Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Olmo2Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Olmo2Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Olmo2Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Olmo2Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Olmo2Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Olmo2Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Olmo2Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.OlmoEModel: MLXLLM.LLMModel {}
extension MLXLLM.OlmoEModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.OlmoEModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.OlmoEModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.OlmoEConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.OlmoEConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.OlmoEConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.OlmoEConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.OlmoEConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.OlmoEConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.OlmoEConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.OlmoEConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.OlmoeSparseMoeBlock: MLXNN.UnaryLayer {}
extension MLXLLM.OpenELMModel: MLXLLM.LLMModel {}
extension MLXLLM.OpenELMModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.OpenELMModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.OpenELMModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.OpenElmConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.OpenElmConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.OpenElmConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.OpenElmConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.OpenElmConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.OpenElmConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.OpenElmConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.OpenElmConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.FeedForwardNetwork: MLXNN.UnaryLayer {}
extension MLXLLM.PhiModel: MLXLLM.LLMModel {}
extension MLXLLM.PhiModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.PhiModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.PhiModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.PhiConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.PhiConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.PhiConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.PhiConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.PhiConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.PhiConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.PhiConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.PhiConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.PhiMLP: MLXNN.UnaryLayer {}
extension MLXLLM.Phi3Model: MLXLLM.LLMModel {}
extension MLXLLM.Phi3Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.Phi3Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.Phi3Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.Phi3Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Phi3Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Phi3Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Phi3Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Phi3Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Phi3Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Phi3Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Phi3Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.RopeScalingWithFactorArrays: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.RopeScalingWithFactorArrays: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.RopeScalingWithFactorArrays.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.RopeScalingWithFactorArrays.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.RopeScalingWithFactorArrays.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.RopeScalingWithFactorArrays.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.RopeScalingWithFactorArrays.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.RopeScalingWithFactorArrays.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.PhiMoEConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.PhiMoEConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.PhiMoEModel: MLXLLM.LLMModel {}
extension MLXLLM.PhiMoEModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.PhiMoEModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.PhiMoEModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.PhiMoEConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.PhiMoEConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.PhiMoEConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.PhiMoEConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.PhiMoEConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.PhiMoEConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Qwen2Model: MLXLLM.LLMModel {}
extension MLXLLM.Qwen2Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.Qwen2Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.Qwen2Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.Qwen2Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Qwen2Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Qwen2Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Qwen2Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Qwen2Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Qwen2Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Qwen2Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Qwen2Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Qwen3Model: MLXLLM.LLMModel {}
extension MLXLLM.Qwen3Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.Qwen3Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.Qwen3Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.Qwen3Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Qwen3Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Qwen3Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Qwen3Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Qwen3Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Qwen3Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Qwen3Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Qwen3Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Qwen3MoEModel: MLXLLM.LLMModel {}
extension MLXLLM.Qwen3MoEModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.Qwen3MoEModel: MLXLMCommon.LanguageModel {}
extension MLXLLM.Qwen3MoEModel: MLXLMCommon.LoRAModel {}
extension MLXLLM.Qwen3MoEConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Qwen3MoEConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Qwen3MoEConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Qwen3MoEConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Qwen3MoEConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Qwen3MoEConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Qwen3MoEConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Qwen3MoEConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.Qwen3MoESparseMoeBlock: MLXNN.UnaryLayer {}
extension MLXNN.RoPE: MLXLLM.PositionEmbedding {}
extension MLXNN.RoPE: MLXNN.UnaryLayer {}
extension MLXLLM.SmolLM3Model: MLXLLM.LLMModel {}
extension MLXLLM.SmolLM3Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.SmolLM3Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.SmolLM3Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.SmolLM3Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.SmolLM3Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.SmolLM3Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.SmolLM3Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.SmolLM3Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.SmolLM3Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.SmolLM3Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.SmolLM3Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.NoPE: MLXLLM.PositionEmbedding {}
extension MLXLLM.Starcoder2Model: MLXLLM.LLMModel {}
extension MLXLLM.Starcoder2Model: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXLLM.Starcoder2Model: MLXLMCommon.LanguageModel {}
extension MLXLLM.Starcoder2Model: MLXLMCommon.LoRAModel {}
extension MLXLLM.Starcoder2Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLLM.Starcoder2Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLLM.Starcoder2Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLLM.Starcoder2Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLLM.Starcoder2Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLLM.Starcoder2Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLLM.Starcoder2Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLLM.Starcoder2Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXLLM.QuantizedSwitchLinear: MLXNN.Quantized {}
extension MLXLLM.SwitchLinear: MLXNN.Quantizable {}
extension __C.mlx_dtype_: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.mlx_dtype_: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.DType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.DType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLX.DType: Swift.CaseIterable {
    typealias AllCases = [MLX.DType]

    static var allCases: Self.AllCases {
        get
    }
}
extension MLX.DType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLX.DType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLX.DType: MLX.KernelTemplateArg {}
extension ComplexModule.Complex: MLX.HasDType where A == Swift.Float {}
extension ComplexModule.Complex: MLX.ScalarOrArray where A == Swift.Float {}
extension ComplexModule.Complex: Swift.AdditiveArithmetic {
    static var zero: Self {
        get
    }

    static func + (_: Self, _: Self) -> Self
    static func += (_: inout Self, _: Self)
    static func - (_: Self, _: Self) -> Self
    static func -= (_: inout Self, _: Self)
}
extension ComplexModule.Complex: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension ComplexModule.Complex: RealModule.AlgebraicField {}
extension ComplexModule.Complex: Swift.SignedNumeric {
    func negate()

    static func - (_: Self) -> Self
}
extension ComplexModule.Complex: Swift.Decodable where A: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension ComplexModule.Complex: Swift.Encodable where A: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension ComplexModule.Complex: RealModule.ElementaryFunctions {}
extension ComplexModule.Complex: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension ComplexModule.Complex: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = A.ExpressibleByIntegerLiteral.IntegerLiteralType

    init(integerLiteral: Self.IntegerLiteralType)
}
extension ComplexModule.Complex: Swift.Numeric {
    typealias Magnitude = A

    init?<A1>(exactly: A1) where A1: Swift.BinaryInteger

    var magnitude: Self.Magnitude {
        get
    }

    static func * (_: Self, _: Self) -> Self
    static func *= (_: inout Self, _: Self)
}
extension ComplexModule.Complex: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension ComplexModule.Complex: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLX.MLXArray: MLX.ScalarOrArray {}
extension MLX.MLXArray: Swift.Sequence {
    typealias Element = MLX.MLXArray
    typealias Iterator = MLX.MLXArray.MLXArrayIterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension MLX.MLXArray: MLX.MLXArrayIndex {}
extension MLX.MLXArray: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Swift.Int32

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension MLX.MLXArray: MLX.Updatable {}
extension MLX.MLXArray: MLX.Evaluatable {}
extension MLX.MLXArray: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLX.MLXArray: MLX.RandomStateOrKey {}
extension MLX.DeviceType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.DeviceType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLX.DeviceType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLX.Device: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.Device: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLX.MLXError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLX.GPU.Snapshot: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLX.GPU.Snapshot: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLX.GPU.Snapshot: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLX.GPU.Snapshot.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLX.GPU.Snapshot.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLX.GPU.Snapshot.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLX.GPU.Snapshot.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.GPU.Snapshot.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLX.LoadSaveError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLX.LoadSaveError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension MLX.MLXLinalg.NormKind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.MLXLinalg.NormKind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLX.MLXLinalg.NormKind: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLX.MLXArray.AccessMethod: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.MLXArray.AccessMethod: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLX.MLXArrayIndexOperation: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLX.MLXEllipsisIndex: MLX.MLXArrayIndex {}
extension MLX.MLXNewAxisIndex: MLX.MLXArrayIndex {}
extension MLX.MLXSlice: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.MLXSlice: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLX.MLXSlice: MLX.MLXArrayIndex {}
extension Swift.Range: MLX.MLXArrayIndex where A == Swift.Int {}
extension Swift.ClosedRange: MLX.MLXArrayIndex where A == Swift.Int {}
extension Swift.PartialRangeUpTo: MLX.MLXArrayIndex where A == Swift.Int {}
extension Swift.PartialRangeThrough: MLX.MLXArrayIndex where A == Swift.Int {}
extension Swift.PartialRangeFrom: MLX.MLXArrayIndex where A == Swift.Int {}
extension MLX.MLXArray.MLXArrayIterator: Swift.IteratorProtocol {
    typealias Element = MLX.MLXArray

    func next() -> Self.Element?
}
extension MLX.NestedItem: MLX.IndentedDescription {}
extension MLX.NestedItem: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLX.NestedItem: Swift.Equatable where B: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.NestedDictionary: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLX.NestedDictionary: Swift.Equatable where B: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.NestedDictionary: Swift.Collection {
    typealias Element = (key: A, value: MLX.NestedItem<A, B>)
    typealias Index = [A : MLX.NestedItem<A, B>].Index
    typealias Iterator = Swift.IndexingIterator<MLX.NestedDictionary<A, B>>
    typealias SubSequence = Swift.Slice<MLX.NestedDictionary<A, B>>
    typealias Indices = Swift.DefaultIndices<MLX.NestedDictionary<A, B>>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension MLX.NestedDictionary: Swift.Sequence {
    typealias Element = (key: A, value: MLX.NestedItem<A, B>)
    typealias Iterator = Swift.IndexingIterator<MLX.NestedDictionary<A, B>>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension MLX.ConvolveMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.ConvolveMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLX.MeshGridIndexing: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.MeshGridIndexing: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLX.MeshGridIndexing: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLX.PadMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.PadMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLX.PadMode: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLX.IntOrPair: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int

    init(integerLiteral: Self.IntegerLiteralType)
}
extension MLX.IntOrPair: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Swift.Int

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension MLX.IntOrTriple: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int

    init(integerLiteral: Self.IntegerLiteralType)
}
extension MLX.IntOrTriple: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Swift.Int

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension MLX.IntOrArray: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int

    init(integerLiteral: Self.IntegerLiteralType)
}
extension MLX.IntOrArray: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Swift.Int

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension MLX.FloatOrArray: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Float

    init(floatLiteral: Self.FloatLiteralType)
}
extension MLX.FloatOrArray: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = Swift.Float

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension MLX.MLXRandom.RandomState: MLX.RandomStateOrKey {}
extension MLX.MLXRandom.RandomState: MLX.Updatable {}
extension MLX.MLXRandom.RandomState: MLX.Evaluatable {}
extension MLX.StreamOrDevice: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLX.StreamOrDevice: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.Stream: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLX.Stream: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Swift.Float80: RealModule.Real {}
extension Swift.Float80: RealModule.RealFunctions {}
extension Swift.Float80: RealModule.AlgebraicField {}
extension Swift.Float80: RealModule.ElementaryFunctions {}
extension MLXNN.GLU: MLXNN.UnaryLayer {}
extension MLXNN.Sigmoid: MLXNN.UnaryLayer {}
extension MLXNN.Mish: MLXNN.UnaryLayer {}
extension MLXNN.ReLU: MLXNN.UnaryLayer {}
extension MLXNN.LeakyReLU: MLXNN.UnaryLayer {}
extension MLXNN.ReLU6: MLXNN.UnaryLayer {}
extension MLXNN.ReLUSquared: MLXNN.UnaryLayer {}
extension MLXNN.SoftMax: MLXNN.UnaryLayer {}
extension MLXNN.Softmax: MLXNN.UnaryLayer {}
extension MLXNN.SoftPlus: MLXNN.UnaryLayer {}
extension MLXNN.Softplus: MLXNN.UnaryLayer {}
extension MLXNN.SoftSign: MLXNN.UnaryLayer {}
extension MLXNN.Softsign: MLXNN.UnaryLayer {}
extension MLXNN.CELU: MLXNN.UnaryLayer {}
extension MLXNN.SiLU: MLXNN.UnaryLayer {}
extension MLXNN.LogSoftMax: MLXNN.UnaryLayer {}
extension MLXNN.LogSoftmax: MLXNN.UnaryLayer {}
extension MLXNN.LogSigmoid: MLXNN.UnaryLayer {}
extension MLXNN.PReLU: MLXNN.UnaryLayer {}
extension MLXNN.GELU.Approximation: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXNN.GELU.Approximation: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXNN.GELU: MLXNN.UnaryLayer {}
extension MLXNN.Tanh: MLXNN.UnaryLayer {}
extension MLXNN.HardSwish: MLXNN.UnaryLayer {}
extension MLXNN.Step: MLXNN.UnaryLayer {}
extension MLXNN.SELU: MLXNN.UnaryLayer {}
extension MLXNN.Sequential: MLXNN.UnaryLayer {}
extension MLXNN.Conv1d: MLXNN.UnaryLayer {}
extension MLXNN.Conv2d: MLXNN.UnaryLayer {}
extension MLXNN.Conv3d: MLXNN.UnaryLayer {}
extension MLXNN.ConvTransposed1d: MLXNN.UnaryLayer {}
extension MLXNN.ConvTransposed2d: MLXNN.UnaryLayer {}
extension MLXNN.ConvTransposed3d: MLXNN.UnaryLayer {}
extension MLXNN.Dropout: MLXNN.UnaryLayer {}
extension MLXNN.Dropout2d: MLXNN.UnaryLayer {}
extension MLXNN.Dropout3d: MLXNN.UnaryLayer {}
extension MLXNN.Embedding: MLXNN.UnaryLayer {}
extension MLXNN.Embedding: MLXNN.Quantizable {}
extension MLXNN.Identity: MLXNN.UnaryLayer {}
extension MLXNN.Linear: MLXNN.UnaryLayer {}
extension MLXNN.Linear: MLXNN.Quantizable {}
extension MLXNN.LossReduction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXNN.LossReduction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXNN.LossReduction: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXNN.Module.VerifyUpdate: Swift.OptionSet {
    typealias Element = MLXNN.Module.VerifyUpdate

    init(rawValue: Self.RawValue)
}
extension MLXNN.Module.VerifyUpdate: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXNN.Module.VerifyUpdate: Swift.SetAlgebra {
    typealias Element = MLXNN.Module.VerifyUpdate

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension MLXNN.Module.VerifyUpdate: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXNN.Module.VerifyUpdate: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = MLXNN.Module.VerifyUpdate

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension MLXNN.Module: MLX.IndentedDescription {}
extension MLXNN.Module: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXNN.Module: MLX.Updatable {}
extension MLXNN.Module: MLX.Evaluatable {}
extension MLXNN.ModuleInfo: MLXNN.TypeErasedSetterProvider {}
extension MLXNN.UpdateError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension MLXNN.UpdateError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLXNN.ModuleInfo.Setter: MLXNN.TypeErasedSetter {}
extension MLXNN.InstanceNorm: MLXNN.UnaryLayer {}
extension MLXNN.LayerNorm: MLXNN.UnaryLayer {}
extension MLXNN.RMSNorm: MLXNN.UnaryLayer {}
extension MLXNN.GroupNorm: MLXNN.UnaryLayer {}
extension MLXNN.BatchNorm: MLXNN.UnaryLayer {}
extension MLXNN.Pool: MLXNN.UnaryLayer {}
extension MLXNN.SinusoidalPositionalEncoding: MLXNN.UnaryLayer {}
extension MLXNN.ALiBi.Key: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXNN.ALiBi.Key: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXNN.QuantizedEmbedding: MLXNN.Quantized {}
extension MLXNN.QuantizedLinear: MLXNN.Quantized {}
extension MLXNN.Upsample: MLXNN.UnaryLayer {}
extension MLXOptimizers.OptimizerBase: MLXOptimizers.Optimizer {}
extension MLXOptimizers.OptimizerBase: MLX.Updatable {}
extension MLXOptimizers.OptimizerBase: MLX.Evaluatable {}
extension MLXOptimizers.TupleState: MLX.Updatable {}
extension MLXOptimizers.Adafactor.State: MLX.Updatable {}
extension MLXLMCommon.DoRALinear: MLXLMCommon.LoRALayer {}
extension MLXLMCommon.QDoRALinear: MLXLMCommon.LoRALayer {}
extension MLXLMCommon.LoRALinear: MLXLMCommon.LoRALayer {}
extension MLXLMCommon.QLoRALinear: MLXLMCommon.LoRALayer {}
extension MLXLMCommon.LoRAConfiguration.FineTuneType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.LoRAConfiguration.FineTuneType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.LoRAConfiguration.FineTuneType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLMCommon.LoRAConfiguration.FineTuneType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.LoRAConfiguration.FineTuneType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLMCommon.LoRAConfiguration.LoRAParameters: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.LoRAConfiguration.LoRAParameters: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLMCommon.LoRAConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.LoRAConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLMCommon.LoRAContainer: MLXLMCommon.ModelAdapter {}
extension MLXLMCommon.LoRAConfiguration.LoRAParameters.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLMCommon.LoRAConfiguration.LoRAParameters.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLMCommon.LoRAConfiguration.LoRAParameters.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.LoRAConfiguration.LoRAParameters.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.LoRAConfiguration.LoRAParameters.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXLMCommon.LoRAConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLMCommon.LoRAConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLMCommon.LoRAConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLMCommon.LoRAConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.LoRAConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.LoRAConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXLMCommon.ModelAdapterError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLXLMCommon.ModelAdapterBaseConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.ModelAdapterBaseConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLMCommon.ModelAdapterBaseConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLMCommon.ModelAdapterBaseConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLMCommon.ModelAdapterBaseConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.ModelAdapterBaseConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.ModelAdapterBaseConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.Quantization: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.BaseConfiguration.Quantization: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLMCommon.BaseConfiguration.Quantization: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.BaseConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.BaseConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLMCommon.BaseConfiguration.Quantization.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.Quantization.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.Quantization.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.Quantization.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.BaseConfiguration.Quantization.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.BaseConfiguration.Quantization.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.BaseConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.BaseConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.QuantizationContainer: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.BaseConfiguration.QuantizationContainer: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLMCommon.BaseConfiguration.QuantizationContainer._DictionaryCodingKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.QuantizationContainer._DictionaryCodingKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLMCommon.BaseConfiguration.QuantizationContainer._DictionaryCodingKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXLMCommon.Chat.Message.Role: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.Chat.Message.Role: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.Chat.Message.Role: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXLMCommon.DefaultMessageGenerator: MLXLMCommon.MessageGenerator {}
extension MLXLMCommon.NoSystemMessageGenerator: MLXLMCommon.MessageGenerator {}
extension MLXLMCommon.ArgMaxSampler: MLXLMCommon.LogitSampler {}
extension MLXLMCommon.TopPSampler: MLXLMCommon.LogitSampler {}
extension MLXLMCommon.CategoricalSampler: MLXLMCommon.LogitSampler {}
extension MLXLMCommon.RepetitionContext: MLXLMCommon.LogitProcessor {}
extension MLXLMCommon.TokenIterator: Swift.Sequence {
    typealias Element = Swift.Int
    typealias Iterator = MLXLMCommon.TokenIterator

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension MLXLMCommon.TokenIterator: Swift.IteratorProtocol {
    typealias Element = Swift.Int

    func next() -> Self.Element?
}
extension MLXLMCommon.GenerateDisposition: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.GenerateDisposition: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.BaseKVCache: MLXLMCommon.KVCache {}
extension MLXLMCommon.BaseKVCache: MLX.Evaluatable {}
extension MLXLMCommon.KVCacheSimple: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLMCommon.RotatingKVCache: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLMCommon.QuantizedKVCache: MLXLMCommon.QuantizedKVCacheProtocol {}
extension MLXLMCommon.KVCacheError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLXLMCommon.ModelConfiguration: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.ModelConfiguration.Identifier: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.ModelContainer: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension MLXLMCommon.ModelFactoryError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension MLXLMCommon.ModelFactoryError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLXLMCommon.Gemma.RMSNorm: MLXNN.UnaryLayer {}
extension MLXLMCommon.StringOrNumber: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.StringOrNumber: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLMCommon.StringOrNumber: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.NaiveStreamingDetokenizer: MLXLMCommon.StreamingDetokenizer {}
extension MLXLMCommon.NaiveStreamingDetokenizer: Swift.IteratorProtocol {
    typealias Element = Swift.String

    func next() -> Self.Element?
}
extension MLXLMCommon.TokenizerError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLXLMCommon.Tool: MLXLMCommon.ToolProtocol {}
extension MLXLMCommon.ToolCall.Function: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.ToolCall.Function: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.ToolCall.Function: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLMCommon.ToolCall.Function: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.ToolCall: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.ToolCall: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.ToolCall: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLMCommon.ToolCall: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.ToolError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLXLMCommon.ToolError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension MLXLMCommon.ToolCall.Function.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLMCommon.ToolCall.Function.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLMCommon.ToolCall.Function.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.ToolCall.Function.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.ToolCall.Function.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXLMCommon.ToolCall.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLMCommon.ToolCall.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXLMCommon.ToolCall.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.ToolCall.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.ToolCall.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXLMCommon.ToolCallProcessor.State: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.ToolCallProcessor.State: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.JSONValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXLMCommon.JSONValue: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXLMCommon.JSONValue: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXLMCommon.JSONValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXLMCommon.UserInput.Prompt: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXLMCommon.StandInUserInputProcessor: MLXLMCommon.UserInputProcessor {}
extension MLXLMCommon.UserInputError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension MLXLMCommon.UserInputError: Swift.Error {
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension __C.CIImage.ResamplingMethod: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.CIImage.ResamplingMethod: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Gemma3TextConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Gemma3TextConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Gemma3VisionConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Gemma3VisionConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.QuantizationConfig: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.QuantizationConfig: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Gemma3Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Gemma3Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Gemma3: MLXVLM.VLMModel {}
extension MLXVLM.Gemma3: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXVLM.Gemma3: MLXLMCommon.LanguageModel {}
extension MLXVLM.Gemma3: MLXLMCommon.LoRAModel {}
extension MLXVLM.Gemma3Processor: MLXLMCommon.UserInputProcessor {}
extension MLXVLM.Gemma3ProcessorConfiguration.ImageSize: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Gemma3ProcessorConfiguration.ImageSize: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Gemma3ProcessorConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Gemma3ProcessorConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Gemma3TextConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3TextConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3TextConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Gemma3TextConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Gemma3TextConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Gemma3TextConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3VisionConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3VisionConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3VisionConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Gemma3VisionConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Gemma3VisionConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Gemma3VisionConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.QuantizationConfig.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.QuantizationConfig.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.QuantizationConfig.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.QuantizationConfig.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.QuantizationConfig.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.QuantizationConfig.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Gemma3Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Gemma3Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Gemma3Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3ProcessorConfiguration.ImageSize.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3ProcessorConfiguration.ImageSize.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3ProcessorConfiguration.ImageSize.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Gemma3ProcessorConfiguration.ImageSize.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Gemma3ProcessorConfiguration.ImageSize.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3ProcessorConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3ProcessorConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3ProcessorConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Gemma3ProcessorConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Gemma3ProcessorConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Gemma3ProcessorConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Gemma3MultiModalProjector: MLXNN.UnaryLayer {}
extension MLXVLM.VisionEmbeddings: MLXNN.UnaryLayer {}
extension MLXVLM.VisionMLP: MLXNN.UnaryLayer {}
extension MLXVLM.LanguageModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXVLM.MLP: MLXNN.UnaryLayer {}
extension MLXVLM.Idefics3Configuration.TextConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Idefics3Configuration.TextConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Idefics3Configuration.VisionConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Idefics3Configuration.VisionConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Idefics3Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Idefics3Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Idefics3: MLXVLM.VLMModel {}
extension MLXVLM.Idefics3: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXVLM.Idefics3: MLXLMCommon.LanguageModel {}
extension MLXVLM.Idefics3: MLXLMCommon.LoRAModel {}
extension MLXVLM.Idefics3ProcessorConfiguration.Size: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Idefics3ProcessorConfiguration.Size: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Idefics3ProcessorConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Idefics3ProcessorConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Idefics3Processor: MLXLMCommon.UserInputProcessor {}
extension MLXVLM.Idefics3Configuration.TextConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3Configuration.TextConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3Configuration.TextConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Idefics3Configuration.TextConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Idefics3Configuration.TextConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Idefics3Configuration.TextConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3Configuration.VisionConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3Configuration.VisionConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3Configuration.VisionConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Idefics3Configuration.VisionConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Idefics3Configuration.VisionConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Idefics3Configuration.VisionConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Idefics3Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Idefics3Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Idefics3Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3ProcessorConfiguration.Size.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3ProcessorConfiguration.Size.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3ProcessorConfiguration.Size.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Idefics3ProcessorConfiguration.Size.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Idefics3ProcessorConfiguration.Size.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Idefics3ProcessorConfiguration.Size.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3ProcessorConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3ProcessorConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Idefics3ProcessorConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Idefics3ProcessorConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Idefics3ProcessorConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Idefics3ProcessorConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Vision.VisionEmbeddings: MLXNN.UnaryLayer {}
extension MLXVLM.Vision.MLP: MLXNN.UnaryLayer {}
extension MLXVLM.Language.LanguageModel: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXVLM.Language.MLP: MLXNN.UnaryLayer {}
extension MLXVLM.Idefics3MLP: MLXNN.UnaryLayer {}
extension MLXVLM.PaliGemmaProcessor: MLXLMCommon.UserInputProcessor {}
extension MLXVLM.PaliGemma: MLXVLM.VLMModel {}
extension MLXVLM.PaliGemma: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXVLM.PaliGemma: MLXLMCommon.LanguageModel {}
extension MLXVLM.PaliGemma: MLXLMCommon.LoRAModel {}
extension MLXVLM.PaliGemmaConfiguration.TextConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.PaliGemmaConfiguration.TextConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.PaliGemmaConfiguration.VisionConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.PaliGemmaConfiguration.VisionConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.PaliGemmaConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.PaliGemmaConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.PaliGemmaProcessorConfiguration.Size: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.PaliGemmaProcessorConfiguration.Size: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.PaliGemmaProcessorConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.PaliGemmaProcessorConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.PaliGemmaConfiguration.TextConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.TextConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.TextConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.TextConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.PaliGemmaConfiguration.TextConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.PaliGemmaConfiguration.TextConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.VisionConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.VisionConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.VisionConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.VisionConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.PaliGemmaConfiguration.VisionConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.PaliGemmaConfiguration.VisionConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.PaliGemmaConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.PaliGemmaConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.PaliGemmaConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaProcessorConfiguration.Size.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaProcessorConfiguration.Size.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaProcessorConfiguration.Size.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.PaliGemmaProcessorConfiguration.Size.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.PaliGemmaProcessorConfiguration.Size.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaProcessorConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaProcessorConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaProcessorConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.PaliGemmaProcessorConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.PaliGemmaProcessorConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.PaliGemmaProcessorConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.PaliGemmaMultiModalProjector: MLXNN.UnaryLayer {}
extension MLXVLM.Vision.PhiMLP: MLXNN.UnaryLayer {}
extension MLXVLM.Qwen25VLProcessor: MLXLMCommon.UserInputProcessor {}
extension MLXVLM.Qwen25VL: MLXVLM.VLMModel {}
extension MLXVLM.Qwen25VL: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXVLM.Qwen25VL: MLXLMCommon.LanguageModel {}
extension MLXVLM.Qwen25VL: MLXLMCommon.LoRAModel {}
extension MLXVLM.Qwen25VLConfiguration.TextConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen25VLConfiguration.TextConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen25VLConfiguration.VisionConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen25VLConfiguration.VisionConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen25VLConfiguration.BaseConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen25VLConfiguration.BaseConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen25VLConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen25VLConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen25VLProcessorConfiguration.Size: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen25VLProcessorConfiguration.Size: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen25VLProcessorConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen25VLProcessorConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen25VLConfiguration.TextConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.TextConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.TextConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.TextConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen25VLConfiguration.TextConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen25VLConfiguration.TextConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.VisionConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.VisionConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.VisionConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.VisionConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen25VLConfiguration.VisionConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen25VLConfiguration.VisionConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.BaseConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.BaseConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.BaseConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.BaseConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen25VLConfiguration.BaseConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen25VLConfiguration.BaseConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen25VLConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen25VLConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen25VLConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLProcessorConfiguration.Size.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLProcessorConfiguration.Size.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLProcessorConfiguration.Size.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen25VLProcessorConfiguration.Size.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen25VLProcessorConfiguration.Size.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen25VLProcessorConfiguration.Size.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLProcessorConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLProcessorConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen25VLProcessorConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen25VLProcessorConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen25VLProcessorConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen25VLProcessorConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Vision.PatchMerger: MLXNN.UnaryLayer {}
extension MLXVLM.Qwen2VLProcessor: MLXLMCommon.UserInputProcessor {}
extension MLXVLM.Qwen2VL: MLXVLM.VLMModel {}
extension MLXVLM.Qwen2VL: MLXLMCommon.KVCacheDimensionProvider {}
extension MLXVLM.Qwen2VL: MLXLMCommon.LanguageModel {}
extension MLXVLM.Qwen2VL: MLXLMCommon.LoRAModel {}
extension MLXVLM.Qwen2VLConfiguration.TextConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen2VLConfiguration.TextConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen2VLConfiguration.VisionConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen2VLConfiguration.VisionConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen2VLConfiguration.BaseConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen2VLConfiguration.BaseConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen2VLConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen2VLConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen2VLProcessorConfiguration.Size: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen2VLProcessorConfiguration.Size: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen2VLProcessorConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.Qwen2VLProcessorConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.Qwen2VLMessageGenerator: MLXLMCommon.MessageGenerator {}
extension MLXVLM.Qwen2VLConfiguration.TextConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.TextConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.TextConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.TextConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen2VLConfiguration.TextConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen2VLConfiguration.TextConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.VisionConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.VisionConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.VisionConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.VisionConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen2VLConfiguration.VisionConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen2VLConfiguration.VisionConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.BaseConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.BaseConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.BaseConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.BaseConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen2VLConfiguration.BaseConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen2VLConfiguration.BaseConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen2VLConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen2VLConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen2VLConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLProcessorConfiguration.Size.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLProcessorConfiguration.Size.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLProcessorConfiguration.Size.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen2VLProcessorConfiguration.Size.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen2VLProcessorConfiguration.Size.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen2VLProcessorConfiguration.Size.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLProcessorConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLProcessorConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.Qwen2VLProcessorConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.Qwen2VLProcessorConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.Qwen2VLProcessorConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.Qwen2VLProcessorConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.QwenVL.PatchEmbed: MLXNN.UnaryLayer {}
extension MLXVLM.SmolVLMProcessorConfiguration.Size: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.SmolVLMProcessorConfiguration.Size: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.SmolVLMProcessorConfiguration.VideoSampling: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.SmolVLMProcessorConfiguration.VideoSampling: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.SmolVLMProcessorConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.SmolVLMProcessorConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.SmolVLMProcessor: MLXLMCommon.UserInputProcessor {}
extension MLXVLM.SmolVLMProcessorConfiguration.Size.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.Size.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.Size.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.Size.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.SmolVLMProcessorConfiguration.Size.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.SmolVLMProcessorConfiguration.Size.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.VideoSampling.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.VideoSampling.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.VideoSampling.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.VideoSampling.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.SmolVLMProcessorConfiguration.VideoSampling.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.SmolVLMProcessorConfiguration.VideoSampling.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.SmolVLMProcessorConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.SmolVLMProcessorConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.SmolVLMProcessorConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension MLXVLM.VLMError: Foundation.LocalizedError {
    var errorDescription: Swift.String? {
        get
    }
    var failureReason: Swift.String? {
        get
    }
    var recoverySuggestion: Swift.String? {
        get
    }
    var helpAnchor: Swift.String? {
        get
    }
}
extension MLXVLM.VLMError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLXVLM.BaseProcessorConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXVLM.BaseProcessorConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXVLM.VLMModelFactory: MLXLMCommon.ModelFactory {}
extension MLXVLM.TrampolineModelFactory: MLXLMCommon.ModelFactoryTrampoline {}
extension MLXVLM.BaseProcessorConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXVLM.BaseProcessorConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXVLM.BaseProcessorConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXVLM.BaseProcessorConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXVLM.BaseProcessorConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXVLM.BaseProcessorConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var intValue: Swift.Int? {
        get
    }
    var stringValue: Swift.String {
        get
    }
}
extension __C.SCNetworkReachabilityFlags: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = __C.SCNetworkReachabilityFlags

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension __C.SCNetworkReachabilityFlags: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C.SCNetworkReachabilityFlags: Swift.SetAlgebra {
    typealias Element = __C.SCNetworkReachabilityFlags

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension __C.SCNetworkReachabilityFlags: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C.SCNetworkReachabilityFlags: Swift.OptionSet {
    typealias Element = __C.SCNetworkReachabilityFlags

    init(rawValue: Self.RawValue)
}
extension PostHog.BaseApplicationLifecyclePublisher: PostHog.AppLifecyclePublishing {}
extension PostHog.PostHogAppLifeCycleIntegration: PostHog.PostHogIntegration {}
extension PostHog.PostHogConfig.PostHogDataMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.PostHogConfig.PostHogDataMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension PostHog.PostHogConfig.PostHogDataMode: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension PostHog.PostHogPersonProfiles: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.PostHogPersonProfiles: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension PostHog.PostHogPersonProfiles: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension PostHog.PostHogQueue.PostHogApiEndpoint: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension PostHog.PostHogQueue.PostHogApiEndpoint: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension PostHog.PostHogQueue.PostHogApiEndpoint: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.PostHogSessionManager.SessionIDChangeReason: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension PostHog.PostHogSessionManager.SessionIDChangeReason: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension PostHog.PostHogSessionManager.SessionIDChangeReason: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.PostHogStorage.StorageKey: Swift.CaseIterable {
    typealias AllCases = [PostHog.PostHogStorage.StorageKey]

    static var allCases: Self.AllCases {
        get
    }
}
extension PostHog.PostHogStorage.StorageKey: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension PostHog.PostHogStorage.StorageKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension PostHog.PostHogStorage.StorageKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.BaseScreenViewPublisher: PostHog.ScreenViewPublishing {}
extension PostHog.PostHogScreenViewIntegration: PostHog.PostHogIntegration {}
extension PostHog.PostHogDisplaySurvey: Swift.Identifiable {
    typealias ID = Swift.String

    var id: Self.ID {
        get
    }
}
extension PostHog.PostHogDisplaySurveyRatingType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.PostHogDisplaySurveyRatingType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension PostHog.PostHogDisplaySurveyRatingType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension PostHog.PostHogDisplaySurveyTextContentType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.PostHogDisplaySurveyTextContentType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension PostHog.PostHogDisplaySurveyTextContentType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension PostHog.PostHogSurveyResponseType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.PostHogSurveyResponseType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension PostHog.PostHogSurveyResponseType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension PostHog.PostHogSwiftUIViewModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<PostHog.PostHogSwiftUIViewModifier>, SwiftUI._AppearanceActionModifier>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension PostHog.CompressionLevel: Swift.RawRepresentable {
    typealias RawValue = Swift.Int32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension PostHog.GzipError.Kind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.GzipError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension PostHog.InternalPostHogError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension PostHog.InternalPostHogError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension PostHog.ReachabilityError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension PostHog.Reachability.NetworkStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.Reachability.NetworkStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension PostHog.Reachability.NetworkStatus: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension PostHog.Reachability.Connection: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension PostHog.Reachability.Connection: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension PostHog.Reachability.Connection: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseRemoteConfig.RemoteConfigValueCodableError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseRemoteConfig.RemoteConfigCodableError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseRemoteConfig.CustomSignalValue: Swift.ExpressibleByStringInterpolation {
    typealias StringInterpolation = Swift.DefaultStringInterpolation

    init(stringInterpolation: Self.StringInterpolation)
}
extension FirebaseRemoteConfig.CustomSignalValue: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension FirebaseRemoteConfig.CustomSignalValue: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension FirebaseRemoteConfig.CustomSignalValue: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension FirebaseRemoteConfig.CustomSignalValue: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int

    init(integerLiteral: Self.IntegerLiteralType)
}
extension FirebaseRemoteConfig.CustomSignalValue: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Double

    init(floatLiteral: Self.FloatLiteralType)
}
extension FirebaseRemoteConfig.FirebaseRemoteConfigValueDecoderHelper: FirebaseSharedSwift.FirebaseRemoteConfigValueDecoding {}
extension FirebaseRemoteConfig.RemoteConfigProperty: SwiftUI.DynamicProperty {
    func update()

    static var _propertyBehaviors: Swift.UInt32 {
        get
    }

    static func _makeProperty<A1>(in: inout SwiftUI._DynamicPropertyBuffer, container: SwiftUI._GraphValue<A1>, fieldOffset: Swift.Int, inputs: inout SwiftUI._GraphInputs)
}
extension FirebaseRemoteConfig.RemoteConfigValueObservable: Combine.ObservableObject {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher

    var objectWillChange: Self.ObjectWillChangePublisher {
        get
    }
}
extension Promises.Maybe: Swift.Equatable where A: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Promises.Promise: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Promises.PromiseError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Promises.PromiseError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Promises.PromiseError: Foundation.CustomNSError {
    var errorCode: Swift.Int {
        get
    }
    var errorUserInfo: [Swift.String : Any] {
        get
    }

    static var errorDomain: Swift.String {
        get
    }
}
extension Promises.PromiseError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _code: Swift.Int {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension __C._firebase_appquality_sessions_EventType: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C._firebase_appquality_sessions_EventType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C._firebase_appquality_sessions_EventType: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension __C._firebase_appquality_sessions_DataCollectionState: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C._firebase_appquality_sessions_DataCollectionState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C._firebase_appquality_sessions_DataCollectionState: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension __C._firebase_appquality_sessions_OsName: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C._firebase_appquality_sessions_OsName: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C._firebase_appquality_sessions_OsName: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension __C._firebase_appquality_sessions_LogEnvironment: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension __C._firebase_appquality_sessions_LogEnvironment: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension __C._firebase_appquality_sessions_LogEnvironment: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseSessions.ApplicationInfo: FirebaseSessions.ApplicationInfoProtocol {}
extension FirebaseSessions.DevEventConsoleLogger: FirebaseSessions.EventGDTLoggerProtocol {}
extension FirebaseSessions.EventGDTLogger: FirebaseSessions.EventGDTLoggerProtocol {}
extension FirebaseSessions.FirebaseSessionsError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseSessions.GoogleDataTransporter: FirebaseSessions.GoogleDataTransportProtocol {}
extension FirebaseSessions.GoogleDataTransportProtocolErrors: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseSessions.GoogleDataTransportProtocolErrors: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseSessions.GoogleDataTransportProtocolErrors: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension __C.FIRInstallations: FirebaseSessions.InstallationsProtocol {}
extension FirebaseSessions.NetworkInfo: FirebaseSessions.NetworkInfoProtocol {}
extension FirebaseSessions.SessionsSubscriberName: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseSessions.SessionsSubscriberName: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseSessions.SessionsSubscriberName: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseSessions.SessionsSubscriberName: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseSessions.SessionCoordinator: FirebaseSessions.SessionCoordinatorProtocol {}
extension FirebaseSessions.LocalOverrideSettings: FirebaseSessions.SettingsProvider {}
extension FirebaseSessions.RemoteSettings: FirebaseSessions.SettingsProvider {}
extension FirebaseSessions.SDKDefaultSettings: FirebaseSessions.SettingsProvider {}
extension FirebaseSessions.SessionsSettings: FirebaseSessions.SettingsProtocol {}
extension FirebaseSessions.SettingsCache: FirebaseSessions.SettingsCacheClient {}
extension FirebaseSessions.CacheKey: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseSessions.CacheKey: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseSessions.CacheKey.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseSessions.CacheKey.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseSessions.CacheKey.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseSessions.CacheKey.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseSessions.CacheKey.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseSessions.SettingsDownloader: FirebaseSessions.SettingsDownloadClient {}
extension FirebaseSessions.SettingsDownloaderError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseSessions.Time: FirebaseSessions.TimeProvider {}
extension FirebaseCrashlyticsSwift.EncodedRolloutAssignment: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseCrashlyticsSwift.EncodedRolloutAssignment: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseCrashlyticsSwift.EncodedRolloutsState: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseCrashlyticsSwift.EncodedRolloutsState: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseCrashlyticsSwift.EncodedRolloutsState.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseCrashlyticsSwift.EncodedRolloutsState.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseCrashlyticsSwift.EncodedRolloutsState.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseCrashlyticsSwift.EncodedRolloutsState.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCrashlyticsSwift.EncodedRolloutsState.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseCrashlyticsSwift.EncodedRolloutAssignment.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseCrashlyticsSwift.EncodedRolloutAssignment.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseCrashlyticsSwift.EncodedRolloutAssignment.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseCrashlyticsSwift.EncodedRolloutAssignment.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseCrashlyticsSwift.EncodedRolloutAssignment.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseMLModelDownloader.CustomModel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.CustomModel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.ModelFileDownloader: FirebaseMLModelDownloader.FileDownloader {}
extension FirebaseMLModelDownloader.FileDownloaderError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseMLModelDownloader.LocalModelInfo: FirebaseMLModelDownloader.DownloaderUserDefaultsWriteable {}
extension FirebaseMLModelDownloader.ModelDownloadStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.ModelDownloadStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.ModelDownloadType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.ModelDownloadType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.DownloadError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension FirebaseMLModelDownloader.DownloadError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.DownloadedModelError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension __C.NSURLSession: FirebaseMLModelDownloader.ModelInfoRetrieverSession {}
extension FirebaseMLModelDownloader.ModelInfoResponse: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseMLModelDownloader.ModelInfoResponse: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseMLModelDownloader.ModelInfoResponse.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension FirebaseMLModelDownloader.ModelInfoResponse.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseMLModelDownloader.ModelInfoResponse.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseMLModelDownloader.ModelInfoResponse.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.ModelInfoResponse.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.ModelInfoResponse.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension FirebaseMLModelDownloader.EventName: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.EventName: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.EventName: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseMLModelDownloader.EventName: Swift.CaseIterable {
    typealias AllCases = [FirebaseMLModelDownloader.EventName]

    static var allCases: Self.AllCases {
        get
    }
}
extension FirebaseMLModelDownloader.EventName: SwiftProtobuf.Enum {}
extension FirebaseMLModelDownloader.EventName: SwiftProtobuf._ProtoNameProviding {}
extension FirebaseMLModelDownloader.FirebaseMlLogEvent: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.FirebaseMlLogEvent: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.FirebaseMlLogEvent: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseMLModelDownloader.FirebaseMlLogEvent: SwiftProtobuf._ProtoNameProviding {}
extension FirebaseMLModelDownloader.FirebaseMlLogEvent: SwiftProtobuf._MessageImplementationBase {}
extension FirebaseMLModelDownloader.FirebaseMlLogEvent: SwiftProtobuf.Message {}
extension FirebaseMLModelDownloader.DeleteModelLogEvent: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.DeleteModelLogEvent: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.DeleteModelLogEvent: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseMLModelDownloader.DeleteModelLogEvent: SwiftProtobuf._ProtoNameProviding {}
extension FirebaseMLModelDownloader.DeleteModelLogEvent: SwiftProtobuf._MessageImplementationBase {}
extension FirebaseMLModelDownloader.DeleteModelLogEvent: SwiftProtobuf.Message {}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent.DownloadStatus: SwiftProtobuf._ProtoNameProviding {}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent.DownloadStatus: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent.DownloadStatus: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent.DownloadStatus: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent.DownloadStatus: Swift.CaseIterable {
    typealias AllCases = [FirebaseMLModelDownloader.ModelDownloadLogEvent.DownloadStatus]

    static var allCases: Self.AllCases {
        get
    }
}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent.DownloadStatus: SwiftProtobuf.Enum {}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent: SwiftProtobuf._ProtoNameProviding {}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent: SwiftProtobuf._MessageImplementationBase {}
extension FirebaseMLModelDownloader.ModelDownloadLogEvent: SwiftProtobuf.Message {}
extension FirebaseMLModelDownloader.ModelOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.ModelOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.ModelOptions: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseMLModelDownloader.ModelOptions: SwiftProtobuf._ProtoNameProviding {}
extension FirebaseMLModelDownloader.ModelOptions: SwiftProtobuf._MessageImplementationBase {}
extension FirebaseMLModelDownloader.ModelOptions: SwiftProtobuf.Message {}
extension FirebaseMLModelDownloader.ModelInfo.ModelType: SwiftProtobuf._ProtoNameProviding {}
extension FirebaseMLModelDownloader.ModelInfo.ModelType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.ModelInfo.ModelType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.ModelInfo.ModelType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseMLModelDownloader.ModelInfo.ModelType: Swift.CaseIterable {
    typealias AllCases = [FirebaseMLModelDownloader.ModelInfo.ModelType]

    static var allCases: Self.AllCases {
        get
    }
}
extension FirebaseMLModelDownloader.ModelInfo.ModelType: SwiftProtobuf.Enum {}
extension FirebaseMLModelDownloader.ModelInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.ModelInfo: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.ModelInfo: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseMLModelDownloader.ModelInfo: SwiftProtobuf._ProtoNameProviding {}
extension FirebaseMLModelDownloader.ModelInfo: SwiftProtobuf._MessageImplementationBase {}
extension FirebaseMLModelDownloader.ModelInfo: SwiftProtobuf.Message {}
extension FirebaseMLModelDownloader.SystemInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.SystemInfo: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.SystemInfo: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension FirebaseMLModelDownloader.SystemInfo: SwiftProtobuf._ProtoNameProviding {}
extension FirebaseMLModelDownloader.SystemInfo: SwiftProtobuf._MessageImplementationBase {}
extension FirebaseMLModelDownloader.SystemInfo: SwiftProtobuf.Message {}
extension FirebaseMLModelDownloader.ErrorCode: SwiftProtobuf._ProtoNameProviding {}
extension FirebaseMLModelDownloader.ErrorCode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseMLModelDownloader.ErrorCode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension FirebaseMLModelDownloader.ErrorCode: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension FirebaseMLModelDownloader.ErrorCode: Swift.CaseIterable {
    typealias AllCases = [FirebaseMLModelDownloader.ErrorCode]

    static var allCases: Self.AllCases {
        get
    }
}
extension FirebaseMLModelDownloader.ErrorCode: SwiftProtobuf.Enum {}
extension SwiftProtobuf.AnyUnpackError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.AnyUnpackError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.AnyUnpackError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftProtobuf.AsyncMessageSequence.AsyncIterator: Swift.AsyncIteratorProtocol {
    typealias Element = B
    typealias Failure = Swift.Error

    func next() async throws -> Self.Element?
    func next(isolation: isolated Swift.Actor?) async throws(Self.Failure) -> Self.Element?
}
extension SwiftProtobuf.AsyncMessageSequence: Swift.AsyncSequence {
    typealias AsyncIterator = SwiftProtobuf.AsyncMessageSequence<A, B>.AsyncIterator
    typealias Element = B
    typealias Failure = Swift.Error

    func makeAsyncIterator() -> Self.AsyncIterator
}
extension SwiftProtobuf.BinaryDecoder: SwiftProtobuf.Decoder {}
extension SwiftProtobuf.BinaryDecodingError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.BinaryDecodingError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.BinaryDecodingError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftProtobuf.BinaryDelimited.Error: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.BinaryDelimited.Error: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.BinaryDelimited.Error: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftProtobuf.BinaryEncodingError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.BinaryEncodingError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftProtobuf.BinaryEncodingError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.BinaryEncodingSizeVisitor: SwiftProtobuf.Visitor {}
extension SwiftProtobuf.BinaryEncodingSizeVisitor.BinaryEncodingMessageSetSizeVisitor: SwiftProtobuf.SelectiveVisitor {}
extension SwiftProtobuf.BinaryEncodingSizeVisitor.BinaryEncodingMessageSetSizeVisitor: SwiftProtobuf.Visitor {}
extension SwiftProtobuf.BinaryEncodingVisitor: SwiftProtobuf.Visitor {}
extension SwiftProtobuf.BinaryEncodingVisitor.BinaryEncodingMessageSetVisitor: SwiftProtobuf.SelectiveVisitor {}
extension SwiftProtobuf.BinaryEncodingVisitor.BinaryEncodingMessageSetVisitor: SwiftProtobuf.Visitor {}
extension SwiftProtobuf.ExtensionFieldValueSet: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.ExtensionFieldValueSet: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.OptionalExtensionField: SwiftProtobuf.ExtensionField {
    typealias ValueType = A.FieldType.BaseType
}
extension SwiftProtobuf.OptionalExtensionField: SwiftProtobuf.AnyExtensionField {}
extension SwiftProtobuf.OptionalExtensionField: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.OptionalExtensionField: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.OptionalExtensionField: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.RepeatedExtensionField: SwiftProtobuf.ExtensionField {
    typealias ValueType = [A.FieldType.BaseType]
}
extension SwiftProtobuf.RepeatedExtensionField: SwiftProtobuf.AnyExtensionField {}
extension SwiftProtobuf.RepeatedExtensionField: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.RepeatedExtensionField: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.RepeatedExtensionField: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.PackedExtensionField: SwiftProtobuf.ExtensionField {
    typealias ValueType = [A.FieldType.BaseType]
}
extension SwiftProtobuf.PackedExtensionField: SwiftProtobuf.AnyExtensionField {}
extension SwiftProtobuf.PackedExtensionField: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.PackedExtensionField: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.PackedExtensionField: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.OptionalEnumExtensionField: SwiftProtobuf.ExtensionField {
    typealias ValueType = A
}
extension SwiftProtobuf.OptionalEnumExtensionField: SwiftProtobuf.AnyExtensionField {}
extension SwiftProtobuf.OptionalEnumExtensionField: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.OptionalEnumExtensionField: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.OptionalEnumExtensionField: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.RepeatedEnumExtensionField: SwiftProtobuf.ExtensionField {
    typealias ValueType = [A]
}
extension SwiftProtobuf.RepeatedEnumExtensionField: SwiftProtobuf.AnyExtensionField {}
extension SwiftProtobuf.RepeatedEnumExtensionField: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.RepeatedEnumExtensionField: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.RepeatedEnumExtensionField: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.PackedEnumExtensionField: SwiftProtobuf.ExtensionField {
    typealias ValueType = [A]
}
extension SwiftProtobuf.PackedEnumExtensionField: SwiftProtobuf.AnyExtensionField {}
extension SwiftProtobuf.PackedEnumExtensionField: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.PackedEnumExtensionField: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.PackedEnumExtensionField: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.OptionalMessageExtensionField: SwiftProtobuf.ExtensionField {
    typealias ValueType = A
}
extension SwiftProtobuf.OptionalMessageExtensionField: SwiftProtobuf.AnyExtensionField {}
extension SwiftProtobuf.OptionalMessageExtensionField: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.OptionalMessageExtensionField: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.OptionalMessageExtensionField: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.RepeatedMessageExtensionField: SwiftProtobuf.ExtensionField {
    typealias ValueType = [A]
}
extension SwiftProtobuf.RepeatedMessageExtensionField: SwiftProtobuf.AnyExtensionField {}
extension SwiftProtobuf.RepeatedMessageExtensionField: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.RepeatedMessageExtensionField: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.RepeatedMessageExtensionField: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.OptionalGroupExtensionField: SwiftProtobuf.ExtensionField {
    typealias ValueType = A
}
extension SwiftProtobuf.OptionalGroupExtensionField: SwiftProtobuf.AnyExtensionField {}
extension SwiftProtobuf.OptionalGroupExtensionField: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.OptionalGroupExtensionField: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.OptionalGroupExtensionField: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.RepeatedGroupExtensionField: SwiftProtobuf.ExtensionField {
    typealias ValueType = [A]
}
extension SwiftProtobuf.RepeatedGroupExtensionField: SwiftProtobuf.AnyExtensionField {}
extension SwiftProtobuf.RepeatedGroupExtensionField: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.RepeatedGroupExtensionField: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.RepeatedGroupExtensionField: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.FieldTag: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.ProtobufFloat: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.Float
}
extension SwiftProtobuf.ProtobufFloat: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufDouble: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.Double
}
extension SwiftProtobuf.ProtobufDouble: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufInt32: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.Int32
}
extension SwiftProtobuf.ProtobufInt32: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufInt32: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufInt64: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.Int64
}
extension SwiftProtobuf.ProtobufInt64: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufInt64: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufUInt32: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.UInt32
}
extension SwiftProtobuf.ProtobufUInt32: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufUInt32: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufUInt64: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.UInt64
}
extension SwiftProtobuf.ProtobufUInt64: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufUInt64: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufSInt32: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.Int32
}
extension SwiftProtobuf.ProtobufSInt32: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufSInt32: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufSInt64: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.Int64
}
extension SwiftProtobuf.ProtobufSInt64: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufSInt64: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufFixed32: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.UInt32
}
extension SwiftProtobuf.ProtobufFixed32: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufFixed32: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufFixed64: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.UInt64
}
extension SwiftProtobuf.ProtobufFixed64: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufFixed64: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufSFixed32: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.Int32
}
extension SwiftProtobuf.ProtobufSFixed32: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufSFixed32: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufSFixed64: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.Int64
}
extension SwiftProtobuf.ProtobufSFixed64: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufSFixed64: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufBool: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.Bool
}
extension SwiftProtobuf.ProtobufBool: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufBool: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufString: SwiftProtobuf.FieldType {
    typealias BaseType = Swift.String
}
extension SwiftProtobuf.ProtobufString: SwiftProtobuf.MapKeyType {}
extension SwiftProtobuf.ProtobufString: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.ProtobufBytes: SwiftProtobuf.FieldType {
    typealias BaseType = Foundation.Data
}
extension SwiftProtobuf.ProtobufBytes: SwiftProtobuf.MapValueType {}
extension SwiftProtobuf.Google_Protobuf_Any: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_Any: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Any: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Any: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Any: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Any: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Any: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Duration: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_Duration: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Double

    init(floatLiteral: Self.FloatLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_Duration: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Duration: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Duration: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Duration: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Duration: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Duration: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldMask: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_FieldMask: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FieldMask: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FieldMask: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FieldMask: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldMask: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldMask: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.FieldMaskError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.FieldMaskError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.FieldMaskError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftProtobuf.Google_Protobuf_ListValue: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = SwiftProtobuf.Google_Protobuf_Value

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension SwiftProtobuf.Google_Protobuf_ListValue: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_ListValue: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_ListValue: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_ListValue: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_ListValue: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_ListValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_ListValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_NullValue: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_NullValue: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_NullValue: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_NullValue]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_NullValue: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_NullValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_NullValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_NullValue: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Struct: Swift.ExpressibleByDictionaryLiteral {
    typealias Key = Swift.String
    typealias Value = SwiftProtobuf.Google_Protobuf_Value

    init(dictionaryLiteral: (Self.Key, Self.Value)...)
}
extension SwiftProtobuf.Google_Protobuf_Struct: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_Struct: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Struct: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Struct: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Struct: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Struct: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Struct: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Timestamp: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_Timestamp: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Timestamp: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Timestamp: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Timestamp: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Timestamp: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Timestamp: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Value: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int64

    init(integerLiteral: Self.IntegerLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_Value: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Double

    init(floatLiteral: Self.FloatLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_Value: Swift.ExpressibleByBooleanLiteral {
    typealias BooleanLiteralType = Swift.Bool

    init(booleanLiteral: Self.BooleanLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_Value: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_Value: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_Value: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_Value: Swift.ExpressibleByNilLiteral {
    init(nilLiteral: ())
}
extension SwiftProtobuf.Google_Protobuf_Value: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_Value: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Value: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Value: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Value: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Value: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Value: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_DoubleValue: SwiftProtobuf.ProtobufWrapper {
    typealias WrappedType = SwiftProtobuf.ProtobufDouble
}
extension SwiftProtobuf.Google_Protobuf_DoubleValue: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Double

    init(floatLiteral: Self.FloatLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_DoubleValue: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_DoubleValue: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_DoubleValue: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_DoubleValue: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_DoubleValue: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_DoubleValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_DoubleValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FloatValue: SwiftProtobuf.ProtobufWrapper {
    typealias WrappedType = SwiftProtobuf.ProtobufFloat
}
extension SwiftProtobuf.Google_Protobuf_FloatValue: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Float

    init(floatLiteral: Self.FloatLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_FloatValue: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_FloatValue: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FloatValue: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FloatValue: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FloatValue: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FloatValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FloatValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Int64Value: SwiftProtobuf.ProtobufWrapper {
    typealias WrappedType = SwiftProtobuf.ProtobufInt64
}
extension SwiftProtobuf.Google_Protobuf_Int64Value: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int64

    init(integerLiteral: Self.IntegerLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_Int64Value: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_Int64Value: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Int64Value: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Int64Value: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Int64Value: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Int64Value: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Int64Value: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_UInt64Value: SwiftProtobuf.ProtobufWrapper {
    typealias WrappedType = SwiftProtobuf.ProtobufUInt64
}
extension SwiftProtobuf.Google_Protobuf_UInt64Value: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.UInt64

    init(integerLiteral: Self.IntegerLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_UInt64Value: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_UInt64Value: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_UInt64Value: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_UInt64Value: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_UInt64Value: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_UInt64Value: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_UInt64Value: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Int32Value: SwiftProtobuf.ProtobufWrapper {
    typealias WrappedType = SwiftProtobuf.ProtobufInt32
}
extension SwiftProtobuf.Google_Protobuf_Int32Value: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.Int32

    init(integerLiteral: Self.IntegerLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_Int32Value: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_Int32Value: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Int32Value: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Int32Value: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Int32Value: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Int32Value: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Int32Value: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_UInt32Value: SwiftProtobuf.ProtobufWrapper {
    typealias WrappedType = SwiftProtobuf.ProtobufUInt32
}
extension SwiftProtobuf.Google_Protobuf_UInt32Value: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.UInt32

    init(integerLiteral: Self.IntegerLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_UInt32Value: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_UInt32Value: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_UInt32Value: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_UInt32Value: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_UInt32Value: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_UInt32Value: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_UInt32Value: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_BoolValue: SwiftProtobuf.ProtobufWrapper {
    typealias WrappedType = SwiftProtobuf.ProtobufBool
}
extension SwiftProtobuf.Google_Protobuf_BoolValue: Swift.ExpressibleByBooleanLiteral {
    typealias BooleanLiteralType = Swift.Bool

    init(booleanLiteral: Self.BooleanLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_BoolValue: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_BoolValue: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_BoolValue: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_BoolValue: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_BoolValue: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_BoolValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_BoolValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_StringValue: SwiftProtobuf.ProtobufWrapper {
    typealias WrappedType = SwiftProtobuf.ProtobufString
}
extension SwiftProtobuf.Google_Protobuf_StringValue: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_StringValue: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_StringValue: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_StringValue: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension SwiftProtobuf.Google_Protobuf_StringValue: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_StringValue: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_StringValue: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_StringValue: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_StringValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_StringValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_BytesValue: SwiftProtobuf.ProtobufWrapper {
    typealias WrappedType = SwiftProtobuf.ProtobufBytes
}
extension SwiftProtobuf.Google_Protobuf_BytesValue: SwiftProtobuf._CustomJSONCodable {}
extension SwiftProtobuf.Google_Protobuf_BytesValue: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_BytesValue: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_BytesValue: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_BytesValue: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_BytesValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_BytesValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.HashVisitor: SwiftProtobuf.Visitor {}
extension SwiftProtobuf.JSONDecoder: SwiftProtobuf.Decoder {}
extension SwiftProtobuf.JSONDecodingError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftProtobuf.JSONEncodingError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.JSONEncodingError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftProtobuf.JSONEncodingError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.JSONEncodingVisitor: SwiftProtobuf.Visitor {}
extension SwiftProtobuf.JSONMapEncodingVisitor: SwiftProtobuf.SelectiveVisitor {}
extension SwiftProtobuf.JSONMapEncodingVisitor: SwiftProtobuf.Visitor {}
extension SwiftProtobuf.MessageExtension: SwiftProtobuf.AnyMessageExtension {}
extension SwiftProtobuf.ProtoNameInstruction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.ProtoNameInstruction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.ProtoNameInstruction: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt64

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.ProtoNameInstruction: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.ProtoNameInstruction]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf._NameMap.Name: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf._NameMap.Name: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftProtobuf._NameMap.Name: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf._NameMap: Swift.ExpressibleByDictionaryLiteral {
    typealias Key = Swift.Int
    typealias Value = SwiftProtobuf._NameMap.NameDescription

    init(dictionaryLiteral: (Self.Key, Self.Value)...)
}
extension SwiftProtobuf.PathDecodingError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.PathDecodingError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.PathDecodingError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftProtobuf.PathDecoder: SwiftProtobuf.Decoder {}
extension SwiftProtobuf.PathVisitor: SwiftProtobuf.Visitor {}
extension SwiftProtobuf.SimpleExtensionMap: SwiftProtobuf.ExtensionMap {}
extension SwiftProtobuf.SimpleExtensionMap: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = SwiftProtobuf.AnyMessageExtension

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension SwiftProtobuf.SimpleExtensionMap: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.SwiftProtobufError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftProtobuf.SwiftProtobufError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftProtobuf.SwiftProtobufError: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.SwiftProtobufError.Code: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.SwiftProtobufError.Code: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftProtobuf.SwiftProtobufError.Code: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.SwiftProtobufError.SourceLocation: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.SwiftProtobufError.SourceLocation: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.SwiftProtobufError.Code.Wrapped: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftProtobuf.SwiftProtobufError.Code.Wrapped: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.SwiftProtobufError.Code.Wrapped: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.TextFormatDecoder: SwiftProtobuf.Decoder {}
extension SwiftProtobuf.TextFormatDecodingError: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.TextFormatDecodingError: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.TextFormatDecodingError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension SwiftProtobuf.TextFormatEncodingVisitor: SwiftProtobuf.Visitor {}
extension SwiftProtobuf.UnknownStorage: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.WireFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.WireFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.WireFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt8

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Api: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Api: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Api: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Api: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Api: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Api: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Method: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Method: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Method: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Method: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Method: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Method: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Mixin: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Mixin: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Mixin: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Mixin: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Mixin: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Mixin: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Edition: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Edition: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Edition: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Edition: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_Edition: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_Edition]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Edition: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_SymbolVisibility: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_SymbolVisibility: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_SymbolVisibility: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_SymbolVisibility: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_SymbolVisibility: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_SymbolVisibility]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_SymbolVisibility: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorSet: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorSet: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorSet: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorSet: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorSet: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorSet: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorSet: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.VerificationState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.VerificationState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.VerificationState: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.VerificationState: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.VerificationState: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.VerificationState]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.VerificationState: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.TypeEnum: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.TypeEnum: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.TypeEnum: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.TypeEnum: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.TypeEnum: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.TypeEnum]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.TypeEnum: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.Label: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.Label: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.Label: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.Label: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.Label: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.Label]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto.Label: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FileOptions.OptimizeMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FileOptions.OptimizeMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FileOptions.OptimizeMode: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FileOptions.OptimizeMode: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FileOptions.OptimizeMode: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FileOptions.OptimizeMode]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FileOptions.OptimizeMode: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FileOptions: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_FileOptions: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FileOptions: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FileOptions: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FileOptions: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FileOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FileOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_MessageOptions: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_MessageOptions: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_MessageOptions: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_MessageOptions: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_MessageOptions: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_MessageOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_MessageOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.CType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.CType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.CType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.CType: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.CType: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FieldOptions.CType]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.CType: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.JSType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.JSType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.JSType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.JSType: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.JSType: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FieldOptions.JSType]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.JSType: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionRetention: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionRetention: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionRetention: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionRetention: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionRetention: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FieldOptions.OptionRetention]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionRetention: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionTargetType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionTargetType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionTargetType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionTargetType: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionTargetType: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FieldOptions.OptionTargetType]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.OptionTargetType: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_OneofOptions: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_OneofOptions: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_OneofOptions: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_OneofOptions: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_OneofOptions: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_OneofOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_OneofOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_EnumOptions: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_EnumOptions: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_EnumOptions: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_EnumOptions: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_EnumOptions: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_EnumOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_EnumOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_EnumValueOptions: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_EnumValueOptions: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_EnumValueOptions: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_EnumValueOptions: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_EnumValueOptions: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_EnumValueOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_EnumValueOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_ServiceOptions: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_ServiceOptions: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_ServiceOptions: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_ServiceOptions: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_ServiceOptions: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_ServiceOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_ServiceOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_MethodOptions.IdempotencyLevel: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_MethodOptions.IdempotencyLevel: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_MethodOptions.IdempotencyLevel: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_MethodOptions.IdempotencyLevel: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_MethodOptions.IdempotencyLevel: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_MethodOptions.IdempotencyLevel]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_MethodOptions.IdempotencyLevel: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_MethodOptions: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_MethodOptions: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_MethodOptions: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_MethodOptions: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_MethodOptions: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_MethodOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_MethodOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.FieldPresence: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.FieldPresence: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.FieldPresence: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.FieldPresence: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.FieldPresence: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FeatureSet.FieldPresence]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.FieldPresence: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnumType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnumType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnumType: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnumType: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnumType: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FeatureSet.EnumType]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnumType: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.RepeatedFieldEncoding: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.RepeatedFieldEncoding: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.RepeatedFieldEncoding: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.RepeatedFieldEncoding: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.RepeatedFieldEncoding: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FeatureSet.RepeatedFieldEncoding]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.RepeatedFieldEncoding: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.Utf8Validation: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.Utf8Validation: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.Utf8Validation: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.Utf8Validation: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.Utf8Validation: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FeatureSet.Utf8Validation]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.Utf8Validation: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.MessageEncoding: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.MessageEncoding: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.MessageEncoding: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.MessageEncoding: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.MessageEncoding: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FeatureSet.MessageEncoding]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.MessageEncoding: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.JsonFormat: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.JsonFormat: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.JsonFormat: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.JsonFormat: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.JsonFormat: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FeatureSet.JsonFormat]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.JsonFormat: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnforceNamingStyle: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnforceNamingStyle: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnforceNamingStyle: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnforceNamingStyle: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnforceNamingStyle: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FeatureSet.EnforceNamingStyle]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.EnforceNamingStyle: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature.DefaultSymbolVisibility: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature.DefaultSymbolVisibility: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature.DefaultSymbolVisibility: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature.DefaultSymbolVisibility: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature.DefaultSymbolVisibility: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature.DefaultSymbolVisibility]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature.DefaultSymbolVisibility: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo: SwiftProtobuf.ExtensibleMessage {}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation.Semantic: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation.Semantic: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation.Semantic: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation.Semantic: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation.Semantic: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation.Semantic]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation.Semantic: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorProto: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorProto: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorProto: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorProto: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorProto: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FileDescriptorProto: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ExtensionRange: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ExtensionRange: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ExtensionRange: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ExtensionRange: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ExtensionRange: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ExtensionRange: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ReservedRange: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ReservedRange: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ReservedRange: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ReservedRange: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ReservedRange: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_DescriptorProto.ReservedRange: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.Declaration: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.Declaration: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.Declaration: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.Declaration: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.Declaration: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_ExtensionRangeOptions.Declaration: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldDescriptorProto: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_OneofDescriptorProto: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_OneofDescriptorProto: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_OneofDescriptorProto: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_OneofDescriptorProto: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_OneofDescriptorProto: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_OneofDescriptorProto: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto.EnumReservedRange: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto.EnumReservedRange: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto.EnumReservedRange: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto.EnumReservedRange: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto.EnumReservedRange: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_EnumDescriptorProto.EnumReservedRange: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_EnumValueDescriptorProto: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_EnumValueDescriptorProto: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_EnumValueDescriptorProto: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_EnumValueDescriptorProto: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_EnumValueDescriptorProto: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_EnumValueDescriptorProto: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_ServiceDescriptorProto: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_ServiceDescriptorProto: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_ServiceDescriptorProto: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_ServiceDescriptorProto: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_ServiceDescriptorProto: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_ServiceDescriptorProto: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_MethodDescriptorProto: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_MethodDescriptorProto: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_MethodDescriptorProto: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_MethodDescriptorProto: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_MethodDescriptorProto: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_MethodDescriptorProto: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.EditionDefault: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.EditionDefault: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.EditionDefault: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.EditionDefault: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.EditionDefault: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.EditionDefault: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.FeatureSupport: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.FeatureSupport: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.FeatureSupport: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.FeatureSupport: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.FeatureSupport: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FieldOptions.FeatureSupport: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption.NamePart: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption.NamePart: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption.NamePart: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption.NamePart: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption.NamePart: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_UninterpretedOption.NamePart: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSet.VisibilityFeature: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults.FeatureSetEditionDefault: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults.FeatureSetEditionDefault: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults.FeatureSetEditionDefault: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults.FeatureSetEditionDefault: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults.FeatureSetEditionDefault: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_FeatureSetDefaults.FeatureSetEditionDefault: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo.Location: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo.Location: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo.Location: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo.Location: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo.Location: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_SourceCodeInfo.Location: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo.Annotation: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Empty: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Empty: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Empty: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Empty: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Empty: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Empty: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_SourceContext: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_SourceContext: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_SourceContext: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_SourceContext: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_SourceContext: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_SourceContext: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Value.OneOf_Kind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Syntax: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_Syntax: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_Syntax]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Syntax: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Syntax: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Syntax: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Syntax: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Field.Kind: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_Field.Kind: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_Field.Kind]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Field.Kind: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Field.Kind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Field.Kind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Field.Kind: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Field.Cardinality: SwiftProtobuf.Enum {}
extension SwiftProtobuf.Google_Protobuf_Field.Cardinality: Swift.CaseIterable {
    typealias AllCases = [SwiftProtobuf.Google_Protobuf_Field.Cardinality]

    static var allCases: Self.AllCases {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Field.Cardinality: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Field.Cardinality: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Field.Cardinality: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Field.Cardinality: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Type: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Type: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Type: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Type: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Type: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Type: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Field: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Field: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Field: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Field: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Field: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Field: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Enum: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Enum: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Enum: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Enum: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Enum: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Enum: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_EnumValue: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_EnumValue: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_EnumValue: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_EnumValue: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_EnumValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_EnumValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftProtobuf.Google_Protobuf_Option: SwiftProtobuf.Message {}
extension SwiftProtobuf.Google_Protobuf_Option: SwiftProtobuf._MessageImplementationBase {}
extension SwiftProtobuf.Google_Protobuf_Option: SwiftProtobuf._ProtoNameProviding {}
extension SwiftProtobuf.Google_Protobuf_Option: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftProtobuf.Google_Protobuf_Option: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftProtobuf.Google_Protobuf_Option: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Configuration.JournalModeConfiguration: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Configuration.JournalModeConfiguration: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.AnyCursor: GRDB.Cursor {
    typealias Element = A
}
extension GRDB.DropFirstCursor: GRDB.Cursor {
    typealias Element = A.Cursor.Element
}
extension GRDB.DropWhileCursor: GRDB.Cursor {
    typealias Element = A.Cursor.Element
}
extension GRDB.EnumeratedCursor: GRDB.Cursor {
    typealias Element = (Swift.Int, A.Cursor.Element)
}
extension GRDB.FilterCursor: GRDB.Cursor {
    typealias Element = A.Cursor.Element
}
extension GRDB.FlattenCursor: GRDB.Cursor {
    typealias Element = A.Cursor.Element.Cursor.Element
}
extension GRDB.MapCursor: GRDB.Cursor {
    typealias Element = B
}
extension GRDB.PrefixCursor: GRDB.Cursor {
    typealias Element = A.Cursor.Element
}
extension GRDB.PrefixWhileCursor: GRDB.Cursor {
    typealias Element = A.Cursor.Element
}
extension GRDB.ColumnInfo: GRDB.FetchableRecord {}
extension GRDB.IndexInfo.Origin: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.IndexInfo.Origin: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.IndexInfo.Origin: GRDB.DatabaseValueConvertible {}
extension GRDB.IndexInfo.Origin: GRDB.SQLExpressible {}
extension GRDB.IndexInfo.Origin: GRDB.StatementBinding {}
extension GRDB.ForeignKeyViolation: GRDB.FetchableRecord {}
extension GRDB.ForeignKeyViolation: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.Database.SchemaIdentifier: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.SchemaIdentifier: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SchemaObject: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SchemaObject: GRDB.FetchableRecord {}
extension GRDB.SchemaObject: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SchemaObjectType: GRDB.StatementBinding {}
extension GRDB.SchemaObjectType: GRDB.SQLExpressible {}
extension GRDB.SchemaObjectType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SchemaObjectType: GRDB.DatabaseValueConvertible {}
extension GRDB.SchemaObjectType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.SchemaObjectType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.TableInfo: GRDB.FetchableRecord {}
extension GRDB.SchemaInfo: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.TableInfo.Kind: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.SQLStatementCursor: GRDB.Cursor {
    typealias Element = GRDB.Statement
}
extension GRDB.Database: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.Database: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension GRDB.Database.CheckpointMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.CheckpointMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Database.CheckpointMode: Swift.RawRepresentable {
    typealias RawValue = Swift.Int32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.Database.CollationName: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.Database.CollationName: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Database.CollationName: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.ColumnType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.Database.ColumnType: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Database.ColumnType: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.ConflictResolution: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.ConflictResolution: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Database.ConflictResolution: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.Database.ForeignKeyAction: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.ForeignKeyAction: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Database.ForeignKeyAction: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.Database.StorageClass: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.Database.StorageClass: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Database.StorageClass: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.TracingOptions: Swift.OptionSet {
    typealias Element = GRDB.Database.TracingOptions

    init(rawValue: Self.RawValue)
}
extension GRDB.Database.TracingOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.Int32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.Database.TracingOptions: Swift.SetAlgebra {
    typealias Element = GRDB.Database.TracingOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension GRDB.Database.TracingOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.TracingOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = GRDB.Database.TracingOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension GRDB.Database.TraceEvent.Statement: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.Database.TraceEvent: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.Database.TransactionCompletion: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.TransactionCompletion: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Database.TransactionKind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.TransactionKind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Database.TransactionKind: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.Database.ThreadingMode: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Database.ThreadingMode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.AutocommitState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Database.AutocommitState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabaseCollation.ID: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.DatabaseCollation.ID: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabaseCollation: Swift.Identifiable {
    typealias ID = GRDB.DatabaseCollation.ID

    var id: Self.ID {
        get
    }
}
extension GRDB.ResultCode: Swift.RawRepresentable {
    typealias RawValue = Swift.Int32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.ResultCode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.ResultCode: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.DatabaseError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension GRDB.DatabaseError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.DatabaseError: Foundation.CustomNSError {
    var errorCode: Swift.Int {
        get
    }
    var errorUserInfo: [Swift.String : Any] {
        get
    }

    static var errorDomain: Swift.String {
        get
    }
}
extension GRDB.DatabaseFunction.ID: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.DatabaseFunction.ID: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabaseFunction: Swift.Identifiable {
    typealias ID = GRDB.DatabaseFunction.ID

    var id: Self.ID {
        get
    }
}
extension GRDB.DatabasePool: GRDB.DatabaseReader {}
extension GRDB.DatabasePool: GRDB.DatabaseWriter {}
extension GRDB.DatabaseQueue: GRDB.DatabaseReader {}
extension GRDB.DatabaseQueue: GRDB.DatabaseWriter {}
extension GRDB.DatabasePublishers.Read: Combine.Publisher {
    func receive<A1>(subscriber: A1) where A1: Combine.Subscriber, Self.Failure == A1.Failure, Self.Output == A1.Input
}
extension GRDB.AnyDatabaseReader: GRDB.DatabaseReader {}
extension GRDB.DatabaseRegion: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabaseRegion: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.DatabaseRegion: GRDB.DatabaseRegionConvertible {}
extension GRDB.AnyDatabaseRegionConvertible: GRDB.DatabaseRegionConvertible {}
extension GRDB.TableRegion: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabasePublishers.DatabaseRegion: Combine.Publisher {
    func receive<A1>(subscriber: A1) where A1: Combine.Subscriber, Self.Failure == A1.Failure, Self.Output == A1.Input
}
extension GRDB.DatabasePublishers.DatabaseRegionSubscription: Combine.CustomCombineIdentifierConvertible {
    var combineIdentifier: Combine.CombineIdentifier {
        get
    }
}
extension GRDB.DatabasePublishers.DatabaseRegionSubscription: Combine.Cancellable {
    func cancel()
}
extension GRDB.DatabasePublishers.DatabaseRegionSubscription: Combine.Subscription {
    func request(_: Combine.Subscribers.Demand)
}
extension GRDB.DatabaseRegionObserver: GRDB.TransactionObserver {}
extension GRDB.DatabaseSnapshot: GRDB.DatabaseSnapshotReader {}
extension GRDB.DatabaseSnapshot: GRDB.DatabaseReader {}
extension GRDB.DatabaseSnapshotPool: GRDB.DatabaseSnapshotReader {}
extension GRDB.DatabaseSnapshotPool: GRDB.DatabaseReader {}
extension GRDB.DatabaseValue: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.DatabaseValue: GRDB.StatementBinding {}
extension GRDB.DatabaseValue: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabaseValue: GRDB.DatabaseValueConvertible {}
extension GRDB.DatabaseValue: GRDB.SQLExpressible {}
extension GRDB.DatabaseValue: GRDB.SQLSpecificExpressible {}
extension GRDB.DatabaseValue: GRDB.SQLSelectable {}
extension GRDB.DatabaseValue: GRDB.SQLOrderingTerm {}
extension GRDB.DatabaseValue: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.DatabaseValue.Storage: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabaseValueCursor: GRDB.DatabaseCursor {}
extension GRDB.DatabaseValueCursor: GRDB.Cursor {
    typealias Element = A
}
extension GRDB.DatabasePublishers.Write: Combine.Publisher {
    func receive<A1>(subscriber: A1) where A1: Combine.Subscriber, Self.Failure == A1.Failure, Self.Output == A1.Input
}
extension GRDB.AnyDatabaseWriter: GRDB.DatabaseReader {}
extension GRDB.AnyDatabaseWriter: GRDB.DatabaseWriter {}
extension GRDB.PreparedRequest: GRDB.Refinable {}
extension GRDB.AdaptedFetchRequest: GRDB.SQLSubqueryable {}
extension GRDB.AdaptedFetchRequest: GRDB.SQLSpecificExpressible {}
extension GRDB.AdaptedFetchRequest: GRDB.SQLExpressible {}
extension GRDB.AdaptedFetchRequest: GRDB.SQLSelectable {}
extension GRDB.AdaptedFetchRequest: GRDB.SQLOrderingTerm {}
extension GRDB.AdaptedFetchRequest: GRDB.FetchRequest {
    typealias RowDecoder = A.FetchRequest.RowDecoder
}
extension GRDB.AdaptedFetchRequest: GRDB.DatabaseRegionConvertible {}
extension GRDB.AnyFetchRequest: GRDB.SQLSubqueryable {}
extension GRDB.AnyFetchRequest: GRDB.SQLSpecificExpressible {}
extension GRDB.AnyFetchRequest: GRDB.SQLExpressible {}
extension GRDB.AnyFetchRequest: GRDB.SQLSelectable {}
extension GRDB.AnyFetchRequest: GRDB.SQLOrderingTerm {}
extension GRDB.AnyFetchRequest: GRDB.FetchRequest {
    typealias RowDecoder = A
}
extension GRDB.AnyFetchRequest: GRDB.DatabaseRegionConvertible {}
extension GRDB.FetchRequestEraser: GRDB.SQLOrderingTerm {}
extension GRDB.FetchRequestEraser: GRDB.SQLSelectable {}
extension GRDB.FetchRequestEraser: GRDB.SQLExpressible {}
extension GRDB.FetchRequestEraser: GRDB.SQLSpecificExpressible {}
extension GRDB.FetchRequestEraser: GRDB.DatabaseRegionConvertible {}
extension GRDB.FetchRequestEraser: GRDB.SQLSubqueryable {}
extension GRDB.FetchRequestEraser: GRDB.FetchRequest {
    typealias RowDecoder = ()
}
extension GRDB.RowCursor: GRDB.DatabaseCursor {}
extension GRDB.RowCursor: GRDB.Cursor {
    typealias Element = GRDB.Row
}
extension GRDB.Row: Swift.RandomAccessCollection {
    typealias Element = (Swift.String, GRDB.DatabaseValue)
    typealias Index = GRDB.Row.Index
    typealias SubSequence = Swift.Slice<GRDB.Row>
    typealias Indices = Swift.Range<GRDB.Row.Index>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension GRDB.Row: Swift.BidirectionalCollection {
    typealias Element = (Swift.String, GRDB.DatabaseValue)
    typealias Index = GRDB.Row.Index
    typealias SubSequence = Swift.Slice<GRDB.Row>
    typealias Indices = Swift.Range<GRDB.Row.Index>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension GRDB.Row: Swift.Collection {
    typealias Element = (Swift.String, GRDB.DatabaseValue)
    typealias Index = GRDB.Row.Index
    typealias Iterator = Swift.IndexingIterator<GRDB.Row>
    typealias SubSequence = Swift.Slice<GRDB.Row>
    typealias Indices = Swift.Range<GRDB.Row.Index>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension GRDB.Row: Swift.Sequence {
    typealias Element = (Swift.String, GRDB.DatabaseValue)
    typealias Iterator = Swift.IndexingIterator<GRDB.Row>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension GRDB.Row: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Row: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Row: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.Row: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension GRDB.Row: Swift.ExpressibleByDictionaryLiteral {
    typealias Key = Swift.String
    typealias Value = GRDB.DatabaseValueConvertible?

    init(dictionaryLiteral: (Self.Key, Self.Value)...)
}
extension GRDB.Row: GRDB.ColumnAddressable {
    typealias ColumnIndex = Swift.Int
}
extension GRDB.Row.Index: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Row.Index: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Row.Index: Swift.Strideable {
    typealias Stride = Swift.Int

    func distance(to: Self) -> Self.Stride
    func advanced(by: Self.Stride) -> Self

    static func _step(after: (index: Swift.Int?, value: Self), from: Self, by: Self.Stride) -> (index: Swift.Int?, value: Self)
}
extension GRDB.Row.ScopesView: Swift.Collection {
    typealias Element = (name: Swift.String, row: GRDB.Row)
    typealias Index = [Swift.String : GRDB._LayoutedRowAdapter].Index
    typealias Iterator = Swift.IndexingIterator<GRDB.Row.ScopesView>
    typealias SubSequence = Swift.Slice<GRDB.Row.ScopesView>
    typealias Indices = Swift.DefaultIndices<GRDB.Row.ScopesView>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension GRDB.Row.ScopesView: Swift.Sequence {
    typealias Element = (name: Swift.String, row: GRDB.Row)
    typealias Iterator = Swift.IndexingIterator<GRDB.Row.ScopesView>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension GRDB.Row.PrefetchedRowsView: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Row.Prefetch: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.ArrayRowImpl: GRDB.RowImpl {}
extension GRDB.EmptyRowImpl: GRDB.RowImpl {}
extension GRDB.StatementCopyRowImpl: GRDB.RowImpl {}
extension GRDB.StatementRowImpl: GRDB.RowImpl {}
extension GRDB._LayoutedColumnMapping: GRDB._LayoutedRowAdapter {}
extension GRDB._LayoutedColumnMapping: GRDB._RowLayout {}
extension GRDB.Statement: GRDB._RowLayout {}
extension GRDB.Statement: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.EmptyRowAdapter: GRDB.RowAdapter {}
extension GRDB.ColumnMapping: GRDB.RowAdapter {}
extension GRDB.SuffixRowAdapter: GRDB.RowAdapter {}
extension GRDB.RangeRowAdapter: GRDB.RowAdapter {}
extension GRDB.ScopeAdapter: GRDB.RowAdapter {}
extension GRDB.RenameColumnAdapter: GRDB.RowAdapter {}
extension GRDB.LayoutedScopeAdapter: GRDB._LayoutedRowAdapter {}
extension GRDB.ChainedAdapter: GRDB.RowAdapter {}
extension GRDB.AdaptedRowImpl: GRDB.RowImpl {}
extension GRDB.RowKey: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.RowKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.RowDecodingError.Context: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension GRDB.RowDecodingError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension GRDB.RowDecodingError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.SQL: GRDB.SQLSpecificExpressible {}
extension GRDB.SQL: GRDB.SQLExpressible {}
extension GRDB.SQL: GRDB.SQLSelectable {}
extension GRDB.SQL: GRDB.SQLOrderingTerm {}
extension GRDB.SQL: Swift.ExpressibleByStringInterpolation {
    typealias StringInterpolation = GRDB.SQLInterpolation

    init(stringInterpolation: Self.StringInterpolation)
}
extension GRDB.SQL: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension GRDB.SQL: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension GRDB.SQL: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension GRDB.SQLInterpolation: Swift.StringInterpolationProtocol {
    typealias StringLiteralType = Swift.String

    init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)

    func appendLiteral(_: Self.StringLiteralType)
}
extension GRDB.SQLRequest: GRDB.FetchRequest {
    typealias RowDecoder = A
}
extension GRDB.SQLRequest: GRDB.SQLSubqueryable {}
extension GRDB.SQLRequest: GRDB.DatabaseRegionConvertible {}
extension GRDB.SQLRequest: GRDB.SQLSpecificExpressible {}
extension GRDB.SQLRequest: GRDB.SQLExpressible {}
extension GRDB.SQLRequest: GRDB.SQLSelectable {}
extension GRDB.SQLRequest: GRDB.SQLOrderingTerm {}
extension GRDB.SQLRequest: Swift.ExpressibleByStringInterpolation {
    typealias StringInterpolation = GRDB.SQLInterpolation

    init(stringInterpolation: Self.StringInterpolation)
}
extension GRDB.SQLRequest: Swift.ExpressibleByStringLiteral {
    typealias StringLiteralType = Swift.String

    init(stringLiteral: Self.StringLiteralType)
}
extension GRDB.SQLRequest: Swift.ExpressibleByExtendedGraphemeClusterLiteral {
    typealias ExtendedGraphemeClusterLiteralType = Swift.String

    init(extendedGraphemeClusterLiteral: Self.ExtendedGraphemeClusterLiteralType)
}
extension GRDB.SQLRequest: Swift.ExpressibleByUnicodeScalarLiteral {
    typealias UnicodeScalarLiteralType = Swift.String

    init(unicodeScalarLiteral: Self.UnicodeScalarLiteralType)
}
extension GRDB.SQLRequest.Cache: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SQLRequest.Cache: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Mutex: GRDB.DatabaseCancellable where A == GRDB.DatabaseAccessCancellationState {}
extension GRDB.StatementArguments: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.StatementArguments: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.StatementArguments: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = GRDB.DatabaseValueConvertible?

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension GRDB.StatementArguments: Swift.ExpressibleByDictionaryLiteral {
    typealias Key = Swift.String
    typealias Value = GRDB.DatabaseValueConvertible?

    init(dictionaryLiteral: (Self.Key, Self.Value)...)
}
extension GRDB.StatementArguments: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.Statement.TransactionEffect: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.StatementCursor: GRDB.Cursor {
    typealias Element = ()
}
extension GRDB.StatementCursor: GRDB.DatabaseCursor {}
extension GRDB.FastDatabaseValueCursor: GRDB.DatabaseCursor {}
extension GRDB.FastDatabaseValueCursor: GRDB.Cursor {
    typealias Element = A
}
extension CoreGraphics.CGFloat: GRDB.DatabaseValueConvertible {}
extension CoreGraphics.CGFloat: GRDB.SQLExpressible {}
extension CoreGraphics.CGFloat: GRDB.StatementBinding {}
extension GRDB.DatabaseDateComponents.Format: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabaseDateComponents.Format: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.DatabaseDateComponents.Format: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.DatabaseDateComponents: GRDB.StatementColumnConvertible {}
extension GRDB.DatabaseDateComponents: GRDB.DatabaseValueConvertible {}
extension GRDB.DatabaseDateComponents: GRDB.SQLExpressible {}
extension GRDB.DatabaseDateComponents: GRDB.StatementBinding {}
extension GRDB.DatabaseDateComponents: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension GRDB.DatabaseDateComponents: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension __C.NSDate: GRDB.DatabaseValueConvertible {}
extension __C.NSDate: GRDB.SQLExpressible {}
extension __C.NSDate: GRDB.StatementBinding {}
extension __C.Decimal: GRDB.DatabaseValueConvertible {}
extension __C.Decimal: GRDB.SQLExpressible {}
extension __C.Decimal: GRDB.StatementBinding {}
extension __C.Decimal: GRDB.StatementColumnConvertible {}
extension __C.NSData: GRDB.DatabaseValueConvertible {}
extension __C.NSData: GRDB.SQLExpressible {}
extension __C.NSData: GRDB.StatementBinding {}
extension __C.NSNull: GRDB.DatabaseValueConvertible {}
extension __C.NSNull: GRDB.SQLExpressible {}
extension __C.NSNull: GRDB.StatementBinding {}
extension __C.NSNumber: GRDB.DatabaseValueConvertible {}
extension __C.NSNumber: GRDB.SQLExpressible {}
extension __C.NSNumber: GRDB.StatementBinding {}
extension __C.NSURL: GRDB.DatabaseValueConvertible {}
extension __C.NSURL: GRDB.SQLExpressible {}
extension __C.NSURL: GRDB.StatementBinding {}
extension __C.NSUUID: GRDB.DatabaseValueConvertible {}
extension __C.NSUUID: GRDB.SQLExpressible {}
extension __C.NSUUID: GRDB.StatementBinding {}
extension Foundation.UUID: GRDB.DatabaseValueConvertible {}
extension Foundation.UUID: GRDB.SQLExpressible {}
extension Foundation.UUID: GRDB.StatementBinding {}
extension Foundation.UUID: GRDB.StatementColumnConvertible {}
extension GRDB.DatabaseValueDecoder: Swift.Decoder {
    var userInfo: [Swift.CodingUserInfoKey : Any] {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func container<A1>(keyedBy: A1.Type) throws -> Swift.KeyedDecodingContainer<A1> where A1: Swift.CodingKey
    func unkeyedContainer() throws -> Swift.UnkeyedDecodingContainer
    func singleValueContainer() throws -> Swift.SingleValueDecodingContainer
}
extension GRDB.DatabaseValueDecodingContainer: Swift.SingleValueDecodingContainer {
    var codingPath: [Swift.CodingKey] {
        get
    }

    func decodeNil() -> Swift.Bool
    func decode(_: Swift.Bool.Type) throws -> Swift.Bool
    func decode(_: Swift.String.Type) throws -> Swift.String
    func decode(_: Swift.Double.Type) throws -> Swift.Double
    func decode(_: Swift.Float.Type) throws -> Swift.Float
    func decode(_: Swift.Int.Type) throws -> Swift.Int
    func decode(_: Swift.Int8.Type) throws -> Swift.Int8
    func decode(_: Swift.Int16.Type) throws -> Swift.Int16
    func decode(_: Swift.Int32.Type) throws -> Swift.Int32
    func decode(_: Swift.Int64.Type) throws -> Swift.Int64
    func decode(_: Swift.Int128.Type) throws -> Swift.Int128
    func decode(_: Swift.UInt.Type) throws -> Swift.UInt
    func decode(_: Swift.UInt8.Type) throws -> Swift.UInt8
    func decode(_: Swift.UInt16.Type) throws -> Swift.UInt16
    func decode(_: Swift.UInt32.Type) throws -> Swift.UInt32
    func decode(_: Swift.UInt64.Type) throws -> Swift.UInt64
    func decode(_: Swift.UInt128.Type) throws -> Swift.UInt128
    func decode<A1>(_: A1.Type) throws -> A1 where A1: Swift.Decodable
}
extension GRDB.DatabaseValueEncoder: Swift.Encoder {
    var userInfo: [Swift.CodingUserInfoKey : Any] {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func container<A1>(keyedBy: A1.Type) -> Swift.KeyedEncodingContainer<A1> where A1: Swift.CodingKey
    func unkeyedContainer() -> Swift.UnkeyedEncodingContainer
    func singleValueContainer() -> Swift.SingleValueEncodingContainer
}
extension GRDB.DatabaseValueEncodingContainer: Swift.SingleValueEncodingContainer {
    var codingPath: [Swift.CodingKey] {
        get
    }

    func encodeNil() throws
    func encode(_: Swift.Bool) throws
    func encode(_: Swift.String) throws
    func encode(_: Swift.Double) throws
    func encode(_: Swift.Float) throws
    func encode(_: Swift.Int) throws
    func encode(_: Swift.Int8) throws
    func encode(_: Swift.Int16) throws
    func encode(_: Swift.Int32) throws
    func encode(_: Swift.Int64) throws
    func encode(_: Swift.Int128) throws
    func encode(_: Swift.UInt) throws
    func encode(_: Swift.UInt8) throws
    func encode(_: Swift.UInt16) throws
    func encode(_: Swift.UInt32) throws
    func encode(_: Swift.UInt64) throws
    func encode(_: Swift.UInt128) throws
    func encode<A1>(_: A1) throws where A1: Swift.Encodable
}
extension GRDB.JSONRequiredError: Swift.Error {
    var _userInfo: Swift.AnyObject? {
        get
    }
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension GRDB.JSONRequiredEncoder: Swift.UnkeyedEncodingContainer {
    var count: Swift.Int {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func encodeNil() throws
    func encode(_: Swift.Bool) throws
    func encode(_: Swift.String) throws
    func encode(_: Swift.Double) throws
    func encode(_: Swift.Float) throws
    func encode(_: Swift.Int) throws
    func encode(_: Swift.Int8) throws
    func encode(_: Swift.Int16) throws
    func encode(_: Swift.Int32) throws
    func encode(_: Swift.Int64) throws
    func encode(_: Swift.Int128) throws
    func encode(_: Swift.UInt) throws
    func encode(_: Swift.UInt8) throws
    func encode(_: Swift.UInt16) throws
    func encode(_: Swift.UInt32) throws
    func encode(_: Swift.UInt64) throws
    func encode(_: Swift.UInt128) throws
    func encode<A1>(_: A1) throws where A1: Swift.Encodable
    func encodeConditional<A1>(_: A1) throws where A1: AnyObject, A1: Swift.Encodable
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Bool
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.String
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Double
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Float
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int8
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int16
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int32
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int64
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.Int128
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt8
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt16
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt32
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt64
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element == Swift.UInt128
    func encode<A1>(contentsOf: A1) throws where A1: Swift.Sequence, A1.Element: Swift.Encodable
    func nestedContainer<A1>(keyedBy: A1.Type) -> Swift.KeyedEncodingContainer<A1> where A1: Swift.CodingKey
    func nestedUnkeyedContainer() -> Swift.UnkeyedEncodingContainer
    func superEncoder() -> Swift.Encoder
}
extension GRDB.JSONRequiredEncoder: Swift.SingleValueEncodingContainer {
    var codingPath: [Swift.CodingKey] {
        get
    }

    func encodeNil() throws
    func encode(_: Swift.Bool) throws
    func encode(_: Swift.String) throws
    func encode(_: Swift.Double) throws
    func encode(_: Swift.Float) throws
    func encode(_: Swift.Int) throws
    func encode(_: Swift.Int8) throws
    func encode(_: Swift.Int16) throws
    func encode(_: Swift.Int32) throws
    func encode(_: Swift.Int64) throws
    func encode(_: Swift.Int128) throws
    func encode(_: Swift.UInt) throws
    func encode(_: Swift.UInt8) throws
    func encode(_: Swift.UInt16) throws
    func encode(_: Swift.UInt32) throws
    func encode(_: Swift.UInt64) throws
    func encode(_: Swift.UInt128) throws
    func encode<A1>(_: A1) throws where A1: Swift.Encodable
}
extension GRDB.JSONRequiredEncoder: Swift.Encoder {
    var userInfo: [Swift.CodingUserInfoKey : Any] {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func container<A1>(keyedBy: A1.Type) -> Swift.KeyedEncodingContainer<A1> where A1: Swift.CodingKey
    func unkeyedContainer() -> Swift.UnkeyedEncodingContainer
    func singleValueContainer() -> Swift.SingleValueEncodingContainer
}
extension GRDB.JSONRequiredEncoder.KeyedContainer: Swift.KeyedEncodingContainerProtocol {
    typealias Key = A

    var codingPath: [Swift.CodingKey] {
        get
    }

    func encodeNil(forKey: Self.Key) throws
    func encode(_: Swift.Bool, forKey: Self.Key) throws
    func encode(_: Swift.String, forKey: Self.Key) throws
    func encode(_: Swift.Double, forKey: Self.Key) throws
    func encode(_: Swift.Float, forKey: Self.Key) throws
    func encode(_: Swift.Int, forKey: Self.Key) throws
    func encode(_: Swift.Int8, forKey: Self.Key) throws
    func encode(_: Swift.Int16, forKey: Self.Key) throws
    func encode(_: Swift.Int32, forKey: Self.Key) throws
    func encode(_: Swift.Int64, forKey: Self.Key) throws
    func encode(_: Swift.Int128, forKey: Self.Key) throws
    func encode(_: Swift.UInt, forKey: Self.Key) throws
    func encode(_: Swift.UInt8, forKey: Self.Key) throws
    func encode(_: Swift.UInt16, forKey: Self.Key) throws
    func encode(_: Swift.UInt32, forKey: Self.Key) throws
    func encode(_: Swift.UInt64, forKey: Self.Key) throws
    func encode(_: Swift.UInt128, forKey: Self.Key) throws
    func encode<A1>(_: A1, forKey: Self.Key) throws where A1: Swift.Encodable
    func encodeConditional<A1>(_: A1, forKey: Self.Key) throws where A1: AnyObject, A1: Swift.Encodable
    func encodeIfPresent(_: Swift.Bool?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.String?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Double?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Float?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int8?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int16?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int32?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int64?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int128?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt8?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt16?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt32?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt64?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt128?, forKey: Self.Key) throws
    func encodeIfPresent<A1>(_: A1?, forKey: Self.Key) throws where A1: Swift.Encodable
    func nestedContainer<A1>(keyedBy: A1.Type, forKey: Self.Key) -> Swift.KeyedEncodingContainer<A1> where A1: Swift.CodingKey
    func nestedUnkeyedContainer(forKey: Self.Key) -> Swift.UnkeyedEncodingContainer
    func superEncoder() -> Swift.Encoder
    func superEncoder(forKey: Self.Key) -> Swift.Encoder
}
extension GRDB.DefaultTransactionClock: GRDB.TransactionClock {}
extension GRDB.CustomTransactionClock: GRDB.TransactionClock {}
extension GRDB.Database.TransactionObservationExtent: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.Database.TransactionObservationExtent: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.DatabaseEvent.Kind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabaseEvent.Kind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.DatabaseEvent.Kind: Swift.RawRepresentable {
    typealias RawValue = Swift.Int32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.DatabaseEvent: GRDB.DatabaseEventProtocol {}
extension GRDB.Database.TransactionHandler: GRDB.TransactionObserver {}
extension GRDB.MetalDatabaseEventImpl: GRDB.DatabaseEventImpl {}
extension GRDB.CopiedDatabaseEventImpl: GRDB.DatabaseEventImpl {}
extension GRDB.DumpTableHeaderOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DumpTableHeaderOptions: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.DumpStream: Swift.TextOutputStream {
    func _lock()
    func _unlock()
    func write(_: Swift.String)
    func _writeASCII(_: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
extension GRDB.StandardOutputStream: Swift.TextOutputStream {
    func _lock()
    func _unlock()
    func write(_: Swift.String)
    func _writeASCII(_: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
extension GRDB.DebugDumpFormat: GRDB.DumpFormat {}
extension GRDB.JSONDumpFormat: GRDB.DumpFormat {}
extension GRDB.LineDumpFormat: GRDB.DumpFormat {}
extension GRDB.ListDumpFormat: GRDB.DumpFormat {}
extension GRDB.QuoteDumpFormat: GRDB.DumpFormat {}
extension GRDB.FTS3.Diacritics: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.FTS3.Diacritics: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.FTS3: GRDB.VirtualTableModule {
    typealias TableDefinition = GRDB.FTS3TableDefinition
}
extension GRDB.FTS3Pattern: GRDB.DatabaseValueConvertible {}
extension GRDB.FTS3Pattern: GRDB.SQLExpressible {}
extension GRDB.FTS3Pattern: GRDB.StatementBinding {}
extension GRDB.FTS4: GRDB.VirtualTableModule {
    typealias TableDefinition = GRDB.FTS4TableDefinition
}
extension GRDB.FTS5.Diacritics: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.FTS5.Diacritics: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.FTS5: GRDB.VirtualTableModule {
    typealias TableDefinition = GRDB.FTS5TableDefinition
}
extension GRDB.FTS5Pattern: GRDB.DatabaseValueConvertible {}
extension GRDB.FTS5Pattern: GRDB.SQLExpressible {}
extension GRDB.FTS5Pattern: GRDB.StatementBinding {}
extension GRDB.FTS5Tokenization: Swift.OptionSet {
    typealias Element = GRDB.FTS5Tokenization

    init(rawValue: Self.RawValue)
}
extension GRDB.FTS5Tokenization: Swift.RawRepresentable {
    typealias RawValue = Swift.Int32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.FTS5Tokenization: Swift.SetAlgebra {
    typealias Element = GRDB.FTS5Tokenization

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension GRDB.FTS5Tokenization: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.FTS5Tokenization: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = GRDB.FTS5Tokenization

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension GRDB.Database.FTS5RegisteredTokenizer: GRDB.FTS5Tokenizer {}
extension GRDB.FTS5TokenFlags: Swift.OptionSet {
    typealias Element = GRDB.FTS5TokenFlags

    init(rawValue: Self.RawValue)
}
extension GRDB.FTS5TokenFlags: Swift.RawRepresentable {
    typealias RawValue = Swift.Int32

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.FTS5TokenFlags: Swift.SetAlgebra {
    typealias Element = GRDB.FTS5TokenFlags

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension GRDB.FTS5TokenFlags: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.FTS5TokenFlags: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = GRDB.FTS5TokenFlags

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension GRDB.JSONColumn: GRDB.ColumnExpression {}
extension GRDB.JSONColumn: GRDB.SQLJSONExpressible {}
extension GRDB.JSONColumn: GRDB.SQLSpecificExpressible {}
extension GRDB.JSONColumn: GRDB.SQLExpressible {}
extension GRDB.JSONColumn: GRDB.SQLSelectable {}
extension GRDB.JSONColumn: GRDB.SQLOrderingTerm {}
extension GRDB.AnySQLJSONExpressible: GRDB.SQLJSONExpressible {}
extension GRDB.AnySQLJSONExpressible: GRDB.SQLSpecificExpressible {}
extension GRDB.AnySQLJSONExpressible: GRDB.SQLExpressible {}
extension GRDB.AnySQLJSONExpressible: GRDB.SQLSelectable {}
extension GRDB.AnySQLJSONExpressible: GRDB.SQLOrderingTerm {}
extension GRDB.DatabaseMigrator.ForeignKeyChecks: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabaseMigrator.ForeignKeyChecks: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.DatabaseMigrator: GRDB.Refinable {}
extension GRDB.DatabasePublishers.Migrate: Combine.Publisher {
    func receive<A1>(subscriber: A1) where A1: Combine.Subscriber, Self.Failure == A1.Failure, Self.Output == A1.Input
}
extension GRDB.Migration.ForeignKeyChecks: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Migration.ForeignKeyChecks: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.ForeignKey: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.AssociationAggregate: GRDB.Refinable {}
extension GRDB.BelongsToAssociation: GRDB.AssociationToOne {}
extension GRDB.BelongsToAssociation: GRDB.Association {
    typealias OriginRowDecoder = A
}
extension GRDB.BelongsToAssociation: GRDB.DerivableRequest {}
extension GRDB.BelongsToAssociation: GRDB.AggregatingRequest {}
extension GRDB.BelongsToAssociation: GRDB.FilteredRequest {}
extension GRDB.BelongsToAssociation: GRDB.JoinableRequest {}
extension GRDB.BelongsToAssociation: GRDB.OrderedRequest {}
extension GRDB.BelongsToAssociation: GRDB.SelectionRequest {}
extension GRDB.BelongsToAssociation: GRDB.TableRequest {}
extension GRDB.BelongsToAssociation: GRDB.TypedRequest {
    typealias RowDecoder = B
}
extension GRDB.HasManyAssociation: GRDB.AssociationToMany {}
extension GRDB.HasManyAssociation: GRDB.Association {
    typealias OriginRowDecoder = A
}
extension GRDB.HasManyAssociation: GRDB.DerivableRequest {}
extension GRDB.HasManyAssociation: GRDB.AggregatingRequest {}
extension GRDB.HasManyAssociation: GRDB.FilteredRequest {}
extension GRDB.HasManyAssociation: GRDB.JoinableRequest {}
extension GRDB.HasManyAssociation: GRDB.OrderedRequest {}
extension GRDB.HasManyAssociation: GRDB.SelectionRequest {}
extension GRDB.HasManyAssociation: GRDB.TableRequest {}
extension GRDB.HasManyAssociation: GRDB.TypedRequest {
    typealias RowDecoder = B
}
extension GRDB.HasManyThroughAssociation: GRDB.AssociationToMany {}
extension GRDB.HasManyThroughAssociation: GRDB.Association {
    typealias OriginRowDecoder = A
}
extension GRDB.HasManyThroughAssociation: GRDB.DerivableRequest {}
extension GRDB.HasManyThroughAssociation: GRDB.AggregatingRequest {}
extension GRDB.HasManyThroughAssociation: GRDB.FilteredRequest {}
extension GRDB.HasManyThroughAssociation: GRDB.JoinableRequest {}
extension GRDB.HasManyThroughAssociation: GRDB.OrderedRequest {}
extension GRDB.HasManyThroughAssociation: GRDB.SelectionRequest {}
extension GRDB.HasManyThroughAssociation: GRDB.TableRequest {}
extension GRDB.HasManyThroughAssociation: GRDB.TypedRequest {
    typealias RowDecoder = B
}
extension GRDB.HasOneAssociation: GRDB.AssociationToOne {}
extension GRDB.HasOneAssociation: GRDB.Association {
    typealias OriginRowDecoder = A
}
extension GRDB.HasOneAssociation: GRDB.DerivableRequest {}
extension GRDB.HasOneAssociation: GRDB.AggregatingRequest {}
extension GRDB.HasOneAssociation: GRDB.FilteredRequest {}
extension GRDB.HasOneAssociation: GRDB.JoinableRequest {}
extension GRDB.HasOneAssociation: GRDB.OrderedRequest {}
extension GRDB.HasOneAssociation: GRDB.SelectionRequest {}
extension GRDB.HasOneAssociation: GRDB.TableRequest {}
extension GRDB.HasOneAssociation: GRDB.TypedRequest {
    typealias RowDecoder = B
}
extension GRDB.HasOneThroughAssociation: GRDB.AssociationToOne {}
extension GRDB.HasOneThroughAssociation: GRDB.Association {
    typealias OriginRowDecoder = A
}
extension GRDB.HasOneThroughAssociation: GRDB.DerivableRequest {}
extension GRDB.HasOneThroughAssociation: GRDB.AggregatingRequest {}
extension GRDB.HasOneThroughAssociation: GRDB.FilteredRequest {}
extension GRDB.HasOneThroughAssociation: GRDB.JoinableRequest {}
extension GRDB.HasOneThroughAssociation: GRDB.OrderedRequest {}
extension GRDB.HasOneThroughAssociation: GRDB.SelectionRequest {}
extension GRDB.HasOneThroughAssociation: GRDB.TableRequest {}
extension GRDB.HasOneThroughAssociation: GRDB.TypedRequest {
    typealias RowDecoder = B
}
extension GRDB.JoinAssociation: GRDB.AssociationToOne {}
extension GRDB.JoinAssociation: GRDB.Association {
    typealias OriginRowDecoder = A
}
extension GRDB.JoinAssociation: GRDB.DerivableRequest {}
extension GRDB.JoinAssociation: GRDB.AggregatingRequest {}
extension GRDB.JoinAssociation: GRDB.FilteredRequest {}
extension GRDB.JoinAssociation: GRDB.JoinableRequest {}
extension GRDB.JoinAssociation: GRDB.OrderedRequest {}
extension GRDB.JoinAssociation: GRDB.SelectionRequest {}
extension GRDB.JoinAssociation: GRDB.TableRequest {}
extension GRDB.JoinAssociation: GRDB.TypedRequest {
    typealias RowDecoder = B
}
extension GRDB.QueryInterfaceRequest: GRDB.Refinable {}
extension GRDB.QueryInterfaceRequest: GRDB.FetchRequest {
    typealias RowDecoder = A
}
extension GRDB.QueryInterfaceRequest: GRDB.SQLSubqueryable {}
extension GRDB.QueryInterfaceRequest: GRDB.DatabaseRegionConvertible {}
extension GRDB.QueryInterfaceRequest: GRDB.SQLSpecificExpressible {}
extension GRDB.QueryInterfaceRequest: GRDB.SQLExpressible {}
extension GRDB.QueryInterfaceRequest: GRDB.SQLSelectable {}
extension GRDB.QueryInterfaceRequest: GRDB.SQLOrderingTerm {}
extension GRDB.QueryInterfaceRequest: GRDB.SelectionRequest {}
extension GRDB.QueryInterfaceRequest: GRDB.FilteredRequest {}
extension GRDB.QueryInterfaceRequest: GRDB.OrderedRequest {}
extension GRDB.QueryInterfaceRequest: GRDB.AggregatingRequest {}
extension GRDB.QueryInterfaceRequest: GRDB.JoinableRequest {}
extension GRDB.QueryInterfaceRequest: GRDB.TypedRequest {
    typealias RowDecoder = A
}
extension GRDB.QueryInterfaceRequest: GRDB.TableRequest {}
extension GRDB.QueryInterfaceRequest: GRDB.DerivableRequest {}
extension GRDB.Column: GRDB.ColumnExpression {}
extension GRDB.Column: GRDB.SQLSpecificExpressible {}
extension GRDB.Column: GRDB.SQLExpressible {}
extension GRDB.Column: GRDB.SQLSelectable {}
extension GRDB.Column: GRDB.SQLOrderingTerm {}
extension GRDB.DatabasePromise: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB._SQLAssociation: GRDB.Refinable {}
extension GRDB.SQLAssociationStep: GRDB.Refinable {}
extension GRDB.SQLAssociationKey: GRDB.Refinable {}
extension GRDB.SQLAssociationCardinality: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SQLAssociationCardinality: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SQLExpression.AssociativeBinaryOperator: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SQLExpression.AssociativeBinaryOperator: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SQLExpression: GRDB.SQLSpecificExpressible {}
extension GRDB.SQLExpression: GRDB.SQLExpressible {}
extension GRDB.SQLExpression: GRDB.SQLSelectable {}
extension GRDB.SQLExpression: GRDB.SQLOrderingTerm {}
extension GRDB.SQLExpression.JSONInterpretation: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SQLExpression.JSONInterpretation: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SQLExpression.BinaryOperator: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SQLExpression.BinaryOperator: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SQLExpression.UnaryOperator: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SQLExpression.UnaryOperator: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SQLExpression.EqualityOperator: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.SQLExpression.EqualityOperator: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SQLExpression.EqualityOperator: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SQLDateModifier: GRDB.SQLSpecificExpressible {}
extension GRDB.SQLDateModifier: GRDB.SQLExpressible {}
extension GRDB.SQLDateModifier: GRDB.SQLSelectable {}
extension GRDB.SQLDateModifier: GRDB.SQLOrderingTerm {}
extension GRDB.SQLOrdering: GRDB.SQLOrderingTerm {}
extension GRDB.PersistenceContainer: GRDB.ColumnAddressable {
    typealias ColumnIndex = Swift.String
}
extension GRDB.PersistenceContainer: Swift.RandomAccessCollection {
    typealias Element = (Swift.String, GRDB.DatabaseValue)
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<GRDB.PersistenceContainer>
    typealias Indices = Swift.Range<Swift.Int>

    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension GRDB.PersistenceContainer: Swift.BidirectionalCollection {
    typealias Element = (Swift.String, GRDB.DatabaseValue)
    typealias Index = Swift.Int
    typealias SubSequence = Swift.Slice<GRDB.PersistenceContainer>
    typealias Indices = Swift.Range<Swift.Int>

    func index(before: Self.Index) -> Self.Index
    func formIndex(before: inout Self.Index)
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
}
extension GRDB.PersistenceContainer: Swift.Collection {
    typealias Element = (Swift.String, GRDB.DatabaseValue)
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<GRDB.PersistenceContainer>
    typealias SubSequence = Swift.Slice<GRDB.PersistenceContainer>
    typealias Indices = Swift.Range<Swift.Int>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension GRDB.PersistenceContainer: Swift.Sequence {
    typealias Element = (Swift.String, GRDB.DatabaseValue)
    typealias Iterator = Swift.IndexingIterator<GRDB.PersistenceContainer>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension GRDB.SQLRelation: GRDB.Refinable {}
extension GRDB.SQLRelation.Child: GRDB.Refinable {}
extension GRDB.DummyRow: GRDB.ColumnAddressable {
    typealias ColumnIndex = GRDB.DummyRow.DummyIndex
}
extension GRDB.SQLForeignKeyCondition: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SQLRelation.Child.Kind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SQLRelation.Child.Kind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SQLSelection: GRDB.SQLSelectable {}
extension GRDB.AllColumns: GRDB.SQLSelectable {}
extension GRDB.AllColumnsExcluding: GRDB.SQLSelectable {}
extension GRDB.SQLSubquery: GRDB.SQLSubqueryable {}
extension GRDB.SQLSubquery: GRDB.SQLSpecificExpressible {}
extension GRDB.SQLSubquery: GRDB.SQLExpressible {}
extension GRDB.SQLSubquery: GRDB.SQLSelectable {}
extension GRDB.SQLSubquery: GRDB.SQLOrderingTerm {}
extension GRDB.Table: GRDB.DatabaseRegionConvertible {}
extension GRDB.SQLQueryGenerator: GRDB.Refinable {}
extension GRDB.SQLQualifiedRelation: GRDB.Refinable {}
extension GRDB.SQLQualifiedJoin: GRDB.Refinable {}
extension GRDB.SQLQualifiedJoin.Kind: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.SQLQualifiedJoin.Kind: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.SQLQualifiedJoin.Kind: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.TableAliasBase: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.TableAliasBase: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.ColumnDefinition.GeneratedColumnQualification: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.ColumnDefinition.GeneratedColumnQualification: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.ViewOptions: Swift.OptionSet {
    typealias Element = GRDB.ViewOptions

    init(rawValue: Self.RawValue)
}
extension GRDB.ViewOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.ViewOptions: Swift.SetAlgebra {
    typealias Element = GRDB.ViewOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension GRDB.ViewOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.ViewOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = GRDB.ViewOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension GRDB.ForeignKeyDefinition.Indexing: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.ForeignKeyDefinition.Indexing: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.IndexOptions: Swift.OptionSet {
    typealias Element = GRDB.IndexOptions

    init(rawValue: Self.RawValue)
}
extension GRDB.IndexOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.IndexOptions: Swift.SetAlgebra {
    typealias Element = GRDB.IndexOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension GRDB.IndexOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.IndexOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = GRDB.IndexOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension GRDB.TableOptions: Swift.OptionSet {
    typealias Element = GRDB.TableOptions

    init(rawValue: Self.RawValue)
}
extension GRDB.TableOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.TableOptions: Swift.SetAlgebra {
    typealias Element = GRDB.TableOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension GRDB.TableOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.TableOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = GRDB.TableOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension GRDB.VirtualTableOptions: Swift.OptionSet {
    typealias Element = GRDB.VirtualTableOptions

    init(rawValue: Self.RawValue)
}
extension GRDB.VirtualTableOptions: Swift.RawRepresentable {
    typealias RawValue = Swift.Int

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension GRDB.VirtualTableOptions: Swift.SetAlgebra {
    typealias Element = GRDB.VirtualTableOptions

    init()
    init<A1>(_: __owned A1) where A1: Swift.Sequence, Self.Element == A1.Element

    var isEmpty: Swift.Bool {
        get
    }

    func contains(_: Self.Element) -> Swift.Bool
    func union(_: __owned Self) -> Self
    func intersection(_: Self) -> Self
    func symmetricDifference(_: __owned Self) -> Self
    func insert(_: __owned Self.Element) -> (inserted: Swift.Bool, memberAfterInsert: Self.Element)
    func remove(_: Self.Element) -> Self.Element?
    func update(with: __owned Self.Element) -> Self.Element?
    func formUnion(_: __owned Self)
    func formIntersection(_: Self)
    func formSymmetricDifference(_: __owned Self)
    func subtracting(_: Self) -> Self
    func isSubset(of: Self) -> Swift.Bool
    func isDisjoint(with: Self) -> Swift.Bool
    func isSuperset(of: Self) -> Swift.Bool
    func subtract(_: Self)
}
extension GRDB.VirtualTableOptions: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.VirtualTableOptions: Swift.ExpressibleByArrayLiteral {
    typealias ArrayLiteralElement = GRDB.VirtualTableOptions

    init(arrayLiteral: Self.ArrayLiteralElement...)
}
extension GRDB.ColumnEncoder: Swift.SingleValueEncodingContainer {
    var codingPath: [Swift.CodingKey] {
        get
    }

    func encodeNil() throws
    func encode(_: Swift.Bool) throws
    func encode(_: Swift.String) throws
    func encode(_: Swift.Double) throws
    func encode(_: Swift.Float) throws
    func encode(_: Swift.Int) throws
    func encode(_: Swift.Int8) throws
    func encode(_: Swift.Int16) throws
    func encode(_: Swift.Int32) throws
    func encode(_: Swift.Int64) throws
    func encode(_: Swift.Int128) throws
    func encode(_: Swift.UInt) throws
    func encode(_: Swift.UInt8) throws
    func encode(_: Swift.UInt16) throws
    func encode(_: Swift.UInt32) throws
    func encode(_: Swift.UInt64) throws
    func encode(_: Swift.UInt128) throws
    func encode<A1>(_: A1) throws where A1: Swift.Encodable
}
extension GRDB.ColumnEncoder: Swift.Encoder {
    var userInfo: [Swift.CodingUserInfoKey : Any] {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func container<A1>(keyedBy: A1.Type) -> Swift.KeyedEncodingContainer<A1> where A1: Swift.CodingKey
    func unkeyedContainer() -> Swift.UnkeyedEncodingContainer
    func singleValueContainer() -> Swift.SingleValueEncodingContainer
}
extension GRDB.RecordEncoder: Swift.SingleValueEncodingContainer {
    var codingPath: [Swift.CodingKey] {
        get
    }

    func encodeNil() throws
    func encode(_: Swift.Bool) throws
    func encode(_: Swift.String) throws
    func encode(_: Swift.Double) throws
    func encode(_: Swift.Float) throws
    func encode(_: Swift.Int) throws
    func encode(_: Swift.Int8) throws
    func encode(_: Swift.Int16) throws
    func encode(_: Swift.Int32) throws
    func encode(_: Swift.Int64) throws
    func encode(_: Swift.Int128) throws
    func encode(_: Swift.UInt) throws
    func encode(_: Swift.UInt8) throws
    func encode(_: Swift.UInt16) throws
    func encode(_: Swift.UInt32) throws
    func encode(_: Swift.UInt64) throws
    func encode(_: Swift.UInt128) throws
    func encode<A1>(_: A1) throws where A1: Swift.Encodable
}
extension GRDB.RecordEncoder: Swift.Encoder {
    var userInfo: [Swift.CodingUserInfoKey : Any] {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func container<A1>(keyedBy: A1.Type) -> Swift.KeyedEncodingContainer<A1> where A1: Swift.CodingKey
    func unkeyedContainer() -> Swift.UnkeyedEncodingContainer
    func singleValueContainer() -> Swift.SingleValueEncodingContainer
}
extension GRDB.RecordEncoder.KeyedContainer: Swift.KeyedEncodingContainerProtocol {
    typealias Key = A1

    var codingPath: [Swift.CodingKey] {
        get
    }

    func encodeNil(forKey: Self.Key) throws
    func encode(_: Swift.Bool, forKey: Self.Key) throws
    func encode(_: Swift.String, forKey: Self.Key) throws
    func encode(_: Swift.Double, forKey: Self.Key) throws
    func encode(_: Swift.Float, forKey: Self.Key) throws
    func encode(_: Swift.Int, forKey: Self.Key) throws
    func encode(_: Swift.Int8, forKey: Self.Key) throws
    func encode(_: Swift.Int16, forKey: Self.Key) throws
    func encode(_: Swift.Int32, forKey: Self.Key) throws
    func encode(_: Swift.Int64, forKey: Self.Key) throws
    func encode(_: Swift.Int128, forKey: Self.Key) throws
    func encode(_: Swift.UInt, forKey: Self.Key) throws
    func encode(_: Swift.UInt8, forKey: Self.Key) throws
    func encode(_: Swift.UInt16, forKey: Self.Key) throws
    func encode(_: Swift.UInt32, forKey: Self.Key) throws
    func encode(_: Swift.UInt64, forKey: Self.Key) throws
    func encode(_: Swift.UInt128, forKey: Self.Key) throws
    func encode<A1>(_: A1, forKey: Self.Key) throws where A1: Swift.Encodable
    func encodeConditional<A1>(_: A1, forKey: Self.Key) throws where A1: AnyObject, A1: Swift.Encodable
    func encodeIfPresent(_: Swift.Bool?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.String?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Double?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Float?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int8?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int16?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int32?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int64?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.Int128?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt8?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt16?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt32?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt64?, forKey: Self.Key) throws
    func encodeIfPresent(_: Swift.UInt128?, forKey: Self.Key) throws
    func encodeIfPresent<A1>(_: A1?, forKey: Self.Key) throws where A1: Swift.Encodable
    func nestedContainer<A1>(keyedBy: A1.Type, forKey: Self.Key) -> Swift.KeyedEncodingContainer<A1> where A1: Swift.CodingKey
    func nestedUnkeyedContainer(forKey: Self.Key) -> Swift.UnkeyedEncodingContainer
    func superEncoder() -> Swift.Encoder
    func superEncoder(forKey: Self.Key) -> Swift.Encoder
}
extension GRDB.DatabaseUUIDEncodingStrategy: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.DatabaseUUIDEncodingStrategy: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.ColumnDecoder: Swift.SingleValueDecodingContainer {
    var codingPath: [Swift.CodingKey] {
        get
    }

    func decodeNil() -> Swift.Bool
    func decode(_: Swift.Bool.Type) throws -> Swift.Bool
    func decode(_: Swift.String.Type) throws -> Swift.String
    func decode(_: Swift.Double.Type) throws -> Swift.Double
    func decode(_: Swift.Float.Type) throws -> Swift.Float
    func decode(_: Swift.Int.Type) throws -> Swift.Int
    func decode(_: Swift.Int8.Type) throws -> Swift.Int8
    func decode(_: Swift.Int16.Type) throws -> Swift.Int16
    func decode(_: Swift.Int32.Type) throws -> Swift.Int32
    func decode(_: Swift.Int64.Type) throws -> Swift.Int64
    func decode(_: Swift.Int128.Type) throws -> Swift.Int128
    func decode(_: Swift.UInt.Type) throws -> Swift.UInt
    func decode(_: Swift.UInt8.Type) throws -> Swift.UInt8
    func decode(_: Swift.UInt16.Type) throws -> Swift.UInt16
    func decode(_: Swift.UInt32.Type) throws -> Swift.UInt32
    func decode(_: Swift.UInt64.Type) throws -> Swift.UInt64
    func decode(_: Swift.UInt128.Type) throws -> Swift.UInt128
    func decode<A1>(_: A1.Type) throws -> A1 where A1: Swift.Decodable
}
extension GRDB.ColumnDecoder: Swift.Decoder {
    var userInfo: [Swift.CodingUserInfoKey : Any] {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }

    func container<A1>(keyedBy: A1.Type) throws -> Swift.KeyedDecodingContainer<A1> where A1: Swift.CodingKey
    func unkeyedContainer() throws -> Swift.UnkeyedDecodingContainer
    func singleValueContainer() throws -> Swift.SingleValueDecodingContainer
}
extension GRDB.PrefetchedRowsDecoder: Swift.UnkeyedDecodingContainer {
    var count: Swift.Int? {
        get
    }
    var isAtEnd: Swift.Bool {
        get
    }
    var codingPath: [Swift.CodingKey] {
        get
    }
    var currentIndex: Swift.Int {
        get
    }

    func decodeNil() throws -> Swift.Bool
    func decode(_: Swift.Bool.Type) throws -> Swift.Bool
    func decode(_: Swift.String.Type) throws -> Swift.String
    func decode(_: Swift.Double.Type) throws -> Swift.Double
    func decode(_: Swift.Float.Type) throws -> Swift.Float
    func decode(_: Swift.Int.Type) throws -> Swift.Int
    func decode(_: Swift.Int8.Type) throws -> Swift.Int8
    func decode(_: Swift.Int16.Type) throws -> Swift.Int16
    func decode(_: Swift.Int32.Type) throws -> Swift.Int32
    func decode(_: Swift.Int64.Type) throws -> Swift.Int64
    func decode(_: Swift.Int128.Type) throws -> Swift.Int128
    func decode(_: Swift.UInt.Type) throws -> Swift.UInt
    func decode(_: Swift.UInt8.Type) throws -> Swift.UInt8
    func decode(_: Swift.UInt16.Type) throws -> Swift.UInt16
    func decode(_: Swift.UInt32.Type) throws -> Swift.UInt32
    func decode(_: Swift.UInt64.Type) throws -> Swift.UInt64
    func decode(_: Swift.UInt128.Type) throws -> Swift.UInt128
    func decode<A1>(_: A1.Type) throws -> A1 where A1: Swift.Decodable
    func decodeIfPresent(_: Swift.Bool.Type) throws -> Swift.Bool?
    func decodeIfPresent(_: Swift.String.Type) throws -> Swift.String?
    func decodeIfPresent(_: Swift.Double.Type) throws -> Swift.Double?
    func decodeIfPresent(_: Swift.Float.Type) throws -> Swift.Float?
    func decodeIfPresent(_: Swift.Int.Type) throws -> Swift.Int?
    func decodeIfPresent(_: Swift.Int8.Type) throws -> Swift.Int8?
    func decodeIfPresent(_: Swift.Int16.Type) throws -> Swift.Int16?
    func decodeIfPresent(_: Swift.Int32.Type) throws -> Swift.Int32?
    func decodeIfPresent(_: Swift.Int64.Type) throws -> Swift.Int64?
    func decodeIfPresent(_: Swift.Int128.Type) throws -> Swift.Int128?
    func decodeIfPresent(_: Swift.UInt.Type) throws -> Swift.UInt?
    func decodeIfPresent(_: Swift.UInt8.Type) throws -> Swift.UInt8?
    func decodeIfPresent(_: Swift.UInt16.Type) throws -> Swift.UInt16?
    func decodeIfPresent(_: Swift.UInt32.Type) throws -> Swift.UInt32?
    func decodeIfPresent(_: Swift.UInt64.Type) throws -> Swift.UInt64?
    func decodeIfPresent(_: Swift.UInt128.Type) throws -> Swift.UInt128?
    func decodeIfPresent<A1>(_: A1.Type) throws -> A1? where A1: Swift.Decodable
    func nestedContainer<A1>(keyedBy: A1.Type) throws -> Swift.KeyedDecodingContainer<A1> where A1: Swift.CodingKey
    func nestedUnkeyedContainer() throws -> Swift.UnkeyedDecodingContainer
    func superDecoder() throws -> Swift.Decoder
}
extension GRDB.PrefetchedRowsDecoder: Swift.Decoder {
    var codingPath: [Swift.CodingKey] {
        get
    }
    var userInfo: [Swift.CodingUserInfoKey : Any] {
        get
    }

    func container<A1>(keyedBy: A1.Type) throws -> Swift.KeyedDecodingContainer<A1> where A1: Swift.CodingKey
    func unkeyedContainer() throws -> Swift.UnkeyedDecodingContainer
    func singleValueContainer() throws -> Swift.SingleValueDecodingContainer
}
extension GRDB._RowDecoder.KeyedContainer: Swift.KeyedDecodingContainerProtocol {
    var codingPath: [Swift.CodingKey] {
        get
    }
    var allKeys: [Self.Key] {
        get
    }

    func contains(_: Self.Key) -> Swift.Bool
    func decodeNil(forKey: Self.Key) throws -> Swift.Bool
    func decode(_: Swift.Bool.Type, forKey: Self.Key) throws -> Swift.Bool
    func decode(_: Swift.String.Type, forKey: Self.Key) throws -> Swift.String
    func decode(_: Swift.Double.Type, forKey: Self.Key) throws -> Swift.Double
    func decode(_: Swift.Float.Type, forKey: Self.Key) throws -> Swift.Float
    func decode(_: Swift.Int.Type, forKey: Self.Key) throws -> Swift.Int
    func decode(_: Swift.Int8.Type, forKey: Self.Key) throws -> Swift.Int8
    func decode(_: Swift.Int16.Type, forKey: Self.Key) throws -> Swift.Int16
    func decode(_: Swift.Int32.Type, forKey: Self.Key) throws -> Swift.Int32
    func decode(_: Swift.Int64.Type, forKey: Self.Key) throws -> Swift.Int64
    func decode(_: Swift.Int128.Type, forKey: Self.Key) throws -> Swift.Int128
    func decode(_: Swift.UInt.Type, forKey: Self.Key) throws -> Swift.UInt
    func decode(_: Swift.UInt8.Type, forKey: Self.Key) throws -> Swift.UInt8
    func decode(_: Swift.UInt16.Type, forKey: Self.Key) throws -> Swift.UInt16
    func decode(_: Swift.UInt32.Type, forKey: Self.Key) throws -> Swift.UInt32
    func decode(_: Swift.UInt64.Type, forKey: Self.Key) throws -> Swift.UInt64
    func decode(_: Swift.UInt128.Type, forKey: Self.Key) throws -> Swift.UInt128
    func decode<A1>(_: A1.Type, forKey: Self.Key) throws -> A1 where A1: Swift.Decodable
    func decodeIfPresent(_: Swift.Bool.Type, forKey: Self.Key) throws -> Swift.Bool?
    func decodeIfPresent(_: Swift.String.Type, forKey: Self.Key) throws -> Swift.String?
    func decodeIfPresent(_: Swift.Double.Type, forKey: Self.Key) throws -> Swift.Double?
    func decodeIfPresent(_: Swift.Float.Type, forKey: Self.Key) throws -> Swift.Float?
    func decodeIfPresent(_: Swift.Int.Type, forKey: Self.Key) throws -> Swift.Int?
    func decodeIfPresent(_: Swift.Int8.Type, forKey: Self.Key) throws -> Swift.Int8?
    func decodeIfPresent(_: Swift.Int16.Type, forKey: Self.Key) throws -> Swift.Int16?
    func decodeIfPresent(_: Swift.Int32.Type, forKey: Self.Key) throws -> Swift.Int32?
    func decodeIfPresent(_: Swift.Int64.Type, forKey: Self.Key) throws -> Swift.Int64?
    func decodeIfPresent(_: Swift.Int128.Type, forKey: Self.Key) throws -> Swift.Int128?
    func decodeIfPresent(_: Swift.UInt.Type, forKey: Self.Key) throws -> Swift.UInt?
    func decodeIfPresent(_: Swift.UInt8.Type, forKey: Self.Key) throws -> Swift.UInt8?
    func decodeIfPresent(_: Swift.UInt16.Type, forKey: Self.Key) throws -> Swift.UInt16?
    func decodeIfPresent(_: Swift.UInt32.Type, forKey: Self.Key) throws -> Swift.UInt32?
    func decodeIfPresent(_: Swift.UInt64.Type, forKey: Self.Key) throws -> Swift.UInt64?
    func decodeIfPresent(_: Swift.UInt128.Type, forKey: Self.Key) throws -> Swift.UInt128?
    func decodeIfPresent<A1>(_: A1.Type, forKey: Self.Key) throws -> A1? where A1: Swift.Decodable
    func nestedContainer<A1>(keyedBy: A1.Type, forKey: Self.Key) throws -> Swift.KeyedDecodingContainer<A1> where A1: Swift.CodingKey
    func nestedUnkeyedContainer(forKey: Self.Key) throws -> Swift.UnkeyedDecodingContainer
    func superDecoder() throws -> Swift.Decoder
    func superDecoder(forKey: Self.Key) throws -> Swift.Decoder
}
extension GRDB._RowDecoder: Swift.Decoder {
    var codingPath: [Swift.CodingKey] {
        get
    }
    var userInfo: [Swift.CodingUserInfoKey : Any] {
        get
    }

    func container<A1>(keyedBy: A1.Type) throws -> Swift.KeyedDecodingContainer<A1> where A1: Swift.CodingKey
    func unkeyedContainer() throws -> Swift.UnkeyedDecodingContainer
    func singleValueContainer() throws -> Swift.SingleValueDecodingContainer
}
extension GRDB.SingleValueRowDecoder: Swift.SingleValueDecodingContainer {
    var codingPath: [Swift.CodingKey] {
        get
    }

    func decodeNil() -> Swift.Bool
    func decode(_: Swift.Bool.Type) throws -> Swift.Bool
    func decode(_: Swift.String.Type) throws -> Swift.String
    func decode(_: Swift.Double.Type) throws -> Swift.Double
    func decode(_: Swift.Float.Type) throws -> Swift.Float
    func decode(_: Swift.Int.Type) throws -> Swift.Int
    func decode(_: Swift.Int8.Type) throws -> Swift.Int8
    func decode(_: Swift.Int16.Type) throws -> Swift.Int16
    func decode(_: Swift.Int32.Type) throws -> Swift.Int32
    func decode(_: Swift.Int64.Type) throws -> Swift.Int64
    func decode(_: Swift.Int128.Type) throws -> Swift.Int128
    func decode(_: Swift.UInt.Type) throws -> Swift.UInt
    func decode(_: Swift.UInt8.Type) throws -> Swift.UInt8
    func decode(_: Swift.UInt16.Type) throws -> Swift.UInt16
    func decode(_: Swift.UInt32.Type) throws -> Swift.UInt32
    func decode(_: Swift.UInt64.Type) throws -> Swift.UInt64
    func decode(_: Swift.UInt128.Type) throws -> Swift.UInt128
    func decode<A1>(_: A1.Type) throws -> A1 where A1: Swift.Decodable
}
extension GRDB.RecordCursor: GRDB.DatabaseCursor {}
extension GRDB.RecordCursor: GRDB.Cursor {
    typealias Element = A
}
extension GRDB.UpdateQuery: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.UpdateQuery: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.InsertQuery: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.InsertQuery: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.Record: GRDB.TableRecord {
    typealias Columns = Swift.Never
    typealias DatabaseComponents = Swift.Never.Type
}
extension GRDB.Record: GRDB.PersistableRecord {}
extension GRDB.Record: GRDB.MutablePersistableRecord {}
extension GRDB.Record: GRDB.EncodableRecord {}
extension GRDB.Record: GRDB.FetchableRecord {}
extension GRDB.RecordError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension GRDB.RecordError: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.CaseInsensitiveIdentifier: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.CaseInsensitiveIdentifier: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.OnDemandFutureSubscription: Combine.CustomCombineIdentifierConvertible {
    var combineIdentifier: Combine.CombineIdentifier {
        get
    }
}
extension GRDB.OnDemandFutureSubscription: Combine.Cancellable {
    func cancel()
}
extension GRDB.OnDemandFutureSubscription: Combine.Subscription {
    func request(_: Combine.Subscribers.Demand)
}
extension GRDB.OnDemandFuture: Combine.Publisher {
    typealias Output = A
    typealias Failure = B

    func receive<A1>(subscriber: A1) where A1: Combine.Subscriber, Self.Failure == A1.Failure, Self.Output == A1.Input
}
extension GRDB.OrderedDictionary: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension GRDB.OrderedDictionary: Swift.Equatable where B: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.OrderedDictionary: Swift.ExpressibleByDictionaryLiteral {
    typealias Key = A
    typealias Value = B

    init(dictionaryLiteral: (Self.Key, Self.Value)...)
}
extension GRDB.OrderedDictionary: Swift.Sequence {
    typealias Element = (key: A, value: B)
    typealias Iterator = Swift.IndexingIterator<GRDB.OrderedDictionary<A, B>>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension GRDB.OrderedDictionary: Swift.Collection {
    typealias Element = (key: A, value: B)
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<GRDB.OrderedDictionary<A, B>>
    typealias SubSequence = Swift.Slice<GRDB.OrderedDictionary<A, B>>
    typealias Indices = Swift.DefaultIndices<GRDB.OrderedDictionary<A, B>>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension GRDB.PoolCompletion: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.PoolCompletion: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.ReceiveValuesOnSubscription: Combine.CustomCombineIdentifierConvertible {
    var combineIdentifier: Combine.CombineIdentifier {
        get
    }
}
extension GRDB.ReceiveValuesOnSubscription: Combine.Cancellable {
    func cancel()
}
extension GRDB.ReceiveValuesOnSubscription: Combine.Subscriber {
    typealias Input = A.Publisher.Output
    typealias Failure = A.Publisher.Failure

    func receive(subscription: Combine.Subscription)
    func receive(_: Self.Input) -> Combine.Subscribers.Demand
    func receive(completion: Combine.Subscribers.Completion<Self.Failure>)
}
extension GRDB.ReceiveValuesOnSubscription: Combine.Subscription {
    func request(_: Combine.Subscribers.Demand)
}
extension GRDB.ReceiveValuesOn: Combine.Publisher {
    typealias Output = A.Publisher.Output
    typealias Failure = A.Publisher.Failure

    func receive<A1>(subscriber: A1) where A1: Combine.Subscriber, Self.Failure == A1.Failure, Self.Output == A1.Input
}
extension GRDB.PrintOutputStream: Swift.TextOutputStream {
    func _lock()
    func _unlock()
    func write(_: Swift.String)
    func _writeASCII(_: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
extension GRDB.AnyDatabaseCancellable: GRDB.DatabaseCancellable {}
extension GRDB.ValueConcurrentObserver.FetchingState: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.ValueConcurrentObserver.FetchingState: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.ValueConcurrentObserver: GRDB.DatabaseCancellable {}
extension GRDB.ValueConcurrentObserver: GRDB.TransactionObserver {}
extension GRDB.ValueWriteOnlyObserver: GRDB.DatabaseCancellable {}
extension GRDB.ValueWriteOnlyObserver: GRDB.TransactionObserver {}
extension GRDB.ValueReducers.Fetch._Fetcher: GRDB._ValueReducerFetcher {}
extension GRDB.ValueReducers.Fetch: GRDB.ValueReducer {}
extension GRDB.ValueReducers.Fetch: GRDB._ValueReducer {}
extension GRDB.ValueReducers.Map: GRDB.ValueReducer {}
extension GRDB.ValueReducers.Map: GRDB._ValueReducer {}
extension GRDB.ValueReducers.RemoveDuplicates: GRDB.ValueReducer {}
extension GRDB.ValueReducers.RemoveDuplicates: GRDB._ValueReducer {}
extension GRDB.ValueReducers.Trace._Fetcher: GRDB._ValueReducerFetcher {}
extension GRDB.ValueReducers.Trace: GRDB.ValueReducer {}
extension GRDB.ValueReducers.Trace: GRDB._ValueReducer {}
extension GRDB.SharedValueObservationExtent: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension GRDB.SharedValueObservationExtent: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension GRDB.ValueObservation: GRDB.Refinable {}
extension GRDB.AsyncValueObservation.Iterator: Swift.AsyncIteratorProtocol {
    typealias Element = A
    typealias Failure = Swift.Error

    func next() async throws -> Self.Element?
    func next(isolation: isolated Swift.Actor?) async throws(Self.Failure) -> Self.Element?
}
extension GRDB.AsyncValueObservation: Swift.AsyncSequence {
    typealias AsyncIterator = GRDB.AsyncValueObservation<A>.Iterator
    typealias Element = A
    typealias Failure = Swift.Error

    func makeAsyncIterator() -> Self.AsyncIterator
}
extension GRDB.DatabasePublishers.Value: Combine.Publisher {
    func receive<A1>(subscriber: A1) where A1: Combine.Subscriber, Self.Failure == A1.Failure, Self.Output == A1.Input
}
extension GRDB.ValueObservationEvents: GRDB.Refinable {}
extension GRDB.DatabasePublishers.ValueSubscription: Combine.CustomCombineIdentifierConvertible {
    var combineIdentifier: Combine.CombineIdentifier {
        get
    }
}
extension GRDB.DatabasePublishers.ValueSubscription: Combine.Cancellable {
    func cancel()
}
extension GRDB.DatabasePublishers.ValueSubscription: Combine.Subscription {
    func request(_: Combine.Subscribers.Demand)
}
extension GRDB.AsyncValueObservationScheduler: GRDB.ValueObservationScheduler {}
extension GRDB.ImmediateValueObservationScheduler: GRDB.ValueObservationMainActorScheduler {}
extension GRDB.ImmediateValueObservationScheduler: GRDB.ValueObservationScheduler {}
extension GRDB.TaskValueObservationScheduler: GRDB.ValueObservationScheduler {}
extension GRDB.DelayedMainActorValueObservationScheduler: GRDB.ValueObservationMainActorScheduler {}
extension GRDB.DelayedMainActorValueObservationScheduler: GRDB.ValueObservationScheduler {}
extension Grape.AnyGraphContent: Grape.GraphContent {
    typealias NodeID = A
    typealias Body = Grape._IdentifiableNever<A>
}
extension Grape.LinkMark: Grape.GraphContent {
    typealias NodeID = A
    typealias Body = Grape._IdentifiableNever<A>
}
extension Grape.LinkMark: Swift.Identifiable {
    typealias ID = ForceSimulation.EdgeID<A>

    var id: Self.ID {
        get
    }
}
extension Grape.LinkMark: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension Grape.LinkMark: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Grape.ModifiedGraphContent: Grape.GraphContent {
    typealias NodeID = A.GraphContent.NodeID
    typealias Body = Grape._IdentifiableNever<A.GraphContent.NodeID>
}
extension Grape.NodeMark: Grape.GraphContent {
    typealias NodeID = A
    typealias Body = Grape._IdentifiableNever<A>
}
extension Grape.NodeMark: Swift.Identifiable {
    typealias ID = A

    var id: Self.ID {
        get
    }
}
extension Grape.NodeMark: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Grape.AnnotationNodeMark: Grape.GraphContent {
    typealias NodeID = A
    typealias Body = Grape.ModifiedGraphContent<Grape.ModifiedGraphContent<Grape.ModifiedGraphContent<Grape.NodeMark<A>, Grape.GraphContentEffect.SymbolSize>, Grape.GraphContentEffect.Shading>, Grape.GraphContentEffect.ViewAnnotation>
}
extension Grape.AnnotationNodeMark: Swift.Identifiable {
    typealias ID = A

    var id: Self.ID {
        get
    }
}
extension Grape.Series: Grape.GraphContent {
    typealias NodeID = A
    typealias Body = Grape._IdentifiableNever<A>
}
extension Grape._ArrayGraphContent: Grape.GraphContent {
    typealias NodeID = A.GraphContent.NodeID
    typealias Body = Grape._IdentifiableNever<A.GraphContent.NodeID>
}
extension Grape._ConditionalGraphContent: Grape.GraphContent {
    typealias NodeID = A.GraphContent.NodeID
    typealias Body = Grape._IdentifiableNever<A.GraphContent.NodeID>
}
extension Grape._EmptyGraphContent: Grape.GraphContent {
    typealias NodeID = A
    typealias Body = Grape._IdentifiableNever<A>
}
extension Grape._IdentifiableNever: Grape.GraphContent {
    typealias NodeID = A
    typealias Body = Grape._IdentifiableNever<A>
}
extension Grape._IdentifiableNever: Swift.Identifiable {
    typealias ID = A

    var id: Self.ID {
        get
    }
}
extension Grape._OptionalGraphContent: Grape.GraphContent {
    typealias NodeID = A.GraphContent.NodeID
    typealias Body = Grape._IdentifiableNever<A.GraphContent.NodeID>
}
extension Grape._PairedGraphContent: Grape.GraphContent {
    typealias NodeID = C
    typealias Body = Grape._IdentifiableNever<C>
}
extension Grape.NodeAttribute: Swift.ExpressibleByFloatLiteral where B == Swift.Double {
    typealias FloatLiteralType = Swift.Double

    init(floatLiteral: Self.FloatLiteralType)
}
extension Grape.SealedForceDescriptor: Grape._ForceDescriptor {
    typealias NodeID = A
}
extension Grape.CenterForce: Grape._ForceDescriptor {
    typealias NodeID = A
}
extension Grape.ManyBodyForce: Grape._ForceDescriptor {
    typealias NodeID = A
}
extension Grape.LinkForce.Stiffness: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Double

    init(floatLiteral: Self.FloatLiteralType)
}
extension Grape.LinkForce.LinkLength: Swift.ExpressibleByFloatLiteral {
    typealias FloatLiteralType = Swift.Double

    init(floatLiteral: Self.FloatLiteralType)
}
extension Grape.LinkForce: Grape._ForceDescriptor {
    typealias NodeID = A
}
extension Grape.CollideForce: Grape._ForceDescriptor {
    typealias NodeID = A
}
extension Grape.PositionForce: Grape._ForceDescriptor {
    typealias NodeID = A
}
extension Grape.RadialForce: Grape._ForceDescriptor {
    typealias NodeID = A
}
extension Grape.GraphDragModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI._ViewModifier_Content<Grape.GraphDragModifier<A>>SwiftUI._EndedGesture<SwiftUI._ChangedGesture<SwiftUI.DragGesture>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Grape.GraphMagnifyModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI._ViewModifier_Content<Grape.GraphMagnifyModifier>SwiftUI._EndedGesture<SwiftUI._ChangedGesture<SwiftUI.MagnifyGesture>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension Grape.AnyGraphContentModifier: Grape.GraphContentModifier {}
extension Grape.GraphContentEffect.ForegroundStyle: Grape.GraphContentModifier {}
extension Grape.GraphContentEffect.Shading: Grape.GraphContentModifier {}
extension Grape.GraphContentEffect.TextAnnotation: Grape.GraphContentModifier {}
extension Grape.GraphContentEffect.ViewAnnotation: Grape.GraphContentModifier {}
extension Grape.GraphContentEffect.Opacity: Grape.GraphContentModifier {}
extension Grape.StrokeColor: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Grape.StrokeColor: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Grape.GraphContentEffect.Stroke: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Grape.GraphContentEffect.Stroke: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Grape.GraphContentEffect.Stroke: Grape.GraphContentModifier {}
extension Grape.GraphContentEffect.Symbol: Grape.GraphContentModifier {}
extension Grape.GraphContentEffect.SymbolSize: Grape.GraphContentModifier {}
extension Grape.GraphContentEffect._LinkShape: Grape.GraphContentModifier {}
extension Grape.GraphEnvironmentViewModifier: SwiftUI.ViewModifier {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI._ViewModifier_Content<Grape.GraphEnvironmentViewModifier>, SwiftUI._EnvironmentKeyWritingModifier<[Swift.AnyHashable : SwiftUI.GraphicsContext.Shading]>>

    func body(content: SwiftUI._ViewModifier_Content<Self>) -> Self.Body

    static func _makeView(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs, body: (SwiftUI._Graph, SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(modifier: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs, body: (SwiftUI._Graph, SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs, body: (_: SwiftUI._ViewListCountInputs) -> Swift.Int?) -> Swift.Int?
}
extension SwiftUI.EnvironmentValues.__Key_graphForegroundScaleEnvironment: SwiftUI.EnvironmentKey {
    typealias Value = [Swift.AnyHashable : SwiftUI.GraphicsContext.Shading]

    static var defaultValue: Self.Value {
        get
    }

    static func _valuesEqual(_: Self.Value, _: Self.Value) -> Swift.Bool
}
extension Grape.GraphProxy: Grape._AnyGraphProxyProtocol {}
extension Grape.GraphProxyKey: SwiftUI.PreferenceKey {
    typealias Value = Grape.GraphProxy

    static var _includesRemovedValues: Swift.Bool {
        get
    }
    static var _isReadableByHost: Swift.Bool {
        get
    }
    static var defaultValue: Self.Value {
        get
    }

    static func reduce(value: inout Self.Value, nextValue: () -> Self.Value)
}
extension Grape.KeyFrame: Swift.RawRepresentable {
    typealias RawValue = Swift.UInt

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension Grape.KeyFrame: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Grape.KeyFrame: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Grape.KeyFrame: Swift.ExpressibleByIntegerLiteral {
    typealias IntegerLiteralType = Swift.UInt

    init(integerLiteral: Self.IntegerLiteralType)
}
extension Grape.KeyFrame: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension Grape.PlainLineLink: Grape.LinkShape {}
extension Grape.PlainLineLink: Grape.StraightLineLinkShape {}
extension Grape.ArrowLineLink: Grape.LinkShape {}
extension Grape.ViewportTransform: Grape.TransformProtocol {
    typealias Scalar = Swift.Double
    typealias Vector = Swift.SIMD2<Swift.Double>
}
extension Grape.VolumeTransform: Grape.TransformProtocol {
    typealias Scalar = Swift.Double
    typealias Vector = Swift.SIMD3<Swift.Double>
}
extension Grape.ForceDirectedGraph: SwiftUI.View {
    typealias Body = SwiftUI.ModifiedContent<SwiftUI.ModifiedContent<SwiftUI.Canvas<SwiftUI.EmptyView>, SwiftUI._PreferenceWritingModifier<Grape.GraphProxyKey>>Grape._GraphRenderingContext<A>, SwiftUI._AppearanceActionModifier>

    var body: Self.Body {
        get
    }

    static func _makeView(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewInputs) -> SwiftUI._ViewOutputs
    static func _makeViewList(view: SwiftUI._GraphValue<Self>, inputs: SwiftUI._ViewListInputs) -> SwiftUI._ViewListOutputs
    static func _viewListCount(inputs: SwiftUI._ViewListCountInputs) -> Swift.Int?
}
extension Grape.ForceDirectedGraph: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Grape.ForceDirectedGraphModel: Observation.Observable {}
extension Grape.ForceDirectedGraphModel: Grape._AnyGraphProxyProtocol {}
extension Grape.ForceDirectedGraphState: Observation.Observable {}
extension Grape._GraphRenderingContext: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Grape.GraphRenderingStates.StateID: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension Grape.GraphRenderingStates.StateID: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Grape.PathOrSymbolSize: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Grape.RenderOperation.Node: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension Grape.RenderOperation.Link: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseDatabase.ServerTimestamp: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension FirebaseDatabase.ServerTimestamp: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension FirebaseDatabase.ServerTimestamp: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension FirebaseDatabase.ServerTimestamp: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftGraph.DijkstraNode: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.DijkstraNode: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.TSColor: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftGraph.TSColor: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.PriorityQueue: Swift.IteratorProtocol {
    typealias Element = A

    func next() -> Self.Element?
}
extension SwiftGraph.PriorityQueue: Swift.Sequence {
    typealias Element = A
    typealias Iterator = SwiftGraph.PriorityQueue<A>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension SwiftGraph.PriorityQueue: Swift.Collection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias Iterator = SwiftGraph.PriorityQueue<A>
    typealias SubSequence = Swift.Slice<SwiftGraph.PriorityQueue<A>>
    typealias Indices = Swift.DefaultIndices<SwiftGraph.PriorityQueue<A>>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension SwiftGraph.PriorityQueue: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.PriorityQueue: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftGraph.UniqueElementsGraph: SwiftGraph.Graph {
    typealias V = A
    typealias E = B
}
extension SwiftGraph.UniqueElementsGraph: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.UniqueElementsGraph: Swift.Collection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<SwiftGraph.UniqueElementsGraph<A, B>>
    typealias SubSequence = Swift.Slice<SwiftGraph.UniqueElementsGraph<A, B>>
    typealias Indices = Swift.DefaultIndices<SwiftGraph.UniqueElementsGraph<A, B>>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension SwiftGraph.UniqueElementsGraph: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftGraph.UniqueElementsGraph: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftGraph.UniqueElementsGraph: Swift.Sequence {
    typealias Element = A
    typealias Iterator = Swift.IndexingIterator<SwiftGraph.UniqueElementsGraph<A, B>>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension SwiftGraph.UniqueElementsGraph.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.UniqueElementsGraph.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftGraph.UniqueElementsGraph.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftGraph.UniqueElementsGraph.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.UniqueElementsGraph.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftGraph.UnweightedEdge: SwiftGraph.Edge {}
extension SwiftGraph.UnweightedEdge: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.UnweightedEdge: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.UnweightedEdge: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftGraph.UnweightedEdge: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftGraph.UnweightedEdge.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.UnweightedEdge.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftGraph.UnweightedEdge.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftGraph.UnweightedEdge.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.UnweightedEdge.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftGraph.UnweightedGraph: SwiftGraph.Graph {
    typealias V = A
    typealias E = SwiftGraph.UnweightedEdge
}
extension SwiftGraph.UnweightedGraph: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.UnweightedGraph: Swift.Collection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<SwiftGraph.UnweightedGraph<A>>
    typealias SubSequence = Swift.Slice<SwiftGraph.UnweightedGraph<A>>
    typealias Indices = Swift.DefaultIndices<SwiftGraph.UnweightedGraph<A>>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension SwiftGraph.UnweightedGraph: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftGraph.UnweightedGraph: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftGraph.UnweightedGraph: Swift.Sequence {
    typealias Element = A
    typealias Iterator = Swift.IndexingIterator<SwiftGraph.UnweightedGraph<A>>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension SwiftGraph.UnweightedGraph.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.UnweightedGraph.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftGraph.UnweightedGraph.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftGraph.UnweightedGraph.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.UnweightedGraph.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftGraph.WeightedEdge: SwiftGraph.WeightedEdgeProtocol {
    typealias Weight = A
}
extension SwiftGraph.WeightedEdge: SwiftGraph.Edge {}
extension SwiftGraph.WeightedEdge: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.WeightedEdge: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.WeightedEdge: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftGraph.WeightedEdge: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftGraph.WeightedEdge: Swift.Comparable where A: Swift.Comparable {
    static func < (_: Self, _: Self) -> Swift.Bool
    static func <= (_: Self, _: Self) -> Swift.Bool
    static func >= (_: Self, _: Self) -> Swift.Bool
    static func > (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.WeightedEdge.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.WeightedEdge.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftGraph.WeightedEdge.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftGraph.WeightedEdge.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.WeightedEdge.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension SwiftGraph.WeightedGraph: SwiftGraph.Graph {
    typealias V = A
    typealias E = SwiftGraph.WeightedEdge<B>
}
extension SwiftGraph.WeightedGraph: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.WeightedGraph: Swift.Collection {
    typealias Element = A
    typealias Index = Swift.Int
    typealias Iterator = Swift.IndexingIterator<SwiftGraph.WeightedGraph<A, B>>
    typealias SubSequence = Swift.Slice<SwiftGraph.WeightedGraph<A, B>>
    typealias Indices = Swift.DefaultIndices<SwiftGraph.WeightedGraph<A, B>>

    var count: Swift.Int {
        get
    }
    var isEmpty: Swift.Bool {
        get
    }
    var startIndex: Self.Index {
        get
    }
    var endIndex: Self.Index {
        get
    }
    var indices: Self.Indices {
        get
    }

    func _customIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func _customLastIndexOfEquatableElement(_: Self.Element) -> Self.Index??
    func index(_: Self.Index, offsetBy: Swift.Int) -> Self.Index
    func index(_: Self.Index, offsetBy: Swift.Int, limitedBy: Self.Index) -> Self.Index?
    func distance(from: Self.Index, to: Self.Index) -> Swift.Int
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.Range<Self.Index>)
    func _failEarlyRangeCheck(_: Self.Index, bounds: Swift.ClosedRange<Self.Index>)
    func _failEarlyRangeCheck(_: Swift.Range<Self.Index>, bounds: Swift.Range<Self.Index>)
    func index(after: Self.Index) -> Self.Index
    func formIndex(after: inout Self.Index)

    subscript(_: Swift.Range<Self.Index>) -> Self.SubSequence {
        get
    }
}
extension SwiftGraph.WeightedGraph: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension SwiftGraph.WeightedGraph: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension SwiftGraph.WeightedGraph: Swift.Sequence {
    typealias Element = A
    typealias Iterator = Swift.IndexingIterator<SwiftGraph.WeightedGraph<A, B>>

    var underestimatedCount: Swift.Int {
        get
    }

    func makeIterator() -> Self.Iterator
    func _customContainsEquatableElement(_: Self.Element) -> Swift.Bool?
    func _copyToContiguousArray() -> Swift.ContiguousArray<Self.Element>
    func _copyContents(initializing: Swift.UnsafeMutableBufferPointer<Self.Element>) -> (Self.Iterator, Swift.Int)
    func withContiguousStorageIfAvailable<A1>(_: (_: Swift.UnsafeBufferPointer<Self.Element>) throws -> A1) throws -> A1?
}
extension SwiftGraph.WeightedGraph.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension SwiftGraph.WeightedGraph.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension SwiftGraph.WeightedGraph.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension SwiftGraph.WeightedGraph.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension SwiftGraph.WeightedGraph.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.Quantization: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXEmbedders.BaseConfiguration.Quantization: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXEmbedders.BaseConfiguration.Quantization: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.BaseConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXEmbedders.BaseConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXEmbedders.BaseConfiguration.Quantization.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.Quantization.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.Quantization.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.Quantization.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXEmbedders.BaseConfiguration.Quantization.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.BaseConfiguration.Quantization.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.QuantizationContainer: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXEmbedders.BaseConfiguration.QuantizationContainer: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXEmbedders.BaseConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXEmbedders.BaseConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.BaseConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.QuantizationContainer._DictionaryCodingKey: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.QuantizationContainer._DictionaryCodingKey: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXEmbedders.BaseConfiguration.QuantizationContainer._DictionaryCodingKey: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXEmbedders.BertModel: MLXEmbedders.EmbeddingModel {}
extension MLXEmbedders.BertConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXEmbedders.BertConfiguration.BertCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXEmbedders.BertConfiguration.BertCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXEmbedders.BertConfiguration.BertCodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXEmbedders.BertConfiguration.BertCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXEmbedders.BertConfiguration.BertCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.BertConfiguration.BertCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXEmbedders.BertConfiguration.DistilBertCodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXEmbedders.BertConfiguration.DistilBertCodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXEmbedders.BertConfiguration.DistilBertCodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXEmbedders.BertConfiguration.DistilBertCodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXEmbedders.BertConfiguration.DistilBertCodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.BertConfiguration.DistilBertCodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXEmbedders.BertConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXEmbedders.BertConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXEmbedders.BertConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXEmbedders.BertConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXEmbedders.BertConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.BertConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXEmbedders.StringOrNumber: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXEmbedders.StringOrNumber: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXEmbedders.StringOrNumber: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.ModelType: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXEmbedders.ModelType: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXEmbedders.ModelType: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXEmbedders.ModelContainer: Swift.Actor {
    var unownedExecutor: Swift.UnownedSerialExecutor {
        get
    }
}
extension MLXEmbedders.EmbedderError: Swift.Error {
    var _code: Swift.Int {
        get
    }
    var _domain: Swift.String {
        get
    }
    var _userInfo: Swift.AnyObject? {
        get
    }

    func _getEmbeddedNSError() -> Swift.AnyObject?
}
extension MLXEmbedders.NomicBertModel: MLXEmbedders.EmbeddingModel {}
extension MLXEmbedders.NomicBertConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXEmbedders.MLP: MLXNN.UnaryLayer {}
extension MLXEmbedders.NomicBertConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXEmbedders.NomicBertConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXEmbedders.NomicBertConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXEmbedders.NomicBertConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXEmbedders.NomicBertConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.NomicBertConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXEmbedders.PoolingConfiguration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXEmbedders.PoolingConfiguration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXEmbedders.Pooling.Strategy: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.Pooling.Strategy: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXEmbedders.PoolingConfiguration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXEmbedders.PoolingConfiguration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXEmbedders.PoolingConfiguration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXEmbedders.PoolingConfiguration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXEmbedders.PoolingConfiguration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.PoolingConfiguration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension MLXEmbedders.Qwen3Model: MLXEmbedders.EmbeddingModel {}
extension MLXEmbedders.Qwen3Configuration: Swift.Decodable {
    init(from: Swift.Decoder) throws
}
extension MLXEmbedders.Qwen3Configuration: Swift.Encodable {
    func encode(to: Swift.Encoder) throws
}
extension MLXEmbedders.Qwen3Configuration.CodingKeys: Swift.CustomStringConvertible {
    var description: Swift.String {
        get
    }
}
extension MLXEmbedders.Qwen3Configuration.CodingKeys: Swift.CustomDebugStringConvertible {
    var debugDescription: Swift.String {
        get
    }
}
extension MLXEmbedders.Qwen3Configuration.CodingKeys: Swift.RawRepresentable {
    typealias RawValue = Swift.String

    init?(rawValue: Self.RawValue)

    var rawValue: Self.RawValue {
        get
    }
}
extension MLXEmbedders.Qwen3Configuration.CodingKeys: Swift.Hashable {
    var hashValue: Swift.Int {
        get
    }

    func hash(into: inout Swift.Hasher)
    func _rawHashValue(seed: Swift.Int) -> Swift.Int
}
extension MLXEmbedders.Qwen3Configuration.CodingKeys: Swift.Equatable {
    static func == (_: Self, _: Self) -> Swift.Bool
}
extension MLXEmbedders.Qwen3Configuration.CodingKeys: Swift.CodingKey {
    init?(stringValue: Swift.String)
    init?(intValue: Swift.Int)

    var stringValue: Swift.String {
        get
    }
    var intValue: Swift.Int? {
        get
    }
}
extension Spec.SpecChatView.NotificationObserver {
    typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
}
extension NIOCore.NIOBSDSocket.AddressFamily {
    typealias RawValue = Swift.Int32
}
extension NIOCore.NIOBSDSocket.ProtocolFamily {
    typealias RawValue = Swift.Int32
}
extension NIOCore.NIOBSDSocket.OptionLevel {
    typealias RawValue = Swift.Int32
}
extension NIOCore.NIOBSDSocket.Option {
    typealias RawValue = Swift.Int32
}
extension NIOCore.ChannelOptions.Types.SocketOption {
    typealias Value = Swift.Int32
}
extension NIOCore.ChannelOptions.Types.AllocatorOption {
    typealias Value = NIOCore.ByteBufferAllocator
}
extension NIOCore.ChannelOptions.Types.RecvAllocatorOption {
    typealias Value = NIOCore.RecvByteBufferAllocator
}
extension NIOCore.ChannelOptions.Types.AutoReadOption {
    typealias Value = Swift.Bool
}
extension NIOCore.ChannelOptions.Types.WriteSpinOption {
    typealias Value = Swift.UInt
}
extension NIOCore.ChannelOptions.Types.MaxMessagesPerReadOption {
    typealias Value = Swift.UInt
}
extension NIOCore.ChannelOptions.Types.BacklogOption {
    typealias Value = Swift.Int32
}
extension NIOCore.ChannelOptions.Types.DatagramVectorReadMessageCountOption {
    typealias Value = Swift.Int
}
extension NIOCore.ChannelOptions.Types.DatagramSegmentSize {
    typealias Value = Swift.Int32
}
extension NIOCore.ChannelOptions.Types.DatagramReceiveOffload {
    typealias Value = Swift.Bool
}
extension NIOCore.ChannelOptions.Types.ExplicitCongestionNotificationsOption {
    typealias Value = Swift.Bool
}
extension NIOCore.ChannelOptions.Types.WriteBufferWaterMarkOption {
    typealias Value = NIOCore.ChannelOptions.Types.WriteBufferWaterMark
}
extension NIOCore.ChannelOptions.Types.ConnectTimeoutOption {
    typealias Value = NIOCore.TimeAmount?
}
extension NIOCore.ChannelOptions.Types.AllowRemoteHalfClosureOption {
    typealias Value = Swift.Bool
}
extension NIOCore.ChannelOptions.Types.ReceivePacketInfo {
    typealias Value = Swift.Bool
}
extension NIOCore.ChannelOptions.Types.BufferedWritableBytesOption {
    typealias Value = Swift.Int
}
extension NIOCore.NIOBSDSocket.SocketType {
    typealias RawValue = Swift.Int32
}
extension NIOCore.NIOBSDSocket.ProtocolSubtype {
    typealias RawValue = Swift.Int32
}
extension NIOCore.ChannelOptions.Types.LocalVsockContextID {
    typealias Value = NIOPosix.VsockAddress.ContextID
}
extension GRDB.DatabasePublishers.Read {
    typealias Output = A
    typealias Failure = Swift.Error
}
extension GRDB.DatabasePublishers.DatabaseRegion {
    typealias Output = GRDB.Database
    typealias Failure = Swift.Error
}
extension GRDB.DatabasePublishers.Write {
    typealias Output = A
    typealias Failure = Swift.Error
}
extension GRDB.DatabasePublishers.Migrate {
    typealias Output = ()
    typealias Failure = Swift.Error
}
extension GRDB._RowDecoder.KeyedContainer {
    typealias Key = A1
}
extension GRDB.ValueReducers.Fetch._Fetcher {
    typealias Value = A
}
extension GRDB.ValueReducers.Fetch {
    typealias Fetcher = GRDB.ValueReducers.Fetch<A>._Fetcher
    typealias Value = A
}
extension GRDB.ValueReducers.Map {
    typealias Fetcher = A._ValueReducer.Fetcher
    typealias Value = B
}
extension GRDB.ValueReducers.RemoveDuplicates {
    typealias Fetcher = A._ValueReducer.Fetcher
    typealias Value = A._ValueReducer.Value
}
extension GRDB.ValueReducers.Trace._Fetcher {
    typealias Value = A._ValueReducer.Fetcher._ValueReducerFetcher.Value
}
extension GRDB.ValueReducers.Trace {
    typealias Fetcher = GRDB.ValueReducers.Trace<A>._Fetcher
    typealias Value = A._ValueReducer.Value
}
extension GRDB.DatabasePublishers.Value {
    typealias Output = A
    typealias Failure = Swift.Error
}
